1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 1
 
 
 
 AUTHORS:      T.J.DEKKER AND W.HOFFMANN.
 
 
 CONTRIBUTORS: W.HOFFMANN, J.G.VERWER.
 
 
 INSTITUTE:    MATHEMATICAL CENTRE.
 
 
 RECEIVED:     730716.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION  CONTAINS FOUR PROCEDURES FOR CALCULATING  EIGENVALUES
     OR EIGENVECTORS OF A SYMMETRIC TRIDIAGONAL MATRIX.
     VALSYMTRI  CALCULATES  ALL, OR  SOME  CONSECUTIVE, EIGENVALUES OF A
     SYMMETRIC TRIDIAGONAL MATRIX BY MEANS OF LINEAR INTERPOLATION USING
     A STURM SEQUENCE;
     VECSYMTRI  CALCULATES  THE  CORRESPONDING  EIGENVECTORS BY MEANS OF
     INVERSE ITERATION.
     QRIVALSYMTRI  CALCULATES ALL EIGENVALUES OF A SYMMETRIC TRIDIAGONAL
     MATRIX BY MEANS OF QR ITERATION;
     QRISYMTRI CALCULATES THE EIGENVECTORS AS WELL.
     WHEN ALL EIGENVALUES HAVE TO BE CALCULATED, QRIVALSYMTRI IS
     PREFERABLE WITH RESPECT TO THE RUNNING TIME; WHEN THE EIGENVECTORS
     ALSO HAVE TO BE CALCULATED, INVERSE ITERATION IS PREFERABLE.
 
 KEYWORDS:
     EIGENVALUES,
     EIGENVECTORS,
     TRIDIAGONAL MATRIX,
     STURM-SEQUENCE,
     INVERSE ITERATION,
     QR ITERATION.
 
 
1SECTION 3.3.1.1.1            (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION: VALSYMTRI.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" VALSYMTRI(D, BB, N, N1, N2, VAL, EM);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
     "ARRAY" D, BB, VAL, EM;
     "CODE" 34151;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[1:N];
             ENTRY:  THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX;
     BB:     <ARRAY IDENTIFIER>;
             "ARRAY" BB[1:N-1];
             ENTRY:  THE  SQUARES  OF THE  CODIAGONAL   ELEMENTS  OF THE
                     SYMMETRIC TRIDIAGONAL MATRIX;
     N1,N2:  <ARITHMETIC EXPRESSION>;
             THE  SERIAL  NUMBER  OF THE FIRST AND LAST EIGENVALUE TO BE
             CALCULATED, RESPECTIVELY;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[N1:N2];
             EXIT:   THE N2-N1+1 CALCULATED CONSECUTIVE  EIGENVALUES IN
                     NONINCREASING  ORDER;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:3];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[1], AN UPPERBOUND FOR THE MODULI OF THE
                            EIGENVALUES OF THE GIVEN MATRIX,
                     EM[2], A RELATIVE  TOLERANCE FOR THE EIGENVALUES;
             EXIT:   EM[3], THE  TOTAL  NUMBER  OF  ITERATIONS  USED FOR
                            CALCULATING THE EIGENVALUES.
 
 
 PROCEDURES USED:
     ZEROIN  =       CP34150.
 
 
 RUNNING TIME:
     DEPENDS STRONGLY ON THE DISTANCE OF SUCCESSIVE EIGENVALUES.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     LET T DENOTE THE GIVEN SYMMETRIC  TRIDIAGONAL MATRIX OF ORDER N AND
     I THE IDENTITY MATRIX.  THE  EIGENVALUES OF T ARE THE ZEROES OF THE
     N-TH DEGREE POLYNOMIAL P(N,X) = DET(T - X*I).  INSTEAD OF SEARCHING
     FOR THE ZEROES OF  P(N,X)  WE  LOOK  FOR THE ZEROES OF THE FUNCTION
     F(N,X) =  P(N,X) /  P(N-1,X).   MAINTAINING   A  LOWER   BOUND  FOR
     ABS(P(N-1,X)) WE DO AVOID  OVERFLOW OF THE REAL NUMBER  CAPACITY IN
     THE  COMPUTATION  OF  F(N,X).  THIS  FUNCTION  CAN BE CALCULATED AS
     FOLLOWS:
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 3
 
 
 
             F(1,X) = D[1] - X,
             F(K,X) = D[K] - X - BB[K-1] /
             ("IF" ABS(F(K-1,X)) > MACHTOL "THEN" F(K-1,X)
             "ELSE" "IF" F(K-1,X) <= 0 "THEN" -MACHTOL
             "ELSE" MACHTOL),  K = 2, . . . ,N,
     WHERE MACHTOL EQUALS EM[0] * EM[1].
     USING THE STURM SEQUENCE  PROPERTY OF (F(K,X)), K=1,2,...,N, WE CAN
     LOCATE  THE DESIRED  EIGENVALUES  BY  MEANS OF THE PROCEDURE ZEROIN
     (SECTION  5.1.1.1). FOR FURTHER DETAILS SEE REF[1], REF[2].
 
 
 SUBSECTION: VECSYMTRI.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
     "ARRAY" D, B, VAL, VEC, EM;
     "CODE" 34152;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[1:N],
             ENTRY:  THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE CODIAGONAL OF THE SYMMETRIC  TRIDIAGONAL MATRIX
                     FOLLOWED BY AN ADDITIONAL ELEMENT 0;
     N1, N2: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ARRAY VAL (SEE ALSO METHOD AND
             PERFORMANCE);
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[N1:N2];
             ENTRY:  A ROW OF NONINCREASING  EIGENVALUES AS DELIVERED BY
                     VALSYMTRI;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,N1:N2];
             EXIT:   THE  EIGENVECTORS   CORRESPONDING  WITH  THE  GIVEN
                     EIGENVALUES  (SEE  ALSO  METHOD  AND  PERFORMANCE);
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[1], A NORM OF THE GIVEN MATRIX,
                     EM[4], THE  ORTHOGONALISATION  PARAMETER (SEE ALSO
                            METHOD AND PERFORMANCE),
                     EM[6], THE RELATIVE TOLERANCE FOR THE EIGENVECTORS,
                     EM[8], THE  MAXIMUM  NUMBER  OF ITERATIONS  ALLOWED
                            FOR  THE  CALCULATION  OF EACH  EIGENVECTOR;
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 4
 
 
 
             EXIT:   EM[5], THE NUMBER OF  EIGENVECTORS  INVOLVED IN THE
                            LAST  GRAM-SCHMIDT  ORTHOGONALISATION   (SEE
                            METHOD AND PERFORMANCE),
                     EM[7], THE MAXIMUM  EUCLIDEAN NORM OF THE RESIDUES,
                     EM[9], THE  LARGEST  NUMBER OF ITERATIONS PERFORMED
                            FOR THE CALCULATION OF SOME EIGENVECTOR (SEE
                            METHOD AND PERFORMANCE).
 
 PROCEDURES USED:
     VECVEC   =      CP34010,
     TAMVEC   =      CP34012,
     ELMVECCOL=      CP34021.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: FIVE  AUXILIARY ONE-DIMENSIONAL REAL ARRAYS
                     AND ONE BOOLEAN ARRAY, ALL OF LENGTH N, ARE USED.
 
 
 RUNNING TIME: THE PROCESS IS OF ORDER N FOR EACH EIGENVECTOR.
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     AN EIGENVECTOR OF A SYMMETRIC  TRIDIAGONAL  MATRIX T, CORRESPONDING
     TO  AN  EIGENVALUE  LAMBDA,  IS  CALCULATED  BY  MEANS  OF  INVERSE
     ITERATION;  I.E.  STARTING  FROM  SOME INITIAL VECTOR X, THE LINEAR
     SYSTEM (T - LAMBDA * I)Y = X IS SOLVED ITERATIVELY, THE SOLUTION Y,
     DIVIDED BY ITS EUCLIDEAN NORM REPLACING X EACH TIME.
     IF THE DISTANCE  BETWEEN  SOME  APPROXIMATE  EIGENVALUES IS SMALLER
     THAN MACHTOL (=EM[0] * EM[1]), THEN THEY ARE SLIGHTLY MODIFIED SUCH
     THAT THE DISTANCE  BETWEEN  THEM  EQUALS  MACHTOL. IF THE  DISTANCE
     BETWEEN  SOME  EIGENVALUES  IS  SMALLER THAN THE  ORTHOGONALISATION
     PARAMETER (=EM[4]) TIMES EM[1], THEN IN EACH ITERATION  STEP  GRAM-
     SCHMIDT  ORTHOGONALISATION IS CARRIED OUT, SO THAT THE EIGENVECTORS
     OBTAINED ARE ORTHOGONAL  WITHIN  WORKING  PRECISION. THE  ITERATION
     ENDS AS SOON AS EITHER THE EUCLIDEAN NORM OF THE RESIDUE IS SMALLER
     THAN EM[1] * EM[6], OR THE MAXIMUM  ALLOWED  NUMBER  OF  ITERATIONS
     (=EM[8])  HAS BEEN PERFORMED. IN THE LATTER CASE EM[9]:= EM[8] + 1.
     IF N1 > 1, THEN  VECSYMTRI  SHOULD BE PRECEDED BY ONE OR MORE CALLS
     OF VECSYMTRI PRODUCING A NUMBER  OF  EIGENVECTORS  CORRESPONDING TO
     THE  PRECEDING  EIGENVALUES.  MOREOVER  ONE  MUST  GIVE  EM[5],  AS
     PRODUCED  BY  THE  LAST  CALL  OF  VECSYMTRI;  THE  K-TH  TO  N2-TH
     EIGENVALUES, WHERE K = N1 - EM[5], MUST BE GIVEN IN ARRAY VAL[K:N2]
     IN  MONOTONICALLY  NONINCREASING   ORDER  (THE  K-TH  TO  (N1-1)-TH
     EIGENVALUES  BEING  NEEDED  FOR THE MODIFYING MENTIONED ABOVE), AND
     THE  CORRESPONDING  EIGENVECTORS  UP  TO  THE  (N1-1)-TH (WHICH ARE
     NEEDED FOR THE GRAM-SCHMIDT ORTHOGONALISATION) IN THE CORRESPONDING
     COLUMNS OF ARRAY VEC[1:N,K:N2].
     THE  TOLERANCES   SHOULD   SATISFY:  EM[0] ( < EM[2]) <  EM[6]  AND
     EM[4]  >=  EM[0] / EM[6]. FOR FURTHER DETAILS SEE REF[1].
 
 
 
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 5
 
 
 
 SUBSECTION: QRIVALSYMTRI.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" QRIVALSYMTRI(D, BB, N, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" D, BB, EM;
     "CODE" 34160;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[1:N];
             ENTRY:  THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX;
             EXIT:   THE  EIGENVALUES  OF THE  MATRIX IN SOME  ARBITRARY
                     ORDER;
      BB:     <ARRAY IDENTIFIER>;
             "ARRAY" BB[1:N];
             ENTRY:  THE   SQUARES  OF THE  CODIAGONAL  ELEMENTS  OF THE
                     SYMMETRIC   TRIDIAGONAL   MATRIX   FOLLOWED  BY  AN
                     ADDITONAL   ELEMENT O;
             EXIT:   THE   SQUARES  OF THE  CODIAGONAL  ELEMENTS  OF THE
                     SYMMETRIC  TRIDIAGONAL MATRIX RESULTING FROM THE QR
                     ITERATION;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0], THE MACHINE PRECISION;
                     EM[1], A NORM OF THE GIVEN MATRIX;
                     EM[2], A RELATIVE TOLERANCE FOR THE EIGENVALUES;
                     EM[4], THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
             EXIT:   EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE CODIAGONAL
                            ELEMENTS NEGLECTED;
                     EM[5], THE NUMBER OF ITERATIONS PERFORMED.
     MOREOVER:
             QRIVALSYMTRI:= THE NUMBER OF  EIGENVALUES  NOT  CALCULATED.
 
 PROCEDURES USED:    NONE.
 
 
 RUNNING TIME:       THE PROCESS IS OF ORDER N SQUARED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION 3.3.1.1.1            (DECEMBER 1975)                     PAGE 6
 
 
 
 METHOD AND PERFORMANCE:
     IN QRIVALSYMTRI THE EIGENVALUES OF A SYMMETRIC TRIDIAGONAL MATRIX
     ARE CALCULATED BY MEANS OF QR-ITERATION. FOR THIS PROCEDURE WE USED
     ESSENTIALLY THE SQUARE-ROOT-FREE VERSION OF THE QR ALGORITHM DUE TO
     REINSCH[3].
     IN ADDITION TO THE RELATIVE ERROR, WHICH IS SUPPOSED TO BE BOUNDED
     BY EM[1] * EM[2] (I.E. MATRIX NORM TIMES RELATIVE TOLERANCE), THE
     CALCULATED EIGENVALUES HAVE AN ABSOLUTE ERROR WHICH IS BOUNDED BY
     BY EM[0] * EM[1] (I.E. MACHINE PRECISION TIMES MATRIX NORM).
     IN PARTICULAR, WHEN SOME EIGENVALUES ARE VERY SMALL COMPARED TO THE
     MATRIX NORM, THE ACCURACY OF THE CALCULATED EIGENVALUES CAN BE
     INCREASED BY GIVING EM[0] A (POSITIVE) VALUE WHICH IS LESS THAN
     THE MACHINE PRECISION.
     A PARTICULAR CHOICE OF EM[0] IS HARMLESS FOR THE PROCEDURE
     PROVIDED THAT FOR EACH I THE CALCULATION OF BB[I] / EM[0] ** 2
     CAUSES NO OVERFLOW AND THE CALCULATION OF (EM[0] * EM[1]) ** 2
     CAUSES NO UNDERFLOW.
     ONE SHOULD NOTICE THAT THE NUMBER OF QR ITERATIONS INCREASES BY A
     SMALLER CHOICE OF EM[0].
     FOR FURTHER DETAILS SEE [2], [3].
 
 
 SUBSECTION: QRISYMTRI.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" QRISYMTRI(A, N, D, B, BB, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A, D, B, BB, EM;
     "CODE" 34161;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[1:N];
             ENTRY:  THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX;
             EXIT:   THE  EIGENVALUES  OF THE  MATRIX IN SOME  ARBITRARY
                     ORDER;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE CODIAGONAL OF THE SYMMETRIC  TRIDIAGONAL MATRIX
                     FOLLOWED BY AN ADDITIONAL ELEMENT 0;
             EXIT:   THE CODIAGONAL OF THE SYMMETRIC  TRIDIAGONAL MATRIX
                     RESULTING FROM THE QR ITERATION, FOLLOWED BY AN
                     ADDITIONAL ELEMENT 0;
     BB:     <ARRAY IDENTIFIER>;
             "ARRAY" BB[1:N];
             ENTRY:  THE  SQUARED  CODIAGONAL  ELEMENTS OF THE SYMMETRIC
                     TRIDIAGONAL   MATRIX,  FOLLOWED  BY  AN  ADDITIONAL
                     ELEMENT O;
             EXIT:   THE  SQUARED  CODIAGONAL  ELEMENTS OF THE SYMMETRIC
                     TRIDIAGONAL MATRIX RESULTING FROM THE QR ITERATION;
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 7
 
 
 
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:  SOME MATRIX S, SAY, (POSSIBLY THE IDENTITY MATRIX);
             EXIT:   THE   EIGENVECTORS   OF  THE   ORIGINAL   SYMMETRIC
                     TRIDIAGONAL  MATRIX, PREMULTIPLIED BY S (SEE METHOD
                     AND PERFORMANCE);
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0], THE MACHINE PRECISION;
                     EM[1], A NORM OF THE GIVEN MATRIX;
                     EM[2], A RELATIVE TOLERANCE FOR THE QR ITERATION;
                     EM[4], THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
             EXIT:   EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE CODIAGONAL
                            ELEMENTS NEGLECTED;
                     EM[5], THE NUMBER OF ITERATIONS PERFORMED.
     MOREOVER:
             QRISYMTRI:=    THE NUMBER OF  EIGENVALUES  AND -VECTORS NOT
                            CALCULATED.
 
 PROCEDURES USED:
     ROTCOL  =       CP34040.
 
 
 RUNNING TIME:       THE PROCESS IS OF ORDER N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 
 METHOD AND PERFORMANCE:
     IN  QRISYMTRI  THE  EIGENVALUES  AND  EIGENVECTORS  OF A  SYMMETRIC
     TRIDIAGONAL MATRIX ARE COMPUTED SIMULTANEOUSLY.
     IN MOST  APPLICATIONS  QRISYMTRI  IS  USED  IN THE  COMPUTATION  OF
     EIGENVALUES AND -VECTORS OF A GENERAL  SYMMETRIC MATRIX (SEE QRISYM
     SECTION 3.3.1.1.2); IN THAT CASE ARRAY A IS INITIALLY GIVEN THE
     VALUE OF THE TRANSFORMING MATRIX (TFMPREVEC SECTION 3.2.1.2.1.1).
     FOR THE  COMPUTATION OF EIGENVALUES AND EIGENVECTORS OF A SYMMETRIC
     TRIDIAGONAL  MATRIX,  ARRAY A HAS TO BE INITIALIZED TO THE IDENTITY
     MATRIX.  THE  AVERAGE  NUMBER OF ITERATIONS IS ABOUT 3N.  WHEN  THE
     PROCESS IS COMPLETED  WITHIN  EM[4] ITERATIONS, THEN QRISYMTRI:= 0;
     OTHERWISE QRISYMTRI:= THE NUMBER, K, OF EIGENVALUES NOT CALCULATED,
     EM[5]:= EM[4] + 1  AND  ONLY THE LAST  N - K  ELEMENTS OF D AND THE
     LAST  N - K  COLUMNS OF A ARE APPROXIMATE  EIGENVALUES AND -VECTORS
     RESPECTIVELY, OF THE ORIGINAL MATRIX.
     FOR FURTHER  DETAILS  SEE REF[1], REF[2].
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 8
 
 
 
 REFERENCES:
     [1]     DEKKER, T.J. AND HOFFMANN, W.
             ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
             MATHEMATICAL CENTRE TRACTS 23,
             MATHEMATISCH CENTRUM, AMSTERDAM, 1968;
 
     [2]     WILKINSON, J.H.
             THE ALGEBRAIC EIGENVALUE PROBLEM,
             CLARENDON PRESS, OXFORD 1965.
 
     [3]     REINSCH, CHR.H.
             A STABLE, RATIONAL QR ALGORITHM FOR THE COMPUTATION OF THE
             EIGENVALUES OF AN HERMITIAN, TRIDIAGONAL MATRIX.
             MATH. OF COMP. VOL 25(1971) PP. 591-597.
 
 EXAMPLE OF USE:
 
     THE FIRST AND SECOND EIGENVALUE IN MONOTONICALLY NON-INCREASING
     ORDER  AND  THE  CORRESPONDING  EIGENVECTORS  OF T, WITH  N = 4 AND
     T[I,J] = "IF" I = J  "THEN" 2 "ELSE" "IF" ABS(I - J) = 1 "THEN" - 1
     "ELSE" 0, MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" J;
         "ARRAY" B, D[1:4], BB[1:3], VAL[1:2], EM[0:9], VEC[1:4,1:2];
 
         EM[0]:= "-14; EM[1]:= 4; EM[2]:= "-12;
         EM[4]:= "-3; EM[6]:= "-10; EM[8]:= 5;
         "FOR" J:= 1, 2, 3, 4 "DO" D[J]:= 2; B[4]:= 0;
         "FOR" J:= 1, 2, 3 "DO"
         "BEGIN" BB[J]:= 1; B[J]:= -1 "END";
         VALSYMTRI(D, BB, 4, 1, 2, VAL, EM);
         VECSYMTRI(D, B, 4, 1, 2, VAL, VEC, EM);
         OUTPUT(61, "("2(+.13D"+2D, 2B), 2/")", VAL[1], VAL[2]);
         "FOR" J:= 1, 2, 3, 4 "DO"
         OUTPUT(61, "("2(+.13D"+2D, 2B), /")", VEC[J,1], VEC[J,2]);
         OUTPUT(61, "("/, .2D"+2D, /, 3(2ZD, /)")",
         EM[7], EM[3], EM[5], EM[9])
     "END"
 
     THE PROGRAM DELIVERS:
 
     THE EIGENVALUES:  +.3618033988751"+01  +.2618033988750"+01
 
     THE EIGENVECTORS: +.3717480344602"+00  +.6015009550075"+00
                       +.6015009550075"+00  +.3717480344602"+00
                       +.6015009550075"+00  -.3717480344602"+00
                       +.3717480344602"+00  -.6015009550075"+00
 
     EM[7] = .15"-11
     EM[3] = 24
     EM[5] = 1
     EM[9] = 1  .
1SECTION 3.3.1.1.1            (JULY 1974)                         PAGE 9
 
 
 
 SOURCE TEXT(S):
0"CODE" 34151;
     "COMMENT" MCA 2311;
     "PROCEDURE" VALSYMTRI(D, BB, N, N1, N2, VAL, EM);
     "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" D, BB, VAL, EM;
         "BEGIN" "INTEGER" K, COUNT;
         "REAL" MAX, X, Y, MACHEPS, NORM, RE, MACHTOL, UB, LB, LAMBDA;
 
         "REAL" "PROCEDURE" STURM;
         "BEGIN" "INTEGER" P, I; "REAL" F;
             COUNT:= COUNT + 1;
             P:= K; F:= D[1] - X;
             "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" F <= 0 "THEN"
                 "BEGIN" P:= P + 1;
                     "IF" P > N "THEN" "GOTO" OUT
                 "END"
                 "ELSE" "IF" P < I - 1 "THEN"
                 "BEGIN" LB:= X; "GOTO" OUT "END";
                 "IF" ABS(F) < MACHTOL "THEN"
                 F:= "IF" F <= 0 "THEN" - MACHTOL "ELSE" MACHTOL;
                 F:= D[I] - X - BB[I - 1] / F
             "END";
             "IF" P = N "OR" F <= 0 "THEN"
             "BEGIN" "IF" X < UB "THEN" UB:= X "END" "ELSE" LB:= X;
        OUT: STURM:= "IF" P = N "THEN" F "ELSE" (N - P) * MAX
         "END" STURM;
 
         MACHEPS:= EM[0]; NORM:= EM[1]; RE:= EM[2];
         MACHTOL:= NORM * MACHEPS; MAX:= NORM / MACHEPS; COUNT:= 0;
         UB:= 1.1 * NORM; LB:= - UB; LAMBDA:= UB;
         "FOR" K:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" X:= LB; Y:= UB; LB:= -1.1  * NORM;
             ZEROIN(X, Y, STURM, ABS(X) * RE + MACHTOL);
             VAL[K]:= LAMBDA:= "IF" X > LAMBDA "THEN" LAMBDA "ELSE" X;
             "IF" UB > X "THEN" UB:= "IF" X > Y "THEN" X "ELSE" Y
         "END";
         EM[3]:= COUNT
     "END" VALSYMTRI
1SECTION 3.3.1.1.1            (JULY 1974)                        PAGE 10
 
 
                                                                  ;
         "EOP"
0"CODE" 34152;
     "COMMENT" MCA 2312;
     "PROCEDURE" VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM);
     "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" D, B, VAL, VEC, EM;
     "BEGIN" "INTEGER" I, J, K, COUNT, MAXCOUNT, COUNTLIM, ORTH, IND;
         "REAL" BI, BI1, U, W, Y, MI1, LAMBDA, OLDLAMBDA, ORTHEPS,
         VALSPREAD, SPR, RES, MAXRES, OLDRES, NORM, NEWNORM, OLDNORM,
         MACHTOL, VECTOL;
         "ARRAY" M, P, Q, R, X[1:N];
         "BOOLEAN" "ARRAY" INT[1:N];
 
         NORM:= EM[1]; MACHTOL:= EM[0] * NORM; VALSPREAD:= EM[4] * NORM;
         VECTOL:= EM[6] * NORM; COUNTLIM:= EM[8]; ORTHEPS:= SQRT(EM[0]);
         MAXCOUNT:= IND:= 0; MAXRES:= 0;
         "IF" N1 > 1 "THEN"
         "BEGIN" ORTH:= EM[5]; OLDLAMBDA:= VAL[N1 - ORTH];
             "FOR" K:= N1 - ORTH + 1 "STEP" 1 "UNTIL" N1 - 1  "DO"
             "BEGIN" LAMBDA:= VAL[K]; SPR:= OLDLAMBDA - LAMBDA;
                 "IF" SPR < MACHTOL "THEN" LAMBDA:= OLDLAMBDA - MACHTOL;
                 OLDLAMBDA:= LAMBDA
             "END"
         "END" "ELSE" ORTH:= 1;
         "FOR" K:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" LAMBDA:= VAL[K]; "IF" K > 1 "THEN"
             "BEGIN" SPR:= OLDLAMBDA - LAMBDA;
                 "IF" SPR < VALSPREAD "THEN"
                 "BEGIN" "IF" SPR < MACHTOL "THEN"
                     LAMBDA:= OLDLAMBDA - MACHTOL;
                     ORTH:= ORTH +1
                 "END" "ELSE" ORTH:= 1
             "END";
             COUNT:= 0; U:= D[1] - LAMBDA; BI:= W:= B[1];
             "IF" ABS(BI) < MACHTOL "THEN" BI:= MACHTOL;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1  "DO"
             "BEGIN" BI1:= B[I + 1];
                 "IF" ABS(BI1) < MACHTOL "THEN" BI1:= MACHTOL;
                 "IF" ABS(BI) >= ABS(U) "THEN"
                 "BEGIN" MI1:= M[I + 1]:= U / BI; P[I]:= BI;
                     Y:= Q[I]:= D[I + 1] - LAMBDA; R[I]:= BI1;
                     U:= W - MI1 * Y; W:= - MI1 * BI1; INT[I]:= "TRUE"
                 "END"
                 "ELSE"
                 "BEGIN" MI1:= M[I + 1]:= BI / U; P[I]:= U; Q[I]:= W;
                     R[I]:= 0; U:= D[I + 1] - LAMBDA - MI1 * W;W:= BI1;
                     INT[I]:= "FALSE"
                 "END";
                 X[I]:= 1; BI:= BI1
             "END" TRANSFORM
1SECTION 3.3.1.1.1            (JULY 1974)                        PAGE 11
                                                                 ;
 
 
             P[N]:= "IF" ABS(U) < MACHTOL "THEN" MACHTOL "ELSE" U;
             Q[N]:= R[N]:= 0; X[N]:= 1; "GOTO" ENTRY;
         ITERATE: W:= X[1];
             "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" INT[I - 1] "THEN"
                 "BEGIN" U:= W; W:= X[I - 1]:= X[I] "END"
                 "ELSE" U:= X[I]; W:= X[I]:= U - M[I] * W
             "END" ALTERNATE;
         ENTRY: U:= W:= 0;
             "FOR" I:= N "STEP" -1 "UNTIL" 1 "DO"
             "BEGIN" Y:= U; U:= X[I]:= (X[I] - Q[I] * U - R[I] * W) /
                 P[I]; W:= Y
             "END" NEXT ITERATION;
             NEWNORM:= SQRT(VECVEC(1, N, 0, X, X)); "IF" ORTH > 1"THEN"
             "BEGIN" OLDNORM:= NEWNORM;
                 "FOR" J:= K - ORTH + 1 "STEP" 1 "UNTIL" K - 1 "DO"
                 ELMVECCOL(1, N, J, X, VEC, -TAMVEC(1, N, J, VEC, X));
                 NEWNORM:= SQRT(VECVEC(1, N, 0, X, X));
                 "IF" NEWNORM < ORTHEPS * OLDNORM "THEN"
                 "BEGIN" IND:= IND + 1; COUNT:= 1;
                     "FOR" I:= 1 "STEP" 1 "UNTIL" IND - 1,
                     IND + 1 "STEP" 1 "UNTIL" N "DO" X[I]:= 0;
                     X[IND]:= 1; "IF" IND = N "THEN" IND:= 0;
                     "GOTO" ITERATE
                 "END" NEW START
             "END" ORTHOGONALISATION;
             RES:= 1 / NEWNORM; "IF" RES > VECTOL "OR" COUNT = 0 "THEN"
             "BEGIN" COUNT:= COUNT + 1; "IF" COUNT <= COUNTLIM "THEN"
                 "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                     X[I]:= X[I] * RES; "GOTO" ITERATE
                 "END"
             "END";
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" VEC[I,K]:= X[I] * RES;
             "IF" COUNT > MAXCOUNT "THEN" MAXCOUNT:= COUNT;
             "IF" RES > MAXRES "THEN" MAXRES:= RES; OLDLAMBDA:= LAMBDA
         "END";
         EM[5]:= ORTH; EM[7]:= MAXRES; EM[9]:= MAXCOUNT
     "END" VECSYMTRI
1SECTION 3.3.1.1.1            (JULY 1974)                        PAGE 12
 
 
                                                                  ;
         "EOP"
0"CODE" 34160;
     "INTEGER" "PROCEDURE" QRIVALSYMTRI(D, BB, N, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" D, BB, EM;
     "BEGIN" "INTEGER" I, I1, LOW, OLDLOW, N1, COUNT, MAX;
         "REAL" BBTOL, BBMAX, BBI, BBN1, MACHTOL, DN, DELTA, F, NUM,
         SHIFT, G, H, T, P, R, S, C, OLDG;
         BBTOL:= (EM[2] * EM[1]) ** 2; MACHTOL:= EM[0] * EM[1];
         MAX:= EM[4]; BBMAX:= 0; COUNT:= 0; OLDLOW:= N;
         "FOR" N1:= N - 1 "WHILE" N > 0 "DO"
         "BEGIN"
             "FOR" I:= N, I - 1 "WHILE" ("IF" I >= 1 "THEN"
             BB[I] > BBTOL "ELSE" "FALSE") "DO" LOW:= I;
             "IF" LOW > 1 "THEN" "BEGIN" "IF" BB[LOW-1] > BBMAX "THEN"
             BBMAX:= BB[LOW-1] "END";
             "IF" LOW = N "THEN" N:= N1 "ELSE"
             "BEGIN" DN:= D[N]; DELTA:= D[N1] - DN;
                 BBN1:= BB[N1];
                 "IF" ABS(DELTA) < MACHTOL "THEN" R:= SQRT(BBN1) "ELSE"
                 "BEGIN"
                     F:= 2 / DELTA; NUM:= BBN1 * F;
                     R:= -NUM / (SQRT(NUM * F + 1) + 1)
                 "END";
                 "IF" LOW = N1 "THEN"
                 "BEGIN" D[N]:= DN + R; D[N1]:= D[N1] - R; N:= N - 2
                 "END"
                 "ELSE"
                 "BEGIN" COUNT:= COUNT + 1;
                     "IF" COUNT > MAX "THEN" "GOTO" END;
                     "IF" LOW < OLDLOW "THEN"
                     "BEGIN" SHIFT:= 0; OLDLOW:= LOW "END"
                     "ELSE"  SHIFT:= DN + R;
                     H:= D[LOW] - SHIFT;
                     "IF" ABS(H) < MACHTOL "THEN" H:= "IF" H <= 0 "THEN"
                     -MACHTOL "ELSE" MACHTOL;
                     G:= H; T:= G * H;
                     BBI:= BB[LOW]; P:= T + BBI; I1:= LOW;
                     "FOR" I:= LOW + 1 "STEP" 1 "UNTIL" N "DO"
                     "BEGIN" S:= BBI / P; C:= T / P;
                         H:= D[I] - SHIFT - BBI / H;
                         "IF" ABS(H) < MACHTOL "THEN" H:= "IF" H <= 0
                         "THEN" -MACHTOL "ELSE" MACHTOL;
                         OLDG:= G; G:= H * C; T:= G * H;
                         D[I1]:= OLDG - G + D[I];
                         BBI:= "IF" I = N "THEN" 0 "ELSE" BB[I];
                         P:= T + BBI; BB[I1]:= S * P; I1:= I
                     "END";
                     D[N]:= G + SHIFT
                 "END" QRSTEP
             "END"
         "END";
      END: EM[3]:= SQRT(BBMAX); EM[5]:= COUNT; QRIVALSYMTRI:= N
     "END" QRIVALSYMTRI
1SECTION 3.3.1.1.1            (JULY 1974)                        PAGE 13
 
 
                                                                  ;
          "EOP"
0"CODE" 34161;
     "COMMENT" MCA 2321;
     "INTEGER" "PROCEDURE" QRISYMTRI(A, N, D, B, BB, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, D, B, BB, EM;
     "BEGIN" "INTEGER" I, J, J1, K, M, M1, COUNT, MAX;
         "REAL" BBMAX, R, S, SIN, T, C, COS, OLDCOS, G, P, W, TOL, TOL2,
         LAMBDA, DK1, A0, A1;
 
         TOL:= EM[2] * EM[1]; TOL2:= TOL * TOL; COUNT:= 0; BBMAX:= 0;
         MAX:= EM[4]; M:= N;
      IN: K:= M; M1:= M - 1;
      NEXT: K:= K - 1; "IF" K > 0 "THEN"
         "BEGIN" "IF" BB[K] >= TOL2 "THEN" "GOTO" NEXT;
             "IF" BB[K] > BBMAX "THEN" BBMAX:= BB[K]
         "END";
         "IF" K = M1 "THEN" M:= M1 "ELSE"
         "BEGIN"
             T:= D[M] - D[M1]; R:= BB[M1];
             "IF" ABS(T) < TOL "THEN" S:= SQRT(R) "ELSE"
             "BEGIN" W:= 2 / T; S:= W * R / (SQRT(W * W * R + 1) + 1)
             "END"; "IF" K = M - 2 "THEN"
             "BEGIN" D[M]:= D[M] + S; D[M1]:= D[M1] - S;
                 T:= - S / B[M1]; R:= SQRT(T * T + 1); COS:= 1 / R;
                 SIN:= T / R; ROTCOL(1,N,M1,M,A,COS,SIN); M:= M - 2
             "END"
             "ELSE"
             "BEGIN" COUNT:= COUNT + 1;
                 "IF" COUNT > MAX "THEN" "GOTO" END;
                 LAMBDA:= D[M] + S; "IF" ABS(T) < TOL "THEN"
                 "BEGIN" W:= D[M1] - S;
                     "IF" ABS(W) < ABS(LAMBDA) "THEN" LAMBDA:= W
                 "END";
                 K:= K + 1; T:= D[K] - LAMBDA; COS:= 1; W:= B[K];
                 P:= SQRT(T * T + W * W); J1:= K;
                 "FOR" J:= K + 1 "STEP" 1 "UNTIL" M "DO"
                 "BEGIN" OLDCOS:= COS; COS:= T / P; SIN:= W / P;
                     DK1:= D[J] - LAMBDA; T:= OLDCOS * T;
                     D[J1]:= (T + DK1) * SIN * SIN + LAMBDA + T;
                     T:= COS * DK1 - SIN * W * OLDCOS; W:= B[J];
                     P:= SQRT(T * T + W * W); G:= B[J1]:= SIN * P;
                     BB[J1]:= G * G; ROTCOL(1, N, J1, J, A, COS, SIN);
                     J1:= J
                 "END";
                 D[M]:= COS * T + LAMBDA; "IF" T < 0 "THEN" B[M1]:= - G
             "END" QRSTEP
         "END";
         "IF" M > 0 "THEN" "GOTO" IN;
      END: EM[3]:= SQRT(BBMAX); EM[5]:= COUNT; QRISYMTRI:= M
     "END" QRISYMTRI;
         "EOP"
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 1
 
 
 
 AUTHORS:      T.J.DEKKER AND W.HOFFMANN.
 
 
 CONTRIBUTORS: W.HOFFMANN, J.G.VERWER.
 
 
 INSTITUTE:    MATHEMATICAL CENTRE.
 
 
 RECEIVED:     730924.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION  CONTAINS SEVEN PROCEDURES.
     A) EIGVALSYM1  AND  EIGVALSYM2  CALCULATE  ALL EIGENVALUES, OR SOME
     CONSECUTIVE  EIGENVALUES  INCLUDING  THE  LARGEST, OF  A  SYMMETRIC
     MATRIX  USING  LINEAR  INTERPOLATION ON A FUNCTION  DERIVED  FROM A
     STURM SEQUENCE,
     B) EIGSYM1  AND  EIGSYM2  CALCULATE THE CORRESPONDING  EIGENVECTORS
     AS WELL, BY MEANS OF INVERSE ITERATION,
     C) QRIVALSYM1  AND  QRIVALSYM2   CALCULATE  ALL  EIGENVALUES  OF  A
     SYMMETRIC MATRIX BY MEANS OF QR ITERATION,
     D) QRISYM CALCULATES ALL EIGENVECTORS AS WELL IN THE SAME ITERATION
     PROCESS.
     EIGVALSYM1, EIGSYM1 AND QRIVALSYM1 USE IONAL  ARRAY FOR
     THE GIVEN SYMMETRIC MATRIX; THE OTHER  PROCEDURES EXPECT THE MATRIX
     TO BE STORED IN "ARRAY".
     QRISYM DELIVERS THE EIGENVECTORS IN THE ARRAY THAT WAS USED FOR THE
     ORIGINAL MATRIX IN CONTRAST WITH EIGSYM1 AND EIGSYM2 WHICH  DELIVER
     THE EIGENVECTORS IN AN EXTRA ARRAY.
     WHEN ALL EIGENVALUES HAVE TO BE CALCULATED, THE PROCEDURES USING QR
     ITERATION ARE  PREFERABLE WITH  RESPECT TO THEIR RUNNING TIME. WHEN
     ALSO  THE EIGENVECTORS  HAVE TO BE CALCULATED THE PROCEDURES  USING
     INVERSE  ITERATION ARE FASTER; HOWEVER, THE ONE USING  QR ITERATION
     USES LESS MEMORY SPACE.
 
 KEYWORDS:
     EIGENVALUES,
     EIGENVECTORS,
     SYMMETRIC MATRIX,
     STURM-SEQUENCE,
     INVERSE ITERATION,
     QR ITERATION.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: EIGVALSYM2.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" EIGVALSYM2(A, N, NUMVAL, VAL, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
     "CODE" 34153;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     NUMVAL: <ARITHMETIC EXPRESSION>;
             THE SERIAL  NUMBER OF THE LAST EIGENVALUE TO BE CALCULATED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN  THE  UPPER  TRIANGULAR  PART  OF A  (THE
                     ELEMENTS A[I,J], I<= J);
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK  TRANSFORMATION
                     (WHICH ISN'T USED BY THIS PROCEDURE)  IS  DELIVERED
                     IN THE UPPER TRIANGULAR PART OF A;
             THE ELEMENTS A[I,J] FOR I > J ARE NEITHER USED NOR CHANGED;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:NUMVAL];
             EXIT:   THE  NUMVAL  LARGEST  EIGENVALUES IN  MONOTONICALLY
                     NON-INCREASING ORDER;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:3];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE TOLERANCE FOR THE EIGENVALUES;
             EXIT:   EM[1], THE INFINITY NORM OF THE ORIGINAL MATRIX,
                     EM[3], THE   NUMBER   OF   ITERATIONS    USED   FOR
                            CALCULATING THE NUMVAL EIGENVALUES.
 
 
 PROCEDURES USED:
     TFMSYMTRI2      =      CP34140,
     VALSYMTRI       =      CP34151.
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             THREE ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE USED.
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE BODY OF  EIGVALSYM2  CONSISTS OF TWO PROCEDURE  STATEMENTS; THE
     FIRST IS A CALL OF  TFMSYMTRI2 TO  TRANSFORM THE  SYMMETRIC  MATRIX
     INTO  A  SIMILAR  TRIDIAGONAL  MATRIX  BY  MEANS  OF  HOUSEHOLDER'S
     TRANSFORMATION; THE SECOND IS A CALL OF VALSYMTRI TO  CALCULATE THE
     DESIRED EIGENVALUES. OPERATION DETAILS OF BOTH PROCEDURES ARE GIVEN
     IN THEIR DESCRIPTION.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 3
 
 
 
 SUBSECTION: EIGVALSYM1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" EIGVALSYM1(A, N, NUMVAL, VAL, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
     "CODE" 34155;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     NUMVAL: <ARITHMETIC EXPRESSION>;
             THE SERIAL  NUMBER OF THE LAST EIGENVALUE TO BE CALCULATED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:(N+1)*N//2];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN SUCH A WAY  THAT THE (I,J)-TH  ELEMENT OF
                     THE MATRIX IS A[(J-1)*J//2+I],  1 <= I <= J <= N;
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK  TRANSFORMATION
                     (WHICH ISN'T USED BY THIS PROCEDURE).
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:NUMVAL];
             EXIT:   THE  NUMVAL  LARGEST  EIGENVALUES IN  MONOTONICALLY
                     NON-INCREASING ORDER;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:3];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE TOLERANCE FOR THE EIGENVALUES;
             EXIT:   EM[1], THE INFINITY NORM OF THE ORIGINAL MATRIX,
                     EM[3], THE   NUMBER   OF   ITERATIONS    USED   FOR
                            CALCULATING THE NUMVAL EIGENVALUES.
 
 PROCEDURES USED:
     TFMSYMTRI1      =      CP34143,
     VALSYMTRI       =      CP34151.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             THREE ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE USED.
 
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE BODY OF  EIGVALSYM1  CONSISTS OF TWO PROCEDURE  STATEMENTS; THE
     FIRST IS A CALL OF  TFMSYMTRI1 TO  TRANSFORM THE  SYMMETRIC  MATRIX
     INTO  A  SIMILAR  TRIDIAGONAL  MATRIX  BY  MEANS  OF  HOUSEHOLDER'S
     TRANSFORMATION; THE SECOND IS A CALL OF VALSYMTRI TO  CALCULATE THE
     DESIRED EIGENVALUES. OPERATION DETAILS OF BOTH PROCEDURES ARE GIVEN
     IN THEIR DESCRIPTION.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 4
 
 
 
 SUBSECTION: EIGSYM2.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" EIGSYM2(A, N, NUMVAL, VAL, VEC, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL; "ARRAY" A, VAL, VEC, EM;
     "CODE" 34154;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     NUMVAL: <ARITHMETIC EXPRESSION>;
             THE SERIAL  NUMBER OF THE LAST EIGENVALUE TO BE CALCULATED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN  THE  UPPER  TRIANGULAR  PART  OF A  (THE
                     ELEMENTS A[I,J], I<= J);
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK  TRANSFORMATION
                     IS DELIVERED IN THE UPPER TRIANGULAR PART OF A;
             THE ELEMENTS A[I,J] FOR I > J ARE NEITHER USED NOR CHANGED;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:NUMVAL];
             EXIT:   THE  NUMVAL  LARGEST  EIGENVALUES IN  MONOTONICALLY
                     NON-INCREASING ORDER;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:NUMVAL];
             EXIT:   THE NUMVAL CALCULATED  EIGENVECTORS, STORED COLUMN-
                     WISE, CORRESPONDING TO THE CALCULATED  EIGENVALUES;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE TOLERANCE FOR THE EIGENVALUES,
                     EM[4], THE ORTHOGONALISATION  PARAMETER (SEE METHOD
                            AND PERFORMANCE),
                     EM[6], THE TOLERANCE FOR THE EIGENVECTORS,
                     EM[8], THE  MAXIMUM  NUMBER OF  INVERSE  ITERATIONS
                            ALLOWED  FOR THE CALCULATION OF EACH  EIGEN-
                            VECTOR;
             EXIT:   EM[1], THE INFINITY NORM OF THE MATRIX,
                     EM[3], THE   NUMBER   OF   ITERATIONS    USED   FOR
                            CALCULATING THE NUMVAL EIGENVALUES,
                     EM[5], THE  NUMBER OF EIGENVECTORS  INVOLVED IN THE
                            LAST GRAM-SCHMIDT ORTHOGONALISATION,
                     EM[7], THE MAXIMUM  EUCLIDEAN  NORM OF THE RESIDUES
                            OF THE CALCULATED EIGENVECTORS,
                     EM[9], THE  LARGEST  NUMBER  OF INVERSE  ITERATIONS
                            PERFORMED FOR THE CALCULATION OF SOME EIGEN-
                            VECTOR.
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 5
 
 
 
 PROCEDURES USED:
     TFMSYMTRI2      =      CP34140,
     VALSYMTRI       =      CP34151,
     VECSYMTRI       =      CP34152,
     BAKSYMTRI2      =      CP34141.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             THREE ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE DECLARED;
             MOREOVER,  VECSYMTRI USES FIVE ONE-DIMENSIONAL  REAL ARRAYS
             OF LENGTH N AND ONE BOOLEAN ARRAY OF LENGTH N.
 
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE  BODY  OF  EIGSYM2  CONSISTS  OF  FOUR  PROCEDURE   STATEMENTS;
     THE  FIRST  IS  A  CALL  OF TFMSYMTRI2 TO  TRANSFORM THE  SYMMETRIC
     MATRIX  INTO   A   SIMILAR   TRIDIAGONAL   MATRIX   BY   MEANS   OF
     HOUSEHOLDERS TRANSFORMATION,
     THE  SECOND  IS  A  CALL  OF  VALSYMTRI  TO  CALCULATE THE  DESIRED
     EIGENVALUES,
     THE  THIRD  IS A CALL OF VECSYMTRI  TO CALCULATE  THE CORRESPONDING
     EIGENVECTORS AND
     THE   FOURTH   IS  A   CALL  OF  BAKSYMTRI2  TO  PERFORM  THE  BACK
     TRANSFORMATION.
     THE  PARAMETERS  EM[5], EM[7] AND EM[9] ARE  GIVEN ITS VALUE IN THE
     PROCEDURE  VECSYMTRI.  FOR A POSSIBLY  SUBSEQUENT CALL OF VECSYMTRI
     THE VALUE OF EM[5] IS NEEDED.  WHEN CONSECUTIVE EIGENVALUES ARE TOO
     CLOSE TOGETHER, THE CORRESPONDING  EIGENVECTORS ARE NOT NECESSARILY
     DELIVERED ORTHOGONAL BY INVERSE ITERATION (THE METHOD WHICH IS USED
     IN VECSYMTRI). THEREFORE GRAM-SCHMIDT  ORTHOGONALISATION IS APPLIED
     ON  THE  EIGENVECTORS  WHEN  THE  DISTANCE  BETWEEN TWO CONSECUTIVE
     EIGENVALUES IS SMALLER THAN EM[4].
     FOR FURTHER  DETAILS  ONE IS REFERRED  TO  THE  SPECIFIC  PROCEDURE
     DESCRIPTIONS.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 6
 
 
 
 SUBSECTION: EIGSYM1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" EIGSYM1(A, N, NUMVAL, VAL, VEC, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL; "ARRAY" A, VAL, VEC, EM;
     "CODE" 34156;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     NUMVAL: <ARITHMETIC EXPRESSION>;
             THE SERIAL  NUMBER OF THE LAST EIGENVALUE TO BE CALCULATED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:(N+1)*N//2];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN SUCH A WAY  THAT THE (I,J)-TH  ELEMENT OF
                     THE MATRIX IS A[(J-1)*J//2+I],  1 <= I <= J <= N;
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK TRANSFORMATION;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:NUMVAL];
             EXIT:   THE  NUMVAL  LARGEST  EIGENVALUES IN  MONOTONICALLY
                     NON-INCREASING ORDER;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:NUMVAL];
             EXIT:   THE NUMVAL CALCULATED  EIGENVECTORS, STORED COLUMN-
                     WISE, CORRESPONDING TO THE CALCULATED  EIGENVALUES;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE TOLERANCE FOR THE EIGENVALUES,
                     EM[4], THE ORTHOGONALISATION  PARAMETER (SEE METHOD
                            AND PERFORMANCE),
                     EM[6], THE TOLERANCE FOR THE EIGENVECTORS,
                     EM[8], THE  MAXIMUM  NUMBER OF  INVERSE  ITERATIONS
                            ALLOWED  FOR THE CALCULATION OF EACH  EIGEN-
                            VECTOR;
             EXIT:   EM[1], THE INFINITY NORM OF THE MATRIX,
                     EM[3], THE   NUMBER   OF   ITERATIONS    USED   FOR
                            CALCULATING THE NUMVAL EIGENVALUES,
                     EM[5], THE  NUMBER OF EIGENVECTORS  INVOLVED IN THE
                            LAST GRAM-SCHMIDT ORTHOGONALISATION,
                     EM[7], THE MAXIMUM  EUCLIDEAN  NORM OF THE RESIDUES
                            OF THE CALCULATED EIGENVECTORS,
                     EM[9], THE  LARGEST  NUMBER  OF INVERSE  ITERATIONS
                            PERFORMED FOR THE CALCULATION OF SOME EIGEN-
                            VECTOR.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 7
 
 
 
 PROCEDURES USED:
     TFMSYMTRI1      =      CP34143,
     VALSYMTRI       =      CP34151,
     VECSYMTRI       =      CP34152,
     BAKSYMTRI1      =      CP34144.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             THREE ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE DECLARED;
             MOREOVER,  VECSYMTRI  AND  BAKSYMTRI1 USE A TOTAL AMOUNT OF
             SIX ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N AND ONE BOOLEAN
             ARRAY OF LENGTH N.
 
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE  BODY  OF  EIGSYM1  CONSISTS  OF  FOUR  PROCEDURE   STATEMENTS;
     THE  FIRST  IS  A  CALL  OF TFMSYMTRI1 TO  TRANSFORM THE  SYMMETRIC
     MATRIX  INTO   A   SIMILAR   TRIDIAGONAL   MATRIX   BY   MEANS   OF
     HOUSEHOLDERS TRANSFORMATION,
     THE  SECOND  IS  A  CALL  OF  VALSYMTRI  TO  CALCULATE THE  DESIRED
     EIGENVALUES,
     THE  THIRD  IS A CALL OF VECSYMTRI  TO CALCULATE  THE CORRESPONDING
     EIGENVECTORS AND
     THE   FOURTH   IS  A   CALL  OF  BAKSYMTRI1  TO  PERFORM  THE  BACK
     TRANSFORMATION.
     FOR DETAILS ONE IS REFERRED  TO EIGSYM2  OR TO THE  DESCRIPTIONS OF
     THE FOUR PROCEDURES USED.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 8
 
 
 
 SUBSECTION: QRIVALSYM2.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" QRIVALSYM2(A, N, VAL, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A, VAL, EM;
     "CODE" 34162;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN  THE  UPPER  TRIANGULAR  PART  OF A  (THE
                     ELEMENTS A[I,J], I<= J);
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK  TRANSFORMATION
                     (WHICH ISN'T USED BY THIS PROCEDURE)  IS  DELIVERED
                     IN THE UPPER TRIANGULAR PART OF A;
             THE ELEMENTS A[I,J] FOR I > J ARE NEITHER USED NOR CHANGED;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT:   THE EIGENVALUES OF THE  MATRIX  IN  SOME  ARBITRARY
                     ORDER;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE  TOLERANCE FOR THE EIGENVALUES,
                     EM[4], THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
             EXIT:   EM[1], THE INFINITY NORM OF THE MATRIX,
                     EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE CODIAGONAL
                            ELEMENTS NEGLECTED,
                     EM[5], THE NUMBER OF ITERATIONS PERFORMED;
     MOREOVER:
             QRIVALSYM2:=   THE NUMBER OF  EIGENVALUES  NOT  CALCULATED.
 
 PROCEDURES USED:
     TFMSYMTRI2      =      CP34140,
     QRIVALSYMTRI    =      CP34160.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             IONAL REAL ARRAYS OF LENGTH N ARE USED.
 
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                         PAGE 9
 
 
 
 METHOD AND PERFORMANCE:
     THE BODY OF  QRIVALSYM2  CONSISTS OF TWO PROCEDURE  STATEMENTS; THE
     FIRST IS A CALL OF  TFMSYMTRI2 TO  TRANSFORM THE  SYMMETRIC  MATRIX
     INTO  A  SIMILAR  TRIDIAGONAL  MATRIX  BY  MEANS  OF  HOUSEHOLDER'S
     TRANSFORMATION; THE SECOND IS A CALL OF  QRIVALSYMTRI TO  CALCULATE
     THE  EIGENVALUES.  WHEN  THE  PROCESS  IS  COMPLETED  WITHIN  EM[4]
     ITERATIONS  THEN QRIVALSYM2:= 0; OTHERWISE QRIVALSYM2:= THE NUMBER,
     K, OF  EIGENVALUES  NOT  CALCULATED, EM[5]:= EM[4] + 1 AND ONLY THE
     LAST N - K ELEMENTS OF VAL ARE APPROXIMATE EIGENVALUES OF THE GIVEN
     MATRIX. OPERATION  DETAILS OF BOTH  PROCEDURES  USED  ARE  GIVEN IN
     THEIR DESCRIPTION.
 
 
 SUBSECTION: QRIVALSYM1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" QRIVALSYM1(A, N, VAL, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A, VAL, EM;
     "CODE" 34164;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:(N+1)*N//2];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN SUCH A WAY  THAT THE (I,J)-TH  ELEMENT OF
                     THE MATRIX IS A[(J-1)*J//2+I],  1 <= I <= J <= N;
             EXIT:   THE  DATA  FOR  HOUSEHOLDER'S  BACK  TRANSFORMATION
                     (WHICH ISN'T USED BY THIS PROCEDURE).
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT:   THE EIGENVALUES OF THE  MATRIX  IN  SOME  ARBITRARY
                     ORDER;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE  TOLERANCE FOR THE EIGENVALUES,
                     EM[4], THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
             EXIT:   EM[1], THE INFINITY NORM OF THE MATRIX,
                     EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE CODIAGONAL
                            ELEMENTS NEGLECTED,
                     EM[5], THE NUMBER OF ITERATIONS PERFORMED;
     MOREOVER:
             QRIVALSYM1:=   THE NUMBER OF  EIGENVALUES  NOT  CALCULATED.
 
 PROCEDURES USED:
     TFMSYMTRI1      =      CP34143,
     QRIVALSYMTRI    =      CP34160.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             TWO ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE USED.
 
 
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 10
 
 
 
 RUNNING TIME:
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE BODY OF  QRIVALSYM1  CONSISTS OF TWO PROCEDURE  STATEMENTS; THE
     FIRST IS A CALL OF  TFMSYMTRI1 TO  TRANSFORM THE  SYMMETRIC  MATRIX
     INTO  A  SIMILAR  TRIDIAGONAL  MATRIX  BY  MEANS  OF  HOUSEHOLDER'S
     TRANSFORMATION; THE SECOND IS A CALL OF  QRIVALSYMTRI TO  CALCULATE
     THE  EIGENVALUES.  WHEN  THE  PROCESS  IS  COMPLETED  WITHIN  EM[4]
     ITERATIONS  THEN QRIVALSYM1:= 0; OTHERWISE QRIVALSYM1:= THE NUMBER,
     K, OF  EIGENVALUES  NOT  CALCULATED, EM[5]:= EM[4] + 1 AND ONLY THE
     LAST N - K ELEMENTS OF VAL ARE APPROXIMATE EIGENVALUES OF THE GIVEN
     MATRIX. OPERATION  DETAILS OF BOTH  PROCEDURES  USED  ARE  GIVEN IN
     THEIR DESCRIPTION.
 
 
 SUBSECTION: QRISYM.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" QRISYM(A, N, VAL, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A, VAL, EM;
     "CODE" 34163;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:  THE UPPER  TRIANGLE OF THE SYMMETRIC MATRIX MUST BE
                     GIVEN  IN  THE  UPPER  TRIANGULAR  PART  OF A  (THE
                     ELEMENTS A[I,J], I<= J);
             EXIT:   THE  EIGENVECTORS OF THE  SYMMETRIC  MATRIX, STORED
                     COLUMNWISE;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT:   THE EIGENVALUES OF THE MATRIX  CORRESPONDING TO THE
                     CALCULATED EIGENVECTORS;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0], THE MACHINE PRECISION,
                     EM[2], THE RELATIVE TOLERANCE FOR THE QR ITERATION,
                     EM[4], THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
             EXIT:   EM[1], THE INFINITY NORM OF THE MATRIX,
                     EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE CODIAGONAL
                            ELEMENTS NEGLECTED,
                     EM[5], THE NUMBER OF ITERATIONS PERFORMED;
     MOREOVER:
             QRISYM  :=     THE NUMBER OF  EIGENVALUES AND  -VECTORS NOT
                            CALCULATED.
 
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 11
 
 
 
 PROCEDURES USED:
     TFMSYMTRI2      =      CP34140,
     TFMPREVEC       =      CP34142,
     QRISYMTRI       =      CP34161.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH:
             TWO ONE-DIMENSIONAL REAL ARRAYS OF LENGTH N ARE USED.
 
 RUNNING TIME:
     PROPORTIONAL TO N CUBED.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE BODY OF  QRISYM  CONSISTS OF  THREE  PROCEDURE  STATEMENTS; THE
     FIRST IS A CALL OF  TFMSYMTRI2 TO  TRANSFORM THE  SYMMETRIC  MATRIX
     INTO  A  SIMILAR  TRIDIAGONAL  MATRIX  BY  MEANS  OF  HOUSEHOLDER'S
     TRANSFORMATION,  THE  SECOND IS A CALL OF TFMPREVEC  TO PERFORM THE
     DESIRED  BACK TRANSFORMATION ON THE EIGENVECTORS IN ADVANCE AND THE
     THIRD IS A CALL OF  QRISYMTRI  TO  CALCULATE  THE  EIGENVALUES  AND
     THE EIGENVECTORS.  WHEN  THE  PROCESS  IS  COMPLETED  WITHIN  EM[4]
     ITERATIONS  THEN  QRISYM:= 0;  OTHERWISE QRISYM:= THE NUMBER, K, OF
     EIGENVALUES AND -VECTORS NOT CALCULATED, EM[5]:= EM[4] + 1 AND ONLY
     THE LAST N - K  ELEMENTS OF VAL AND THE LAST N - K COLUMNS OF A ARE
     APPROXIMATE EIGENVALUES AND EIGENVECTORS  RESPECTIVELY OF THE GIVEN
     MATRIX. OPERATION  DETAILS OF  THE  PROCEDURES  USED  ARE  GIVEN IN
     THEIR DESCRIPTION.
 
 
 EXAMPLES OF USE:
 
     THE TWO LARGEST  EIGENVALUES IN MONOTONICALLY NON INCREASING  ORDER
     AND THE  CORRESPONDING  EIGENVECTORS OF M, WITH N = 4 AND  M[I,J] =
     1 / (I + J - 1), MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" I, J;
         "ARRAY" A[1:10], VAL[1:2], EM[0:9], VEC[1:4,1:2];
 
         EM[0]:= "-14; EM[2]:= "-12; EM[4]:= "-3;
         EM[6]:= 10"-10; EM[8]:= 5;
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "FOR" J:= I "STEP" 1 "UNTIL" 4 "DO"
         A[(J * J - J) / 2 + I]:= 1 / (I + J - 1);
         EIGSYM1(A, 4, 2, VAL, VEC, EM);
         OUTPUT(61, "("2(+.13D"+2D, 2B), 2/")", VAL[1], VAL[2]);
         "FOR" I:= 1, 2, 3, 4 "DO"
         OUTPUT(61, "("2(+.13D"+2D, 2B), /")", VEC[I,1], VEC[I,2]);
         OUTPUT(61, "("2(.2D"+2D, /), 3(2ZD, /)")",
         EM[1], EM[7], EM[3], EM[5], EM[9])
     "END"
 
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 12
 
 
 
     THE PROGRAM DELIVERS(THE RESULTS ARE CORRECT UP TO TWELVE DIGITS):
 
     THE EIGENVALUES:  +.1500214280059"+01  +.1691412202214"+00
 
     THE EIGENVECTORS: -.7926082911638"+00  +.5820756994972"+00
                       -.4519231209016"+00  -.3705021850671"+00
                       -.3224163985818"+00  -.5095786345018"+00
                       -.2521611696882"+00  -.5140482722222"+00
 
     EM[1] = .21"+01
     EM[7] = .92"-14
     EM[3] = 32
     EM[5] = 1
     EM[9] = 1 .
 
 
     THE  TWO  LARGEST  EIGENVALUES  OF  M, WITH  N = 4   AND   M[I,J] =
     1 / (I + J - 1), MAY  BE  OBTAINED IN  MONOTONICALLY NON INCREASING
     ORDER BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" I, J;
         "ARRAY" A[1:4,1:4], VAL[1:2], EM[0:3];
 
         EM[0]:= "-14; EM[2]:= "-12;
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "FOR" J:= I "STEP" 1 "UNTIL" 4 "DO" A[I,J]:= 1 / (I + J -1);
         EIGVALSYM2(A, 4, 2, VAL, EM);
         OUTPUT(61, "("2(+.13D"+2D, 2B)")", VAL[1], VAL[2]);
         OUTPUT(61, "("2/, .2D"+2D, /, 2ZD")", EM[1], EM[3])
     "END"
 
     THE PROGRAM DELIVERS(THE RESULTS ARE CORRECT UP TO TWELVE DIGITS):
 
     THE EIGENVALUES: +.1500214280059"+01  +.1691412202214"+00
     EM[3] = .21"+01
     EM[1] = 32  .
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 13
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34153;
 "COMMENT" MCA 2313;
 "PROCEDURE" EIGVALSYM2(A, N, NUMVAL, VAL, EM); "VALUE" N, NUMVAL;
 "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B, BB, D[1:N];
 
         TFMSYMTRI2(A, N, D, B, BB, EM);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
     "END" EIGVALSYM2;
         "EOP"
0"CODE" 34154;
 "COMMENT" MCA 2314;
 "PROCEDURE" EIGSYM2(A, N, NUMVAL, VAL, VEC, EM); "VALUE" N, NUMVAL;
 "INTEGER" N, NUMVAL; "ARRAY" A, VAL, VEC, EM;
 "BEGIN" "ARRAY" B, BB, D[1:N];
 
         TFMSYMTRI2(A, N, D, B, BB, EM);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM);
         VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VEC, EM);
         BAKSYMTRI2(A, N, 1, NUMVAL, VEC)
     "END" EIGSYM2;
         "EOP"
0"CODE" 34155;
 "COMMENT" MCA 2318;
 "PROCEDURE" EIGVALSYM1(A, N, NUMVAL, VAL, EM); "VALUE" N, NUMVAL;
 "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B, BB, D[1:N];
 
         TFMSYMTRI1(A, N, D, B, BB, EM);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
     "END" EIGVALSYM1
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 14
 
 
                                                                  ;
         "EOP"
0"CODE" 34156;
 "COMMENT" MCA 2319;
 "PROCEDURE" EIGSYM1(A, N, NUMVAL, VAL, VEC, EM); "VALUE" N, NUMVAL;
 "INTEGER" N, NUMVAL; "ARRAY" A, VAL, VEC, EM;
 "BEGIN" "ARRAY" B, BB, D[1:N];
 
         TFMSYMTRI1(A, N, D, B, BB, EM);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM);
         VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VEC, EM);
         BAKSYMTRI1(A, N, 1, NUMVAL, VEC)
     "END" EIGSYM1;
         "EOP"
0"CODE" 34162;
 "COMMENT" MCA 2322;
 "INTEGER" "PROCEDURE" QRIVALSYM2(A, N, VAL, EM); "VALUE" N;
 "INTEGER" N; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B, BB[1:N];
 
         TFMSYMTRI2(A, N, VAL, B, BB, EM);
         QRIVALSYM2:= QRIVALSYMTRI(VAL, BB, N, EM)
     "END" QRIVALSYM2
1SECTION 3.3.1.1.2            (JULY 1974)                        PAGE 15
 
 
                                                                  ;
         "EOP"
0"CODE" 34163;
 "COMMENT" MCA 2323;
 "INTEGER" "PROCEDURE" QRISYM(A, N, VAL, EM); "VALUE" N;
 "INTEGER" N; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B, BB[1:N];
 
         TFMSYMTRI2(A, N, VAL, B, BB, EM); TFMPREVEC(A, N);
         QRISYM:= QRISYMTRI(A, N, VAL, B, BB, EM)
     "END" QRISYM;
         "EOP"
0"CODE" 34164;
 "COMMENT" MCA 2327;
 "INTEGER" "PROCEDURE" QRIVALSYM1(A, N, VAL, EM); "VALUE" N;
 "INTEGER" N; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B, BB[1 : N];
 
         TFMSYMTRI1(A, N, VAL, B, BB, EM);
         QRIVALSYM1:= QRIVALSYMTRI(VAL, BB, N, EM)
     "END" QRIVALSYM1;
         "EOP"
1SECTION : 3.3.1.1.3.1        (NOVEMBER 1976)                     PAGE 1
 
 
 
 AUTHORS: J.J.G. ADMIRAAL, A.C. YSSELSTEIN.
 
 CONTRIBUTOR: J.J.G. ADMIRAAL.
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 RECEIVED: 761101.
 
 BRIEF DESCRIPTION:
     THIS SECTION CONTAINS THREE PROCEDURES FOR SORTING THE
     ELEMENTS OF A VECTOR AND CORRESPONDINGLY PERMUTING THE
     ELEMENTS OF A VECTOR OR A MATRIX ROW.
     A) MERGESORT DELIVERS A PERMUTATION OF INDICES
        CORRESPONDING TO SORTING THE ELEMENTS OF A GIVEN
        VECTOR INTO NON-DECREASING ORDER.
     B) VECPERM PERMUTES THE ELEMENTS OF A GIVEN VECTOR
        CORRESPONDING TO A GIVEN PERMUTATION OF INDICES.
     C) ROWPERM PERMUTES THE ELEMENTS OF A GIVEN ROW OF A
        MATRIX CORRESPONDING TO A GIVEN PERMUTATION OF
        INDICES.
 
 KEYWORDS:
     SORTING,
     PERMUTING.
 
 
 SUBSECTION: MERGESORT.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" MERGESORT(VEC1,VEC2,LOW,UPP);
     "VALUE" LOW,UPP;"INTEGER" LOW,UPP;"ARRAY" VEC1;
     "INTEGER""ARRAY" VEC2; "CODE" 36405;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     VEC1   :<ARRAY IDENTIFIER>;
             "ARRAY" VEC1[LOW:UPP];
             ENTRY: THE VECTOR TO BE SORTED INTO
                    NONDECREASING ORDER;
             EXIT: THE CONTENTS OF VEC1 ARE LEFT INVARIANT;
     VEC2   :<ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" VEC2[LOW:UPP];
             EXIT: THE PERMUTATION OF INDICES CORRESPONDING TO
                   SORTING THE ELEMENTS OF VEC1 INTO
                   NON-DECREASING ORDER;
     LOW   : <ARITHMETIC EXPRESSION>;
             THE LOWER INDEX OF THE ARRAYS VEC1 AND VEC2;
     UPP   : <ARITHMETIC EXPRESSION>;
             THE UPPER INDEX OF THE ARRAYS VEC1 AND VEC2;
1SECTION : 3.3.1.1.3.1        (NOVEMBER 1976)                     PAGE 2
 
 
 
 PROCEDURES USED: NONE.
 
 REQUIRED CENTRAL MEMORY: ONE LOCAL INTEGER ARRAY OF
                           LENGTH N,WHERE N = UPP - LOW + 1.
 
 RUNNING TIME: AVERAGE PROPORTIONAL TO N * LN(N).
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE: SORTING BY MERGING. ([1],[2])
 
 EXAMPLE OF USE: THE PROCEDURE MERGESORT IS USED IN SYMEIGIMP
                 (SECTION 3.3.1.1.3.3).
 
 
 SUBSECTION: VECPERM.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" VECPERM(PERM,LOW,UPP,VECTOR);
     "VALUE" LOW,UPP; "INTEGER" LOW,UPP;
     "INTEGER" "ARRAY" PERM;"ARRAY" VECTOR;
     "CODE" 36404;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     PERM   :<ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" PERM[LOW:UPP];
             ENTRY: A GIVEN PERMUTATION (E.G.AS PRODUCED BY
             MERGESORT) OF THE NUMBERS IN THE ARRAY VECTOR;
     LOW    :<ARITHMETIC EXPRESSION>;
             THE LOWER INDEX OF THE ARRAYS PERM AND VECTOR;
     UPP    :<ARITHMETIC EXPRESSION>;
             THE UPPER INDEX OF THE ARRAYS PERM AND VECTOR;
     VECTOR :<ARRAY IDENTIFIER>;
             "ARRAY" VECTOR[LOW:UPP];
             ENTRY: THE REAL VECTOR TO BE PERMUTED;
             EXIT: THE PERMUTED VECTOR ELEMENTS.
 
 PROCEDURE  USED: NONE.
 
 REQUIRED CENTRAL MEMORY :
     ONE LOCAL BOOLEAN ARRAY OF LENGTH N IS DECLARED.
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 LANGUAGE: ALGOL 60.
 
 EXAMPLE OF USE: THE PROCEDURE VECPERM IS USED IN SYMEIGIMP;
                 (SECTION 3.3.1.1.3.3).
1SECTION : 3.3.1.1.3.1        (NOVEMBER 1976)                     PAGE 3
 
 
 
 SUBSECTION: ROWPERM.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
 
     "PROCEDURE" ROWPERM(PERM,LOW,UPP,I,MATRIX);
     "VALUE" LOW,UPP,I;"INTEGER" LOW,UPP,I;
     "INTEGER" "ARRAY" PERM;"ARRAY" MATRIX;
     "CODE" 36403;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     PERM   :<ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" PERM[LOW:UPP];
             ENTRY: A GIVEN PERMUTATION (E.G. AS PRODUCED BY
             MERGESORT) OF THE NUMBERS IN THE ARRAY VECTOR;
     LOW    :<ARITHMETIC EXPRESSION>;
             THE LOWER INDEX OF THE ARRAY PERM;
     UPP    :<ARITHMETIC EXPRESSION>;
             THE UPPER INDEX OF THE ARRAY PERM;
     I      :<ARITHMETIC EXPRESSION>;
             THE ROW INDEX OF THE MATRIX ELEMENTS;
     MATRIX :<ARRAY IDENTIFIER>:
             "ARRAY" MATRIX [I :I, LOW : UP];
             ENTRY:MATRIX [I, LOW : UP] SHOULD CONTAIN THE
             ELEMENTS TO BE PERMUTED;
             EXIT: MATRIX[I, LOW : UP] CONTAINS THE ROW OF
             PERMUTED ELEMENTS;
 
 PROCEDURES USED: NONE.
 
 REQUIRED CENTRAL MEMORY:
     ONE LOCAL BOOLEAN ARRAY OF LENGTH N IS DECLARED.
 
 RUNNING TIME: PROPORTIONAL TO N, WHERE N = UPP - LOW + 1.
 
 LANGUAGE: ALGOL 60.
 
 EXAMPLE OF USE: THE PROCEDURE ROWPERM IS USED IN SYMEIGIMP.
                 (SECTION 3.3.1.1.3.3).
 
 
 REFERENCES:
 
     [1]   D.E. KNUTH , THE ART OF COMPUTER PROGRAMMING,
           VOL. 3/ SORTING AND SEARCHING,ADDISON-WESLEY 1973.
           (SECTION 5.2.4  P.159-173).
     [2]   A.V. AHO, J.E. HOPCROFT & J.D. ULLMAN,
           THE DESIGN AND ANALYSIS OF COMPUTER ALGORITHMS,
           ADDISON-WESLEY 1974.
           (SECTION I.M, P65-67).
1SECTION : 3.3.1.1.3.1        (NOVEMBER 1976)                     PAGE 4
 
 
 
 SOURCE TEXTS:
0"CODE" 36405;
 "PROCEDURE" MERGESORT(A,P,LOW,UP);"VALUE" LOW,UP;
 "INTEGER" LOW,UP;"ARRAY" A;"INTEGER" "ARRAY" P;
 "BEGIN" "INTEGER" I,L,R,PL,PR,LO,STEP,STAP,UMLP1,UMSP1,REST,RESTV;
     "BOOLEAN" ROUT,LOUT; "INTEGER" "ARRAY" HP[LOW:UP];
     "PROCEDURE" MERGE(LO,LS,RS);"VALUE" LO,LS,RS;"INTEGER" LO,LS,RS;
     "BEGIN" L:=LO; R:=LO+LS; LOUT:=ROUT:="FALSE";
         "FOR" I:=LO,I+1 "WHILE" ^(LOUT "OR" ROUT) "DO"
         "BEGIN" PL:=P[L];PR:=P[R];"IF" A[PL]>A[PR] "THEN"
             "BEGIN" HP[I]:=PR;R:=R+1;ROUT:=R=LO+LS+RS "END" "ELSE"
             "BEGIN" HP[I]:=PL;L:=L+1;LOUT:=L=LO+LS    "END"
         "END" FOR I;
         "IF" ROUT "THEN"
         "BEGIN" "FOR" I:=LO+LS-1 "STEP" -1 "UNTIL" L "DO"
             P[I+RS]:=P[I];R:=L+RS
         "END";
         "FOR" I:=R-1 "STEP" -1 "UNTIL" LO "DO" P[I]:=HP[I];
     "END" MERGE;
     "FOR" I:=LOW "STEP" 1 "UNTIL" UP "DO" P[I]:=I;RESTV:=0;
     UMLP1:=UP-LOW+1;
     "FOR" STEP:=1, STEP*2 "WHILE" STEP < UMLP1 "DO"
     "BEGIN" STAP:=2*STEP;UMSP1:=UP-STAP+1;
         "FOR" LO:=LOW "STEP" STAP "UNTIL" UMSP1 "DO"
         MERGE(LO,STEP,STEP); REST:=UP-LO+1;
         "IF" REST>RESTV & RESTV>0 "THEN" MERGE(LO,REST-RESTV,RESTV);
         RESTV:=REST
     "END" FOR STEP
 "END" MERGESORT
1SECTION : 3.3.1.1.3.1        (NOVEMBER 1976)                     PAGE 5
 
 
                                                                   ;
         "EOP"
 "CODE" 36404;
 "PROCEDURE" VECPERM(PERM,LOW,UPP,VECTOR);"VALUE" LOW,UPP;
 "INTEGER" LOW,UPP;"INTEGER" "ARRAY" PERM;"REAL" "ARRAY" VECTOR;
 "BEGIN" "INTEGER" T,J,K;"REAL" A;"BOOLEAN" "ARRAY" TODO[LOW:UPP];
     "FOR" T:=LOW "STEP" 1 "UNTIL" UPP "DO" TODO[T]:="TRUE";
     "FOR" T:=LOW "STEP" 1 "UNTIL" UPP "DO"
     "BEGIN" "IF" TODO[T] "THEN"
         "BEGIN" K:=T;A:=VECTOR[K];
             "FOR" J:=PERM[K] "WHILE" J^=T "DO"
             "BEGIN" VECTOR[K]:=VECTOR[J];TODO[K]:="FALSE";K:=J
             "END";VECTOR[K]:=A;TODO[K]:="FALSE"
         "END" CYCLE;
     "END" FOR T;
 "END" VECPERM;
 
         "EOP"
 "CODE" 36403;
 "PROCEDURE" ROWPERM(PERM,LOW,UPP,I,MAT);"VALUE" LOW,UPP,I;
 "INTEGER" LOW,UPP,I;"INTEGER" "ARRAY" PERM;"REAL" "ARRAY" MAT;
 "BEGIN" "INTEGER" T,J,K;"REAL" A;"BOOLEAN" "ARRAY" TODO[LOW:UPP];
     "FOR" T:=LOW "STEP" 1 "UNTIL" UPP "DO" TODO[T]:="TRUE";
     "FOR" T:=LOW "STEP" 1 "UNTIL" UPP "DO"
     "BEGIN" "IF" TODO[T] "THEN"
         "BEGIN" K:=T;A:=MAT[I,K];
             "FOR" J:=PERM[K] "WHILE" J^=T "DO"
             "BEGIN" MAT[I,K]:=MAT[I,J];TODO[K]:="FALSE";K:=J
             "END";MAT[I,K]:=A;TODO[K]:="FALSE"
         "END" CYCLE;
     "END" FOR T;
 "END" ROWPERM;
         "EOP"
1SECTION : 3.3.1.1.3.2        (NOVEMBER 1976)                     PAGE 1
  
  
  
 AUTHOR/CONTRIBUTOR: J.J.G. ADMIRAAL.
  
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
  
 RECEIVED: 761101.
  
 BRIEF DESCRIPTION:
     THE PROCEDURE ORTHOG ORTHOGONALIZES SOME ADJACENT MATRIX COLUMNS
     ACCORDING TO THE MODIFIED GRAM SCHMIDT METHOD (SEE [1]).
  
 KEYWORDS:
     MATRIX COLUMNS,
     MODIFIED GRAM SCHMIDT ORTHOGONALIZATION.
  
 CALLING SEQUENCE:
  
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
  
     "PROCEDURE" ORTHOG(N,LC,UC,X);
     "VALUE" N,LC,UC; "INTEGER" N,LC,UC;"ARRAY" X;
     "CODE" 36402;
  
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N    :<ARITHMETIC EXPRESSION>;
           THE ORDER OF THE MATRIX X;
     LC   :<ARITHMETIC EXPRESSIOM>;
           THE LOWER COLUMN INDEX OF THE MATRIX COLUMNS;
     UC   :<ARITHMETIC EXPRESSION>;
           THE UPPER COLUMN INDEX OF THE MATRIX COLUMNS;
     X    :<ARRAY IDENTIFIER>;
           "ARRAY" X[1:N,LC:UC];
           ENTRY: THE MATRIX COLUMNS,TO BE
                  ORTHOGONALIZED;
           EXIT: THE ORTHOGONALIZED MATRIX COLUMNS.
  
 PROCEDURES USED:
     TAMMAT = CP34014,
     ELMCOL = CP34023.
  
 REQUIRED CENTRAL MEMORY: NO LOCAL ARRAYS ARE DECLARED.
  
 RUNNING TIME: PROPORTIONAL TO N**3.
  
1SECTION : 3.3.1.1.3.2        (NOVEMBER 1976)                     PAGE 2
  
  
  
 LANGUAGE: ALGOL 60.
  
 METHOD AND PERFORMANCE:
     THE MODIFIED GRAM SCHMIDT METHOD (SEE [1],CHAPTER 4.54).
  
 EXAMPLE OF USE: THE PROCEDURE ORTHOG IS USED IN SYMEIGIMP.
                 (SECTION 3.3.1.1.3.3).
  
  
 REFERENCES:
     [1]   J.H. WILKINSON.
           THE ALGEBRAIC EIGENVALUE PROBLEM.
           CLARENDON PRESS,OXFORD,1965.
  
  
 SOURCE TEXT:
0"CODE" 36402;
 "PROCEDURE" ORTHOG(N,LC,UC,X);"VALUE" N,LC,UC;
 "INTEGER" N,LC,UC;"ARRAY" X;
 "BEGIN" "INTEGER" I,J,K; "REAL" NORMX;
     "FOR" J:=LC "STEP" 1 "UNTIL" UC "DO"
     "BEGIN" NORMX:=SQRT(TAMMAT(1,N,J,J,X,X));
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" X[I,J]:=X[I,J]/NORMX;
         "FOR" K:=J+1 "STEP" 1 "UNTIL" UC "DO"
         ELMCOL(1,N,K,J,X,X,-TAMMAT(1,N,K,J,X,X))
     "END"
 "END" ORTHOG;
         "EOP"
1SECTION : 3.3.1.1.3.3        (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR/CONTRIBUTOR: J.J.G. ADMIRAAL.
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 RECEIVED: 761101.
 
 BRIEF DESCRIPTION:
     THE PROCEDURE SYMEIGIMP IMPROVES A GIVEN APPROXIMATION OF
     A REAL SYMMETRIC EIGENSYSTEM AND CALCULATES ERROR BOUNDS
     FOR THE EIGENVALUES.
 
 KEYWORDS:
     EIGENVALUES.
     EIGENVECTORS.
     SYMMETRIC MATRIX.
     RAYLEIGH QUOTIENTS.
     ERROR BOUNDS.
     IMPROVED EIGENSYSTEM.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS :
 
     "PROCEDURE" SYMEIGIMP(N,A,VEC,VAL1,VAL2,LBOUND,UBOUND,AUX);
     "VALUE" N;"INTEGER" N;
     "ARRAY" A,VEC,VAL1,VAL2,LBOUND,UBOUND,AUX;
     "CODE" 36401;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF MATRIX A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N] CONTAINS A REAL SYMMETRIC MATRIX
             WHOSE EIGENSYSTEM HAS TO BE IMPROVED;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:N] CONTAINS A MATRIX WHOSE COLUMNS ARE
             A SYSTEM OF APPROXIMATE EIGENVECTORS OF MATRIX A;
             ENTRY: INITIAL APPROXIMATIONS;
             EXIT: IMPROVED APPROXIMATIONS;
     VAL1:   <ARRAY IDENTIFIER>;
             "ARRAY" VAL1[1:N];
             ENTRY: INITIAL APPROXIMATIONS OF THE EIGENVALUES OF A;
             EXIT: THE HEAD PARTS OF THE DOUBLE PRECISION IMPROVED
             APPROXIMATIONS OF THE EIGENVALUES OF A;
     VAL2:   <ARRAY IDENTIFIER>;
             "ARRAY" VAL2[1:N];
             EXIT: THE TAIL PARTS OF THE DOUBLE PRECISION
                   IMPROVED EIGENVALUES OF A;
1SECTION : 3.3.1.1.3.3        (DECEMBER 1979)                     PAGE 2
 
 
 
     LBOUND,
     UBOUND: <ARRAY IDENTIFIER>;
             EXIT: "ARRAY" LBOUND, UBOUND [1:N] CONTAIN THE LOWER
                   AND UPPER ERRORBOUNDS RESPECTIVELY FOR THE EIGENVALUE
                   APPROXIMATIONS IN VAL1,VAL2[1:N] SUCH THAT THE
                   I-TH EXACT EIGENVALUE LIES BETWEEN VAL1[I]+VAL2[I]
                   -LBOUND[I] AND VAL1[I]+VAL2[I]+UBOUND[I];
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:5];
             ENTRY: AUX[0]= THE RELATIVE PRECISION OF THE ELEMENTS OF A;
                    AUX[2]= THE RELATIVE TOLERANCE FOR THE RESIDUAL
                            MATRIX; THE ITERATION ENDS WHEN THE MAXIMUM
                            ABSOLUTE VALUE OF THE RESIDUAL ELEMENTS IS
                            SMALLER THAN AUX[2]*AUX[1].
                    AUX[4]= THE MAXIMUM NUMBER OF ITERATIONS ALLOWED;
             EXIT:  AUX[1]= INFINITY NORM OF THE MATRIX A;
                    AUX[3]= MAXIMUM ABSOLUTE ELT. OF THE RESIDUAL MATRIX
                    AUX[5]= NUMBER OF ITERATIONS;
 
 PROCEDURES USED:
     LNGMATVEC = CP34411,
     LNGMATMAT = CP34413,
     LNGTAMMAT = CP34414,
     VECVEC    = CP34010,
     MATMAT    = CP34013,
     TAMMAT    = CP34014.
     MERGESORT = CP36405,
     VECPERM   = CP36404,
     ROWPERM   = CP36403,
     ORTHOG    = CP36402,
     QRISYM    = CP34163,
     INFNRMMAT = CP31064.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 REQUIRED CENTRAL MEMORY:
     AUXILIARY ARRAYS ARE DECLARED TO A TOTAL OF 3*N*N + 6*N REALS
     AND N INTEGERS; MOREOVER, N INTEGERS OR N BOOLEANS ARE USED
     BY MERGESORT, VECPERM AND ROWPERM.
 
 METHOD AND PERFORMANCE: SEE[1].
1SECTION : 3.3.1.1.3.3        (DECEMBER 1979)                     PAGE 3
 
 
 
 REFERENCES:
     [1]. J.J.G. ADMIRAAL.
          ITERATIEF VERBETEREN VAN REEEL SYMMETRISCH EIGENSYSTEEM
          EN BEREKENEN VAN FOUTGRENZEN VOOR DE VERKREGEN EIGENWAARDEN.
          DOCTORAL SCRIPTION,MARCH 1976,
          UNIVERSITEIT VAN AMSTERDAM.
     [2]. R.T. GREGORY AND D.L. KARNEY.
          A COLLECTION OF MATRICES FOR TESTING COMPUTATIONAL
          ALGORITHMS,
          WILEY-INTERSCIENCE, 1969.
 
 EXAMPLE OF USE.
 
 "BEGIN" "INTEGER" I,J;"REAL" S;
    "ARRAY" A,X[1:4,1:4],VAL1,VAL2,LBOUND,UBOUND[1:4],EM,AUX[0:5];
    A[1,1]:=A[2,2]:=A[3,3]:=A[4,4]:=6;
    A[1,2]:=A[2,1]:=A[3,1]:=A[1,3]:=4;
    A[4,2]:=A[2,4]:=A[3,4]:=A[4,3]:=4;
    A[1,4]:=A[4,1]:=A[3,2]:=A[2,3]:=1;
    "FOR" I:=1 "STEP" 1 "UNTIL" 4 "DO"
    "FOR" J:=I "STEP" 1 "UNTIL" 4 "DO" X[I,J]:=X[J,I]:=A[I,J];
    OUTPUT(61,"(""("A")",/,4(4(+DB),/)")",A);
    EM[0]:="-14;EM[4]:=100;EM[2]:="-5;
    QRISYM(X,4,VAL1,EM);
    AUX[0]:=0;AUX[4]:=10;AUX[2]:="-14;
    SYMEIGIMP(4,A,X,VAL1,VAL2,LBOUND,UBOUND,AUX);
    OUTPUT(61,"("/,"("THE EXACT EIGENVALUES ARE: -1 , +5 , +5 , +15")",
    //,"("THE DIFFERENCES BETWEEN THE CALCULATED AND THE EXACT ")",
    "("EIGENVALUES")",
    //,4(N,/)")",(VAL1[1]+1)+VAL2[1],(VAL1[2]-5)+VAL2[2],(VAL1[3]-
    5)+VAL2[3],(VAL1[4]-15)+VAL2[4]);
    OUTPUT(61,"("/,"("LOWERBOUNDS  UPPERBOUNDS")",//")");
    "FOR" I:=1 "STEP" 1 "UNTIL" 4 "DO"
    OUTPUT(61,"("2(+D.D"+DD5B),/")",LBOUND[I],UBOUND[I]);
    OUTPUT(61,"("/,"("NUMBER OF ITERATIONS = ")",ZD//,
    "("INFINITY NORM OF A = ")",ZD//,
    "("MAXIMUM ABSOLUTE ELEMENT OF RESIDU = ")",D.D"+DD")",
    AUX[5],AUX[1],AUX[3])
 "END"  EXAMPLE OF USE
1SECTION : 3.3.1.1.3.3        (NOVEMBER 1976)                     PAGE 4
 
 
 
 DELIVERS:
 
 A
 +6 +4 +4 +1
 +4 +6 +1 +4
 +4 +1 +6 +4
 +1 +4 +4 +6
 
 THE EXACT EIGENVALUES ARE: -1 , +5 , +5 , +15
 
 THE DIFFERENCES BETWEEN THE CALCULATED AND THE EXACT EIGENVALUES
 
 -6.3423147029256"-022
 +5.5934784498910"-018
 +4.0389678347316"-028
 -5.5947317864427"-018
 
 LOWERBOUNDS  UPPERBOUNDS
 
 +1.2"-23     +1.2"-23
 +7.5"-09     +7.5"-09
 +1.0"-13     +1.0"-13
 +5.6"-18     +5.6"-18
 
 NUMBER OF ITERATIONS =  2
 
 INFINITY NORM OF A = 15
 
 MAXIMUM ABSOLUTE ELEMENT OF RESIDU = 2.8"-14
1SECTION : 3.3.1.1.3.3        (NOVEMBER 1976)                     PAGE 5
 
 
 
 SOURCETEXT:
0"CODE" 36401;
 "PROCEDURE" SYMEIGIMP(N,A,VEC,VAL1,VAL2,LBOUND,UBOUND,AUX);
 "VALUE" N;"INTEGER" N;"ARRAY" A,VEC,VAL1,VAL2,LBOUND,UBOUND,AUX;
 "BEGIN"
     "INTEGER" K,I,J,I0,I1,ITER,MAXITP1;"REAL" S,HEAD,TAIL,MAX,TOL,
     MATEPS,RELERRA,RELTOLR,NORMA;"INTEGER" "ARRAY" PERM[1:N];
     "ARRAY" R,P,Y[1:N,1:N],RQ,RQT,EPS,Z,VAL3,ETA[1:N];
     "PROCEDURE" BOUNDS(I0,I1,N,LBOUND,UBOUND);"VALUE" I0,I1,N;
     "INTEGER" I0,I1,N;"ARRAY" LBOUND,UBOUND;
     "BEGIN" "INTEGER" K,I,J,I01;"REAL" EPS2,DL,DR;
         "FOR" I:=I0,I01 "WHILE" I<=I1 "DO"
         "BEGIN" J:=I01:=I;
             "FOR" J:=J+1 "WHILE" "IF" J>I1 "THEN" "FALSE" "ELSE"
             RQ[J]-RQ[J-1]<=EPS[J]+EPS[J-1] "DO" I01:=J;
             "IF" I = I01 "THEN"
             "BEGIN"
                 "IF" I<N "THEN"
                 "BEGIN"
                     "IF" I=1 "THEN" DL:=DR:=RQ[I+1]-RQ[I]-EPS[I+1]
                     "ELSE" "BEGIN" DL:=RQ[I]-RQ[I-1]-EPS[I-1];
                                    DR:=RQ[I+1]-RQ[I]-EPS[I+1]
                            "END"
                 "END" "ELSE" DL:=DR:=RQ[I]-RQ[I-1]-EPS[I-1];
                 EPS2:=EPS[I]*EPS[I];LBOUND[I]:=EPS2/DR+MATEPS;
                 UBOUND[I]:=EPS2/DL+MATEPS
             "END" "ELSE"
             "BEGIN" "FOR" K:=I "STEP" 1 "UNTIL" I01 "DO"
                 LBOUND[K]:=UBOUND[K]:=EPS[K]+MATEPS
             "END";I01:=I01+1
         "END"
     "END" BOUNDS;
     "BOOLEAN" STOP;STOP:="FALSE";NORMA:=INFNRMMAT(1,N,1,N,J,A);
     RELERRA:=AUX[0];RELTOLR:=AUX[2];MAXITP1:=AUX[4]+1;
     MATEPS:=RELERRA*NORMA;TOL:=RELTOLR*NORMA;
     "FOR" ITER:=1 "STEP" 1 "UNTIL" MAXITP1 "DO"
     "BEGIN" STOP:="TRUE";MAX:=0;
                                                               "COMMENT"
1SECTION : 3.3.1.1.3.3        (NOVEMBER 1976)                     PAGE 6
                                                                       ;
 
 
         "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN"
             LNGMATVEC(J,J,I,VEC,VAL1,0,0,HEAD,TAIL);
             LNGMATMAT(1,N,I,J,A,VEC,-HEAD,-TAIL,R[I,J],TAIL);
             "IF"ABS(R[I,J])>MAX "THEN" MAX:=ABS(R[I,J])
         "END";"IF" MAX > TOL "THEN" STOP:="FALSE";
         "IF" "NOT" STOP "AND" ITER<MAXITP1 "THEN"
         "BEGIN"
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             LNGTAMMAT(1,N,I,I,VEC,R,VAL1[I],0,RQ[I],RQT[I]);
             "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                 ETA[I]:=R[I,J]-(RQ[J]-VAL1[J])*VEC[I,J];
                 Z[J]:=SQRT(VECVEC(1,N,0,ETA,ETA))
             "END";
             MERGESORT(RQ,PERM,1,N);VECPERM(PERM,1,N,RQ);
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" EPS[I]:=Z[PERM[I]];VAL3[I]:=VAL1[PERM[I]];
                 ROWPERM(PERM,1,N,I,VEC);ROWPERM(PERM,1,N,I,R)
             "END";
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "FOR" J:=I "STEP" 1 "UNTIL" N "DO"
             P[I,J]:=P[J,I]:=TAMMAT(1,N,I,J,VEC,R);
         "END";
         "FOR"I0:=1,I1+1 "WHILE" I0<=N "DO"
         "BEGIN" J:=I1:=I0;
             "FOR" J:=J+1 "WHILE" "IF" J>N "THEN" "FALSE" "ELSE"
             RQ[J]-RQ[J-1]<=SQRT((EPS[J]+EPS[J-1])*NORMA) "DO" I1:=J;
             "IF" STOP "OR" ITER=MAXITP1 "THEN"
             BOUNDS(I0,I1,N,LBOUND,UBOUND) "ELSE"
             "BEGIN"
                 "IF" I0=I1 "THEN"
                 "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
                     "IF" K=I0 "THEN" Y[K,I0]:=1 "ELSE"
                     R[K,I0]:=P[K,I0];
                     VAL1[I0]:=RQ[I0];VAL2[I0]:=RQT[PERM[I0]]
                 "END" "ELSE"
                 "BEGIN""INTEGER" N1,I0M1,I1P1;"REAL" M1;"ARRAY"EM[0:5];
                     N1:=I1-I0+1;EM[0]:=EM[2]:="-14;EM[4]:=10*N1;
                     "BEGIN" "ARRAY" PP[1:N1,1:N1],VAL4[1:N1];M1:=0;
                         "FOR" K:=I0 "STEP" 1 "UNTIL" I1 "DO"
                         M1:=M1+VAL3[K];M1:=M1/N1;
                                                               "COMMENT"
1SECTION : 3.3.1.1.3.3        (DECEMBER 1979)                     PAGE 7
                                                                       ;
 
 
                         "FOR" I:=1 "STEP" 1 "UNTIL" N1 "DO"
                         "FOR" J:=1 "STEP" 1 "UNTIL" N1 "DO"
                         "BEGIN" PP[I,J]:=P[I+I0-1,J+I0-1];
                             "IF" I=J "THEN"
                             PP[I,J]:=PP[I,J]+VAL3[J+I0-1]-M1
                         "END";"FOR" I:=I0 "STEP" 1 "UNTIL" I1 "DO"
                         "BEGIN" VAL3[I]:=M1;VAL1[I]:=RQ[I];
                             VAL2[I]:=RQT[PERM[I]]
                         "END";
                         QRISYM(PP,N1,VAL4,EM);
                         MERGESORT(VAL4,PERM,1,N1);
                         "FOR" I:=1 "STEP" 1 "UNTIL" N1 "DO"
                         "FOR" J:=1 "STEP" 1 "UNTIL" N1 "DO"
                         P[I+I0-1,J+I0-1]:=PP[I,PERM[J]];
                         I0M1:=I0-1;I1P1:=I1+1;
                         "FOR" J:=I0 "STEP" 1 "UNTIL" I1 "DO"
                         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" I0M1,
                             I1P1 "STEP" 1 "UNTIL" N "DO"
                             "BEGIN" S:=0;
                                 "FOR" K:=I0 "STEP" 1 "UNTIL" I1 "DO"
                                 S:=S+P[I,K]*P[K,J];
                                 R[I,J]:=S
                             "END";"FOR" I:=I0 "STEP" 1 "UNTIL" I1 "DO"
                             Y[I,J]:=P[I,J]
                         "END" FOR J
                     "END" INNERBLOCK
                 "END" I1>I0
             "END" NOT STOP
         "END" FOR I0;
         "IF" "NOT" STOP "AND" ITER<MAXITP1 "THEN"
         "BEGIN"
             "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "IF" VAL3[I]^=VAL3[J] "THEN"
             Y[I,J]:=R[I,J]/(VAL3[J]-VAL3[I]);
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
                 Z[J]:=MATMAT(1,N,I,J,VEC,Y);
                 "FOR" J:=1 "STEP" 1 "UNTIL" N "DO" VEC[I,J]:=Z[J]
             "END";ORTHOG(N,1,N,VEC)
         "END" "ELSE"
         "BEGIN" AUX[5]:=ITER-1;"GOTO" EXIT "END"
     "END" FOR ITER;
     EXIT: AUX[1]:=NORMA;AUX[3]:=MAX
 "END" SYMEIGIMP;
         "EOP"
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 1
 
 
 
 AUTHORS: T.J. DEKKER, W. HOFFMANN.
 
 
 CONTRIBUTORS: W. HOFFMANN, S.P.N. VAN KAMPEN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731115.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FIVE PROCEDURES:
     A) REAVALQRI CALCULATES  THE EIGENVALUES  OF A REAL UPPER-HESSEN-
     BERG  MATRIX, PROVIDED THAT  ALL EIGENVALUES ARE REAL, BY MEANS  OF
     SINGLE QR ITERATION;
     B) REAVECHES CALCULATES  ONE EIGENVECTOR  CORRESPONDING TO  A GIVEN
     REAL EIGENVALUE  OF A  REAL UPPER-HESSENBERG MATRIX  BY MEANS  OF
     INVERSE ITERATION;
     C) REAQRI  CALCULATES  THE EIGENVALUES AND  EIGENVECTORS OF  A REAL
     UPPER-HESSENBERG MATRIX, PROVIDED THAT  ALL EIGENVALUES ARE REAL,
     BY MEANS OF SINGLE QR ITERATION;
     D) COMVALQRI CALCULATES THE REAL  AND COMPLEX EIGENVALUES OF A REAL
     UPPER-HESSENBERG MATRIX BY MEANS OF DOUBLE QR ITERATION;
     E) COMVECHES CALCULATES ONE  EIGENVECTOR  CORRESPONDING  TO A GIVEN
     COMPLEX EIGENVALUE OF A REAL UPPER-HESSENBERG MATRIX  BY MEANS OF
     INVERSE ITERATION.
 
 
 KEYWORDS:
 
     EIGENVALUE,
     EIGENVECTOR,
     UPPER-HESSENBERG MATRIX,
     QR ITERATION,
     INVERSE ITERATION.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: REAVALQRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" REAVALQRI(A, N, EM, VAL); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL;
     "CODE" 34180;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE ELEMENTS OF THE  REAL UPPER-HESSENBERG  MATRIX
                    MUST BE  GIVEN  IN THE UPPER TRIANGLE  AND THE FIRST
                    SUBDIAGONAL OF ARRAY A;
             EXIT:  THE HESSENBERG PART OF ARRAY A IS ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[1], A NORM OF THE GIVEN MATRIX;
                    EM[2], THE  RELATIVE TOLERANCE USED  FOR THE  QR
                           ITERATION;
                           IF  THE ABSOLUTE  VALUE  OF SOME  SUBDIAGONAL
                           ELEMENT IS  SMALLER THAN  EM[1] * EM[2], THEN
                           THIS ELEMENT IS  NEGLECTED AND  THE MATRIX IS
                           PARTITIONED;
                    EM[4], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS OF VAL  ARE APPROXIMATE EIGEN-
                           VALUES  OF  THE  GIVEN  MATRIX,  WHERE  K  IS
                           DELIVERED IN REAVALQRI;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             THE EIGENVALUES OF  THE GIVEN MATRIX  ARE DELIVERED IN VAL.
 
     MOREOVER:
     REAVALQRI DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE REAVALQRI DELIVERS THE NUMBER OF EIGEN-
     VALUES NOT CALCULATED.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 3
 
 
 
 PROCEDURES USED:
 
     ROTCOL = CP34040,
     ROTROW = CP34041.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD  USED IN  THE PROCEDURE  REAVALQRI  IS THE SINGLE QR
     ITERATION OF FRANCIS (SEE REF[1], P. 54, REF[2] P. 515 - 543  AND
     REF[3]). THE EIGENVALUES  OF A REAL  UPPER-HESSENBERG MATRIX  ARE
     CALCULATED, PROVIDED THAT  THE MATRIX HAS  REAL  EIGENVALUES  ONLY.
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
     [3]. J.G. FRANCIS.
          THE QR TRANSFORMATION, PARTS 1 AND 2.
          COMP. J. 4 (1961), 265 - 271 AND 332 - 345.
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE REAVALQRI  IS USED  IN REAEIGVAL, SECTION  3.3.1.2.2.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 4
 
 
 
 SUBSECTION: REAVECHES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" REAVECHES(A, N, LAMBDA, EM, V); "VALUE" N, LAMBDA;
     "INTEGER" N; "REAL" LAMBDA; "ARRAY" A, EM, V;
     "CODE" 34181;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE ELEMENTS OF THE  REAL UPPER-HESSENBERG  MATRIX
                    MUST BE  GIVEN  IN THE UPPER TRIANGLE  AND THE FIRST
                    SUBDIAGONAL OF ARRAY A;
             EXIT:  THE HESSENBERG PART OF ARRAY A IS ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     LAMBDA: <ARITHMETIC EXPRESSION>;
             THE GIVEN REAL EIGENVALUE OF THE UPPER-HESSENBERG MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[1], A NORM OF THE GIVEN MATRIX;
                    EM[6], THE TOLERANCE  USED FOR THE  EIGENVECTOR; THE
                           INVERSE  ITERATION  ENDS IF  THE  EUCLIDIAN
                           NORM  OF THE  RESIDUE VECTOR  IS SMALLER THAN
                           EM[1] * EM[6];
                    EM[8], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[6] = "-10,
                    EM[8] = 5;
             EXIT:  EM[7], THE EUCLIDIAN NORM OF THE RESIDUE VECTOR OF
                           THE CALCULATED EIGENVECTOR;
                    EM[9], THE NUMBER OF  INVERSE ITERATIONS  PERFORMED;
                           IF  EM[7] REMAINS  LARGER THAN  EM[1] * EM[6]
                           DURING EM[8] ITERATIONS, THE VALUE  EM[8] + 1
                           IS DELIVERED;
     V:      <ARRAY IDENTIFIER>;
             "ARRAY" V[1:N];
             THE CALCULATED EIGENVECTOR IS DELIVERED IN V.
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 5
 
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     MATVEC = CP34011.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE REAVECHES CALCULATES  AN EIGENVECTOR CORRESPONDING TO
     A GIVEN  APPROXIMATE REAL  EIGENVALUE OF A REAL  UPPER-HESSENBERG
     MATRIX, BY MEANS  OF INVERSE  ITERATION (SEE REF[1], P. 55, REF[2],
     P. 619 - 629 AND REF[3]).
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
     [3]. J.M. VARAH.
          EIGENVECTORS OF A REAL MATRIX BY INVERSE ITERATION.
          STANFORD UNIVERSITY, TECH. REP. NO. CS 34, 1966.
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE  REAVECHES  IS  USED  IN REAEIG1, SECTION  3.3.1.2.2.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 6
 
 
 
 SUBSECTION: REAQRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" REAQRI(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "CODE" 34186;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE ELEMENTS OF THE  REAL UPPER-HESSENBERG  MATRIX
                    MUST BE  GIVEN  IN THE UPPER TRIANGLE  AND THE FIRST
                    SUBDIAGONAL OF ARRAY A;
             EXIT:  THE HESSENBERG PART OF ARRAY A IS ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[1], A NORM OF THE GIVEN MATRIX;
                    EM[2], THE  RELATIVE TOLERANCE USED  FOR THE  QR
                           ITERATION;
                           IF  THE ABSOLUTE  VALUE  OF SOME  SUBDIAGONAL
                           ELEMENT IS  SMALLER THAN  EM[1] * EM[2], THEN
                           THIS ELEMENT IS  NEGLECTED AND  THE MATRIX IS
                           PARTITIONED;
                    EM[4], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS  DELIVERED; IN  THIS  CASE  ONLY  THE LAST
                           N - K ELEMENTS  OF  VAL  AND  THE  LAST N - K
                           COLUMNS OF VEC  ARE APPROXIMATED  EIGENVALUES
                           AND EIGENVECTORS OF THE GIVEN MATRIX, WHERE K
                           IS DELIVERED IN REAQRI;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             THE EIGENVALUES OF  THE GIVEN MATRIX  ARE DELIVERED IN VAL;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:N];
             THE  CALCULATED  EIGENVECTORS, CORRESPONDING  TO THE EIGEN-
             VALUES  IN ARRAY VAL[1:N], ARE DELIVERED  IN THE COLUMNS OF
             ARRAY VEC.
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 7
 
 
 
     MOREOVER:
     REAQRI DELIVERS 0, PROVIDED  THAT THE  PROCESS IS COMPLETED  WITHIN
     EM[4] ITERATIONS; OTHERWISE  REAQRI DELIVERS  THE NUMBER OF  EIGEN-
     VALUES AND EIGENVECTORS NOT CALCULATED.
 
 
 PROCEDURES USED:
 
     MATVEC = CP34011,
     ROTCOL = CP34040,
     ROTROW = CP34041.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE  PROCEDURE  REAQRI  CALCULATES  THE  EIGENVALUES  OF AN  UPPER-
     HESSENBERG MATRIX BY MEANS OF SINGLE QR ITERATION (SEE METHOD
     AND PERFORMANCE OF REAVALQRI, THIS SECTION).
     THE EIGENVECTORS  ARE CALCULATED  BY A  DIRECT  METHOD (SEE REF[1],
     P. 55-56), IN CONTRAST WITH REAVECHES WHICH USES INVERSE ITERATION.
     IF THE HESSENBERG MATRIX  IS NOT TOO ILL-CONDITIONED WITH RESPECT
     TO ITS  EIGENVALUE  PROBLEM, THEN  THIS METHOD  YIELDS  NUMERICALLY
     INDEPENDENT EIGENVECTORS AND IS COMPETITIVE WITH  INVERSE ITERATION
     AS TO ACCURACY AND COMPUTATION TIME.
     IF THE QR ITERATION PROCESS  IS NOT COMPLETED  WITHIN THE GIVEN
     NUMBER  OF  ITERATIONS, NOT ALL  EIGENVALUES  AND  EIGENVECTORS ARE
     DELIVERED.
     THE PROCEDURE REAQRI  SHOULD  BE USED ONLY  IF ALL EIGENVALUES  ARE
     REAL.
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE REAQRI IS USED IN REAEIG3, SECTION 3.3.1.2.2.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 8
 
 
 
 SUBSECTION: COMVALQRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" COMVALQRI(A, N, EM, RE, IM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, RE, IM;
     "CODE" 34190;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE ELEMENTS OF THE  REAL UPPER-HESSENBERG  MATRIX
                    MUST BE  GIVEN  IN THE UPPER TRIANGLE  AND THE FIRST
                    SUBDIAGONAL OF ARRAY A;
             EXIT:  THE HESSENBERG PART OF ARRAY A IS ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[1], A NORM OF THE GIVEN MATRIX;
                    EM[2], THE  RELATIVE TOLERANCE USED  FOR THE  QR
                           ITERATION;
                           IF  THE ABSOLUTE  VALUE  OF SOME  SUBDIAGONAL
                           ELEMENT IS  SMALLER THAN  EM[1] * EM[2], THEN
                           THIS ELEMENT IS  NEGLECTED AND  THE MATRIX IS
                           PARTITIONED;
                    EM[4], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS OF  RE AND IM  ARE APPROXIMATE
                           EIGENVALUES OF  THE  GIVEN MATRIX, WHERE K IS
                           DELIVERED IN COMVALQRI;
     RE,IM:  <ARRAY IDENTIFIER>;
             "ARRAY" RE, IM[1:N];
             THE REAL AND IMAGINARY PARTS  OF THE CALCULATED EIGENVALUES
             OF THE GIVEN MATRIX ARE DELIVERED IN ARRAY RE, IM[1:N], THE
             MEMBERS  OF  EACH  NONREAL  COMPLEX  CONJUGATE  PAIR  BEING
             CONSECUTIVE.
 
     MOREOVER:
     COMVALQRI DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE COMVALQRI DELIVERS THE NUMBER OF EIGEN-
     VALUES NOT CALCULATED.
 
 
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 9
 
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN THE PROCEDURE COMVALQRI FOR CALCULATING THE REAL
     AND COMPLEX EIGENVALUES  OF A REAL UPPER-HESSENBERG MATRIX IS THE
     DOUBLE QR  ITERATION  OF  FRANCIS (SEE REF[1], P. 74,  REF[2]
     P. 528 - 537 AND REF[3]).
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
     [3]. J.G. FRANCIS.
          THE QR TRANSFORMATION, PARTS 1 AND 2.
          COMP. J. 4 (1961), 265 - 271 AND 332 - 345.
 
 
 EXAMPLE OF USE:
 
     THE COMPLEX EIGENVALUES  AND -VECTORS OF H, WITH N = 4 AND H[I,J] =
     "IF" I = 1 "THEN" -1 "ELSE" "IF" I - J = 1 "THEN" 1 "ELSE" 0,   MAY
     BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J, M;
         "ARRAY" A[1:4,1:4], RE, IM[1:4], EM[0:9];
 
         EM[0]:= "-14; EM[2]:= "-13; EM[1]:= 4; EM[4]:= 40;
         EM[6]:= "-10; EM[8]:= 5;
         "FOR" I:= 1, 2, 3, 4 "DO" "FOR" J:= 1, 2, 3, 4 "DO" A[I,J]:=
         "IF" I = 1 "THEN" -1 "ELSE" "IF" I - J = 1 "THEN" 1 "ELSE" 0;
         M:= COMVALQRI(A, 4, EM, RE, IM); OUTPUT(61, "("D, /")", M);
1SECTION : 3.3.1.2.1          (JULY 1974)                         PAGE 9
 
 
 
         "FOR" J:= M + 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "INTEGER" K; "ARRAY" U, V[1:4];
             "FOR" I:= 1, 2, 3, 4 "DO" "FOR" K:= 1, 2, 3, 4 "DO"
             A[I,K]:= "IF" I = 1 "THEN" -1 "ELSE"
             "IF" I - K = 1 "THEN" 1 "ELSE" 0;
             COMVECHES(A, 4, RE[J], IM[J], EM, U, V);
             OUTPUT(61, "("/, 2(+.13D"+2D, 2B), 2/")", RE[J], IM[J]);
             "FOR" I:= 1, 2, 3, 4 "DO"
             OUTPUT(61, "("21B, 2(+.13D"+2D, 2B), /")", U[I], V[I])
         "END";
         OUTPUT(61, "("/, 2(.2D"+2D, /), 2(ZD, /)")",
         EM[3], EM[7], EM[5], EM[9])
     "END"
 
     THE PROGRAM DELIVERS (THE RESULTS ARE CORRECT UP TO TWELVE DIGITS):
 
     THE NUMBER OF NOT CALCULATED EIGENVALUES: 0
 
     THE EIGENVALUES AND -VECTORS:
 
     +.3090169943750"+00  +.9510565162952"+00
 
                          -.2527643931136"+00  -.4314048696688"+00
                          -.4883989055049"+00  +.1070817869743"+00
                          -.4908273055667"-01  +.4975850535950"+00
                          +.4580641097602"+00  +.2004426884413"+00
 
     +.3090169943750"+00  -.9510565162952"+00
 
                          -.2527643931136"+00  +.4314048696688"+00
                          -.4883989055049"+00  -.1070817869743"+00
                          -.4908273055667"-01  -.4975850535950"+00
                          +.4580641097602"+00  -.2004426884413"+00
 
     -.8090169943749"+00  +.5877852522924"+00
 
                          +.1095191711534"+00  -.4878581260468"+00
                          -.3753586823743"+00  +.3303117611685"+00
                          +.4978239349006"+00  -.4659753040772"-01
                          -.4301373647081"+00  -.2549153731770"+00
 
     -.8090169943749"+00  -.5877852522924"+00
 
                          +.1095191711534"+00  +.4878581260468"+00
                          -.3753586823743"+00  -.3303117611685"+00
                          +.4978239349006"+00  +.4659753040772"-01
                          -.4301373647081"+00  +.2549153731770"+00
 
    THE ARRAY EM: EM[3] = .67"-22
                  EM[7] = .17"-13
                  EM[5] = 9
                  EM[9] = 1 .
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 11
 
 
 
 SUBSECTION: COMVECHES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" COMVECHES(A, N, LAMBDA, MU, EM, U, V);
     "VALUE" N, LAMBDA, MU;
     "INTEGER" N; "REAL" LAMBDA, MU; "ARRAY" A, EM, U, V;
     "CODE" 34191;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE ELEMENTS OF THE  REAL UPPER-HESSENBERG  MATRIX
                    MUST BE  GIVEN  IN THE UPPER TRIANGLE  AND THE FIRST
                    SUBDIAGONAL OF ARRAY A;
             EXIT:  THE HESSENBERG PART OF ARRAY A IS ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     LAMBDA, MU:
             <ARITHMETIC EXPRESSION>;
             THE REAL AND IMAGINARY PART OF THE GIVEN EIGENVALUE;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[1], A NORM OF THE GIVEN MATRIX;
                    EM[6], THE TOLERANCE  USED FOR THE  EIGENVECTOR; THE
                           INVERSE  ITERATION  ENDS IF  THE  EUCLIDIAN
                           NORM  OF THE  RESIDUE VECTOR  IS SMALLER THAN
                           EM[1] * EM[6];
                    EM[8], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[6] = "-10,
                    EM[8] = 5;
             EXIT:  EM[7], THE EUCLIDIAN NORM OF THE RESIDUE VECTOR OF
                           THE CALCULATED EIGENVECTOR;
                    EM[9], THE NUMBER OF  INVERSE ITERATIONS  PERFORMED;
                           IF  EM[7] REMAINS  LARGER THAN  EM[1] * EM[6]
                           DURING EM[8] ITERATIONS, THE VALUE  EM[8] + 1
                           IS DELIVERED;
     U, V:   <ARRAY IDENTIFIER>;
             "ARRAY" U, V[1:N];
             THE REAL AND IMAGINARY  PARTS OF THE CALCULATED EIGENVECTOR
             ARE DELIVERED IN THE ARRAYS U, V[1:N].
 
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 12
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     MATVEC = CP34011,
     TAMVEC = CP34012.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE COMVECHES CALCULATES  AN EIGENVECTOR CORRESPONDING TO
     A GIVEN APPROXIMATE EIGENVALUE OF A REAL UPPER-HESSENBERG MATRIX,
     BY   MEANS  OF   INVERSE  ITERATION  (SEE  REF[1],  P. 75,  REF[2],
     P. 629 - 633 AND REF[3]).
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
     [3]. J.M. VARAH.
          EIGENVECTORS OF A REAL MATRIX BY INVERSE ITERATION.
          STANFORD UNIVERSITY, TECH. REP. NO. CS 34, 1966.
 
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF COMVALQRI, THIS SECTION.
 
 
 SOURCE TEXT(S) :
0"CODE" 34180;
     "COMMENT" MCA 2410;
     "INTEGER" "PROCEDURE" REAVALQRI(A, N, EM, VAL); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL;
     "BEGIN" "INTEGER" N1, I, I1, J, Q, MAX, COUNT;
         "REAL" DET, W, SHIFT, KAPPA, NU, MU, R, TOL, DELTA, MACHTOL, S;
 
         "COMMENT"
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 13
                                                                 ;
 
 
         MACHTOL:= EM[0] * EM[1]; TOL:= EM[1] * EM[2]; MAX:= EM[4];
         COUNT:= 0; R:= 0;
      IN: N1:= N - 1;
         "FOR" I:= N, I - 1 "WHILE" ("IF" I >= 1 "THEN"
         ABS(A[I + 1,I]) > TOL "ELSE" "FALSE") "DO" Q:= I;
         "IF" Q > 1 "THEN"
         "BEGIN" "IF" ABS(A[Q,Q - 1]) > R "THEN"
             R:= ABS(A[Q,Q - 1])
         "END";
         "IF" Q = N "THEN"
         "BEGIN" VAL[N]:= A[N,N]; N:= N1 "END"
         "ELSE"
         "BEGIN" DELTA:= A[N,N] - A[N1,N1]; DET:= A[N,N1] * A[N1,N];
             "IF" ABS(DELTA) < MACHTOL "THEN" S:= SQRT(DET) "ELSE"
             "BEGIN" W:= 2 / DELTA; S:= W * W * DET + 1;
                 S:= "IF" S <= 0 "THEN" -DELTA * .5 "ELSE"
                 W * DET / (SQRT(S) + 1)
             "END";
             "IF" Q = N1 "THEN"
             "BEGIN" VAL[N]:= A[N,N] + S;
                 VAL[N1]:= A[N1,N1] - S; N:= N - 2
             "END"
             "ELSE"
             "BEGIN" COUNT:= COUNT + 1;
                 "IF" COUNT > MAX "THEN" "GOTO" OUT;
                 SHIFT:= A[N,N] + S; "IF" ABS(DELTA) < TOL "THEN"
                 "BEGIN" W:= A[N1,N1] - S;
                     "IF" ABS(W) < ABS(SHIFT) "THEN" SHIFT:= W
                 "END";
                 A[Q,Q]:= A[Q,Q] - SHIFT;
                 "FOR" I:= Q "STEP" 1 "UNTIL" N - 1 "DO"
                 "BEGIN" I1:= I + 1; A[I1,I1]:= A[I1,I1] - SHIFT;
                     KAPPA:= SQRT(A[I,I] ** 2 + A[I1,I] ** 2);
                     "IF" I > Q "THEN"
                     "BEGIN" A[I,I - 1]:= KAPPA * NU;
                         W:= KAPPA * MU
                     "END"
                     "ELSE" W:= KAPPA; MU:= A[I,I] / KAPPA;
                     NU:= A[I1,I] / KAPPA; A[I,I]:= W;
                     ROTROW(I1, N, I, I1, A, MU, NU);
                     ROTCOL(Q, I, I, I1, A, MU, NU);
                     A[I,I]:= A[I,I] + SHIFT
                 "END";
                 A[N,N - 1]:= A[N,N] * NU; A[N,N]:= A[N,N] * MU + SHIFT
             "END"
         "END";
         "IF" N > 0 "THEN" "GOTO" IN;
      OUT: EM[3]:= R; EM[5]:= COUNT; REAVALQRI:= N
     "END" REAVALQRI
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 14
 
 
                                                                  ;
         "EOP"
0"CODE" 34181;
     "COMMENT" MCA 2411;
     "PROCEDURE" REAVECHES(A, N, LAMBDA, EM, V); "VALUE" N, LAMBDA;
     "INTEGER" N; "REAL" LAMBDA; "ARRAY" A, EM, V;
     "BEGIN" "INTEGER" I, I1, J, COUNT, MAX;
         "REAL" M, R, NORM, MACHTOL, TOL;
         "BOOLEAN" "ARRAY" P[1:N];
 
         NORM:= EM[1]; MACHTOL:= EM[0] * NORM; TOL:= EM[6] * NORM;
         MAX:= EM[8]; A[1,1]:= A[1,1] - LAMBDA;
      GAUSS: "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" I1:= I + 1; R:= A[I,I]; M:= A[I1,I];
             "IF" ABS(M) < MACHTOL "THEN" M:= MACHTOL;
             P[I]:= ABS(M) <= ABS(R);
             "IF" P[I] "THEN"
             "BEGIN" A[I1,I]:= M:= M / R;
                 "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
                 A[I1,J]:= ("IF" J > I1 "THEN" A[I1,J]
                 "ELSE" A[I1,J] - LAMBDA) - M * A[I,J]
             "END"
             "ELSE"
             "BEGIN" A[I,I]:= M; A[I1,I]:= M:= R / M;
                 "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" R:= ("IF" J > I1 "THEN" A[I1,J] "ELSE"
                     A[I1,J] - LAMBDA);
                     A[I1,J]:= A[I,J] - M * R; A[I,J]:= R
                 "END"
             "END"
         "END" GAUSS;
         "IF" ABS(A[N,N]) < MACHTOL "THEN" A[N,N]:= MACHTOL;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" V[J]:= 1; COUNT:= 0;
      FORWARD: COUNT:= COUNT + 1; "IF" COUNT > MAX "THEN" "GOTO" OUT;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" I1:= I + 1;
             "IF" P[I] "THEN" V[I1]:= V[I1] - A[I1,I] * V[I] "ELSE"
             "BEGIN" R:= V[I1]; V[I1]:= V[I] - A[I1,I] * R;
                 V[I]:=R
             "END"
         "END" FORWARD;
      BACKWARD: "FOR" I:= N "STEP" -1 "UNTIL" 1 "DO"
         V[I]:= (V[I] - MATVEC(I + 1, N, I, A, V)) / A[I,I];
         R:= 1 / SQRT(VECVEC(1, N, 0, V, V));
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" V[J]:= V[J] * R;
         "IF" R > TOL "THEN" "GOTO" FORWARD;
      OUT: EM[7]:= R; EM[9]:= COUNT
     "END" REAVECHES
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 15
 
 
                                                                  ;
         "EOP"
0"CODE" 34186;
     "COMMENT" MCA 2416;
     "INTEGER" "PROCEDURE" REAQRI(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "BEGIN" "INTEGER" M1, I, I1, M, J, Q, MAX, COUNT;
         "REAL" W, SHIFT, KAPPA, NU, MU, R, TOL, S, MACHTOL,
         ELMAX, T, DELTA, DET;
         "ARRAY" TF[1:N];
 
         MACHTOL:= EM[0] * EM[1]; TOL:= EM[1] * EM[2]; MAX:= EM[4];
         COUNT:= 0; ELMAX:= 0; M:= N;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" VEC[I,I]:= 1;
             "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO"
             VEC[I,J]:= VEC[J,I]:= 0
         "END";
      IN: M1:= M - 1;
         "FOR" I:= M, I - 1 "WHILE" ("IF" I >= 1 "THEN"
         ABS(A[I + 1,I]) > TOL "ELSE" "FALSE") "DO" Q:= I;
         "IF" Q > 1 "THEN"
         "BEGIN" "IF" ABS(A[Q,Q - 1]) > ELMAX "THEN"
             ELMAX:= ABS(A[Q, Q - 1])
         "END";
         "IF" Q = M "THEN"
         "BEGIN" VAL[M]:= A[M,M]; M:= M1 "END"
         "ELSE"
         "BEGIN" DELTA:= A[M,M] - A[M1,M1]; DET:= A[M,M1] * A[M1,M];
             "IF" ABS(DELTA) < MACHTOL "THEN" S:= SQRT(DET) "ELSE"
             "BEGIN" W:= 2 / DELTA; S:= W * W * DET + 1;
                 S:= "IF" S <= 0 "THEN" -DELTA * .5 "ELSE"
                 W * DET / (SQRT(S) + 1)
             "END";
             "IF" Q = M1 "THEN"
             "BEGIN" A[M,M]:= VAL[M]:= A[M,M] + S;
                 A[Q,Q]:= VAL[Q]:= A[Q,Q] - S;
                 T:= "IF" ABS(S) < MACHTOL "THEN"
                 (S + DELTA) / A[M,Q] "ELSE" A[Q,M] / S;
                 R:= SQRT(T * T + 1); NU:= 1 / R;
                 MU:= -T * NU; A[Q,M]:= A[Q,M] - A[M,Q];
                 ROTROW(Q + 2, N, Q, M, A, MU, NU);
                 ROTCOL(1, Q - 1, Q, M, A, MU, NU);
                 ROTCOL(1, N, Q, M, VEC, MU, NU); M:= M - 2
             "END"
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 16
 
 
 
             "ELSE"
             "BEGIN" COUNT:= COUNT + 1;
                 "IF" COUNT > MAX "THEN" "GOTO" END;
                 SHIFT:= A[M,M] + S; "IF" ABS(DELTA) < TOL "THEN"
                 "BEGIN" W:= A[M1,M1] - S;
                     "IF" ABS(W) < ABS(SHIFT) "THEN" SHIFT:= W
                 "END";
                 A[Q,Q]:= A[Q,Q] - SHIFT;
                 "FOR" I:= Q "STEP" 1 "UNTIL" M1 "DO"
                 "BEGIN" I1:= I + 1; A[I1,I1]:= A[I1,I1] - SHIFT;
                     KAPPA:= SQRT(A[I,I] ** 2 + A[I1,I] ** 2);
                     "IF" I > Q "THEN"
                     "BEGIN" A[I,I - 1]:= KAPPA * NU;
                         W:= KAPPA * MU
                     "END"
                     "ELSE" W:= KAPPA; MU:= A[I,I] / KAPPA;
                     NU:= A[I1,I] / KAPPA; A[I,I]:= W;
                     ROTROW(I1, N, I, I1, A, MU, NU);
                     ROTCOL(1, I, I, I1, A, MU, NU);
                     A[I,I]:= A[I,I] + SHIFT;
                     ROTCOL(1, N, I, I1, VEC, MU, NU)
                 "END";
                 A[M,M1]:= A[M,M] * NU; A[M,M]:= A[M,M] * MU + SHIFT
             "END"
         "END";
         "IF" M > 0 "THEN" "GOTO" IN;
         "FOR" J:= N "STEP" -1 "UNTIL" 2 "DO"
         "BEGIN" TF[J]:= 1; T:= A[J,J];
             "FOR" I:= J - 1 "STEP" -1 "UNTIL" 1 "DO"
             "BEGIN" DELTA:= T - A[I,I];
                 TF[I]:= MATVEC(I + 1, J, I, A, TF) /
                 ("IF" ABS(DELTA) < MACHTOL "THEN" MACHTOL "ELSE" DELTA)
             "END";
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             VEC[I,J]:= MATVEC(1, J, I, VEC, TF)
         "END";
      END: EM[3]:= ELMAX; EM[5]:= COUNT; REAQRI:= M
     "END" REAQRI
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 17
 
 
                                                                  ;
         "EOP"
0"CODE" 34190;
     "COMMENT" MCA 2420;
     "INTEGER" "PROCEDURE" COMVALQRI(A, N, EM, RE, IM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, RE, IM;
     "BEGIN" "INTEGER" I, J, P, Q, MAX, COUNT, N1, P1, P2, IMIN1,
         I1, I2, I3;
         "REAL" DISC, SIGMA, RHO, G1, G2, G3, PSI1, PSI2, AA, E, K,
         S, NORM, MACHTOL2, TOL, W;
         "BOOLEAN" B;
 
         NORM:= EM[1]; MACHTOL2:= (EM[0] * NORM) ** 2;
         TOL:= EM[2] * NORM; MAX:= EM[4]; COUNT:= 0; W:= 0;
      IN: "FOR" I:= N, I - 1 "WHILE"
         ("IF" I >= 1 "THEN" ABS(A[I + 1,I]) > TOL "ELSE" "FALSE")
         "DO" Q:= I; "IF" Q > 1 "THEN"
         "BEGIN" "IF" ABS(A[Q,Q - 1]) > W "THEN" W:= ABS(A[Q,Q - 1])
         "END";
         "IF" Q >= N - 1 "THEN"
         "BEGIN" N1:= N - 1; "IF" Q = N "THEN"
             "BEGIN" RE[N]:= A[N,N]; IM[N]:= 0; N:= N1 "END"
             "ELSE"
             "BEGIN" SIGMA:= A[N,N] - A[N1,N1];
                 RHO:= -A[N,N1] * A[N1,N];
                 DISC:= SIGMA ** 2 - 4 * RHO; "IF" DISC > 0 "THEN"
                 "BEGIN" DISC:= SQRT(DISC);
                     S:= -2 * RHO / (SIGMA + ("IF" SIGMA >= 0
                     "THEN" DISC "ELSE" -DISC));
                     RE[N]:= A[N,N] + S;
                     RE[N1]:= A[N1,N1] - S; IM[N]:= IM[N1]:= 0
                 "END"
                 "ELSE"
                 "BEGIN" RE[N]:= RE[N1]:= (A[N1,N1] + A[N,N]) / 2;
                     IM[N1]:= SQRT( -DISC) / 2; IM[N]:= -IM[N1]
                 "END";
                 N:= N - 2
             "END"
         "END"
         "ELSE"
         "BEGIN" COUNT:= COUNT + 1; "IF" COUNT > MAX "THEN"
             "GOTO" OUT; N1:= N - 1;
             SIGMA:= A[N,N] + A[N1,N1] + SQRT(ABS(A[N1,N - 2] * A[N,N1])
             * EM[0]); RHO:= A[N,N] * A[N1,N1] - A[N,N1] * A[N1,N];
             "FOR" I:= N - 1, I - 1 "WHILE"
             ("IF" I - 1 >= Q "THEN" ABS(A[I,I - 1] *
             A[I1,I] * (ABS(A[I,I] + A[I1,I1] - SIGMA) +
             ABS(A[I + 2,I1]))) > ABS(A[I,I] * ((A[I,I] - SIGMA) +
             A[I,I1] * A[I1,I] + RHO)) * TOL
             "ELSE" "FALSE") "DO" P1:= I1:= I; P:= P1 - 1;
             P2:= P + 2;
                                                               "COMMENT"
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 18
                                                                 ;
 
 
             "FOR" I:= P "STEP" 1 "UNTIL" N - 1 "DO"
             "BEGIN" IMIN1:= I - 1; I1:= I + 1; I2:= I + 2;
                 "IF" I = P "THEN"
                 "BEGIN" G1:= A[P,P] * (A[P,P] - SIGMA) + A[P,P1] *
                     A[P1,P] + RHO;
                     G2:= A[P1,P] * (A[P,P] + A[P1,P1] - SIGMA);
                     "IF" P1 <= N1 "THEN"
                     "BEGIN" G3:= A[P1,P] * A[P2,P1]; A[P2,P]:= 0 "END"
                     "ELSE" G3:= 0
                 "END"
                 "ELSE"
                 "BEGIN" G1:= A[I,IMIN1]; G2:= A[I1,IMIN1];
                     G3:= "IF" I2 <= N "THEN" A[I2,IMIN1] "ELSE" 0
                 "END";
                 K:= "IF" G1 >= 0 "THEN"
                 SQRT(G1 ** 2 + G2 ** 2 + G3 ** 2) "ELSE"
                 -SQRT(G1 ** 2 + G2 ** 2 + G3 ** 2);
                 B:= ABS(K) > MACHTOL2;
                 AA:= "IF" B "THEN" G1 / K + 1 "ELSE" 2;
                 PSI1:= "IF" B "THEN" G2 / (G1 + K) "ELSE" 0;
                 PSI2:= "IF" B "THEN" G3 / (G1 + K) "ELSE" 0;
                 "IF" I ^= Q "THEN" A[I,IMIN1]:= "IF" I = P "THEN"
                 -A[I,IMIN1] "ELSE" -K;
                 "FOR" J:= I "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" E:= AA * (A[I,J] + PSI1 * A[I1,J] +
                     ("IF" I2 <= N "THEN" PSI2 * A[I2,J] "ELSE" 0));
                     A[I,J]:= A[I,J] - E; A[I1,J]:= A[I1,J] - PSI1 * E;
                     "IF" I2 <= N "THEN" A[I2,J]:= A[I2,J] - PSI2 * E
                 "END";
                 "FOR" J:= Q "STEP" 1 "UNTIL"
                 ("IF" I2 <= N "THEN" I2 "ELSE" N) "DO"
                 "BEGIN" E:= AA * (A[J,I] + PSI1 * A[J,I1] +
                     ("IF" I2 <= N "THEN" PSI2 * A[J,I2] "ELSE" 0));
                     A[J,I]:= A[J,I] - E; A[J,I1]:= A[J,I1] - PSI1 * E;
                     "IF" I2 <= N "THEN" A[J,I2]:= A[J,I2] - PSI2 * E
                 "END";
                 "IF" I2 <= N1 "THEN"
                 "BEGIN" I3:= I + 3; E:= AA * PSI2 * A[I3,I2];
                     A[I3,I]:= -E;
                     A[I3,I1]:= -PSI1 * E;
                     A[I3,I2]:= A[I3,I2] - PSI2 * E
                 "END"
             "END"
         "END";
         "IF" N > 0 "THEN" "GOTO" IN;
     OUT: EM[3]:= W; EM[5]:= COUNT; COMVALQRI:= N
     "END" COMVALQRI
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 19
 
 
                                                                  ;
         "EOP"
0"CODE" 34191;
     "COMMENT" MCA 2421;
     "PROCEDURE" COMVECHES(A, N, LAMBDA, MU, EM, U, V);
     "VALUE" N, LAMBDA, MU;
     "INTEGER" N; "REAL" LAMBDA, MU; "ARRAY" A, EM, U, V;
     "BEGIN" "INTEGER" I, I1, J, COUNT, MAX;
         "REAL" AA, BB, D, M, R, S, W, X, Y, NORM, MACHTOL, TOL;
         "ARRAY" G, F[1:N];
         "BOOLEAN" "ARRAY" P[1:N];
 
         NORM:= EM[1]; MACHTOL:= EM[0] * NORM; TOL:= EM[6] * NORM;
         MAX:= EM[8];
         "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" F[I - 1]:= A[I,I - 1]; A[I,1]:= 0 "END";
         AA:= A[1,1] - LAMBDA; BB:= -MU;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" I1:= I + 1; M:= F[I];
             "IF" ABS(M) < MACHTOL "THEN" M:= MACHTOL;
             A[I,I]:= M; D:= AA ** 2 + BB ** 2; P[I]:= ABS(M) < SQRT(D);
             "IF" P[I] "THEN"
             "BEGIN" "COMMENT" A[I,J] * FACTOR AND A[I1,J] - A[I,J];
                 F[I]:= R:= M * AA / D; G[I]:= S:= -M * BB / D;
                 W:= A[I1,I]; X:= A[I,I1]; A[I1,I]:= Y:= X * S + W * R;
                 A[I,I1]:= X:= X * R - W * S;
                 AA:= A[I1,I1] - LAMBDA - X; BB:= -(MU + Y);
                 "FOR" J:= I + 2 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" W:= A[J,I]; X:= A[I,J];
                     A[J,I]:= Y:= X * S + W * R;
                     A[I,J]:= X:= X * R - W * S; A[J,I1]:= -Y;
                     A[I1,J]:= A[I1,J] - X
                 "END"
             "END"
             "ELSE"
             "BEGIN" "COMMENT" INTERCHANGE A[I1,J] AND
                 A[I,J] - A[I1,J] * FACTOR;
                 F[I]:= R:= AA / M; G[I]:= S:= BB / M;
                 W:= A[I1,I1] - LAMBDA; AA:= A[I,I1] - R * W - S * MU;
                 A[I,I1]:= W; BB:= A[I1,I] - S * W + R * MU;
                 A[I1,I]:= -MU;
                 "FOR" J:= I + 2 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" W:= A[I1,J]; A[I1,J]:= A[I,J] - R * W;
                     A[I,J]:= W;
                     A[J,I1]:= A[J,I] - S * W; A[J,I]:= 0
                 "END"
             "END"
         "END"
1SECTION : 3.3.1.2.1          (JULY 1974)                        PAGE 20
                                                                 ;
 
 
         P[N]:= "TRUE"; D:= AA ** 2 + BB ** 2; "IF" D < MACHTOL ** 2
         "THEN" "BEGIN" AA:= MACHTOL; BB:= 0; D:= MACHTOL ** 2 "END";
         A[N,N]:= D; F[N]:= AA; G[N]:= -BB;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" U[I]:= 1; V[I]:= 0 "END";
         COUNT:= 0;
      FORWARD: "IF" COUNT > MAX "THEN" "GOTO" OUTM;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "IF" P[I] "THEN"
              "BEGIN" W:= V[I]; V[I]:= G[I] * U[I] + F[I] * W;
                 U[I]:= F[I] * U[I] - G[I] * W; "IF" I < N "THEN"
                 "BEGIN" V[I + 1]:= V[I + 1] - V[I];
                     U[I + 1]:= U[I + 1] - U[I]
                 "END"
             "END"
             "ELSE"
             "BEGIN" AA:= U[I + 1]; BB:= V[I + 1];
                 U[I + 1]:= U[I] - (F[I] * AA - G[I] * BB); U[I]:= AA;
                 V[I + 1]:= V[I] - (G[I] * AA + F[I] * BB); V[I]:= BB
             "END"
         "END" FORWARD;
      BACKWARD: "FOR" I:= N "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" I1:= I + 1;
             U[I]:= (U[I] - MATVEC(I1, N, I, A, U) + ("IF" P[I] "THEN"
             TAMVEC(I1, N, I, A, V) "ELSE" A[I1,I] * V[I1])) / A[I,I];
             V[I]:= (V[I] - MATVEC(I1, N, I, A, V) - ("IF" P[I] "THEN"
             TAMVEC(I1, N, I, A, U) "ELSE" A[I1,I] * U[I1])) / A[I,I]
         "END" BACKWARD;
      NORMALISE: W:= 1 / SQRT(VECVEC(1, N, 0, U, U) +
         VECVEC(1, N, 0, V, V));
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" U[J]:= U[J] * W; V[J]:= V[J] * W "END";
         COUNT:= COUNT + 1; "IF" W > TOL "THEN" "GOTO" FORWARD;
      OUTM: EM[7]:= W; EM[9]:= COUNT
     "END" COMVECHES;
         "EOP"
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 1
 
 
 
 AUTHORS   : T.J. DEKKER, W. HOFFMANN.
 
 
 CONTRIBUTORS: W. HOFFMANN, S.P.N. VAN KAMPEN, J.G. VERWER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731205.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION CONTAINS FIVE PROCEDURES FOR  CALCULATING  EIGENVALUES
     AND / OR EIGENVECTORS OF REAL MATRICES:
     A) REAEIGVAL CALCULATES THE EIGENVALUES OF A MATRIX, PROVIDED  THAT
     ALL EIGENVALUES ARE REAL,
     B) REAEIG1 CALCULATES THE EIGENVALUES, PROVIDED THAT  THEY  ARE ALL
     REAL, AND THE EIGENVECTORS OF A MATRIX,
     C) REAEIG3 CALCULATES THE EIGENVALUES, PROVIDED THAT  THEY  ARE ALL
     REAL, AND THE EIGENVECTORS OF A MATRIX,
     D) COMEIGVAL CALCULATES THE EIGENVALUES OF A MATRIX,
     E) COMEIG1 CALCULATES THE EIGENVALUES AND EIGENVECTORS OF A MATRIX.
 
 KEYWORDS:
     EIGENVALUES,
     EIGENVECTORS.
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: REAEIGVAL.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" REAEIGVAL(A, N, EM, VAL); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL;
     "CODE" 34182;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE MATRIX WHOSE EIGENVALUES ARE TO BE CALCULATED;
             EXIT:  THE ARRAY ELEMENTS ARE ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[2], THE  RELATIVE TOLERANCE USED  FOR THE  QR
                           ITERATION;
                    EM[4], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[1], THE INFINITY NORM OF THE EQUILIBRATED MATRIX;
                    EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS OF VAL  ARE APPROXIMATE EIGEN-
                           VALUES  OF  THE  GIVEN  MATRIX,  WHERE  K  IS
                           DELIVERED IN REAEIGVAL;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT: THE  EIGENVALUES OF THE GIVEN  MATRIX  ARE  DELIVERED
                   IN MONOTONICALLY NONINCREASING ORDER;
 
     MOREOVER:
     REAEIGVAL DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE  REAEIGVAL  DELIVERS  K, THE  NUMBER OF
     EIGENVALUES NOT CALCULATED.
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 3
 
 
 
 
 PROCEDURES USED:
     EQILBR    = CP34173,
     TFMREAHES = CP34170,
     REAVALQRI = CP34180.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: 3N.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE GIVEN MATRIX IS EQUILIBRATED  BY  CALLING  EQILBR (SEE  SECTION
     3.2.1.1.1) AND TRANSFORMED TO A SIMILAR UPPER-HESSENBERG   MATRIX
     BY CALLING TFMREAHES  (SEE  SECTION 3.2.1.2.1.2). THE   EIGENVALUES
     ARE THEN CALCULATED BY CALLING REAVALQRI, WHICH USES SINGLE  QR
     ITERATION (SEE SECTION 3.3.1.2.1).
     THE PROCEDURE REAEIGVAL SHOULD  BE USED ONLY IF ALL EIGENVALUES ARE
     REAL.
     FOR FURTHER DETAILS SEE REFERENCES [1], [2] AND [3].
 
 
 SUBSECTION: REAEIG1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" REAEIG1(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "CODE" 34184;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE MATRIX WHOSE EIGENVALUES AND EIGENVECTORS ARE TO
                    BE CALCULATED;
             EXIT:  THE ARRAY ELEMENTS ARE ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 4
 
 
 
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[2], THE RELATIVE  TOLERANCE  USED  FOR THE QR
                           ITERATION;
                    EM[4], THE   MAXIMUM   ALLOWED   NUMBER   OF  QR
                           ITERATIONS;
                    EM[6], THE TOLERANCE  USED  FOR  THE   EIGENVECTORS;
                           FOR EACH EIGENVECTOR  THE  INVERSE  ITERATION
                           ENDS IF THE EUCLIDEAN  NORM  OF THE RESIDUE
                           VECTOR IS SMALLER THAN EM[1] * EM[6];
                    EM[8], THE   MAXIMUM   ALLOWED   NUMBER  OF  INVERSE
                           ITERATIONS  FOR  THE  CALCULATION  OF    EACH
                           EIGENVECTOR;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N,
                    EM[6] > EM[2] (E.G. EM[6] = "-10),
                    EM[8] = 5;
             EXIT:  EM[1], THE INFINITY NORM OF THE EQUILIBRATED MATRIX;
                    EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS OF VAL AND COLUMNS OF VEC  ARE
                           APPROXIMATE EIGENVALUES AND  EIGENVECTORS  OF
                           THE GIVEN MATRIX, WHERE  K IS  DELIVERED   IN
                           REAEIG1;
                    EM[7], THE  MAXIMUM EUCLIDIAN NORM OF THE RESIDUES
                           OF THE CALCULATED EIGENVECTORS (OF THE TRANS-
                           FORMED MATRIX);
                    EM[9], THE  LARGEST  NUMBER  OF  INVERSE  ITERATIONS
                           PERFORMED FOR THE CALCULATION OF SOME  EIGEN-
                           VECTOR;  IF,  FOR   SOME   EIGENVECTOR    THE
                           EUCLIDEAN  NORM  OF  THE  RESIDUE   REMAINS
                           LARGER   THAN    EM[1] * EM[6],  THE    VALUE
                           EM[8] + 1  IS  DELIVERED;  NEVERTHELESS   THE
                           EIGENVECTORS  MAY  THEN  VERY WELL BE USEFUL,
                           THIS  SHOULD  BE   JUDGED   FROM   THE  VALUE
                           DELIVERED IN EM[7] OR FROM SOME OTHER TEST;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT: THE  EIGENVALUES OF THE GIVEN  MATRIX  ARE  DELIVERED
                   IN MONOTONICALLY DECREASING ORDER;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:N];
             EXIT: THE CALCULATED EIGENVECTORS, CORRESPONDING   TO   THE
                   EIGENVALUES IN ARRAY VAL[1:N], ARE DELIVERED  IN  THE
                   COLUMNS OF ARRAY VEC;
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 5
 
 
 
     MOREOVER:
     REAEIG1   DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE  REAEIG1    DELIVERS  K, THE  NUMBER OF
     EIGENVALUES AND EIGENVECTORS NOT CALCULATED.
 
 PROCEDURES USED:
     EQILBR     = CP34173,
     TFMREAHES  = CP34170,
     BAKREAHES2 = CP34172,
     BAKLBR     = CP34174,
     REAVALQRI  = CP34180,
     REAVECHES  = CP34181,
     REASCL     = CP34183.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: N * N + 5N.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 OPTIONS: F.
 
 METHOD AND PERFORMANCE:
     THE GIVEN MATRIX IS EQUILIBRATED  BY  CALLING  EQILBR (SEE  SECTION
     3.2.1.1.1) AND TRANSFORMED TO A SIMILAR UPPER-HESSENBERG   MATRIX
     BY CALLING TFMREAHES  (SEE  SECTION 3.2.1.2.1.2). THE   EIGENVALUES
     ARE THEN CALCULATED BY CALLING REAVALQRI, WHICH USES SINGLE  QR
     ITERATION (SEE SECTION 3.3.1.2.1).
     FURTHERMORE, TO FIND THE EIGENVECTORS WILKINSON'S DEVICE IS FIRST
     APPLIED [2, P.328 AND 628]. SUBSEQUENTLY  THE  EIGENVECTORS  OF THE
     UPPER-HESSENBERG MATRIX  ARE  CALCULATED  BY  CALLING  REAVECHES,
     WHICH   USES   INVERSE   ITERATION  (SEE  SECTION  3.3.1.2.1).  THE
     CALCULATED VECTORS ARE THEN BACK-TRANSFORMED TO  THE  CORRESPONDING
     EIGENVECTORS OF THE GIVEN MATRIX BY CALLING BAKREAHES2  AND  BAKLBR
     (SEE SECTIONS 3.2.1.2.1.2 AND 3.2.1.1.1). FINALLY  THE  APPROXIMATE
     EIGENVECTORS ARE NORMALIZED BY  CALLING  REASCL (SEE SECTION 1.1.9)
     SUCH THAT, IN EACH  EIGENVECTOR, AN  ELEMENT  OF  MAXIMUM  ABSOLUTE
     VALUE EQUALS 1.
     THE PROCEDURE REAEIG1 SHOULD BE USED  ONLY IF ALL  EIGENVALUES  ARE
     REAL.
     FOR FURTHER DETAILS SEE THE GIVEN REFERENCES.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 6
 
 
 
 SUBSECTION: REAEIG3.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" REAEIG3(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "CODE" 34187;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE MATRIX WHOSE EIGENVALUES AND EIGENVECTORS ARE TO
                    BE CALCULATED;
             EXIT:  THE ARRAY ELEMENTS ARE ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[2], THE RELATIVE  TOLERANCE  USED  FOR THE QR
                           ITERATION;
                    EM[4], THE   MAXIMUM   ALLOWED   NUMBER   OF  QR
                           ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[1], THE INFINITY NORM OF THE EQUILIBRATED MATRIX;
                    EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED. IN   THIS  CASE  ONLY THE  LAST
                           N - K  ELEMENTS  OF  VAL   ARE    APPROXIMATE
                           EIGENVALUES OF THE GIVEN MATRIX AND NO USEFUL
                           EIGENVECTORS ARE DELIVERED. THE  VALUE  K  IS
                           DELIVERED IN REAEIG3;
     VAL:    <ARRAY IDENTIFIER>;
             "ARRAY" VAL[1:N];
             EXIT: THE  EIGENVALUES OF THE GIVEN  MATRIX ARE  DELIVERED;
 
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY" VEC[1:N,1:N];
             EXIT: THE CALCULATED EIGENVECTORS, CORRESPONDING   TO   THE
                   EIGENVALUES IN ARRAY VAL[1:N], ARE DELIVERED  IN  THE
                   COLUMNS OF ARRAY VEC;
 
     MOREOVER:
     REAEIG3   DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE  REAEIG3    DELIVERS  K, THE  NUMBER OF
     EIGENVALUES NOT CALCULATED.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 7
 
 
 
 PROCEDURES USED:
     EQILBR     = CP34173,
     TFMREAHES  = CP34170,
     BAKREAHES2 = CP34172,
     BAKLBR     = CP34174,
     REAQRI     = CP34186,
     REASCL     = CP34183.
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: 4N.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE GIVEN MATRIX IS EQUILIBRATED  BY  CALLING  EQILBR (SEE  SECTION
     3.2.1.1.1) AND TRANSFORMED TO A SIMILAR UPPER-HESSENBERG   MATRIX
     BY CALLING TFMREAHES  (SEE  SECTION 3.2.1.2.1.2). THE   EIGENVALUES
     AND  EIGENVECTORS  OF  THE   UPPER-HESSENBERG   MATRIX  ARE  THEN
     CALCULATED BY CALLING REAQRI, WHICH USES SINGLE  QR   ITERATION
     FOR THE EIGENVALUES AND A DIRECT METHOD FOR THE  EIGENVECTORS  (SEE
     SECTION 3.3.1.2.1). FINALLY  THE  EIGENVECTORS   OF  THE   UPPER-
     HESSENBERG MATRIX ARE BACK-TRANSFORMED TO THE CORRESPONDING  EIGEN-
     VECTORS OF THE  GIVEN  MATRIX  BY  CALLING  BAKREAHES2 (SEE SECTION
     3.1.2.1.2.1) AND NORMALIZED BY CALLING  REASCL  (SEE SECTION 1.1.9)
     SUCH THAT, IN EACH EIGENVECTOR, AN  ELEMENT  OF  MAXIMUM   ABSOLUTE
     VALUE EQUALS 1.
     THE PROCEDURE REAEIG3  SHOULD  BE USED  ONLY IF ALL EIGENVALUES ARE
     REAL.
     FOR FURTHER DETAILS SEE THE GIVEN REFERENCES.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 8
 
 
 
 SUBSECTION: COMEIGVAL.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" COMEIGVAL(A, N, EM, RE, IM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, RE, IM;
     "CODE" 34192;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE MATRIX WHOSE EIGENVALUES ARE TO BE CALCULATED;
             EXIT:  THE ARRAY ELEMENTS ARE ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[2], THE  RELATIVE TOLERANCE USED  FOR THE  QR
                           ITERATION;
                    EM[4], THE  MAXIMUM  ALLOWED  NUMBER  OF ITERATIONS;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N;
             EXIT:  EM[1], THE INFINITY NORM OF THE EQUILIBRATED MATRIX;
                    EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS  OF RE AND IM  ARE APPROXIMATE
                           EIGENVALUES  OF THE GIVEN MATRIX, WHERE  K IS
                           DELIVERED IN COMEIGVAL;
     RE,IM:  <ARRAY IDENTIFIER>;
             "ARRAY" RE, IM[1:N];
             EXIT:  THE  REAL  AND  IMAGINARY  PARTS  OF THE  CALCULATED
                    EIGENVALUES  OF THE  GIVEN  MATRIX  ARE DELIVERED IN
                    ARRAY  RE, IM[1:N], THE  MEMBERS  OF  EACH   NONREAL
                    COMPLEX CONJUGATE PAIR BEING CONSECUTIVE;
 
     MOREOVER:
     COMEIGVAL DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4] ITERATIONS; OTHERWISE  COMEIGVAL  DELIVERS  K, THE  NUMBER OF
     EIGENVALUES NOT CALCULATED.
 
 PROCEDURES USED:
     EQILBR    = CP34173,
     TFMREAHES = CP34170,
     COMVALQRI = CP34190.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                         PAGE 9
 
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: 3N.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE GIVEN MATRIX IS EQUILIBRATED  BY  CALLING  EQILBR (SEE  SECTION
     3.2.1.1.1) AND TRANSFORMED TO A SIMILAR UPPER-HESSENBERG   MATRIX
     BY CALLING TFMREAHES  (SEE  SECTION 3.2.1.2.1.2). THE   EIGENVALUES
     ARE THEN CALCULATED BY CALLING COMVALQRI, WHICH USES DOUBLE  QR
     ITERATION (SEE SECTION 3.3.1.2.1).
     FOR FURTHER DETAILS SEE REFERENCES [1], [2] AND [3].
 
 
 SUBSECTION: COMEIG1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "INTEGER" "PROCEDURE" COMEIG1(A, N, EM, RE, IM, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, RE, IM, VEC;
     "CODE" 34194;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE MATRIX WHOSE EIGENVALUES AND EIGENVECTORS ARE TO
                    BE CALCULATED;
             EXIT:  THE ARRAY ELEMENTS ARE ALTERED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:9];
             ENTRY: EM[0], THE MACHINE PRECISION;
                    EM[2], THE RELATIVE  TOLERANCE  USED  FOR THE QR
                           ITERATION;
                    EM[4], THE   MAXIMUM   ALLOWED   NUMBER   OF  QR
                           ITERATIONS;
                    EM[6], THE TOLERANCE  USED  FOR  THE   EIGENVECTORS;
                           FOR EACH EIGENVECTOR  THE  INVERSE  ITERATION
                           ENDS IF THE EUCLIDEAN  NORM  OF THE RESIDUE
                           VECTOR IS SMALLER THAN EM[1] * EM[6];
                    EM[8], THE   MAXIMUM   ALLOWED   NUMBER  OF  INVERSE
                           ITERATIONS  FOR  THE  CALCULATION  OF    EACH
                           EIGENVECTOR;
                    FOR THE  CD CYBER 73-28  SUITABLE VALUES  OF THE
                    DATA TO BE GIVEN IN EM ARE:
                    EM[0] = "-14,
                    EM[2] > EM[0] (E.G. EM[2] = "-13),
                    EM[4] = 10 * N,
                    EM[6] > EM[2] (E.G. EM[6] = "-10),
                    EM[8] = 5;
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 10
 
 
 
             EXIT:  EM[1], THE INFINITY NORM OF THE EQUILIBRATED MATRIX;
                    EM[3], THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                           ELEMENTS NEGLECTED;
                    EM[5], THE  NUMBER OF QR  ITERATIONS  PERFORMED;
                           IF THE  ITERATION  PROCESS IS  NOT  COMPLETED
                           WITHIN EM[4] ITERATIONS, THE VALUE  EM[4] + 1
                           IS DELIVERED  AND IN THIS CASE  ONLY THE LAST
                           N - K ELEMENTS OF RE, IM  AND COLUMNS  OF VEC
                           ARE APPROXIMATE EIGENVALUES AND  EIGENVECTORS
                           OF THE GIVEN MATRIX, WHERE  K IS DELIVERED IN
                           COMEIG1;
                    EM[7], THE  MAXIMUM EUCLIDIAN NORM OF THE RESIDUES
                           OF THE CALCULATED EIGENVECTORS (OF THE TRANS-
                           FORMED MATRIX);
                    EM[9], THE  LARGEST  NUMBER  OF  INVERSE  ITERATIONS
                           PERFORMED FOR THE CALCULATION OF SOME  EIGEN-
                           VECTOR;  IF  THE   EUCLIDIAN  NORM  OF  THE
                           RESIDUE FOR ONE OR MORE EIGENVECTORS  REMAINS
                           LARGER THAN EM[1] * EM[6], THE VALUE  EM[8]+1
                           IS  DELIVERED; NEVERTHELESS  THE EIGENVECTORS
                           MAY THEN  VERY WELL BE USEFUL, THIS SHOULD BE
                           JUDGED  FROM THE VALUE  DELIVERED IN EM[7] OR
                           FROM SOME OTHER TEST;
     RE,IM:  <ARRAY IDENTIFIER>;
             "ARRAY" RE, IM[1:N];
             EXIT:  THE  REAL  AND  IMAGINARY  PARTS  OF THE  CALCULATED
                    EIGENVALUES  OF THE  GIVEN  MATRIX  ARE DELIVERED IN
                    ARRAY  RE, IM[1:N], THE  MEMBERS  OF  EACH   NONREAL
                    COMPLEX CONJUGATE PAIR BEING CONSECUTIVE;
     VEC:    <ARRAY IDENTFIER>;
             "ARRAY" VEC[1:N,1:N];
             EXIT:  THE CALCULATED  EIGENVECTORS  ARE  DELIVERED  IN THE
                    COLUMNS OF ARRAY VEC;
                    AN EIGENVECTOR, CORRESPONDING  TO A REAL  EIGENVALUE
                    GIVEN IN ARRAY RE, IS DELIVERED IN THE CORRESPONDING
                    COLUMN OF ARRAY VEC;
                    THE  REAL  AND  IMAGINARY  PART  OF AN  EIGENVECTOR,
                    CORRESPONDING  TO THE  FIRST  MEMBER  OF  A  NONREAL
                    COMPLEX CONJUGATE PAIR  OF EIGENVALUES  GIVEN IN THE
                    ARRAYS RE, IM, ARE DELIVERED  IN THE TWO CONSECUTIVE
                    COLUMNS OF ARRAY VEC CORRESPONDING TO THIS PAIR (THE
                    EIGENVECTORS  CORRESPONDING TO THE SECOND MEMBERS OF
                    NONREAL  COMPLEX CONJUGATE PAIRS  ARE NOT DELIVERED,
                    SINCE THEY ARE SIMPLY THE COMPLEX CONJUGATE OF THOSE
                    CORRESPONDING TO THE FIRST MEMBER OF SUCH PAIRS);
 
     MOREOVER:
     COMEIG1   DELIVERS 0, PROVIDED THAT THE PROCESS IS COMPLETED WITHIN
     EM[4]  ITERATIONS; OTHERWISE  COMEIG1  DELIVERS  K, THE  NUMBER  OF
     EIGENVALUES AND EIGENVECTORS NOT CALCULATED.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 11
 
 
 
 PROCEDURES USED:
     EQILBR     = CP34173,
     TFMREAHES  = CP34170,
     BAKREAHES2 = CP34172,
     BAKLBR     = CP34174,
     REAVECHES  = CP34181,
     COMVALQRI  = CP34190,
     COMVECHES  = CP34191,
     COMSCL     = CP34193.
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: N * N + 5N.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE GIVEN MATRIX IS EQUILIBRATED  BY  CALLING  EQILBR (SEE  SECTION
     3.2.1.1.1) AND TRANSFORMED TO A SIMILAR UPPER-HESSENBERG   MATRIX
     BY CALLING TFMREAHES  (SEE  SECTION 3.2.1.2.1.2). THE   EIGENVALUES
     ARE THEN CALCULATED BY CALLING COMVALQRI, WHICH USES DOUBLE  QR
     ITERATION (SEE SECTION 3.3.1.2.1).
     FURTHERMORE, TO FIND THE EIGENVECTORS WILKINSON'S DEVICE IS FIRST
     APPLIED [2, P.328 AND 628]. SUBSEQUENTLY  THE  EIGENVECTORS  OF THE
     UPPER-HESSENBERG MATRIX ARE COMPUTED BY CALLING REAVECHES FOR THE
     REAL EIGENVALUES AND  COMVECHES FOR THE OTHERS (SECTION 3.3.1.2.1.)
     THE COMPUTED VECTORS ARE THEN BACK-TRANSFORMED TO THE CORRESPONDING
     EIGENVECTORS OF THE GIVEN MATRIX BY CALLING BAKREAHES2  AND  BAKLBR
     (SEE SECTIONS 3.2.1.2.1.2 AND 3.2.1.1.1). FINALLY  THE  APPROXIMATE
     EIGENVECTORS ARE NORMALIZED BY  CALLING  COMSCL (SEE SECTION 1.1.9)
     SUCH  THAT, IN EACH  EIGENVECTOR, AN  ELEMENT  OF  MAXIMUM  MODULUS
     EQUALS 1.
     FOR FURTHER DETAILS SEE THE GIVEN REFERENCES.
 
 
 REFERENCES:
     [1]. T.J. DEKKER AND W. HOFFMANN.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
          MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
     [3]. J.G. FRANCIS.
          THE QR TRANSFORMATION, PARTS 1 AND 2.
          COMP. J. 4 (1961), 265 - 271 AND 332 - 345.
     [4]. J.M. VARAH.
          EIGENVECTORS OF A REAL MATRIX BY INVERSE ITERATION.
          STANFORD UNIVERSITY, TECH. REP. NO. CS 34, 1966.
 
 
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 12
 
 
 
 EXAMPLE OF USE:
 
     IN THIS SECTION  WE  ONLY  GIVE AN EXAMPLE OF USE OF THE PROCEDURES
     REAEIG3  AND COMEIGVAL, BECAUSE  A CALL OF  THE OTHER PROCEDURES IS
     ALMOST SIMILAR.
 
     THE EIGENVALUES AND CORRESPONDING EIGENVECTORS OF A MATRIX, STORED
     IN ARRAY A, WITH A[I,J]:= "IF" I=1 "THEN" 1 "ELSE" 1 / (I + J - 1),
     MAY BE OBTAINED BY THE PROCEDURE REAEIG3  IN THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J, M;
         "ARRAY" A, VEC[1:4,1:4], EM[0:5], VAL[1:4];
 
         "FOR" I:= 1, 2, 3, 4 "DO" "FOR" J:= 1, 2, 3, 4 "DO"
         A[I,J]:= "IF" I = 1 "THEN" 1 "ELSE" 1 / ( I + J - 1);
         EM[0]:= "-14; EM[2]:= "-13; EM[4]:= 40;
         M:= REAEIG3(A, 4, EM, VAL, VEC);
         OUTPUT(61, "("D, /")", M);
         "FOR" I:= M + 1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61, "("/, 2(+.13D"+2D, 2B), /, 3(21B, +.13D"+2D, /)")",
         VAL[I], VEC[1,I], VEC[2,I], VEC[3,I], VEC[4,I]);
         OUTPUT(61, "("/, 2(.2D"+2D, /), ZD")", EM[1], EM[3], EM[5])
     "END"
 
     THE PROGRAM DELIVERS(THE RESULTS ARE CORRECT UP TO TWELVE DIGITS):
 
     THE NUMBER OF NOT CALCULATED EIGENVALUES: 0
 
     THE EIGENVALUES AND CORRESPONDING EIGENVECTORS:
 
     +.1886632138548"+01  +.1000000000000"+01
                          +.3942239850770"+00
                          +.2773202862566"+00
                          +.2150878672143"+00
 
     -.1980145931103"+00  +.1000000000000"+01
                          -.7388484093937"+00
                          -.3116238593839"+00
                          -.1475423243327"+00
 
     -.1228293686543"-01  -.4634736456357"+00
                          +.1000000000000"+01
                          -.1542548002737"+00
                          -.3765787365625"+00
 
     -.1441323817331"-03  +.1095712655340"+00
                          -.6208405341138"+00
                          +.1000000000000"+01
                          -.4887465241876"+00
 
     EM[1] = .40"+01
     EM[3] = .15"-14
     EM[5] = 5 .
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 13
 
 
 
     THE COMPLEX EIGENVALUES  OF A MATRIX  STORED IN ARRAY A  WITH N = 3
     AND THE  ROWS  (8, -1, -5), (-4, 4, -2)  AND  (18, -5, -7), MAY  BE
     OBTAINED BY THE PROCEDURE COMEIGVAL IN THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, M;
         "ARRAY" A[1:3,1:3], EM[0:5], RE, IM[1:3];
 
         EM[0]:= "-14; EM[2]:= "-13; EM[4]:= 30;
         A[1,1]:= 8; A[1,2]:= -1; A[1,3]:= -5;
         A[2,1]:= -4; A[2,2]:= 4; A[2,3]:= -2;
         A[3,1]:= 18; A[3,2]:= -5; A[3,3]:= -7;
         M:= COMEIGVAL(A, 3, EM, RE, IM);
         OUTPUT(61, "("D, /")", M);
         "FOR" I:= M + 1 "STEP" 1 "UNTIL" 3 "DO"
         OUTPUT(61, "("2(+.13D"+2D, 2B), /")", RE[I], IM[I]);
         OUTPUT(61, "("/, 2(.2D"+2D, /), ZD")", EM[1], EM[3], EM[5])
     "END"
 
     THE PROGRAM DELIVERS(THE RESULTS ARE CORRECT UP TO TWELVE DIGITS):
 
     THE NUMBER OF NOT CALCULATED EIGENVALUES: 0
 
     THE EIGENVALUES: +.2000000000000"+01  +.4000000000000"+01
                      +.2000000000000"+01  -.4000000000000"+01
                      +.9999999999998"+00  +.0000000000000"+00
 
     THE ARRAY EM: EM[1] = .30"+02
                   EM[3] = .78"-17
                   EM[5] = 6 .
 
 
 SOURCE TEXTS:
0"CODE" 34182;
     "COMMENT" MCA 2412;
     "INTEGER" "PROCEDURE" REAEIGVAL(A, N, EM, VAL); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL;
     "BEGIN" "INTEGER" I, J; "REAL" R;
         "ARRAY" D[1:N]; "INTEGER" "ARRAY" INT, INT0[1:N];
 
         EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
         J:= REAEIGVAL:= REAVALQRI(A, N, EM, VAL);
         "FOR" I:= J + 1 "STEP" 1 "UNTIL" N "DO"
         "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "IF" VAL[J] > VAL[I] "THEN"
             "BEGIN" R:= VAL[I]; VAL[I]:= VAL[J]; VAL[J]:= R "END"
         "END"
     "END" REAEIGVAL
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 14
 
 
                                                                  ;
         "EOP"
0"CODE" 34184;
     "COMMENT" MCA 2414;
     "INTEGER" "PROCEDURE" REAEIG1(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "BEGIN" "INTEGER" I, K, MAX, J, L;
         "REAL" RESIDU, R, MACHTOL;
         "ARRAY" D, V[1:N], B[1:N,1:N];
         "INTEGER" "ARRAY" INT, INT0[1:N];
 
         RESIDU:= 0; MAX:= 0; EQILBR(A, N, EM, D, INT0);
         TFMREAHES(A, N, EM, INT);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "FOR" J:= ("IF" I = 1 "THEN" 1 "ELSE" I - 1)
         "STEP" 1 "UNTIL" N "DO" B[I,J]:= A[I,J];
         K:= REAEIG1:= REAVALQRI(B, N, EM, VAL);
         "FOR" I:= K + 1 "STEP" 1 "UNTIL" N "DO"
         "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "IF" VAL[J] > VAL[I] "THEN"
             "BEGIN" R:= VAL[I]; VAL[I]:= VAL[J]; VAL[J]:= R "END"
         "END";
         MACHTOL:= EM[0] * EM[1];
         "FOR" L:= K + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "IF" L > 1 "THEN"
             "BEGIN" "IF" VAL[L - 1] - VAL[L] < MACHTOL "THEN"
                 VAL[L]:= VAL[L - 1] - MACHTOL
             "END";
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "FOR" J:= ("IF" I = 1 "THEN" 1 "ELSE" I - 1)
             "STEP" 1 "UNTIL" N "DO" B[I,J]:= A[I,J];
             REAVECHES(B, N, VAL[L], EM, V);
             "IF" EM[7] > RESIDU "THEN" RESIDU:= EM[7];
             "IF" EM[9] > MAX "THEN" MAX:= EM[9];
             "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" VEC[J,L]:= V[J]
         "END";
         EM[7]:= RESIDU; EM[9]:= MAX;
         BAKREAHES2(A, N, K + 1, N, INT, VEC);
         BAKLBR(N, K + 1, N, D, INT0, VEC);
         REASCL(VEC, N, K + 1, N)
     "END" REAEIG1
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 15
 
 
                                                                  ;
         "EOP"
0"CODE" 34187;
     "COMMENT" MCA 2417;
     "INTEGER" "PROCEDURE" REAEIG3(A, N, EM, VAL, VEC); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, VAL, VEC;
     "BEGIN" "INTEGER" I; "REAL" S;
         "INTEGER" "ARRAY" INT, INT0[1:N]; "ARRAY" D[1:N];
 
         EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
         I:= REAEIG3:= REAQRI(A, N, EM, VAL, VEC);
         "IF" I = 0 "THEN"
         "BEGIN" BAKREAHES2(A, N, 1, N, INT, VEC);
             BAKLBR(N, 1, N, D, INT0, VEC); REASCL(VEC, N, 1, N)
         "END"
     "END" REAEIG3;
         "EOP"
0"CODE" 34192;
     "COMMENT" MCA 2422;
     "INTEGER" "PROCEDURE" COMEIGVAL(A, N, EM, RE, IM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, RE, IM;
     "BEGIN" "INTEGER" "ARRAY" INT, INT0[1:N];
         "ARRAY" D[1:N];
 
         EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
         COMEIGVAL:= COMVALQRI(A, N, EM, RE, IM)
     "END" COMEIGVAL
1SECTION 3.3.1.2.2            (JULY 1974)                        PAGE 16
 
                                                                  ;
         "EOP"
0"CODE" 34194;
     "COMMENT" MCA 2424;
     "INTEGER" "PROCEDURE" COMEIG1(A, N, EM, RE, IM, VEC);
     "VALUE" N; "INTEGER" N;
     "ARRAY" A, EM, RE, IM, VEC;
     "BEGIN" "INTEGER" I, J, K, PJ, ITT;
         "REAL" X, Y, MAX, NEPS;
         "ARRAY" AB[1:N,1:N], D, U, V[1:N];
         "INTEGER" "ARRAY" INT, INT0[1:N];
 
         "PROCEDURE" TRANSFER;
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "FOR" J:= ("IF" I = 1 "THEN" 1 "ELSE" I - 1) "STEP" 1
             "UNTIL" N "DO" AB[I,J]:= A[I,J]
         "END" TRANSFER;
 
         EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT); TRANSFER;
         K:= COMEIG1:= COMVALQRI(AB, N, EM, RE, IM);
         NEPS:= EM[0] * EM[1]; MAX:= 0; ITT:= 0;
         "FOR" I:= K + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" X:= RE[I]; Y:= IM[I]; PJ:= 0;
          AGAIN: "FOR" J:= K + 1 "STEP" 1 "UNTIL" I - 1 "DO"
             "BEGIN" "IF" ((X - RE[J]) ** 2 +
                 (Y - IM[J]) ** 2 <= NEPS ** 2) "THEN"
                 "BEGIN" "IF" PJ = J "THEN" NEPS:= EM[2] * EM[1]
                     "ELSE" PJ:= J; X:= X + 2 * NEPS; "GOTO" AGAIN
                 "END"
             "END";
             RE[I]:= X; TRANSFER; "IF" Y ^= 0 "THEN"
             "BEGIN" COMVECHES(AB, N, RE[I], IM[I], EM, U, V);
                 "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" VEC[J,I]:= U[J];
                 I:= I + 1; RE[I]:= X
             "END"
             "ELSE" REAVECHES(AB, N, X, EM, V);
             "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" VEC[J,I]:= V[J];
             "IF" EM[7] > MAX "THEN" MAX:= EM[7];
             ITT:= "IF" ITT > EM[9] "THEN" ITT "ELSE" EM[9]
         "END";
         EM[7]:= MAX; EM[9]:= ITT; BAKREAHES2(A, N, K + 1, N, INT, VEC);
         BAKLBR(N, K + 1, N, D, INT0, VEC); COMSCL(VEC, N, K + 1, N, IM)
     "END" COMEIG1;
         "EOP"
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730917.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOUR PROCEDURES FOR CALCULATING THE
     EIGENVALUES OR THE EIGENVALUES AND EIGENVECTORS OF COMPLEX
     HERMITIAN MATRICES.
     EIGVALHRM CALCULATES THE EIGENVALUES OF A HERMITIAN MATRIX.
     EIGHRM CALCULATES THE EIGENVALUES AND EIGENVECTORS OF A HERMITIAN
     MATRIX.
     QRIVALHRM CALCULATES THE EIGENVALUES OF A HERMITIAN MATRIX.
     QRIHRM CALCULATES THE EIGENVALUES AND EIGENVECTORS OF A HERMITIAN
     MATRIX.
     WHEN A SMALL NUMBER OF EIGENVALUES OR EIGENVALUES AND EIGENVECTORS
     IS REQUIRED, THE USE OF EIGVALHRM OR EIGHRM IS RECOMMANDED; WHEN
     MORE THAN, SAY, 25 PERCENT OF THE EIGENSYSTEM IS REQUIRED. THE
     PROCEDURES QRIVALHRM OR QRIHRM ARE TO BE USED.
 
 
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: EIGVALHRM.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" EIGVALHRM(A, N, NUMVAL, VAL, EM); "VALUE" N, NUMVAL;
     "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
     "CODE" 34368;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[1:N,1:N];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                THE ELEMENTS AF A ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     NUMVAL:    <ARITHMETIC EXPRESSION>;
                EIGVALHRM  CALCULATES  THE LARGEST NUMVAL EIGENVALUES OF
                THE HERMITIAN MATRIX;
     VAL:       <ARRAY IDENTIFIER>;
                "ARRAY" VAL[1:NUMVAL];
                EXIT:
                IN ARRAY VAL THE LARGEST NUMVAL EIGENVALUES ARE
                DELIVERED IN MONOTONICALLY NONINCREASING ORDER;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:3];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE EIGENVALUES;
                       MORE PRECISELY: THE TOLERANCE FOR EACH EIGENVALUE
                       LAMBDA, IS ABS(LAMBDA)*EM[2]+EM[1]*EM[0];
                EXIT:
                EM[1]: AN ESTIMATE OF A NORM OF THE ORIGINAL MATRIX;
                EM[3]: THE NUMBER OF ITERATIONS PERFORMED.
 
 
 PROCEDURES USED:
 
     HSHHRMTRIVAL = CP34364,
     VALSYMTRI    = CP34151.
 
 
 REQUIRED CENTRAL MEMORY:
     TWO AUXILIARY ARRAYS OF ORDER N AND N - 1 RESPECTIVELY ARE DECLARED
 
 
 RUNNING TIME: PROPORTIONAL TO N CUBED.
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 3
 
 
 
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE QRIHRM (THIS SECTION).
 
 
 EXAMPLE OF USE:  SEE EIGHRM (THIS SECTION).
 
 
 SUBSECTION: EIGHRM.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" EIGHRM(A, N, NUMVAL, VAL, VECR, VECI, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL;
     "ARRAY" A, VAL, VECR, VECI, EM;
     "CODE" 34369;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[1:N,1:N];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                THE ELEMENTS AF A ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     NUMVAL:    <ARITHMETIC EXPRESSION>;
                EIGHRM  CALCULATES THE LARGEST NUMVAL EIGENVALUES OF THE
                HERMITIAN MATRIX;
     VAL:       <ARRAY IDENTIFIER>;
                "ARRAY" VAL[1:NUMVAL];
                EXIT:
                IN ARRAY VAL THE LARGEST NUMVAL EIGENVALUES ARE
                DELIVERED IN MONOTONICALLY NONINCREASING ORDER;
     VECR,VECI: <ARRAY IDENTIFIER>;
                "ARRAY" VECR,VECI[1:N,1:NUMVAL];
                EXIT:
                THE CALCULATED EIGENVECTORS;
                THE  COMPLEX EIGENVECTOR WITH REAL PART VECR[1:N,I]  AND
                IMAGINARY PART VECI[1:N,I] CORRESPONDS TO THE EIGENVALUE
                VAL[I], I=1,...,NUMVAL;
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 4
 
 
 
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:9];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE EIGENVALUES;
                       MORE PRECISELY: THE TOLERANCE FOR EACH EIGENVALUE
                       LAMBDA, IS ABS(LAMBDA)*EM[2]+EM[1]*EM[0];
                EM[4]: THE ORTHOGONALIZATION PARAMETER (E.G. .01);
                EM[6]: THE TOLERANCE FOR THE EIGENVECTORS;
                EM[8]: THE  MAXIMUM NUMBER OF INVERSE ITERATIONS ALLOWED
                       FOR THE CALCULATION OF EACH EIGENVECTOR;
                EXIT:
                EM[1]: AN ESTIMATE OF A NORM OF THE ORIGINAL MATRIX;
                EM[3]: THE NUMBER OF ITERATIONS PERFORMED;
                EM[5]: THE  NUMBER  OF EIGENVECTORS INVOLVED IN THE LAST
                       GRAM-SCHMIDT ORTHOGONALIZATION;
                EM[7]: THE MAXIMUM EUCLIDEAN NORM OF THE RESIDUES OF THE
                       CALCULATED EIGENVECTORS;
                EM[9]: THE   LARGEST  NUMBER   OF  INVERSE    ITERATIONS
                       PERFORMED   FOR   THE   CALCULATION   OF     SOME
                       EIGENVECTOR; IF, HOWEVER,  FOR  SOME   CALCULATED
                       EIGENVECTOR, THE  EUCLIDEAN NORM OF THE  RESIDUES
                       REMAINS     GREATER  THAN   EM[1]*EM[6],     THEN
                       EM[9]:=EM[8]+1.
 
 
 PROCEDURES USED:
 
     HSHHRMTRI = CP34363,
     VALSYMTRI = CP34151,
     VECSYMTRI = CP34152,
     BAKHRMTRI = CP34365.
 
 
 REQUIRED CENTRAL MEMORY:
     THREE AUXILIARY ARRAYS OF ORDER N-1 AND TWO OF ORDER N ARE DECLARED
 
 
 RUNNING TIME: PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE QRIHRM (THIS SECTION).
 
 
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 5
 
 
 
 EXAMPLE OF USE:
 
     LET  EIGHRM  CALCULATE THE LARGEST EIGENVALUE AND THE CORRESPONDING
     EIGENVECTOR OF THE FOLLOWING MATRIX:
     (SEE GREGORY AND KARNEY, CHAPTER 6, EXAMPLE 6.6)
          3    1    0   +2I
          1    3   -2I   0
          0   +2I   1    1
         -2I   0    1    1
     THE EIGENVECTORS ARE NORMALIZED BY THE PROCEDURE SCLCOM (SEE
     SECTION 1.2.11. ).
 
     "BEGIN"
     "COMMENT" GREGORY AND KARNEY,CHAPTER 6, EXAMPLE 6.6;
     "REAL" "ARRAY" A[1:4,1:4],VAL[1:1],VECR,VECI[1:4,1:1],EM[0:9];
     "INTEGER" I;
     INIMAT(1,4,1,4,A,0);
     A[1,1]:=A[2,2]:=3;
     A[1,2]:=A[3,3]:=A[3,4]:=A[4,4]:=1;
     A[3,2]:=2;A[4,1]:=-2;
     EM[0]:=5"-14;EM[2]:="-12;
     EM[4]:=.01;EM[6]:="-10;EM[8]:=5;
     EIGHRM(A,4,1,VAL,VECR,VECI,EM);
     SCLCOM(VECR,VECI,4,1,1);
     OUTPUT(61,"(""("LARGEST EIGENVALUE: ")",N/")",VAL[1]);
     OUTPUT(61,"(""("CORRESPONDING EIGENVECTOR:")",/")");
     "FOR" I:=1,2,3,4 "DO"
     OUTPUT(61,"("+D.D,+D.DDD,"("*I")",/")",VECR[I,1],VECI[I,1]);
     "FOR" I:=1,3,5,7,9 "DO"
     OUTPUT(61,"("/,"("EM[")",D,"("]: ")",+D.DDD"+DD")",I,EM[I]);
     "END"
 
     DELIVERS:
 
     LARGEST EIGENVALUE: +4.8284271247462"000
     CORRESPONDING EIGENVECTOR:
     +1.0+0.000*I
     +1.0+0.000*I
     -0.0+0.414*I
     +0.0-0.414*I
 
     EM[1]: +6.000"+00
     EM[3]: +1.800"+01
     EM[5]: +1.000"+00
     EM[7]: +5.303"-14
     EM[9]: +1.000"+00
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 6
 
 
 
 SUBSECTION: QRIVALHRM.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "INTEGER" "PROCEDURE" QRIVALHRM(A, N, VAL, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, VAL, EM;
     "CODE" 34370;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[1:N,1:N];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                THE ELEMENTS AF A ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     VAL:       <ARRAY IDENTIFIER>;
                "ARRAY" VAL[1:N];
                EXIT:
                THE CALCULATED EIGENVALUES;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:5];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR ITERATION;
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
                EXIT:
                EM[1]: AN ESTIMATE OF A NORM OF THE ORIGINAL MATRIX;
                EM[3]: THE  MAXIMUM   ABSOLUTE VALUE OF THE   CODIAGONAL
                       ELEMENTS NEGLECTED;
                EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
                       EM[5]:= EM[4]+1 IN THE CASE QRIVALHRM^=0;
 
     QRIVALHRM:=0, PROVIDED  THE QR ITERATION IS COMPLETED  WITHIN EM[4]
     ITERATIONS; OTHERWISE, QRIVALHRM:=THE NUMBER OF EIGENVALUES, K, NOT
     CALCULATED AND ONLY THE LAST N-K ELEMENTS OF VAL ARE APPROXIMATE
     EIGENVALUES OF THE ORIGINAL HERMITEAN MATRIX.
 
 
 PROCEDURES USED:
 
     HSHHRMTRIVAL = CP34364,
     QRIVALSYMTRI = CP34160.
 
 
 REQUIRED CENTRAL MEMORY:
     TWO  AUXILIARY ARRAYS OF ORDER N  ARE DECLARED.
 
 RUNNING TIME: PROPORTIONAL TO N CUBED.
 
 
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 7
 
 
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE: SEE QRIHRM (THIS SECTION).
 
 
 EXAMPLE OF USE: SEE QRIHRM (THIS SECTION).
 
 
 SUBSECTION: QRIHRM.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "INTEGER" "PROCEDURE" QRIHRM(A, N, VAL, VR, VI, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, VAL, VR, VI, EM;
     "CODE" 34371;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[1:N,1:N];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                THE ELEMENTS AF A ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     VAL:       <ARRAY IDENTIFIER>;
                "ARRAY" VAL[1:N];
                EXIT:
                THE CALCULATED EIGENVALUES;
     VR,VI:     <ARRAY IDENTIFIER>;
                "ARRAY" VR,VI[1:N,1:N];
                EXIT:
                THE CALCULATED EIGENVECTORS;
                THE  COMPLEX  EIGENVECTOR WITH REAL PART VR[1:N,I]   AND
                IMAGINARY  PART VI[1:N,I] CORRESPONDS TO THE  EIGENVALUE
                VAL[I], I=1,...,N;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:5];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR ITERATION;
                       (E.G. THE MACHINE PRECISION);
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
                       (E.G. 10 * N);
                EXIT:
                EM[1]: AN ESTIMATE OF A NORM OF THE ORIGINAL MATRIX;
                EM[3]: THE  MAXIMUM   ABSOLUTE VALUE OF THE   CODIAGONAL
                       ELEMENTS NEGLECTED;
                EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
                       EM[5]:=EM[4]+1 IN THE CASE QRIHRM^=0;
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 8
 
 
 
 
     QRIHRM:=0, PROVIDED  THE   PROCESS   IS   COMPLETED   WITHIN  EM[4]
     ITERATIONS; OTHERWISE, QRIHRM:= THE  NUMBER OF EIGENVALUES, K, NOT
     CALCULATED AND ONLY THE LAST N-K ELEMENTS OF  VAL ARE APPROXIMATE
     EIGENVALUES AND THE COLUMNS OF THE ARRAYS VR,VI[1:N,N-K:N] ARE
     APPROXIMATE EIGENVECTORS OF THE ORIGINAL HERMITEAN MATRIX .
 
 
 PROCEDURES USED:
 
     HSHHRMTRI = CP34363,
     QRISYMTRI = CP34161,
     BAKHRMTRI = CP34365.
 
 
 REQUIRED CENTRAL MEMORY:
     TWO AUXILIARY ARRAYS OF ORDER N - 1 AND TWO OF ORDER N ARE DECLARED
 
 
 RUNNING TIME: PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 THE FOLLOWING HOLDS FOR THE FOUR PROCEDURES OF THIS SECTION:
 
 
 METHOD AND PERFORMANCE:
 
     FOR THE TRANSFORMATION OF THE GIVEN HERMITIAN MATRIX INTO A REAL
     SYMMETRIC TRIDIAGONAL MATRIX, AND FOR THE CORRESPONDING BACK
     TRANSFORMATION, PROCEDURES OF SECTION  3.2.1.2.2.1. ARE USED.
     FOR THE CALCULATION OF THE EIGENVALUES AND EIGENVECTORS OF THE
     RESULTING SYMMETRIC TRIDIAGONAL MATRIX, PROCEDURES OF SECTION
     3.3.1.1.1. ARE USED.
 
 
 EXAMPLE OF USE:
 
     QRIHRM CALCULATES THE EIGENVALUES AND EIGENVECTORS OF THE
     FOLLOWING MATRIX:
     (SEE GREGORY AND KARNEY, CHAPTER 6, EXAMPLE 6.6)
          3    1    0   +2I
          1    3   -2I   0
          0   +2I   1    1
         -2I   0    1    1
     THE EIGENVECTORS ARE NORMALIZED BY THE PROCEDURE SCLCOM (SEE
     SECTION 1.2.11. ).
     ONLY THE EIGENVECTORS CORRESPONDING TO VAL[2] AND VAL[3] ARE
     PRINTED BY THE FOLLOWING PROGRAM:
 
1SECTION 3.3.2.1              (JULY 1974)                         PAGE 9
 
 
 
     "BEGIN"
     "COMMENT" GREGORY AND KARNEY,CHAPTER 6, EXAMPLE 6.6;
     "REAL" "ARRAY" A,VR,VI[1:4,1:4],VAL[1:4],EM[0:5];"INTEGER" I;
     INIMAT(1,4,1,4,A,0);
     A[1,1]:=A[2,2]:=3;
     A[3,2]:=2;A[4,1]:=-2;
     A[1,2]:=A[3,3]:=A[3,4]:=A[4,4]:=1;
     EM[0]:=EM[2]:=5"-14;EM[4]:=20;
     OUTPUT(61,"(""("QRIHRM: ")",D/")",QRIHRM(A,4,VAL,VR,VI,EM));
     SCLCOM(VR,VI,4,2,3);
     OUTPUT(61,"(""("EIGENVALUES: ")"")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("/,"("VAL[")",D,"("]: ")",
                                     +D.3DBB")",I,VAL[I]);
     OUTPUT(61,"("/,"("EIGENVECTORS CORRESPONDING TO")",/,
                  "(" VAL[2] , VAL[3] ")",/")");
     "FOR" I:=1,2,3,4 "DO"
     OUTPUT(61,"("+D,+D,"("*I  ,  ")",+D,+D,"("*I")",/")",
               VR[I,2],VI[I,2],VR[I,3],VI[I,3]);
     "FOR" I:=1,3,5 "DO"
      OUTPUT(61,"("/,"("EM[")",D,"("]:  ")",+D.DDD"+DD")",I,EM[I])
     "END"
 
   OUTPUT:
     QRIHRM: 0
     EIGENVALUES:
     VAL[1]: +4.828
     VAL[2]: +4.000
     VAL[3]: -0.000
     VAL[4]: -0.828
     EIGENVECTORS CORRESPONDING TO
      VAL[2] , VAL[3]
     +1+0*I  ,  +0-1*I
     -1+0*I  ,  +0+1*I
     +0-1*I  ,  +1+0*I
     +0-1*I  ,  +1+0*I
 
     EM[1]:  +6.000"+00
     EM[3]:  +3.804"-22
     EM[5]:  +6.000"+00
 
 
 SOURCE TEXT(S) :
0"CODE" 34368;
     "PROCEDURE" EIGVALHRM(A, N, NUMVAL, VAL, EM); "VALUE" N, NUMVAL;
     "INTEGER" N, NUMVAL; "ARRAY" A, VAL, EM;
     "BEGIN" "ARRAY" D[1:N], BB[1:N - 1];
         HSHHRMTRIVAL(A, N, D, BB, EM);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
     "END" EIGVALHRM
1SECTION 3.3.2.1              (JULY 1974)                        PAGE 10
 
 
                                                                  ;
         "EOP"
0"CODE" 34369;
     "PROCEDURE" EIGHRM(A, N, NUMVAL, VAL, VECR, VECI, EM);
     "VALUE" N, NUMVAL; "INTEGER" N, NUMVAL;
     "ARRAY" A, VAL, VECR, VECI, EM;
     "BEGIN" "ARRAY" BB, TR, TI[1:N - 1], D, B[1:N];
         HSHHRMTRI(A, N, D, B, BB, EM, TR, TI);
         VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM); B[N]:= 0;
         VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VECR, EM);
         BAKHRMTRI(A, N, 1, NUMVAL, VECR, VECI, TR, TI)
     "END" EIGHRM;
         "EOP"
0"CODE" 34370;
     "INTEGER" "PROCEDURE" QRIVALHRM(A, N, VAL, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, VAL, EM;
     "BEGIN" "ARRAY" B,BB[1:N];
         "INTEGER" I;
         HSHHRMTRIVAL(A, N, VAL, BB, EM); B[N]:=BB[N]:= 0;
         "FOR" I:=1 "STEP" 1 "UNTIL" N-1 "DO" B[I]:=SQRT(BB[I]);
         QRIVALHRM:=QRIVALSYMTRI(VAL, BB, N, EM)
     "END" QRIVALHRM;
         "EOP"
0"CODE" 34371;
     "INTEGER" "PROCEDURE" QRIHRM(A, N, VAL, VR, VI, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, VAL, VR, VI, EM;
     "BEGIN" "INTEGER" I, J;
         "ARRAY" B, BB[1:N], TR, TI[1:N - 1];
         HSHHRMTRI(A, N, VAL, B, BB, EM, TR, TI);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" VR[I,I]:= 1;
             "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO" VR[I,J]:= VR[J,I]:=
             0
         "END";
         B[N]:= BB[N]:= 0;
         I:= QRIHRM:= QRISYMTRI(VR, N, VAL, B, BB, EM);
         BAKHRMTRI(A, N, I+1, N, VR, VI, TR, TI);
     "END" QRIHRM;
         "EOP"
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731016.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES VALQRICOM AND QRICOM.
     VALQRICOM CALCULATES THE EIGENVALUES OF A COMPLEX UPPER-HESSENBERG
     MATRIX WITH A REAL SUBDIAGONAL.
     QRICOM CALCULATES THE EIGENVECTORS AS WELL.
 
 
 KEYWORDS :
 
     EIGENVALUES,
     EIGENVECTORS,
     COMPLEX UPPER-HESSENBERG MATRIX,
     QR-ITERATION.
 
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: VALQRICOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "INTEGER" "PROCEDURE" VALQRICOM(A1, A2, B, N, EM, VAL1, VAL2);
     "VALUE" N; "INTEGER" N; "ARRAY" A1, A2, B, EM, VAL1, VAL2;
     "CODE" 34372;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A1,A2:     <ARRAY IDENTIFIER>;
                "ARRAY" A1,A2[1:N,1:N];
                ENTRY:
                THE REAL PART AND THE IMAGINARY PART OF THE UPPER
                TRIANGLE OF THE UPPER-HESSENBERG MATRIX MUST BE GIVEN IN
                THE CORRESPONDING PARTS OF THE ARRAYS A1 AND A2;
                THE ELEMENTS IN THE UPPER TRIANGLE OF THE ARRAYS A1 AND
                A2 ARE ALTERED;
     B:         <ARRAY IDENTIFIER>;
                "ARRAY" B[1:N-1];
                ENTRY:
                THE REAL SUBDIAGONAL OF THE UPPER-HESSENBERG MATRIX;
                THE ELEMENTS OF THE ARRAY B ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:5];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[1]: AN ESTIMATE OF THE NORM OF THE UPPER-HESSENBERG
                       MATRIX (E.G. THE SUM OF THE INFINITY NORMS OF THE
                       REAL AND IMAGINARY PARTS OF THE MATRIX);
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR-ITERATION;
                       (E.G. THE MACHINE PRECISION);
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
                       (E.G. 10 * N);
                EXIT:
                EM[3]: THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                       ELEMENTS NEGLECTED;
                EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
                       EM[5]:=EM[4]+1 IN THE CASE VALQRICOM^=0;
     VAL1,VAL2: <ARRAY IDENTIFIER>;
                "ARRAY" VAL1,VAL2[1:N];
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE CALCULATED
                EIGENVALUES ARE DELIVERED IN THE ARRAYS VAL1 AND VAL2,
                RESPECTIVELY;
 
     VALQRICOM:=0, PROVIDED THE PROCESS IS COMPLETED WITHIN EM[4]
     ITERATIONS; OTHERWISE, VALQRICOM:= THE NUMBER, K, OF EIGENVALUES
     NOT CALCULATED AND ONLY THE LAST N-K ELEMENTS OF THE ARRAYS VAL1
     AND VAL2 ARE APPROXIMATE EIGENVALUES OF THE UPPER-HESSENBERG
     MATRIX.
 
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 3
 
 
 
 PROCEDURES USED:
 
     COMKWD    = CP34345,
     ROTCOMROW = CP34358,
     ROTCOMCOL = CP34357,
     COMCOLCST = CP34352.
 
 RUNNING TIME: PROPORTIONAL TO N**2 * NUMBER OF ITERATIONS.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE: SEE QRICOM (THIS SECTION).
 
 EXAMPLE OF USE:
 
     AS A FORMAL TEST OF THE PROCEDURE VALQRICOM THE ZEROS OF THE
     POLYNOMIAL  X**4 + (4+2*I)* X**3 + (5+6*I)* X**2 + (2+6*I)* X + 2*I
     ARE OBTAINED BY MEANS OF THE CALCULATION OF THE EIGENVALUES OF THE
     FOLLOWING COMPANION MATRIX:
     (SEE WILKINSON AND REINSCH, 1971, CONTRIBUTION II/15)
     -4-2*I  -5-6*I  -2-6*I    -2*I
       1       0       0       0
       0       1       0       0
       0       0       1       0
 
     "BEGIN"
     "REAL" "ARRAY" A1,A2[1:4,1:4],B[1:3],EM[0:5],VAL1,VAL2[1:4];
     "INTEGER" I;
     INIMAT(1,4,1,4,A1,0);INIMAT(1,4,1,4,A2,0);
     A1[1,1]:=-4;A1[1,2]:=-5;A1[1,3]:=A2[1,1]:=A2[1,4]:=-2;
     A2[1,2]:=A2[1,3]:=-6;
     B[1]:=B[2]:=B[3]:=1;
     EM[0]:=5"-14;EM[1]:=27;EM[2]:="-12;EM[4]:=15;
     OUTPUT(61,"(""("VALQRICOM: ")",D/")",
            VALQRICOM(A1,A2,B,4,EM,VAL1,VAL2));
     OUTPUT(61,"(""("EIGENVALUES:")",/,"("REAL PART")",14B,
                  "("IMAGINARY PART")",/")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("N,N/")",VAL1[I],VAL2[I]);
     OUTPUT(61,"(""("EM[3]: ")",D.D"+DD/,"("EM[5]: ")",3D")",
                     EM[3],EM[5])
     "END"
 
   OUTPUT:
     VALQRICOM: 0
     EIGENVALUES:
     REAL PART              IMAGINARY PART
     -1.0000001920467"+000  -1.0000000831019"+000
     -9.9999980795324"-001  -9.9999991689805"-001
     -1.0000000047492"+000  +1.6824958523393"-007
     -9.9999999525076"-001  -1.6824956397352"-007
     EM[3]: 3.2"-14
     EM[5]: 010
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 4
 
 
 
 SUBSECTION: QRICOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "INTEGER" "PROCEDURE" QRICOM(A1,A2,B,N,EM,VAL1,VAL2,VEC1,VEC2);
     "VALUE" N; "INTEGER" N;
     "ARRAY" A1, A2, B, EM, VAL1, VAL2, VEC1, VEC2;
     "CODE" 34373;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A1,A2:     <ARRAY IDENTIFIER>;
                "ARRAY" A1,A2[1:N,1:N];
                ENTRY:
                THE REAL PART AND THE IMAGINARY PART OF THE UPPER
                TRIANGLE OF THE UPPER-HESSENBERG MATRIX MUST BE GIVEN IN
                THE CORRESPONDING PARTS OF THE ARRAYS A1 AND A2;
                THE ELEMENTS IN THE UPPER TRIANGLE OF THE ARRAYS A1 AND
                A2 ARE ALTERED;
     B:         <ARRAY IDENTIFIER>;
                "ARRAY" B[1:N-1];
                ENTRY:
                THE REAL SUBDIAGONAL OF THE UPPER-HESSENBERG MATRIX;
                THE ELEMENTS OF THE ARRAY B ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:5];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[1]: AN ESTIMATE OF THE NORM OF THE UPPER-HESSENBERG
                       MATRIX (E.G. THE SUM OF THE INFINITY NORMS OF THE
                       REAL AND IMAGINARY PARTS OF THE MATRIX);
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR-ITERATION;
                       (E.G. THE MACHINE PRECISION);
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
                       (E.G. 10 * N);
                EXIT:
                EM[3]: THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                       ELEMENTS NEGLECTED;
                EM[5] THE NUMBER OF ITERATIONS PERFORMED;
                       EM[5]:=EM[4]+1 IN THE CASE QRICOM^=0;
     VAL1,VAL2: <ARRAY IDENTIFIER>;
                "ARRAY" VAL1,VAL2[1:N];
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE CALCULATED
                EIGENVALUES ARE DELIVERED IN THE ARRAYS VAL1 AND VAL2,
                RESPECTIVELY;
     VEC1,VEC2: <ARRAY IDENTIFIER>;
                "ARRAY" VEC1,VEC2[1:N,1:N];
                EXIT:
                THE EIGENVECTORS OF THE UPPER-HESSENBERG MATRIX;
                THE EIGENVECTOR WITH REAL PART VEC1[1:N,J] AND IMAGINARY
                PART VEC2[1:N,J] CORRESPONDS TO THE EIGENVALUE
                VAL1[J] + VAL2[J] * I, J=1,...,N;
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 5
 
 
 
     QRICOM:=0, PROVIDED THE PROCESS IS COMPLETED WITHIN EM[4]
     ITERATIONS; OTHERWISE, QRICOM:= THE NUMBER, K, OF EIGENVALUES NOT
     CALCULATED AND ONLY THE LAST N-K ELEMENTS OF THE ARRAYS VAL1 AND
     VAL2 ARE APPROXIMATE EIGENVALUES OF THE UPPER-HESSENBERG MATRIX,
     AND NO USEFUL EIGENVECTORS ARE DELIVERED.
 
 
 PROCEDURES USED:
 
     COMKWD    = CP34345,
     ROTCOMROW = CP34358,
     ROTCOMCOL = CP34357,
     COMCOLCST = CP34352,
     COMROWCST = CP34353,
     MATVEC    = CP34011,
     COMMATVEC = CP34354,
     COMDIV    = CP34342.
 
 
 REQUIRED CENTRAL MEMORY: TWO AUXILIARY ARRAYS OF ORDER N ARE DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N**2 * NUMBER OF ITERATIONS.
 
 
 LANGUAGE: ALGOL 60.
 
 
 THE FOLLOWING HOLDS FOR BOTH PROCEDURES:
 
 
 METHOD AND PERFORMANCE:
 
     THE UPPER-HESSENBERG MATRIX IS TRANSFORMED BY MEANS OF FRANCIS' QR
     ITERATION ( FRANCIS, 1961, AND WILKINSON, 1965 ) INTO A COMPLEX
     UPPER TRIANGULAR MATRIX. THE EIGENVALUES ARE THE DIAGONAL ELEMENTS
     OF THE LATTER MATRIX. TO CALCULATE THE EIGENVECTORS WE FIRST SOLVE
     THE RESULTING TRIANGULAR SYSTEM OF LINEAR EQUATIONS AND
     SUBSEQUENTLY PERFORM THE CORRESPONDING BACKTRANSFORMATION.
 
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     QRICOM CALCULATES THE EIGENVALUES AND EIGENVECTORS OF THE
     FOLLOWING MATRIX:
     (SEE WILKINSON AND REINSCH, 1971, CONTRIBUTION II/15)
     -4-2*I  -5-6*I  -2-6*I    -2*I
       1       0       0       0
       0       1       0       0
       0       0       1       0
 
     THE EIGENVECTORS ARE NORMALIZED BY THE PROCEDURE SCLCOM.
     (SEE SECTION 1.2.11.).
     ONLY THE EIGENVECTOR CORRESPONDING TO VAL1[1] + VAL2[1] * I IS
     PRINTED BY THE FOLLOWING PROGRAM.
 
     "BEGIN"
     "REAL" "ARRAY" A1,A2,VEC1,VEC2[1:4,1:4],B[1:3],
                    EM[0:5],VAL1,VAL2[1:4];
     "INTEGER" I;
     INIMAT(1,4,1,4,A1,0);INIMAT(1,4,1,4,A2,0);
     A1[1,1]:=-4;A1[1,2]:=-5;A1[1,3]:=A2[1,1]:=A2[1,4]:=-2;
     A2[1,2]:=A2[1,3]:=-6;
     B[1]:=B[2]:=B[3]:=1;
     EM[0]:=5"-14;EM[1]:=27;EM[2]:="-12;EM[4]:=15;
     OUTPUT(61,"(""("QRICOM: ")",D/")",
         QRICOM(A1,A2,B,4,EM,VAL1,VAL2,VEC1,VEC2));
     OUTPUT(61,"(""("EIGENVALUES:")",/,"("REAL PART")",14B,
                  "("IMAGINARY PART")",/")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("N,N/")",VAL1[I],VAL2[I]);
     SCLCOM(VEC1,VEC2,4,1,4);
     OUTPUT(61,"(""("FIRST EIGENVECTOR:")",/,"("REAL PART")",14B,
                  "("IMAGINARY PART")",/")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("N,N/")",VEC1[I,1],VEC2[I,1]);
     OUTPUT(61,"(""("EM[3]: ")",D.D"+DD/,"("EM[5]: ")",3D")",
                     EM[3],EM[5])
     "END"
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 7
 
 
 
 
     OUTPUT:
 
     QRICOM: 0
     EIGENVALUES:
     REAL PART              IMAGINARY PART
     -9.9999980795324"-001  -9.9999991689805"-001
     -1.0000001920467"+000  -1.0000000831019"+000
     -1.0000000047492"+000  +1.6824958523393"-007
     -9.9999999525076"-001  -1.6824956397352"-007
     FIRST EIGENVECTOR:
     REAL PART              IMAGINARY PART
     +1.0000000000000"+000  -1.7763568394003"-015
     -5.0000004155098"-001  +5.0000009602339"-001
     -5.4472417687634"-008  -5.0000013757436"-001
     +2.5000014403510"-001  +2.5000006232645"-001
     EM[3]: 3.2"-14
     EM[5]: 010
 
 
 REFERENCES:
 
     DEKKER, T.J. (1968),
     ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
     MATH. CENTRE TRACTS 22, MATHEMATISCH CENTRUM;
 
     DEKKER, T.J. AND W.HOFFMANN (1968),
     ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
     MATH. CENTRE TRACTS 23, MATHEMATISCH CENTRUM;
 
     FRANCIS, J.G.F. (1961),
     THE QR-TRANSFORMATION, PART 1 AND 2,
     COMP.J. 4, P.265-271 AND P.332-345;
 
     RUHE, A. (1966),
     EIGENVALUES OF A COMPLEX MATRIX BY THE QR METHOD.
     BIT, 6, P.350-358;
 
     WILKINSON, J.H. (1965),
     THE ALGEBRAIC EIGENVALUE PROBLEM,
     CLARENDOM PRESS, OXFORD;
 
 
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 8
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34372;
     "INTEGER" "PROCEDURE" VALQRICOM(A1, A2, B, N, EM, VAL1, VAL2);
     "VALUE" N; "INTEGER" N; "ARRAY" A1, A2, B, EM, VAL1, VAL2;
     "BEGIN" "INTEGER" M, NM1, I, I1, Q, Q1, MAX, COUNT;
         "REAL" R, Z1, Z2, DD1, DD2, CC, G1, G2, K1, K2, HC, A1NN,
         A2NN, AIJ1, AIJ2, AI1I, KAPPA, NUI, MUI1, MUI2,
         MUIM11, MUIM12, NUIM1, TOL;
         TOL:= EM[1] * EM[2]; MAX:= EM[4]; COUNT:= 0; R:= 0;
         M:= N; "IF" N > 1 "THEN" HC:= B[N - 1];
     IN: NM1:= N - 1;
         "FOR" I:= N, I - 1 "WHILE" ("IF" I >= 1 "THEN" ABS(B[I]) > TOL
         "ELSE" "FALSE") "DO" Q:= I; "IF" Q > 1 "THEN"
         "BEGIN" "IF" ABS(B[Q - 1]) > R "THEN" R:= ABS(B[Q - 1]) "END";
         "IF" Q = N "THEN"
         "BEGIN" VAL1[N]:= A1[N,N]; VAL2[N]:= A2[N,N]; N:= NM1;
             "IF" N > 1 "THEN" HC:= B[N - 1];
         "END"
         "ELSE"
         "BEGIN" DD1:= A1[N,N]; DD2:= A2[N,N]; CC:= B[NM1];
             COMKWD((A1[NM1,NM1] - DD1) / 2, (A2[NM1,NM1] - DD2)
             / 2, CC * A1[NM1,N], CC * A2[NM1,N], G1, G2, K1,
             K2); "IF" Q = NM1 "THEN"
             "BEGIN" VAL1[NM1]:= G1 + DD1; VAL2[NM1]:= G2 + DD2;
                 VAL1[N]:= K1 + DD1; VAL2[N]:= K2 + DD2;
                 N:= N - 2; "IF" N > 1 "THEN" HC:= B[N - 1];
             "END"
             "ELSE"
             "BEGIN" COUNT:= COUNT + 1;
                 "IF" COUNT > MAX "THEN" "GOTO" OUT; Z1:= K1 + DD1;
                 Z2:= K2 + DD2;
                 "IF" ABS(CC) > ABS(HC) "THEN" Z1:= Z1 + ABS(CC);
                 HC:= CC / 2; I:= Q1:= Q + 1;
                 AIJ1:= A1[Q,Q] - Z1; AIJ2:= A2[Q,Q] - Z2;
                 AI1I:= B[Q];
                 KAPPA:= SQRT(AIJ1 ** 2 + AIJ2 ** 2 + AI1I ** 2);
                 MUI1:= AIJ1 / KAPPA; MUI2:= AIJ2 / KAPPA;
                 NUI:= AI1I / KAPPA; A1[Q,Q]:= KAPPA;
                 A2[Q,Q]:= 0; A1[Q1,Q1]:= A1[Q1,Q1] - Z1;
                 A2[Q1,Q1]:= A2[Q1,Q1] - Z2;
                 ROTCOMROW(Q1, N, Q, Q1, A1, A2, MUI1, MUI2,
                 NUI);
                 ROTCOMCOL(Q, Q, Q, Q1, A1, A2, MUI1, - MUI2, -
                 NUI); A1[Q,Q]:= A1[Q,Q] + Z1;
                 A2[Q,Q]:= A2[Q,Q] + Z2;"COMMENT"
1SECTION 3.3.2.2.1            (JULY 1974)                         PAGE 9
                                                                  ;
 
 
                 "FOR" I1:= Q1 + 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" AIJ1:= A1[I,I]; AIJ2:= A2[I,I];
                     AI1I:= B[I];
                     KAPPA:= SQRT(AIJ1 ** 2 + AIJ2 ** 2 + AI1I **
                     2); MUIM11:= MUI1; MUIM12:= MUI2;
                     NUIM1:= NUI; MUI1:= AIJ1 / KAPPA;
                     MUI2:= AIJ2 / KAPPA; NUI:= AI1I / KAPPA;
                     A1[I1,I1]:= A1[I1,I1] - Z1;
                     A2[I1,I1]:= A2[I1,I1] - Z2;
                     ROTCOMROW(I1, N, I, I1, A1, A2, MUI1,
                     MUI2, NUI); A1[I,I]:= MUIM11 * KAPPA;
                     A2[I,I]:= - MUIM12 * KAPPA;
                     B[I - 1]:= NUIM1 * KAPPA;
 
                     ROTCOMCOL(Q, I, I, I1, A1, A2, MUI1, -
                     MUI2, - NUI); A1[I,I]:= A1[I,I] + Z1;
                     A2[I,I]:= A2[I,I] + Z2; I:= I1;
                 "END";
                 AIJ1:= A1[N,N]; AIJ2:= A2[N,N];
                 KAPPA:= SQRT(AIJ1 ** 2 + AIJ2 ** 2);
                 "IF" ("IF" KAPPA < TOL "THEN" "TRUE" "ELSE" AIJ2 ** 2
                 <= EM[0] * AIJ1 ** 2) "THEN"
                 "BEGIN" B[NM1]:= NUI * AIJ1;
                     A1[N,N]:= AIJ1 * MUI1 + Z1;
                     A2[N,N]:= - AIJ1 * MUI2 + Z2
                 "END"
                 "ELSE"
                 "BEGIN" B[NM1]:= NUI * KAPPA; A1NN:= MUI1 * KAPPA;
                     A2NN:= - MUI2 * KAPPA; MUI1:= AIJ1 / KAPPA;
                     MUI2:= AIJ2 / KAPPA;
                     COMCOLCST(Q, NM1, N, A1, A2, MUI1, MUI2);
                     A1[N,N]:= MUI1 * A1NN - MUI2 * A2NN + Z1;
                     A2[N,N]:= MUI1 * A2NN + MUI2 * A1NN + Z2;
                 "END";
             "END"
         "END";
         "IF" N > 0 "THEN" "GOTO" IN;
     OUT: EM[3]:= R; EM[5]:= COUNT; VALQRICOM:= N;
     "END" VALQRICOM;
         "EOP"
0"CODE" 34373;
     "INTEGER" "PROCEDURE" QRICOM(A1, A2, B, N, EM, VAL1, VAL2, VEC1,
     VEC2); "VALUE" N; "INTEGER" N;
     "ARRAY" A1, A2, B, EM, VAL1, VAL2, VEC1, VEC2;
     "BEGIN" "INTEGER" M, NM1, I, I1, J, Q, Q1, MAX, COUNT;
         "REAL" R, Z1, Z2, DD1, DD2, CC, P1, P2, T1, T2, DELTA1,
         DELTA2, MV1, MV2, H, H1, H2, G1, G2, K1, K2, HC,
         AIJ12, AIJ22, A1NN, A2NN, AIJ1, AIJ2, AI1I, KAPPA,
         NUI, MUI1, MUI2, MUIM11, MUIM12, NUIM1, TOL, MACHTOL;
         "ARRAY" TF1, TF2[1:N];"COMMENT"
1SECTION 3.3.2.2.1            (JULY 1974)                        PAGE 10
                                                                 ;
 
 
         TOL:= EM[1] * EM[2]; MACHTOL:= EM[0] * EM[1];
         MAX:= EM[4]; COUNT:= 0; R:= 0; M:= N;
         "IF" N > 1 "THEN" HC:= B[N - 1];
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" VEC1[I,I]:= 1; VEC2[I,I]:= 0;
             "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO" VEC1[I,J]:=
             VEC1[J,I]:= VEC2[I,J]:= VEC2[J,I]:= 0
         "END";
     IN: NM1:= N - 1;
         "FOR" I:= N, I - 1 "WHILE" ("IF" I >= 1 "THEN" ABS(B[I]) > TOL
         "ELSE" "FALSE") "DO" Q:= I; "IF" Q > 1 "THEN"
         "BEGIN" "IF" ABS(B[Q - 1]) > R "THEN" R:= ABS(B[Q - 1]) "END";
         "IF" Q = N "THEN"
         "BEGIN" VAL1[N]:= A1[N,N]; VAL2[N]:= A2[N,N]; N:= NM1;
             "IF" N > 1 "THEN" HC:= B[N - 1];
         "END"
         "ELSE"
         "BEGIN" DD1:= A1[N,N]; DD2:= A2[N,N]; CC:= B[NM1];
             P1:= (A1[NM1,NM1] - DD1) * .5;
             P2:= (A2[NM1,NM1] - DD2) * .5;
             COMKWD(P1, P2, CC * A1[NM1,N], CC * A2[NM1,N], G1,
             G2, K1, K2); "IF" Q = NM1 "THEN"
             "BEGIN" A1[N,N]:= VAL1[N]:= G1 + DD1;
                 A2[N,N]:= VAL2[N]:= G2 + DD2;
                 A1[Q,Q]:= VAL1[Q]:= K1 + DD1;
                 A2[Q,Q]:= VAL2[Q]:= K2 + DD2;
                 KAPPA:= SQRT(K1 ** 2 + K2 ** 2 + CC ** 2);
                 NUI:= CC / KAPPA; MUI1:= K1 / KAPPA;
                 MUI2:= K2 / KAPPA; AIJ1:= A1[Q,N];
                 AIJ2:= A2[Q,N]; H1:= MUI1 ** 2 - MUI2 ** 2;
                 H2:= 2 * MUI1 * MUI2; H:= - NUI * 2;
                 A1[Q,N]:= H * (P1 * MUI1 + P2 * MUI2) - NUI *
                 NUI * CC + AIJ1 * H1 + AIJ2 * H2;
                 A2[Q,N]:= H * (P2 * MUI1 - P1 * MUI2) + AIJ2 *
                 H1 - AIJ1 * H2;
                 ROTCOMROW(Q + 2, M, Q, N, A1, A2, MUI1, MUI2,
                 NUI);
                 ROTCOMCOL(1, Q - 1, Q, N, A1, A2, MUI1, -
                 MUI2, - NUI);
                 ROTCOMCOL(1, M, Q, N, VEC1, VEC2, MUI1, -
                 MUI2, - NUI); N:= N - 2;
                 "IF" N > 1 "THEN" HC:= B[N - 1]; B[Q]:= 0
             "END"
1SECTION 3.3.2.2.1            (JULY 1974)                        PAGE 11
 
 
 
             "ELSE"
             "BEGIN" COUNT:= COUNT + 1;
                 "IF" COUNT > MAX "THEN" "GOTO" OUT; Z1:= K1 + DD1;
                 Z2:= K2 + DD2;
                 "IF" ABS(CC) > ABS(HC) "THEN" Z1:= Z1 + ABS(CC);
                 HC:= CC / 2; Q1:= Q + 1; AIJ1:= A1[Q,Q] - Z1;
                 AIJ2:= A2[Q,Q] - Z2; AI1I:= B[Q];
                 KAPPA:= SQRT(AIJ1 ** 2 + AIJ2 ** 2 + AI1I ** 2);
                 MUI1:= AIJ1 / KAPPA; MUI2:= AIJ2 / KAPPA;
                 NUI:= AI1I / KAPPA; A1[Q,Q]:= KAPPA;
                 A2[Q,Q]:= 0; A1[Q1,Q1]:= A1[Q1,Q1] - Z1;
                 A2[Q1,Q1]:= A2[Q1,Q1] - Z2;
                 ROTCOMROW(Q1, M, Q, Q1, A1, A2, MUI1, MUI2,
                 NUI);
                 ROTCOMCOL(1, Q, Q, Q1, A1, A2, MUI1, - MUI2, -
                 NUI); A1[Q,Q]:= A1[Q,Q] + Z1;
                 A2[Q,Q]:= A2[Q,Q] + Z2;
                 ROTCOMCOL(1, M, Q, Q1, VEC1, VEC2, MUI1, -
                 MUI2, - NUI);
                 "FOR" I:= Q1 "STEP" 1 "UNTIL" NM1 "DO"
                 "BEGIN" I1:= I + 1; AIJ1:= A1[I,I]; AIJ2:= A2[I,I];
                     AI1I:= B[I];
                     KAPPA:= SQRT(AIJ1 ** 2 + AIJ2 ** 2 + AI1I **
                     2); MUIM11:= MUI1; MUIM12:= MUI2;
                     NUIM1:= NUI; MUI1:= AIJ1 / KAPPA;
                     MUI2:= AIJ2 / KAPPA; NUI:= AI1I / KAPPA;
                     A1[I1,I1]:= A1[I1,I1] - Z1;
                     A2[I1,I1]:= A2[I1,I1] - Z2;
                     ROTCOMROW(I1, M, I, I1, A1, A2, MUI1,
                     MUI2, NUI); A1[I,I]:= MUIM11 * KAPPA;
                     A2[I,I]:= - MUIM12 * KAPPA;
                     B[I - 1]:= NUIM1 * KAPPA;
                     ROTCOMCOL(1, I, I, I1, A1, A2, MUI1, -
                     MUI2, - NUI); A1[I,I]:= A1[I,I] + Z1;
                     A2[I,I]:= A2[I,I] + Z2;
                     ROTCOMCOL(1, M, I, I1, VEC1, VEC2, MUI1, -
                     MUI2, - NUI);
                 "END";                                      "COMMENT"
1SECTION 3.3.2.2.1            (JULY 1974)                        PAGE 12
                                                                 ;
 
 
                 AIJ1:= A1[N,N]; AIJ2:= A2[N,N]; AIJ12:= AIJ1 ** 2;
                 AIJ22:= AIJ2 ** 2; KAPPA:= SQRT(AIJ12 + AIJ22);
                 "IF" ("IF" KAPPA < TOL "THEN" "TRUE" "ELSE" AIJ22 <=
                 EM[0] * AIJ12) "THEN"
                 "BEGIN" B[NM1]:= NUI * AIJ1;
                     A1[N,N]:= AIJ1 * MUI1 + Z1;
                     A2[N,N]:= - AIJ1 * MUI2 + Z2
                 "END"
                 "ELSE"
                 "BEGIN" B[NM1]:= NUI * KAPPA; A1NN:= MUI1 * KAPPA;
                     A2NN:= - MUI2 * KAPPA; MUI1:= AIJ1 / KAPPA;
                     MUI2:= AIJ2 / KAPPA;
                     COMCOLCST(1, NM1, N, A1, A2, MUI1, MUI2);
                     COMCOLCST(1, NM1, N, VEC1, VEC2, MUI1,
                     MUI2);
                     COMROWCST(N + 1, M, N, A1, A2, MUI1, -
                     MUI2);
                     COMCOLCST(N, M, N, VEC1, VEC2, MUI1, MUI2);
                     A1[N,N]:= MUI1 * A1NN - MUI2 * A2NN + Z1;
                     A2[N,N]:= MUI1 * A2NN + MUI2 * A1NN + Z2;
                 "END";
             "END";
         "END";
         "IF" N > 0 "THEN" "GOTO" IN;
         "FOR" J:= M "STEP" - 1 "UNTIL" 2 "DO"
         "BEGIN" TF1[J]:= 1; TF2[J]:= 0; T1:= A1[J,J]; T2:= A2[J,J];
             "FOR" I:= J - 1 "STEP" - 1 "UNTIL" 1 "DO"
             "BEGIN" DELTA1:= T1 - A1[I,I]; DELTA2:= T2 - A2[I,I];
                 COMMATVEC(I + 1, J, I, A1, A2, TF1, TF2, MV1,
                 MV2);
                 "IF" ABS(DELTA1) < MACHTOL "AND" ABS(DELTA2) <
                 MACHTOL "THEN"
                 "BEGIN" TF1[I]:= MV1 / MACHTOL;
                     TF2[I]:= MV2 / MACHTOL
                 "END"
                 "ELSE" COMDIV(MV1, MV2, DELTA1, DELTA2, TF1[I],
                 TF2[I]);
             "END";
             "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO" COMMATVEC(1, J, I,
             VEC1, VEC2, TF1, TF2, VEC1[I,J], VEC2[I,J]);
         "END";
     OUT: EM[3]:= R; EM[5]:= COUNT; QRICOM:= N;
     "END" QRICOM;
         "EOP"
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731016.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES EIGVALCOM AND EIGCOM.
     EIGVALCOM CALCULATES THE EIGENVALUES OF A COMPLEX MATRIX AND
     EIGCOM CALCULATES THE EIGENVECTORS AS WELL.
 
 
 KEYWORDS :
 
     EIGENVALUES,
     EIGENVECTORS,
     COMPLEX MATRICES,
     EQUILIBRATION,
     REDUCTION HESSENBERG FORM,
     HOUSEHOLDER TRANSFORMATION,
     QR-ITERATION.
 
 
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 2
 
 
 
 SUBSECTION: EIGVALCOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "INTEGER" "PROCEDURE" EIGVALCOM(AR, AI, N, EM, VALR, VALI);
     "VALUE" N; "INTEGER" N; "ARRAY" AR, AI, EM, VALR, VALI;
     "CODE" 34374;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[1:N,1:N];
                ENTRY:
                THE REAL PART AND THE IMAGINARY PART OF THE MATRIX MUST
                BE GIVEN IN THE ARRAYS AR AND AI, RESPECTIVELY;
                THE ELEMENTS OF THE ARRAYS AR AND AI ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:7];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR-ITERATION;
                       (E.G. THE MACHINE PRECISION);
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF QR-ITERATIONS;
                       (E.G. 10 * N);
                EM[6]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS FOR
                       EQUILIBRATING THE ORIGINAL MATRIX (E.G. N**2/2);
                EXIT:
                EM[1]: THE EUCLIDEAN NORM OF THE EQUILIBRATED MATRIX;
                EM[3]: THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                       ELEMENTS NEGLECTED IN THE QR-ITERATION;
                EM[5]: THE NUMBER OF QR-ITERATIONS PERFORMED;
                       EM[5]:=EM[4]+1 IN THE CASE EIGVALCOM^=0;
                EM[7]: THE NUMBER OF ITERATIONS PERFORMED FOR
                       EQUILIBRATING THE ORIGINAL MATRIX;
     VALR,VALI: <ARRAY IDENTIFIER>;
                "ARRAY" VALR,VALI[1:N];
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE CALCULATED
                EIGENVALUES ARE DELIVERED IN THE ARRAYS VALR AND VALI,
                RESPECTIVELY;
 
     EIGVALCOM:=0, PROVIDED THE QR-ITERATION IS COMPLETED WITHIN EM[4]
     ITERATIONS; OTHERWISE, EIGVALCOM:= THE NUMBER, K, OF EIGENVALUES
     NOT CALCULATED AND ONLY THE LAST N-K ELEMENTS OF THE ARRAYS VALR
     AND VALI ARE APPROXIMATE EIGENVALUES OF THE ORIGINAL MATRIX.
 
 PROCEDURES USED:
 
     EQILBRCOM = CP34361,
     COMEUCNRM = CP34359,
     HSHCOMHES = CP34366,
     VALQRICOM = CP34372.
 
 
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 3
 
 
 
 REQUIRED CENTRAL MEMORY: FIVE  REAL ARRAYS OF ORDER N AND ONE INTEGER
     ARRAY OF ORDER N ARE DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 2 * MAX(N,NUMBER OF ITERATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE EIGCOM (THIS SECTION).
 
 
 EXAMPLE OF USE: SEE EIGCOM (THIS SECTION).
 
 
 SUBSECTION: EIGCOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "INTEGER" "PROCEDURE" EIGCOM(AR, AI, N, EM, VALR, VALI, VR, VI);
     "VALUE" N; "INTEGER" N; "ARRAY" AR, AI, EM, VALR, VALI, VR, VI;
     "CODE" 34375;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[1:N,1:N];
                ENTRY:
                THE REAL PART AND THE IMAGINARY PART OF THE MATRIX MUST
                BE GIVEN IN THE ARRAYS AR AND AI, RESPECTIVELY;
                THE ELEMENTS OF THE ARRAYS AR AND AI ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY" EM[0:7];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[2]: THE RELATIVE TOLERANCE FOR THE QR-ITERATION;
                       (E.G. THE MACHINE PRECISION);
                EM[4]: THE MAXIMUM ALLOWED NUMBER OF QR-ITERATIONS;
                       (E.G. 10 * N);
                EM[6]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS FOR
                       EQUILIBRATING THE ORIGINAL MATRIX (E.G. N**2/2);
                EXIT:
                EM[1]: THE EUCLIDEAN NORM OF THE EQUILIBRATED MATRIX;
                EM[3]: THE MAXIMUM ABSOLUTE VALUE OF THE SUBDIAGONAL
                       ELEMENTS NEGLECTED IN THE QR-ITERATION;
                EM[5]: THE NUMBER OF QR-ITERATIONS PERFORMED;
                       EM[5]:=EM[4]+1 IN THE CASE EIGCOM^=0;
                EM[7]: THE NUMBER OF ITERATIONS PERFORMED FOR
                       EQUILIBRATING THE ORIGINAL MATRIX;
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 4
 
 
 
     VALR,VALI: <ARRAY IDENTIFIER>;
                "ARRAY" VALR,VALI[1:N];
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE CALCULATED
                EIGENVALUES ARE DELIVERED IN THE ARRAYS VALR AND VALI,
                RESPECTIVELY;
     VR,VI:     <ARRAY IDENTIFIER>;
                "ARRAY" VR,VI[1:N,1:N];
                EXIT:
                THE EIGENVECTORS OF THE MATRIX;
                THE NORMALIZED EIGENVECTOR WITH REAL PART VR[1:N,J] AND
                IMAGINARY PART VI[1:N,J] CORRESPONDS TO THE EIGENVALUE
                VALR[J] + VALI[J] * I, J=1,...,N;
 
     EIGCOM:=0, PROVIDED THE QR-ITERATION IS COMPLETED WITHIN EM[4]
     ITERATIONS; OTHERWISE, EIGCOM:= THE NUMBER, K, OF EIGENVALUES
     NOT CALCULATED AND ONLY THE LAST N-K ELEMENTS OF THE ARRAYS VALR
     AND VALI ARE APPROXIMATE EIGENVALUES OF THE ORIGINAL MATRIX AND NO
     USEFUL EIGENVECTORS ARE DELIVERED.
 
 
 PROCEDURES USED:
 
     EQILBRCOM = CP34361,
     COMEUCNRM = CP34359,
     HSHCOMHES = CP34366,
     QRICOM    = CP34373,
     BAKCOMHES = CP34367,
     BAKLBRCOM = CP34362,
     SCLCOM    = CP34360.
 
 
 REQUIRED CENTRAL MEMORY: FIVE  REAL ARRAYS OF ORDER N AND ONE INTEGER
     ARRAY OF ORDER N ARE DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N**2 * MAX(N, NUMBER OF ITERATIONS).
 
 
 LANGUAGE : ALGOL 60.
 
 
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 5
 
 
 
 THE FOLLOWING HOLDS FOR BOTH PROCEDURES:
 
 
 METHOD AND PERFORMANCE:
 
     FOR CALCULATING THE EIGENVALUES AND EIGENVECTORS OF A COMPLEX
     MATRIX WE DISTINGUISH THE FOLLOWING STEPS:
     1) THE MATRIX IS EQUILIBRATED (SEE ALSO SECTION 3.2.1.1.2.).
     2) THE EQUILIBRATED MATRIX IS TRANSFORMED INTO HESSENBERG FORM BY
        MEANS OF HOUSEHOLDER MATRICES (SEE ALSO SECTION 3.2.1.2.2.2.).
     3) THE HESSENBERG MATRIX IS TRANSFORMED INTO AN UPPER TRIANGULAR
        MATRIX BY MEANS OF QR-ITERATION WITH SHIFT OF ORIGIN AND
        DEFLATION (SEE ALSO SECTION 3.3.2.2.1.).
     THE DIAGONAL ELEMENTS OF THE UPPER TRIANGULAR MATRIX ARE THE
     EIGENVALUES OF THE ORIGINAL MATRIX.
     THE EIGENVECTORS OF THE ORIGINAL MATRIX ARE OBTAINED BY CALCULATING
     THE EIGENVECTORS OF THE UPPER TRIANGULAR MATRIX (3) FOLLOWED BY
     BACKTRANSFORMATIONS CORRESPONDING TO (2) AND (1).
 
 
 REFERENCES:
 
     DEKKER, T.J. (1968),
     ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
     MATH. CENTRE TRACTS 22, MATHEMATISCH CENTRUM;
 
     DEKKER, T.J. AND W.HOFFMANN (1968),
     ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
     MATH. CENTRE TRACTS 23, MATHEMATISCH CENTRUM;
 
     FRANCIS, J.G.F. (1961),
     THE QR-TRANSFORMATION, PART 1 AND 2,
     COMP.J. 4, P.265-271 AND P.332-345;
 
     MUELLER, D.J. (1966),
     HOUSEHOLDER,S METHOD  FOR  COMPLEX MATRICES AND EIGENSYSTEMS   OF
     HERMITIAN MATRICES,
     NUMER.MATH., 8, P.72-92;
 
     OSBORNE, E.E. (1960),
     ON PRECONDITIONING OF MATRICES,
     JACM., 7, P.338-354;
 
     PARLETT, B.N. AND C.REINSCH (1969),
     BALANCING A MATRIX FOR CALCULATION OF EIGENVALUES AND
     EIGENVECTORS,
     NUM. MATH., 13, P.293-304;
 
     WILKINSON, J.H. (1965),
     THE ALGEBRAIC EIGENVALUE PROBLEM,
     CLARENDOM PRESS, OXFORD.
 
 
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     EIGCOM CALCULATES THE EIGENVALUES AND THE EIGENVECTORS OF THE
     FOLLOWING MATRIX:
     (SEE WILKINSON AND REINSCH, 1971, CONTRIBUTION II/15)
     1+3*I  2+1*I  3+2*I  1+1*I
     3+4*I  1+2*I  2+1*I  4+3*I
     2+3*I  1+5*I  3+1*I  5+2*I
     1+2*I  3+1*I  1+4*I  5+3*I
 
     ONLY THE EIGENVECTOR CORRESPONDING TO VALR[1] + VALI[1] * I IS
     PRINTED BY THE FOLLOWING PROGRAM.
 
     "BEGIN"
     "REAL" "ARRAY" AR,AI,VR,VI[1:4,1:4],EM[0:7],VALR,VALI[1:4];
     "INTEGER" I;
     AR[1,1]:=AR[1,4]:=AR[2,2]:=AR[3,2]:=AR[4,1]:=AR[4,3]:=
     AI[1,2]:=AI[1,4]:=AI[2,3]:=AI[3,3]:=AI[4,2]:=1;
     AR[1,2]:=AR[2,3]:=AR[3,1]:=AI[1,3]:=AI[2,2]:=AI[3,4]:=AI[4,1]:=2;
     AR[1,3]:=AR[2,1]:=AR[3,3]:=AR[4,2]:=
     AI[1,1]:=AI[2,4]:=AI[3,1]:=AI[4,4]:=3;
     AR[2,4]:=AI[2,1]:=AI[4,3]:=4;
     AR[3,4]:=AR[4,4]:=AI[3,2]:=5;
     EM[0]:=5"-14;EM[2]:="-12;EM[4]:=10;EM[6]:=10;
     OUTPUT(61,"(""("EIGCOM: ")",D")",
               EIGCOM(AR,AI,4,EM,VALR,VALI,VR,VI));
     OUTPUT(61,"("/,"("EIGENVALUES:")",/")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("2(+D.4D),"(" * I")",/")",
                             VALR[I],VALI[I]);
     OUTPUT(61,"(""("FIRST EIGENVECTOR:")",/")");
     "FOR" I:=1,2,3,4 "DO" OUTPUT(61,"("2(+D.4D),"(" * I")",/")",
                             VR[I,1],VI[I,1]);
     OUTPUT(61,"(""("EM[1]: ")",+DD.DD/,"("EM[3]: ")",+D.D"+DD/,
       "("EM[5]: ")",+ZD/,"("EM[7]: ")",+ZD")",EM[1],EM[3],EM[5],EM[7]);
     "END"
 
     OUTPUT:
 
     EIGCOM: 0
     EIGENVALUES:
     -3.3710-0.7705 * I
     +9.7837+9.3225 * I
     +1.3657-1.4011 * I
     +2.2217+1.8490 * I
     FIRST EIGENVECTOR:
     -0.5061+0.5835 * I
     +1.0000+0.0000 * I
     +0.5183-0.7147 * I
     -0.5535+0.0188 * I
     EM[1]: +15.30
     EM[3]: +6.0"-12
     EM[5]:  +7
     EM[7]:  +4
1SECTION 3.3.2.2.2            (JULY 1974)                         PAGE 7
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34374;
     "INTEGER" "PROCEDURE" EIGVALCOM(AR, AI, N, EM, VALR, VALI);
     "VALUE" N; "INTEGER" N; "ARRAY" AR, AI, EM, VALR, VALI;
     "BEGIN" "INTEGER" "ARRAY" INT[1:N];
         "ARRAY" D, B, DEL, TR, TI[1:N];
         EQILBRCOM(AR, AI, N, EM, D, INT);
         EM[1]:= COMEUCNRM(AR, AI, N - 1, N);
         HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL);
         EIGVALCOM:= VALQRICOM(AR, AI, B, N, EM, VALR, VALI)
     "END" EIGVALCOM;
         "EOP"
0"CODE" 34375;
     "INTEGER" "PROCEDURE" EIGCOM(AR, AI, N, EM, VALR, VALI, VR, VI);
     "VALUE" N; "INTEGER" N; "ARRAY" AR, AI, EM, VALR, VALI, VR, VI;
     "BEGIN" "INTEGER" I;
         "INTEGER" "ARRAY" INT[1:N];
         "ARRAY" D, B, DEL, TR, TI[1:N];
         EQILBRCOM(AR, AI, N, EM, D, INT);
         EM[1]:= COMEUCNRM(AR, AI, N - 1, N);
         HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL);
         I:= EIGCOM:= QRICOM(AR, AI, B, N, EM, VALR, VALI, VR,
         VI); "IF" I = 0 "THEN"
         "BEGIN" BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, 1, N);
             BAKLBRCOM(N, 1, N, D, INT, VR, VI);
             SCLCOM(VR, VI, N, 1, N)
         "END"
     "END" EIGCOM;
         "EOP"
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 1
 
 
 
 AUTHOR: J.J.G. ADMIRAAL.
 
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED: 751101.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO MAIN AND NINE AUXILIARY PROCEDURES:
 
     THE TWO MAIN PROCEDURES ARE:
     A. QZIVAL FINDS N PAIRS OF SCALARS (ALFA[M],BETA[M]),WHERE BETA[M]
        IS REAL,SUCH THAT THE MATRIX BETA[M] * A - ALFA[M] * B IS
        SINGULAR.
     B. QZI FINDS N PAIRS OF SCALARS (ALFA[M], BETA[M]),WHERE BETA[M] IS
        REAL,SUCH THAT THE MATRIX BETA[M] * A - ALFA[M] * B IS SINGULAR;
        MOREOVER THE GENERALIZED EIGENVECTORS (THE HOMOGENOUS SOLUTION
        OF ( BETA[M] * A - ALFA[M] * B ) * X = 0 )  ARE CALCULATED.
 
     THE AUXILIARY PROCEDURES ARE:
     A. HSHDECMUL:
        THIS PROCEDURE CALCULATES REAL MATRICES Q AND R SUCH
        THAT Q.A=R WHERE A IS A GIVEN REAL SQUARE MATRIX, Q IS A
        PRODUCT OF HOUSEHOLDER MATRICES AND R AN UPPERTRIANGULAR MATRIX.
        MOREOVER Q.B IS FORMED WITH B, A GIVEN MATRIX.
     B. HESTGL3:
        GIVEN THE REAL SQUARE MATRICES A,B AND X, WITH B AN
        UPPER TRIANGULAR MATRIX,HESTGL3 CALCULATES THE MATRICES Q,Z,H,R,
        WHERE Q,Z ARE ORTHOGONAL, H UPPER HESSENBERG AND R AN UPPER
        TRIANGULAR MATRIX SUCH THAT Q.A.Z = H AND Q.B.Z = R.
        FURTHER: A:= Q.A.Z ; B:= Q.B.Z AND X:= Q.X.Z.
     C. HESTGL2:
        SEE HESTGL3,BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
     D. HSH2COL:
        THIS PROCEDURE CALCULATES A HOUSEHOLDER MATRIX Q
        SUCH THAT BY PREMULTIPLYING A GIVEN COLUMN VECTOR V BY Q
        A ZERO ELEMENT IS FORMED IN V.
        HERE THE VECTOR V IS A COLUMN OF A MATRIX.
        FURTHER: A:= Q.A AND B:= Q.B
        WHERE A,B ARE TWO GIVEN REAL MATRICES.
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 2
 
 
 
     E. HSH3COL:
        THIS PROCEDURE CALCULATES A HOUSEHOLDER MATRIX
        Q SUCH THAT BY PREMULTIPLYING A GIVEN COLUMN VECTOR V BY Q TWO
        SUCCESSIVE ZERO ELEMENTS ARE FORMED IN V.
        HERE THE VECTOR V IS A COLUMN OF A MATRIX.
        FURTHER: A:= Q.A AND B:= Q.B
        WHERE A AND B ARE TWO GIVEN REAL MATRICES.
     F. HSH2ROW3:
        THIS PROCEDURE CALCULATES A HOUSEHOLDER MATRIX
        Z SUCH THAT BY POSTMULTIPLYING A GIVEN ROWVECTOR
        V BY Z A ZERO ELEMENT IS FORMED IN V.
        HERE THE VECTOR V IS A ROW OF A MATRIX.
        FURTHER: A:= A.Z; B:= B.Z AND X:= X.Z
        WHERE A,B,X ARE THREE GIVEN REAL MATRICES.
     G. HSH2ROW2:
        SEE HSH2ROW3, BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
     H. HSH3ROW3:
        THIS PROCEDURE CALCULATES A HOUSEHOLDER MATRIX
        Z SUCH THAT BY POSTMULTIPLYING A GIVEN ROWVECTOR
        V BY Z, TWO SUCCESSIVE ZERO ELEMENTS ARE FORMED
        IN V. HERE THE VECTOR V IS A ROW OF A MATRIX.
        FURTHER: A:= A.Z; B:= B.Z AND X:= X.Z
        WHERE A,B AND X ARE THREE GIVEN REAL MATRICES.
     I: HSH3ROW2:
        SEE HSH3ROW3, BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
 
 KEYWORDS:
           HOUSEHOLDER'S TRANSFORMATION,
           GENERALIZED EIGENVALUES,
           GENERALIZED EIGENVECTORS,
           UPPER HESSENBERG MATRIX,
           UPPER TRIANGULAR MATRIX.
 
 REFERENCES:
 
     [1]. C.B. MOLER AND G.W. STEWART.
          AN ALGORITHM FOR THE GENERALIZED MATRIX EIGENVALUE
          PROBLEM  A * X = LAMBDA * B * X.
          REPORT STANFORD UNIVERSITY
          STAN-CS-232-71;
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 3
 
 
 
 SUBSECTION: QZIVAL
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" QZIVAL(N,A,B,ALFR,ALFI,BETA,ITER,EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A,B,ALFR,ALFI,BETA,EM;
     "INTEGER" "ARRAY" ITER;
     "CODE" 34600;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:    <ARITHMETIC EXPRESSION>;
           THE NUMBER OF ROWS AND COLUMNS OF THE MATRICES A,B
     A:    <ARRAY IDENTIFIER>;
           "ARRAY" A[1:N,1:N];
           ENTRY: THE GIVEN MATRIX;
           EXIT: A QUASI UPPER-TRIANGULAR MATRIX
                 (SEE METHOD AND PERFORMANCE);
     B:    <ARRAY IDENTIFIER>;
           "ARRAY" B[1:N,1:N];
           ENTRY: THE GIVEN MATRIX;
           EXIT: AN UPPER-TRIANGULAR MATRIX;
     ALFR: <ARRAY IDENTIFIER>;
           "ARRAY" ALFR[1:N];
           EXIT : THE REAL PARTS OF ALFA[1:N]
           (SEE METHOD AND PERFORMANCE);
     ALFI: <ARRAY IDENTIFIER>;
           "ARRAY" ALFI[1:N];
           EXIT : THE IMAGINARY PARTS OF ALFA[1:N];
     BETA: <ARRAY IDENTIFIER>;
           "ARRAY" BETA[1:N];
           EXIT : THE REAL SCALARS BETA[N]
     ITER: <ARRAY IDENTIFIER>;
           "INTEGER" "ARRAY" ITER[1:N];
           TROUBLE INDICATOR AND ITERATION COUNTER;
           IF ITER[1]=0 THEN NO TROUBLE IS SIGNALIZED,
           FURTHER SEE METHOD AND PERFORMANCE;
     EM:   <ARRAY IDENTIFIER>;
           "ARRAY" EM[0:1];
            ENTRY: EM[0]: THE SMALLEST POSITIVE MACHINE NUMBER;
                   EM[1]: THE RELATIVE PRECISION OF ELEMENTS OF A AND B;
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 4
 
 
 
 PROCEDURES USED:
     TAMMAT    = CP 34014
     ELMCOL    = CP 34023
     HSHDECMUL = CP 34602
     HESTGL2   = CP 34604
     HSH2COL   = CP 34605
     HSH3COL   = CP 34606
     HSH2ROW2  = CP 34608
     HSH3ROW2  = CP 34610
     CHSH2     = CP 34611
     HSHVECMAT = CP 31070
     HSHVECTAM = CP 31073
 
 REQUIRED CENTRAL MEMORY : HSHDECMUL DECLARES AN ARRAY OF N REALS.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3
 
 METHOD AND PERFORMANCE;
     THE PROCEDURE QZIVAL SOLVES THE GENERALIZED MATRIX
     EIGENVALUE PROBLEM A * X = LAMBDA * B * X BY MEANS
     OF QZ ITERATION (SEE REF[1]);
     QZIVAL FINDS N PAIRS OF SCALARS (ALFA[M],BETA[M])
     SUCH THAT BETA[M] * A - ALFA[M] * B IS SINGULAR.
     THE EIGENVALUES OF A * X - LAMBDA * B * X CAN BE OBTAINED
     BY DIVIDING ALFA[M] BY BETA[M],EXCEPT BETA[M] MIGHT BE ZERO.
     IN THIS ALGORITHM ONLY UNITARY TRANSFORMATIONS ARE
     APPLIED; A FORTIORI NO INVERSES ARE CALCULATED, SO
     EITHER A OR B (OR BOTH) MAY BE SINGULAR.
     BETA[M] IS REAL, ALFA[M] IS COMPLEX.
     REAL AND IMAGINARY PARTS ARE GIVEN IN ALFR[M] AND ALFI[M].
     THE OCCURRENCE OF COMPLEX PAIRS IS ALWAYS IN
     SUCCESSIVE ELEMENTS, SUCH THAT ALFA[M]/BETA[M] AND
     ALFA[M+1]/BETA[M+1] ARE COMPLEX CONJUGATE, BUT ALFA[M]
     AND ALFA[M+1] ARE NOT NECESSARILY CONJUGATE.
     ONLY REAL ARITHMETIC IS USED IN THE PROCEDURE.
     IF A AND B WERE REDUCED TO TRIANGULAR FORM BY UNITARY
     TRANSFORMATIONS,ALFA AND BETA WOULD BE THE DIAGONALS.
     A AND B ARE ACTUALLY REDUCED TO QUASI-TRIANGULAR FORM HAVING ONLY
     1-BY-1 AND 2-BY-2 BLOCKS ON THE DIAGONAL OF A.
     IF ALFA[M] IS NOT REAL, THEN BETA[M] IS NOT ZERO.
     ITER IS THE TROUBLE INDICATOR AND ITERATION COUNTER.
     IF ITER[1]=0 THEN EVERYTHING IS O.K.
     ITER[M] IS THE NUMBER OF ITERATIONS NEEDED FOR THE M-TH EIGENVALUE.
     IF ITER[1] THROUGH ITER[M]= -1 THEN THE ITERATION FOR THE M-TH
     EIGENVALUE DID NOT CONVERGE AND ALFA[1] THROUGH ALFA[M] AND BETA[1]
     THROUGH BETA[M] ARE PROBABLY INACCURATE.
 
 EXAMPLE OF USE:
 
  "BEGIN" "ARRAY" A,B[1:4,1:4],ALFR,ALFI,BETA[1:4],EM[0:1];
      "INTEGER" "ARRAY" ITER[1:4];"INTEGER" K,L;
      A[1,1]:=2; A[1,2]:=3; A[1,3]:=-3; A[1,4]:=4;
1SECTION : 3.4.1.2            (JANUARY 1976)                      PAGE 5
 
 
 
      A[2,1]:=1; A[2,2]:=-1; A[2,3]:=5; A[2,4]:=1;
      A[3,1]:=0; A[3,2]:=2; A[3,3]:=6; A[3,4]:=8;
      A[4,1]:=1; A[4,2]:=1; A[4,3]:=0; A[4,4]:=4;
      B[1,1]:=1; B[1,2]:=5; B[1,3]:=9; B[1,4]:=0;
      B[2,1]:=2; B[2,2]:=6; B[2,3]:=10; B[2,4]:=2;
      B[3,1]:=3; B[3,2]:=7; B[3,3]:=11; B[3,4]:=-1;
      B[4,1]:=4; B[4,2]:=8; B[4,3]:=12; B[4,4]:=3;
      OUTPUT(61,"(""("A")",/,4(4(+ZDBB),/),/")",A);
      OUTPUT(61,"(""("B")",/,4(4(+ZDBB),/),/")",B);
      EM[0]:=DWARF;EM[1]:="-15;
      QZIVAL(4,A,B,ALFR,ALFI,BETA,ITER,EM);
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      OUTPUT(61,"(""("ITER[")",D,"("]=")",ZD,/")",K,ITER[K]);
      OUTPUT(61,"(""("ALFA(REAL PART)")"8B,"("ALFA(IMAGINARY PART)")"
      3B,"("BETA")",/")");
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      OUTPUT(61,"("3(N),/")",ALFR[K],ALFI[K],BETA[K]);
      OUTPUT(61,"("/"("LAMBDA(REAL PART)")"6B,
      "("LAMBDA(IMAGINARY PART)")"/")");
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      "BEGIN" "IF" BETA[K]=0 "THEN"
          OUTPUT(61,"(""("INFINITE")"15B,"("INDEFINITE")"/,")")
          "ELSE" OUTPUT(61,"("2(N),/")",ALFR[K]/BETA[K],ALFI[K]/BETA[K])
      "END"
  "END"
 
  A
   +2   +3   -3   +4
   +1   -1   +5   +1
   +0   +2   +6   +8
   +1   +1   +0   +4
 
  B
   +1   +5   +9   +0
   +2   +6  +10   +2
   +3   +7  +11   -1
   +4   +8  +12   +3
 
  ITER[1]= 0
  ITER[2]= 0
  ITER[3]= 0
  ITER[4]= 5
 
  ALFA(REAL PART)        ALFA(IMAGINARY PART)   BETA
  -4.4347115652167"+000  +0.0000000000000"+000  +0.0000000000000"+000
  -5.7288406521003"+000  +0.0000000000000"+000  +2.8441121744896"+000
  -8.6671777386054"-001  +2.7607904944916"+000  +8.7617886336960"+000
  -4.7262205157527"-001  -1.5054617625576"+000  +4.7778119295757"+000
 
  LAMBDA(REAL PART)      LAMBDA(IMAGINARY PART)
  INFINITE               INDEFINITE
  -2.0142808372628"+000  +0.0000000000000"+000
  -9.8920187429234"-002  +3.1509439566644"-001
  -9.8920187429236"-002  -3.1509439566645"-001
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 6
 
 
 
 SUBSECTION: QZI
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" QZI(N,A,B,X,ALFR,ALFI,BETA,ITER,EM);
     "VALUE" N; "INTEGER" N; "ARRAY" A,B,X,ALFR,ALFI,BETA,EM;
     "INTEGER" "ARRAY" ITER;
     "CODE" 34601;
 
     THE MEANING OF THE FORMAL PARAMETERS IS;
     N:    <ARITHMETIC EXPRESSION>;
           THE NUMBER OF ROWS AND COLUMNS OF THE MATRICES A,B AND X;
     A:    <ARRAY IDENTIFIER>
           "ARRAY" A[1:N,1:N];
           ENTRY: THE GIVEN MATRIX A;
           EXIT: A QUASI UPPER TRIANGULAR MATRIX;
                 (SEE METHOD AND PERFORMANCE);
     B:    <ARRAY IDENTIFIER>;
           "ARRAY" B[1:N,1:N];
           ENTRY: THE GIVEN MATRIX B;
           EXIT: AN UPPER-TRIANGULAR MATRIX;
     X:    <ARRAY IDENTIFIER>;
           "ARRAY" X[1:N,1:N];
           ENTR: THE N*N UNIT MATRIX;
           EXIT: THE MATRIX OF EIGENVECTORS,
           THE EIGENVECTORS ARE STORED IN THE ARRAY X AS FOLLOWS:
           IF ALFI[M]=0 THEN X[.,M] IS THE M-TH REAL EIGENVECTOR;
           OTHERWISE, FOR EACH PAIR OF CONSECUTIVE COLUMNS
           X[.,M] AND X[.,M+1] ARE THE REAL
           AND IMAGINARY PARTS OF THE M-TH COMPLEX EIGENVECTOR.
           X[.,M] AND -X[.,M+1] ARE THE REAL AND IMAGINARY PARTS
           OF THE M+1 -ST COMPLEX EIGENVECTOR.
           THE EIGENVECTORS ARE NORMALIZED SUCH THAT THE LARGEST
           COMPONENT IS 1 OR 1 + 0 * I.
     ALFR: <ARRAY IDENTIFIER>;
           "ARRAY" ALFR[1:N];
           EXIT: THE REAL PARTS OF ALFA[1:N];
     ALFI: <ARRAY IDENTIFIER>;
           "ARRAY" ALFI[1:N];
           EXIT: THE IMAGINARY PARTS OF ALFA[1:N];
     BETA: <ARRAY IDENTIFIER>;
           "ARRAY" BETA[1:N];
     ITER: <ARRAY IDENTIFIER>;
           "INTEGER" "ARRAY" ITER[1:N];
           TROUBLE INDICATOR AND ITERATION COUNTER;
           IF ITER[1]=0 THEN NO TROUBLE IS SIGNALIZED,
           FOR FURTHER INFORMATION SEE
           METHOD AND PEFORMANCE OF PROCEDURE QZIVAL (THIS SECTION).
     EM:   <ARRAY IDENTIFIER>;
           "ARRAY" EM[0:1];
           ENTRY: EM[0]: THE SMALLEST POSITIVE MACHINE NUMBER;
                  EM[1]: THE RELATIVE PRECISION OF ELEMENTS OF A AND B;
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 7
 
 
 
 PROCEDURES USED:
 
     MATMAT    = CP 34013
     TAMMAT    = CP 34014
     ELMCOL    = CP 34023
     HSHDECMUL = CP 34602
     HESTGL3   = CP 34603
     HSH2COL   = CP 34605
     HSH2ROW3  = CP 34607
     HSH3ROW3  = CP 34609
     HSH3COL   = CP 34606
     CHSH2     = CP 34611
     COMDIV    = CP 34342
     HSHVECMAT = CP 31070
     HSHVECTAM = CP 31073
 
 RUNNING TIME: PROPORTIONAL TO N ** 3;
 
 
 REQUIRED CENTRAL MEMORY : HSHDECMUL DECLARES AN ARRAY OF N REALS.
 
 
 METHOD AND PERFORMANCE;
 
     THE PROCEDURE QZI APPLIES THE SAME METHOD AS QZIVAL.
 
 
 EXAMPLE OF USE:
 
  "BEGIN" "ARRAY" A,B,X[1:4,1:4],ALFR,ALFI,BETA[1:4],EM[0:1];
      "INTEGER" "ARRAY" ITER[1:4];"INTEGER" K,L;
      A[1,1]:=2; A[1,2]:=3; A[1,3]:=-3; A[1,4]:=4;
      A[2,1]:=1; A[2,2]:=-1; A[2,3]:=5; A[2,4]:=1;
      A[3,1]:=0; A[3,2]:=2; A[3,3]:=6; A[3,4]:=8;
      A[4,1]:=1; A[4,2]:=1; A[4,3]:=0; A[4,4]:=4;
      B[1,1]:=1; B[1,2]:=5; B[1,3]:=9; B[1,4]:=0;
      B[2,1]:=2; B[2,2]:=6; B[2,3]:=10; B[2,4]:=2;
      B[3,1]:=3; B[3,2]:=7; B[3,3]:=11; B[3,4]:=-1;
      B[4,1]:=4; B[4,2]:=8; B[4,3]:=12; B[4,4]:=3;
      "FOR" K:=1,2,3,4 "DO" "FOR" L:=1,2,3,4 "DO"
      X[K,L]:="IF" K=L "THEN" 1 "ELSE" 0;
      OUTPUT(61,"(""("A")",/,4(4(+ZDBB),/),/")",A);
      OUTPUT(61,"(""("B")",/,4(4(+ZDBB),/),/")",B);
      EM[0]:=1.0"-280;EM[1]:="-15;
      QZI(4,A,B,X,ALFR,ALFI,BETA,ITER,EM);
1SECTION : 3.4.1.2            (JANUARY 1976)                      PAGE 8
 
 
 
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      OUTPUT(61,"(""("ITER[")",D,"("]=")",ZD,/")",K,ITER[K]);
      OUTPUT(61,"("/"("EIGENVECTORS")",/,4(4(+D.8D"+2D2B),/),/")",X);
      OUTPUT(61,"(""("ALFA(REAL PART)")"8B,"("ALFA(IMAGINARY PART)")"
      9B,"("BETA")",/")");
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      OUTPUT(61,"("3(N),/")",ALFR[K],ALFI[K],BETA[K]);
      OUTPUT(61,"("/"("LAMBDA(REAL PART)")"6B,
      "("LAMBDA(IMAGINARY PART)")"/")");
      "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
      "BEGIN" "IF" BETA[K]=0 "THEN"
          OUTPUT(61,"(""("INFINITE")"15B,"("INDEFINITE")"/")")
          "ELSE"
          OUTPUT(61,"("2(N),/")",ALFR[K]/BETA[K],ALFI[K]/BETA[K])
      "END"
  "END"
 
  A
   +2   +3   -3   +4
   +1   -1   +5   +1
   +0   +2   +6   +8
   +1   +1   +0   +4
 
  B
   +1   +5   +9   +0
   +2   +6  +10   +2
   +3   +7  +11   -1
   +4   +8  +12   +3
 
  ITER[1]= 0
  ITER[2]= 0
  ITER[3]= 0
  ITER[4]= 5
 
  EIGENVECTORS
  -5.00000000"-01  +1.00000000"+00  -6.29204867"-01  +6.52026261"-01
  +1.00000000"+00  -3.82541766"-02  +1.00000000"+00  +0.00000000"+00
  -5.00000000"-01  -3.04677732"-02  +1.65896051"-01  +1.09306265"-01
  -4.35116786"-15  -7.63328122"-01  -5.84845537"-01  +1.77430910"-01
 
  ALFA(REAL PART)        ALFA(IMAGINARY PART)   BETA
  -4.4347115652167"+000  +0.0000000000000"+000  +0.0000000000000"+000
  -5.7288406521003"+000  +0.0000000000000"+000  +2.8441121744896"+000
  -8.6671777386054"-001  +2.7607904944916"+000  +8.7617886336960"+000
  -4.7262205157527"-001  -1.5054617625576"+000  +4.7778119295757"+000
 
  LAMBDA(REAL PART)      LAMBDA(IMAGINARY PART)
  INFINITE               INDEFINITE
  -2.0142808372628"+000  +0.0000000000000"+000
  -9.8920187429234"-002  +3.1509439566644"-001
  -9.8920187429236"-002  -3.1509439566645"-001
1SECTION : 3.4.1.2            (FEBRUARY 1979)                     PAGE 9
 
 
 
 SUBSECTION: HSHDECMUL.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" HSHDECMUL(N,A,B,DWARF);
     "VALUE" N,DWARF; "INTEGER"N; "REAL"DWARF; "ARRAY" A,B;
     "CODE" 34602;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N: <ARITHMETIC EXPRESSION>;
        THE ORDER OF THE GIVEN MATRICES;
     A: <ARRAY IDENTIFIER>;
        "REAL" "ARRAY" A[1:N,1:N];
        ENTRY: THE GIVEN MATRIX A;
        EXIT: THE TRANSFORMED MATRIX Q.A (SEE BRIEF DESCRIPTION);
     B: <ARRAY IDENTIFIER>;
        "REAL" "ARRAY" B[1:N,1:N];
        ENTRY: THE GIVEN MATRIX B;
        EXIT: THE UPPER TRIANGULAR MATRIX Q.B (SEE BRIEF DESCRIPTION);
     DWARF: < ARITHMETIC EXPRESSION>;
        THE SMALLEST POSITIVE MACHINE NUMBER.
 
 
 PROCEDURES USED:
     TAMMAT    = CP 34014;
     HSHVECMAT = CP 31070.
 
 
 REQUIRED CENTRAL MEMORY : AN ARRAY OF N REALS IS DECLARED.
 
 
 METHOD AND PERFORMANCE:
     FOR EACH MATRIX COLUMN A[I] A HOUSEHOLDERMATRIX Q IS FORMED,
     SUCH THAT Q.A[I] HAS ONLY ZERO ELEMENTS BELOW THE DIAGONAL ELEMENT.
     WHEN SUCCESSIVELY FOR I = 1,2,....,N-1 THESE TRANSFORMATIONS HAVE
     BEEN PERFORMED,THE MATRIX A HAS BEEN CHANGED INTO AN UPPER
     TRIANGULAR MATRIX.
     THE SAME TRANSFORMATIONS ARE PERFORMED ON THE MATRIX B
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE HSHDECMUL IS USED IN QZI AND QZIVAL (THIS SECTION).
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 10
 
 
 
 SUBSECTION: HESTGL3:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HESTGL3(N,A,B,X);
     "VALUE" N; "INTEGER" N; "ARRAY" A,B,X;
     "CODE" 34603;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N: <ARITHMETIC EXPRESSION>;
        THE ORDER OF THE GIVEN MATRICES;
     A: <ARRAY IDENTIFIER>;
        "ARRAY" A[1:N,1:N];
        ENTRY: THE GIVEN MATRIX A;
        EXIT: THE UPPER HESSENBERG MATRIX Q.A.Z (SEE BRIEF DESCRIPTION);
     B: <ARRAY IDENTIFIER>;
        "ARRAY" B[1:N,1:N];
        ENTRY: THE GIVEN UPPER TRIANGULAR MATRIX B;
        EXIT: THE UPPER TRIANGULAR MATRIX Q.B.Z (SEE BRIEF DESCRIPTION);
     X: <ARRAY IDENTIFIER>;
        "ARRAY" X[1:N,1:N];
        ENTRY: THE GIVEN MATRIX X;
        EXIT: THE TRANSFORMED MATRIX Q.X.Z (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED:
     HSH2COL  = CP 34605
     HSH2ROW3 = CP 34607
 
 
 METHODE AND PERFORMANCE:
     THE REDUCTION OF THE MATRIX A TO UPPER HESSENBERG FORM
     WHILE PRESERVING THE TRIANGULARITY OF THE MATRIX B
     IS THE RESULT OF A NUMBER OF STEPS, WHICH DO THE FOLLOWING
     ACTIONS: INTRODUCING A ZERO ELEMENT IN A AND RESTORING
     THE DISTURBED ZERO IN B, WITHOUT DISTURBING THE ZERO
     INTRODUCED IN A. THIS IS DONE BY PRE-AND POSTMULTIPLICATIONS OF
     HOUSEHOLDER MATRICES.
     THE MATRIX X SHARES THE TRANSFORMATION.
     FOR FURTHER DETAILS SEE [1]
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE HESTGL3 IS USED IN QZI (THIS SECTION).
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 11
 
 
 
 SUBSECTION: HESTGL2:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HESTGL2(N,A,B); "VALUE" N; "INTEGER" N; "ARRAY" A,B;
     "CODE" 34604;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N: <ARITHMETIC EXPRESSION>;
        THE ORDER OF THE GIVEN MATRICES;
     A: <ARRAY IDENTIFIER>;
        "ARRAY" A[1:N,1:N];
        ENTRY: THE GIVEN MATRIX A;
        EXIT: THE UPPER HESSENBERG MATRIX Q.A.Z (SEE BRIEF DESCRIPTION);
     B: <ARRAY IDENTIFIER>;
        "ARRAY" B[1:N,1:N];
        ENTRY: THE GIVEN UPPER TRIANGULAR MATRIX B
        EXIT: THE UPPER TRIANGULAR MATRIX Q.B.Z (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED:
     HSH2COL  = CP 34605
     HSH2ROW2 = CP 34608
 
 
 METHODE AND PERFORMANCE:
     SEE HESTGL3, BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
 
 
 EXAMPLE OF USE:
     THE PROCEDURE HESTGL2 IS USED IN QZIVAL (THIS SECTION).
 
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 12
 
 
 
 SUBSECTION HSH2COL:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH2COL(LA,LB,U,I,A1,A2,A,B); "VALUE" LA,LB,U,I,A1,A2;
     "INTEGER" LA,LB,U,I; "REAL" A1,A2; "ARRAY" A,B;
     "CODE" 34605;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LA: <ARITHMETIC EXPRESSION>;
         THE LOWER BOUND OF THE RUNNING COLUMN SUBSCRIPT OF A;
     LB: <ARITHMETIC EXPRESSION>;
         THE LOWER BOUND OF THE RUNNING COLUMN SUBSCRIPT OF B;
     U:  <ARITHMETIC EXPRESSION>;
         THE UPPER BOUND OF THE RUNNING COLUMN SUBSCRIPTS
         OF A AND B.
     I:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPTS OF A AND B.
         I+1 IS THE UPPERBOUND.
     A1: <ARITHMETIC EXPRESSION>;
         THE I-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED.
     A2: <ARITHMETIC EXPRESSION>;
         THE (I+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[I:I+1,LA:U];
         ENTRY THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX Q.A (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "ARRAY" B[I:I+1,LB:U];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX Q.B (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED:
     HSHVECMAT = CP 31070
 
 
 METHOD AND PERFORMANCE:
        WHEN THE CALCULATED HOUSEHOLDER MATRIX Q PREMULTIPLIES
        A MATRIX M, ONLY ROWS I AND I+1 ARE CHANGED.
        IF THE ELEMENTS I AND I+1 IN A COLUMN OF M ARE ZERO, THEY
        REMAIN ZERO IN Q.M.
        THEREFORE ONLY THE SUBMATRICES A[I:I+1,LA:U] AND
        B[I:I+1,LB:U] ARE CHANGED, WHERE Q.A AND Q.B ARE
        OVERWRITTEN IN A RESP B.
 
 
 EXAMPLE OF USE: THE PROCEDURE HSH2COL IS USED IN QZI AND QZIVAL,
                 (THIS SECTION).
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 13
 
 
 
 SUBSECTION HSH3COL:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH3COL(LA,LB,U,I,A1,A2,A3,A,B);
     "VALUE" LA,LB,U,I,A1,A2,A3;"INTEGER" LA,LB,I,U;"REAL" A1,A2,A3;
     "ARRAY" A,B;
     "CODE" 34606;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LA: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A;
     LB: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF B;
     U:  <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A AND B;
     I:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF A AND B,
         I+2 IS THE UPPERBOUND;
     A1: <ARITHMETIC EXPRESSION>;
         THE I-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A2: <ARITHMETIC EXPRESSION>;
         THE (I+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A3: <ARITHMETIC EXPRESSION>;
         THE (I+2)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED.
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[I:I+2,LA:U];
         ENTRY: THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX Q.A (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "ARRAY" B[I:I+2,LB:U];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX Q.B (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED: HSHVECMAT = CP 31070;
 
 
 METHOD AND PERFORMANCE:
        WHEN THE CALCULATED HOUSEHOLDER MATRIX Q PREMULTIPLIES A MATRIX
        M, ONLY ROWS I, (I+1) AND (I+2) ARE CHANGED.
        IF THE ELEMENTS I, I+1 AND I+2 ARE ZERO, THEN THEY REMAIN ZERO
        IN Q.M.
        THEREFORE ONLY THE SUBMATRICES A[I:I+2,LA:U] AND B[I:I+2,LB:U]
        ARE CHANGED, WHERE Q.A AND Q.B ARE OVERWRITTEN IN A RESP B.
 
 
 EXAMPLE OF USE: THE PROCEDURE HSH3COL IS USED IN QZI AND QZIVAL
                 (THIS SECTION).
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 14
 
 
 
 SUBSECTION HSH2ROW3:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH2ROW3(L,UA,UB,UX,J,A1,A2,A,B,X);
     "VALUE" L,UA,UB,UX,J,A1,A2; "INTEGER" L,UA,UB,UX,J;
     "REAL" A1,A2;"ARRAY" A,B,X;
     "CODE" 34607;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF A,B AND X;
     UA: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF A;
     UB: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF B;
     UX: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF X;
     J:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A,B AND X;
         J+1 IS THE UPPERBOUND;
     A1: <ARITHMETIC EXPRESSION>;
         THE J-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A2: <ARITHMETIC EXPRESSION>;
         THE (J+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[L:UA,J:J+1];
         ENTRY: THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX A.Z (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "ARRAY" B[L:UB,J:J+1];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX B.Z (SEE BRIEF DESCRIPTION);
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[L:UX,J:J+1];
         ENTRY: THE GIVEN MATRIX X;
         EXIT: THE TRANSFORMED MATRIX X.Z (SEE BRIEF DESCRIPTION);
 
 PROCEDURES USED: HSHVECTAM = CP 31073;
 
 METHOD AND PERFORMANCE:
     WHEN THE CALCULATED HOUSEHOLDER MATRIX Z POSTMULTIPLIES
     A MATRIX M, ONLY COLUMNS J AND J+1 ARE CHANGED.
     IF THE ELEMENTS J AND J+1 IN A ROW OF M ARE ZERO, THEN
     THEY REMAIN ZERO IN M.Z
     THEREFORE ONLY THE SUBMATRICES A[L:UA,J:J+1],B[L:UB,J:J+1]
     AND X[L:UX,J:J+1] ARE CHANGED, WHERE A.Z, B.Z AND X.Z ARE
     OVERWRITTEN IN RESP. A,B AND X.
 
 EXAMPLE OF USE: THE PROCEDURE HSH2ROW3 IS USED IN QZI (THIS SECTION).
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 15
 
 
 
 SUBSECTION HSH2ROW2:
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH2ROW2(LA,LB,UA,UB,J,A1,A2,A,B); "VALUE" LA,LB,UA,
     UB,J,A1,A2; "INTEGER" LA,LB,UA,UB,J; "REAL" A1,A2;"ARRAY" A,B;
     "CODE" 34608;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LA: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF A;
     LB: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF B;
     UA: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF A;
     UB: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF B;
     J:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A AND B;
         J+1 IS THE UPPERBOUND;
     A1: < ARITHMETIC EXPRESSION>;
         THE J-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A2: <ARITHMETIC EXPRESSION>;
         THE (J+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" A[LA:UA,J:J+1];
         ENTRY: THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX A.Z (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" B[LB:UB,J:J+1];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX B.Z (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED: HSHVECTAM = CP 31073;
 
 
 METHOD AND PERFORMANCE:
     SEE HSH2ROW3, BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
 
 
 EXAMPLE OF USE:
         THE PROCEDURE HSH2ROW2 IS USED IN QZIVAL,
         (THIS SECTION).
 
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 16
 
 
 
 SUBSECTION: HSH3ROW3.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH3ROW3(L,U,UX,J,A1,A2,A3,A,B,X);
     "VALUE" L,U,UX,J,A1,A2,A3; "INTEGER" L,U,UX,J; "REAL" A1,A2,A3;
     "ARRAY" A,B,X;
     "CODE" 34609;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF A AND B AND X;
     U:  <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF A AND B;
     UX: <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF X;
     J:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A,B AND X;
         J+2 IS THE UPPERBOUND;
     A1: <ARITHMETIC EXPRESSION>;
         THE J-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A2: <ARITHMETIC EXPRESSION>;
         THE (J+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A3: <ARITHMETIC EXPRESSION>;
         THE (J+2)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" A[L:U,J:J+2];
         ENTRY: THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX A.Z (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" B[L:U,J:J+2];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX B.Z (SEE BRIEF DESCRIPTION);
     X:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" X[L:UX,J:J+2];
         ENTRY: THE GIVEN MATRIX X;
         EXIT: THE TRANSFORMED MATRIX X.Z (SEE BRIEF DESCRIPTION);
 
 PROCEDURES USED: HSHVECTAM = CP 31073;
 
 METHOD AND PERFORMANCE:
     WHEN THE CALCULATED HOUSEHOLDER MATRIX Z POSTMULTIPLIES A MATRIX M,
     ONLY COLUMNS J,J+1 AND J+2 ARE CHANGED.
     IF THE ELEMENTS J, J+1 AND J+2 IN A ROW OF M ARE ZERO, THEN THEY
     REMAIN ZERO IN M.Z.
     THEREFORE ONLY THE SUBMATRICES A[L:U,J:J+2], B[L:U,J:J+2] AND
     X[L:UX,J:J+2] ARE CHANGED, WHERE A.Z , B.Z AND X.Z ARE OVERWRITTEN
     ON RESP. A,B AND X;
 
 EXAMPLE OF USE: THE PROCEDURE HSH3ROW3 IS USED IN QZI (THIS SECTION).
 
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 17
 
 
 
 SUBSECTION: HSH3ROW2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" HSH3ROW2(LA,LB,U,J,A1,A2,A3,A,B);
     "VALUE" LA,LB,U,J,A1,A2,A3; "INTEGER" LA,LB,U,J;
     "REAL" A1,A2,A3; "ARRAY" A,B;
     "CODE" 34610;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LA: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF A;
     LB: <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING ROW SUBSCRIPT OF B;
     U:  <ARITHMETIC EXPRESSION>;
         THE UPPERBOUND OF THE RUNNING ROW SUBSCRIPT OF A AND B;
     J:  <ARITHMETIC EXPRESSION>;
         THE LOWERBOUND OF THE RUNNING COLUMN SUBSCRIPT OF A AND B,
         J+2 IS THE UPPERBOUND;
     A1: <ARITHMETIC EXPRESSION>;
         THE J-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A2: <ARITHMETIC EXPRESSION>;
         THE (J+1)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A3: <ARITHMETIC EXPRESSION>;
         THE (J+2)-TH COMPONENT OF THE VECTOR TO BE TRANSFORMED;
     A:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" A[LA:U,J:J+2];
         ENTRY: THE GIVEN MATRIX A;
         EXIT: THE TRANSFORMED MATRIX A.Z (SEE BRIEF DESCRIPTION);
     B:  <ARRAY IDENTIFIER>;
         "REAL" "ARRAY" B[LB:U,J:J+2];
         ENTRY: THE GIVEN MATRIX B;
         EXIT: THE TRANSFORMED MATRIX B.Z (SEE BRIEF DESCRIPTION);
 
 
 PROCEDURES USED: HSHVECTAM = CP 31073;
 
 
 METHOD AND PERFORMANCE:
        SEE HSH3ROW3, BUT HERE THE MATRIX X HAS BEEN LEFT OUT.
 
 
 EXAMPLE OF USE: HSH3ROW2 IS USED IN QZIVAL (THIS SECTION).
 
1SECTION : 3.4.1.2            (JANUARY 1979)                     PAGE 18
 
 
 
 SOURCE TEXTS:
0"CODE" 34600;
 "PROCEDURE" QZIVAL(N,A,B,ALFR,ALFI,BETA,ITER,EM);
 "VALUE" N;"INTEGER" N;"ARRAY" A,B,ALFR,ALFI,BETA,EM;
 "INTEGER" "ARRAY" ITER;
 "BEGIN" "REAL" DWARF,EPS,EPSA,EPSB;
 "PROCEDURE" QZIT(N,A,B,EPS,EPSA,EPSB,ITER);"VALUE"N,EPS;
 "REAL" EPS,EPSA,EPSB;"INTEGER" N;"INTEGER" "ARRAY" ITER;"ARRAY" A,B;
 "BEGIN" "REAL" ANORM,BNORM,ANI,BNI,CONST,A10,A20,A30,B11,
     B22,B33,B44,A11,A12,A21,A22,A33,A34,A43,A44,B12,B34,OLD1,OLD2;
     "INTEGER" I,Q,M,M1,Q1,J,K,K1,K2,K3,KM1;"BOOLEAN" STATIONARY;
     ANORM:=BNORM:=0;"FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" BNI:=0;ITER[I]:=0;ANI:="IF" I>1"THEN"ABS(A[I,I-1])"ELSE" 0;
         "FOR" J:=I "STEP" 1 "UNTIL" N "DO"
         "BEGIN" ANI:=ANI+ABS(A[I,J]);BNI:=BNI+ABS(B[I,J])
         "END";"IF" ANI>ANORM "THEN" ANORM:=ANI;"IF" BNI>BNORM"THEN"
         BNORM:=BNI
     "END";"IF" ANORM=0 "THEN" ANORM:=EPS;"IF"BNORM=0 "THEN" BNORM:=EPS;
     EPSA:=EPS*ANORM;EPSB:=EPS*BNORM;
     "FOR" M:=N,M "WHILE" M>=3 "DO"
   "BEGIN"
     "FOR" I:=M+1,I-1 "WHILE"("IF" I>1 "THEN"ABS(A[I,I-1])>EPSA "ELSE"
     "FALSE") "DO" Q:=I-1;
     "IF" Q>1 "THEN" A[Q,Q-1]:=0;
  L: "IF" Q>=M-1 "THEN" M:=Q-1 "ELSE"
     "BEGIN"
         "IF" ABS(B[Q,Q])<=EPSB "THEN"
         "BEGIN" B[Q,Q]:=0;Q1:=Q+1;
             HSH2COL(Q,Q,M,Q,A[Q,Q],A[Q1,Q],A,B);A[Q1,Q]:=0;
             Q:=Q1;"GOTO" L
         "END" "ELSE" M1:=M-1;Q1:=Q+1;CONST:=0.75;ITER[M]:=ITER[M]+1;
         STATIONARY:="IF" ITER[M]=1 "THEN" "TRUE" "ELSE"
         ABS(A[M,M-1])>=CONST*OLD1"AND"ABS(A[M-1,M-2])>=CONST*OLD2;
         "IF" ITER[M]>30"AND"STATIONARY "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" ITER[I]:=-1;
             "GOTO" OUT
         "END";
         "IF" ITER[M]=10"AND"STATIONARY "THEN"
         "BEGIN" A10:=0;A20:=1;A30:=1.1605
         "END" "ELSE"
         "BEGIN" B11:=B[Q,Q];B22:="IF" ABS(B[Q1,Q1])<EPSB "THEN"EPSB
             "ELSE" B[Q1,Q1];
             B33:="IF" ABS(B[M1,M1])<EPSB "THEN" EPSB "ELSE"B[M1,M1];
                                                               "COMMENT"
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 19
                                                                 ;
 
 
             B44:="IF" ABS(B[M,M])<EPSB "THEN" EPSB "ELSE" B[M,M] ;
             A11:=A[Q,Q]/B11;A12:=A[Q,Q1]/B22;A21:=A[Q1,Q]/B11;
             A22:=A[Q1,Q1]/B22;A33:=A[M1,M1]/B33;A34:=A[M1,M]/B44;
             A43:=A[M,M1]/B33;A44:=A[M,M]/B44;B12:=B[Q,Q1]/B22;
             B34:=B[M1,M]/B44;
             A10:=((A33-A11)*(A44-A11)-A34*A43+A43*B34*A11)/A21
                  +A12-A11*B12;
             A20:=(A22-A11-A21*B12)-(A33-A11)-(A44-A11)+A43*B34;
             A30:=A[Q+2,Q1]/B22
         "END";OLD1:=ABS(A[M,M-1]);OLD2:=ABS(A[M-1,M-2]);
         "FOR" K:=Q "STEP" 1 "UNTIL" M1 "DO"
         "BEGIN" K1:=K+1;K2:=K+2;K3:="IF" K+3>M "THEN" M "ELSE" K+3;
             KM1:="IF" K-1<Q "THEN" Q "ELSE" K-1;
             "IF" K^=M1 "THEN"
             "BEGIN" "IF" K=Q "THEN"
                 HSH3COL(KM1,KM1,M,K,A10,A20,A30,A,B) "ELSE"
                 "BEGIN"
                  HSH3COL(KM1,KM1,M,K,A[K,KM1],A[K1,KM1],A[K2,KM1],A,B);
                   A[K1,KM1]:=A[K2,KM1]:=0
                 "END";
                 HSH3ROW2(Q,Q,K3,K,B[K2,K2],B[K2,K1],B[K2,K],A,B);
                 B[K2,K]:=B[K2,K1]:=0 ;
             "END" "ELSE"
             "BEGIN" HSH2COL(KM1,KM1,M,K,A[K,KM1],A[K1,KM1],A,B);
                 A[K1,KM1]:=0
             "END";
             HSH2ROW2(Q,Q,K3,K3,K,B[K1,K1],B[K1,K],A,B);B[K1,K]:=0
         "END"
       "END"
     "END";
     OUT:
 "END" QZIT;
 
 "PROCEDURE" QZVAL(N,A,B,EPSA,EPSB,ALFR,ALFI,BETA);"VALUE" N;
 "REAL" EPSA,EPSB;"INTEGER" N;"ARRAY" ALFR,ALFI,BETA,A,B;
 "BEGIN" "INTEGER" M,L,J;"REAL" AN,BN,A11,A12,A21,A22,B11,B12,B22,E,C,D,
     ER,EI,A11R,A11I,A12R,A12I,A21R,A21I,A22R,A22I,CZ,SZR,SZI,
     CQ,SQR,SQI,SSR,SSI,TR,TI,BDR,BDI,R;
     "FOR" M:=N,M "WHILE" M>0 "DO"
     "IF"("IF" M>1 "THEN" A[M,M-1]=0 "ELSE" "TRUE") "THEN"
     "BEGIN" ALFR[M]:=A[M,M];BETA[M]:=B[M,M];ALFI[M]:=0;M:=M-1
     "END" "ELSE"
     "BEGIN" L:=M-1;"IF" ABS(B[L,L])<=EPSB "THEN"
         "BEGIN" B[L,L]:=0;HSH2COL(L,L,N,L,A[L,L],A[M,L],A,B);
             A[M,L]:=B[M,L]:=0;ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];
             BETA[L]:=B[L,L];BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END" "ELSE" "IF" ABS(B[M,M])<=EPSB "THEN"
         "BEGIN"B[M,M]:=0;HSH2ROW2(1,1,M,M,L,A[M,M],A[M,L],A,B);
             A[M,L]:=B[M,L]:=0;ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];
             BETA[L]:=B[L,L];BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END""ELSE"
       "BEGIN"
         AN:=ABS(A[L,L])+ABS(A[L,M])+ABS(A[M,L])+ABS(A[M,M]);
         BN:=ABS(B[L,L])+ABS(B[L,M])+ABS(B[M,M]);
         A11:=A[L,L]/AN;A12:=A[L,M]/AN;A21:=A[M,L]/AN;A22:=A[M,M]/AN;
                                                               "COMMENT"
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 20
                                                                 ;
 
 
         B11:=B[L,L]/BN;B12:=B[L,M]/BN;B22:=B[M,M]/BN;
         E:=A11/B11;
         C:=((A22-E*B22)/B22-(A21*B12)/(B11*B22))/2;
         D:=C*C+(A21*(A12-E*B12))/(B11*B22);
         "IF" D>=0 "THEN"
         "BEGIN"E:=E+("IF"C<0"THEN"C-SQRT(D)"ELSE"C+SQRT(D));
             A11:=A11-E*B11;A12:=A12-E*B12;A22:=A22-E*B22;
             "IF" ABS(A11)+ABS(A12)>=ABS(A21)+ABS(A22) "THEN"
             HSH2ROW2(1,1,M,M,L,A12,A11,A,B)"ELSE"
             HSH2ROW2(1,1,M,M,L,A22,A21,A,B);
             "IF"AN>=ABS(E)*BN"THEN"
             HSH2COL(L,L,N,L,B[L,L],B[M,L],A,B) "ELSE"
             HSH2COL(L,L,N,L,A[L,L],A[M,L],A,B);
             A[M,L]:=B[M,L]:=0;
             ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];BETA[L]:=B[L,L];
             BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END""ELSE"
         "BEGIN"
             ER:=E+C;EI:=SQRT(-D);A11R:=A11-ER*B11;A11I:=EI*B11;
             A12R:=A12-ER*B12;A12I:=EI*B12;A21R:=A21;A21I:=0;
             A22R:=A22-ER*B22;A22I:=EI*B22;
             "IF"ABS(A11R)+ABS(A11I)+ABS(A12R)+ABS(A12I)>=
             ABS(A21R)+ABS(A22R)+ABS(A22I)"THEN"
             CHSH2(A12R,A12I,-A11R,-A11I,CZ,SZR,SZI)"ELSE"
             CHSH2(A22R,A22I,-A21R,-A21I,CZ,SZR,SZI);
             "IF"AN>=(ABS(ER)+ABS(EI))*BN"THEN"
             CHSH2(CZ*B11+SZR*B12,SZI*B12,SZR*B22,SZI*B22,CQ,SQR,SQI)
             "ELSE"CHSH2(CZ*A11+SZR*A12,SZI*A12,CZ*A21+SZR*A22,SZI*A22,
             CQ,SQR,SQI);SSR:=SQR*SZR+SQI*SZI;SSI:=SQR*SZI-SQI*SZR;
             TR:=CQ*CZ*A11+CQ*SZR*A12+SQR*CZ*A21+SSR*A22;
             TI:=CQ*SZI*A12-SQI*CZ*A21+SSI*A22;
             BDR:=CQ*CZ*B11+CQ*SZR*B12+SSR*B22;
             BDI:=CQ*SZI*B12+SSI*B22;
             R:=SQRT(BDR*BDR+BDI*BDI);BETA[L]:=BN*R;
             ALFR[L]:=AN*(TR*BDR+TI*BDI)/R;
             ALFI[L]:=AN*(TR*BDI-TI*BDR)/R;
             TR:=SSR*A11-SQR*CZ*A12-CQ*SZR*A21+CQ*CZ*A22;
             TI:=-SSI*A11-SQI*CZ*A12+CQ*SZI*A21;
             BDR:=SSR*B11-SQR*CZ*B12+CQ*CZ*B22;
             BDI:=-SSI*B11-SQI*CZ*B12;
             R:=SQRT(BDR*BDR+BDI*BDI);BETA[M]:=BN*R;
             ALFR[M]:=AN*(TR*BDR+TI*BDI)/R;
             ALFI[M]:=AN*(TR*BDI-TI*BDR)/R;
         "END"
       "END";M:=M-2
     "END"
 "END" QZVAL;
 DWARF:=EM[0];EPS:=EM[1];
 HSHDECMUL(N,A,B,DWARF);
 HESTGL2(N,A,B);
 QZIT(N,A,B,EPS,EPSA,EPSB,ITER);
 QZVAL(N,A,B,EPSA,EPSB,ALFR,ALFI,BETA);
 "END" QZIVAL
 
 
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 21
 
 
                                                                  ;
         "EOP"
0"CODE" 34601;
 "PROCEDURE" QZI(N,A,B,X,ALFR,ALFI,BETA,ITER,EM);
 "VALUE" N;"INTEGER" N;"ARRAY"A,B,X,ALFR,ALFI,BETA,EM;
 "INTEGER" "ARRAY" ITER;
 "BEGIN" "REAL" DWARF,EPS,EPSA,EPSB;
 "PROCEDURE" QZIT(N,A,B,X,EPS,EPSA,EPSB,ITER);"VALUE"N,EPS;
 "REAL" EPS,EPSA,EPSB;"INTEGER" N;"INTEGER" "ARRAY" ITER;"ARRAY" A,B,X;
 "BEGIN" "REAL" ANORM,BNORM,ANI,BNI,CONST,A10,A20,A30,B11,
     B22,B33,B44,A11,A12,A21,A22,A33,A34,A43,A44,B12,B34,OLD1,OLD2;
     "INTEGER" I,Q,M,M1,Q1,J,K,K1,K2,K3,KM1;"BOOLEAN" STATIONARY;
     ANORM:=BNORM:=0;"FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" BNI:=0;ITER[I]:=0;ANI:="IF" I>1"THEN"ABS(A[I,I-1])"ELSE" 0;
         "FOR" J:=I "STEP" 1 "UNTIL" N "DO"
         "BEGIN" ANI:=ANI+ABS(A[I,J]);BNI:=BNI+ABS(B[I,J])
         "END";"IF" ANI>ANORM "THEN" ANORM:=ANI;"IF" BNI>BNORM"THEN"
         BNORM:=BNI
     "END";"IF" ANORM=0 "THEN" ANORM:=EPS;"IF"BNORM=0 "THEN" BNORM:=EPS;
     EPSA:=EPS*ANORM;EPSB:=EPS*BNORM;
     "FOR" M:=N,M "WHILE" M>=3 "DO"
   "BEGIN"
     "FOR" I:=M+1,I-1 "WHILE"("IF" I>1 "THEN"ABS(A[I,I-1])>EPSA "ELSE"
     "FALSE") "DO" Q:=I-1;
     "IF" Q>1 "THEN" A[Q,Q-1]:=0;
  L: "IF" Q>=M-1 "THEN" M:=Q-1 "ELSE"
     "BEGIN"
         "IF" ABS(B[Q,Q])<=EPSB "THEN"
         "BEGIN" B[Q,Q]:=0;Q1:=Q+1;
             HSH2COL(Q,Q,N,Q,A[Q,Q],A[Q1,Q],A,B);A[Q1,Q]:=0;
             Q:=Q1;"GOTO" L
         "END" "ELSE" M1:=M-1;Q1:=Q+1;CONST:=0.75;ITER[M]:=ITER[M]+1;
         STATIONARY:="IF" ITER[M]=1 "THEN" "TRUE" "ELSE"
         ABS(A[M,M-1])>=CONST*OLD1"AND"ABS(A[M-1,M-2])>=CONST*OLD2;
         "IF" ITER[M]>30"AND"STATIONARY "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" ITER[I]:=-1;
             "GOTO" OUT
         "END";
         "IF" ITER[M]=10"AND"STATIONARY "THEN"
         "BEGIN" A10:=0;A20:=1;A30:=1.1605
         "END" "ELSE"
         "BEGIN" B11:=B[Q,Q];B22:="IF" ABS(B[Q1,Q1])<EPSB "THEN"EPSB
             "ELSE" B[Q1,Q1];
                                                               "COMMENT"
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 22
                                                                 ;
 
 
             B33:="IF" ABS(B[M1,M1])<EPSB "THEN" EPSB "ELSE"B[M1,M1];
             B44:="IF" ABS(B[M,M])<EPSB "THEN" EPSB "ELSE" B[M,M] ;
             A11:=A[Q,Q]/B11;A12:=A[Q,Q1]/B22;A21:=A[Q1,Q]/B11;
             A22:=A[Q1,Q1]/B22;A33:=A[M1,M1]/B33;A34:=A[M1,M]/B44;
             A43:=A[M,M1]/B33;A44:=A[M,M]/B44;B12:=B[Q,Q1]/B22;
             B34:=B[M1,M]/B44;
             A10:=((A33-A11)*(A44-A11)-A34*A43+A43*B34*A11)/A21
                  +A12-A11*B12;
             A20:=(A22-A11-A21*B12)-(A33-A11)-(A44-A11)+A43*B34;
             A30:=A[Q+2,Q1]/B22
         "END";OLD1:=ABS(A[M,M-1]);OLD2:=ABS(A[M-1,M-2]);
         "FOR" K:=Q "STEP" 1 "UNTIL" M1 "DO"
         "BEGIN" K1:=K+1;K2:=K+2;K3:="IF" K+3>M "THEN" M "ELSE" K+3;
             KM1:="IF" K-1<Q "THEN" Q "ELSE" K-1;
             "IF" K^=M1 "THEN"
             "BEGIN" "IF" K=Q "THEN"
                 HSH3COL(KM1,KM1,N,K,A10,A20,A30,A,B) "ELSE"
                 "BEGIN"
                  HSH3COL(KM1,KM1,N,K,A[K,KM1],A[K1,KM1],A[K2,KM1],A,B);
                   A[K1,KM1]:=A[K2,KM1]:=0
                 "END";
                 HSH3ROW3(1,K3,N,K,B[K2,K2],B[K2,K1],B[K2,K],A,B,X);
                 B[K2,K]:=B[K2,K1]:=0 ;
             "END" "ELSE"
             "BEGIN" HSH2COL(KM1,KM1,N,K,A[K,KM1],A[K1,KM1],A,B);
                 A[K1,KM1]:=0
             "END";
             HSH2ROW3(1,K3,K3,N,K,B[K1,K1],B[K1,K],A,B,X);B[K1,K]:=0
         "END"
     "END"
   "END"; OUT:
 "END" QZIT;
 "PROCEDURE" QZVAL(N,A,B,X,EPSA,EPSB,ALFR,ALFI,BETA);"VALUE" N;
 "REAL" EPSA,EPSB;"INTEGER" N;"ARRAY" ALFR,ALFI,BETA,A,B,X;
 "BEGIN" "INTEGER" M,L,J;"REAL" AN,BN,A11,A12,A21,A22,B11,B12,B22,E,C,D,
     ER,EI,A11R,A11I,A12R,A12I,A21R,A21I,A22R,A22I,CZ,SZR,SZI,
     CQ,SQR,SQI,SSR,SSI,TR,TI,BDR,BDI,R;
     "FOR" M:=N,M "WHILE" M>0 "DO"
     "IF"("IF" M>1 "THEN" A[M,M-1]=0 "ELSE" "TRUE")"THEN"
     "BEGIN" ALFR[M]:=A[M,M];BETA[M]:=B[M,M];ALFI[M]:=0;M:=M-1
     "END" "ELSE"
     "BEGIN" L:=M-1;"IF" ABS(B[L,L])<=EPSB "THEN"
         "BEGIN" B[L,L]:=0;HSH2COL(L,L,N,L,A[L,L],A[M,L],A,B);
             A[M,L]:=B[M,L]:=0;ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];
             BETA[L]:=B[L,L];BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END" "ELSE" "IF" ABS(B[M,M])<=EPSB "THEN"
         "BEGIN"B[M,M]:=0;HSH2ROW3(1,M,M,N,L,A[M,M],A[M,L],A,B,X);
             A[M,L]:=B[M,L]:=0;ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];
             BETA[L]:=B[L,L];BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END""ELSE"
       "BEGIN"
         AN:=ABS(A[L,L])+ABS(A[L,M])+ABS(A[M,L])+ABS(A[M,M]);
                                                               "COMMENT"
1SECTION : 3.4.1.2            (FEBRUARY 1979)                    PAGE 23
                                                                 ;
 
 
         BN:=ABS(B[L,L])+ABS(B[L,M])+ABS(B[M,M]);
         A11:=A[L,L]/AN;A12:=A[L,M]/AN;A21:=A[M,L]/AN;A22:=A[M,M]/AN;
         B11:=B[L,L]/BN;B12:=B[L,M]/BN;B22:=B[M,M]/BN;
         E:=A11/B11;
         C:=((A22-E*B22)/B22-(A21*B12)/(B11*B22))/2;
         D:=C*C+(A21*(A12-E*B12))/(B11*B22);
         "IF" D>=0 "THEN"
         "BEGIN"E:=E+("IF"C<0"THEN"C-SQRT(D)"ELSE"C+SQRT(D));
             A11:=A11-E*B11;A12:=A12-E*B12;A22:=A22-E*B22;
             "IF" ABS(A11)+ABS(A12)>=ABS(A21)+ABS(A22) "THEN"
             HSH2ROW3(1,M,M,N,L,A12,A11,A,B,X)"ELSE"
             HSH2ROW3(1,M,M,N,L,A22,A21,A,B,X);
             "IF"AN>=ABS(E)*BN"THEN"
             HSH2COL(L,L,N,L,B[L,L],B[M,L],A,B) "ELSE"
             HSH2COL(L,L,N,L,A[L,L],A[M,L],A,B);
             A[M,L]:=B[M,L]:=0;
             ALFR[L]:=A[L,L];ALFR[M]:=A[M,M];BETA[L]:=B[L,L];
             BETA[M]:=B[M,M];ALFI[M]:=ALFI[L]:=0;
         "END""ELSE"
         "BEGIN"
             ER:=E+C;EI:=SQRT(-D);A11R:=A11-ER*B11;A11I:=EI*B11;
             A12R:=A12-ER*B12;A12I:=EI*B12;A21R:=A21;A21I:=0;
             A22R:=A22-ER*B22;A22I:=EI*B22;
             "IF"ABS(A11R)+ABS(A11I)+ABS(A12R)+ABS(A12I)>=
             ABS(A21R)+ABS(A22R)+ABS(A22I)"THEN"
             CHSH2(A12R,A12I,-A11R,-A11I,CZ,SZR,SZI)"ELSE"
             CHSH2(A22R,A22I,-A21R,-A21I,CZ,SZR,SZI);
             "IF"AN>=(ABS(ER)+ABS(EI))*BN"THEN"
             CHSH2(CZ*B11+SZR*B12,SZI*B12,SZR*B22,SZI*B22,CQ,SQR,SQI)
             "ELSE"CHSH2(CZ*A11+SZR*A12,SZI*A12,CZ*A21+SZR*A22,SZI*A22,
             CQ,SQR,SQI);SSR:=SQR*SZR+SQI*SZI;SSI:=SQR*SZI-SQI*SZR;
             TR:=CQ*CZ*A11+CQ*SZR*A12+SQR*CZ*A21+SSR*A22;
             TI:=CQ*SZI*A12-SQI*CZ*A21+SSI*A22;
             BDR:=CQ*CZ*B11+CQ*SZR*B12+SSR*B22;
             BDI:=CQ*SZI*B12+SSI*B22;
             R:=SQRT(BDR*BDR+BDI*BDI);BETA[L]:=BN*R;
             ALFR[L]:=AN*(TR*BDR+TI*BDI)/R;
             ALFI[L]:=AN*(TR*BDI-TI*BDR)/R;
             TR:=SSR*A11-SQR*CZ*A12-CQ*SZR*A21+CQ*CZ*A22;
             TI:=-SSI*A11-SQI*CZ*A12+CQ*SZI*A21;
             BDR:=SSR*B11-SQR*CZ*B12+CQ*CZ*B22;
             BDI:=-SSI*B11-SQI*CZ*B12;
             R:=SQRT(BDR*BDR+BDI*BDI);BETA[M]:=BN*R;
             ALFR[M]:=AN*(TR*BDR+TI*BDI)/R;
             ALFI[M]:=AN*(TR*BDI-TI*BDR)/R;
         "END"
       "END";M:=M-2
     "END"
 "END" QZVAL
 
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 24
                                                                 ;
 
 
 "PROCEDURE" QZVEC(N,A,B,X,EPSA,EPSB,ALFR,ALFI,BETA);"VALUE"N,EPSA,EPSB;
 "INTEGER" N;"REAL" EPSA,EPSB;"ARRAY" A,B,ALFR,ALFI,BETA,X;
 "BEGIN""INTEGER" M,MR,MI,L,L1,J,K;"REAL" BETM,ALFM,SL,SK,D,TKK,TKL,TLK,
     TLL,ALMI,ALMR,TR,TI,SLR,SLI,SKR,SKI,DR,DI,TKKR,TKKI,TKLR,TKLI,TLKR,
     TLKI,TLLR,TLLI,S,R;
     "FOR" M:=N "STEP" -1 "UNTIL" 1 "DO"
     "IF" ALFI[M]=0 "THEN"
     "BEGIN" "COMMENT" M-TH REAL VECTOR;
         ALFM:=ALFR[M];BETM:=BETA[M];B[M,M]:=1;L1:=M;
         "FOR" L:=M-1 "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" SL:=0;
             "FOR" J:=L1 "STEP" 1 "UNTIL" M "DO"
             SL:=SL+(BETM*A[L,J]-ALFM*B[L,J])*B[J,M];
             "IF"("IF"L^=1"THEN"BETM*A[L,L-1]=0"ELSE""TRUE")"THEN"
             "BEGIN""COMMENT" 1-1 BLOCK;
                 D:=BETM*A[L,L]-ALFM*B[L,L];
                 "IF" D=0 "THEN" D:=(EPSA+EPSB)/2;B[L,M]:=-SL/D
             "END""ELSE"
             "BEGIN" "COMMENT" 2-2 BLOCK;K:=L-1;SK:=0;
                 "FOR"J:=L1 "STEP" 1 "UNTIL" M "DO"
                 SK:=SK+(BETM*A[K,J]-ALFM*B[K,J])*B[J,M];
                 TKK:=BETM*A[K,K]-ALFM*B[K,K];
                 TKL:=BETM*A[K,L]-ALFM*B[K,L];
                 TLK:=BETM*A[L,K];
                 TLL:=BETM*A[L,L]-ALFM*B[L,L];
                 D:=TKK*TLL-TKL*TLK;"IF" D=0 "THEN" D:=(EPSA+EPSB)/2;
                 B[L,M]:=(TLK*SK-TKK*SL)/D;
                B[K,M]:="IF"ABS(TKK)>=ABS(TLK)"THEN"-(SK+TKL*B[L,M])/TKK
                 "ELSE" -(SL+TLL*B[L,M])/TLK;L:=L-1
             "END";L1:=L
         "END"
     "END""ELSE"
     "BEGIN" "COMMENT" COMPLEX VECTOR;
         ALMR:=ALFR[M-1];ALMI:=ALFI[M-1];BETM:=BETA[M-1];MR:=M-1;MI:=M;
         B[M-1,MR]:=ALMI*B[M,M]/(BETM*A[M,M-1]);
         B[M-1,MI]:=(BETM*A[M,M]-ALMR*B[M,M])/(BETM*A[M,M-1]);
         B[M,MR]:=0;B[M,MI]:=-1;L1:=M-1;
         "FOR" L:=M-2 "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" SLR:=SLI:=0;
             "FOR" J:=L1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" TR:=BETM*A[L,J]-ALMR*B[L,J];
                 TI:=-ALMI*B[L,J];
                 SLR:=SLR+TR*B[J,MR]-TI*B[J,MI];
                 SLI:=SLI+TR*B[J,MI]+TI*B[J,MR]
             "END";
                                                               "COMMENT"
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 25
                                                                 ;
 
 
             "IF"("IF"L^=1"THEN"BETM*A[L,L-1]=0"ELSE""TRUE")"THEN"
             "BEGIN"DR:=BETM*A[L,L]-ALMR*B[L,L];
                 DI:=-ALMI*B[L,L];
                 COMDIV(-SLR,-SLI,DR,DI,B[L,MR],B[L,MI]);
             "END""ELSE"
             "BEGIN" K:=L-1;SKR:=SKI:=0;
                 "FOR" J:=L1 "STEP" 1 "UNTIL" M "DO"
                 "BEGIN" TR:=BETM*A[K,J]-ALMR*B[K,J];
                     TI:=-ALMI*B[K,J];
                     SKR:=SKR+TR*B[J,MR]-TI*B[J,MI];
                     SKI:=SKI+TR*B[J,MI]+TI*B[J,MR]
                 "END";
                 TKKR:=BETM*A[K,K]-ALMR*B[K,K];
                 TKKI:=-ALMI*B[K,K];
                 TKLR:=BETM*A[K,L]-ALMR*B[K,L];
                 TKLI:=-ALMI*B[K,L];
                 TLKR:=BETM*A[L,K];TLKI:=0;
                 TLLR:=BETM*A[L,L]-ALMR*B[L,L];
                 TLLI:=-ALMI*B[L,L];
                 DR:=TKKR*TLLR-TKKI*TLLI-TKLR*TLKR;
                 DI:=TKKR*TLLI+TKKI*TLLR-TKLI*TLKR;
                 "IF"DR=0"AND"DI=0"THEN"DR:=(EPSA+EPSB)/2;
                 COMDIV(TLKR*SKR-TKKR*SLR+TKKI*SLI,TLKR*SKI-TKKR*SLI-
                 TKKI*SLR,DR,DI,B[L,MR],B[L,MI]);
                 "IF"ABS(TKKR)+ABS(TKKI)>=ABS(TLKR)"THEN"
                 COMDIV(-SKR-TKLR*B[L,MR]+TKLI*B[L,MI],-SKI-TKLR*B[L,MI]
                 -TKLI*B[L,MR],TKKR,TKKI,B[K,MR],B[K,MI])"ELSE"
                 COMDIV(-SLR-TLLR*B[L,MR]+TLLI*B[L,MI],-SLI-TLLR*B[L,MI]
                 -TLLI*B[L,MR],TLKR,TLKI,B[K,MR],B[K,MI]);L:=L-1
             "END";L1:=L
         "END";M:=M-1
     "END";
     "FOR" M:=N "STEP" -1 "UNTIL" 1 "DO"
     "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
     X[K,M]:=MATMAT(1,M,K,M,X,B);
     "FOR" M:=N "STEP" -1 "UNTIL" 1 "DO"
     "BEGIN" S:=0;"IF" ALFI[M]=0 "THEN"
         "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" R:=ABS(X[K,M]);
                 "IF" R>=S "THEN""BEGIN" S:=R;D:=X[K,M] "END"
             "END";"FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
             X[K,M]:=X[K,M]/D
         "END""ELSE"
         "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" R:=ABS(X[K,M-1])+ABS(X[K,M]);
                 R:=R*SQRT((X[K,M-1]/R)**2+(X[K,M]/R)**2);
                 "IF" R>=S"THEN"
                 "BEGIN" S:=R;DR:=X[K,M-1];DI:=X[K,M] "END"
             "END";"FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
             COMDIV(X[K,M-1],X[K,M],DR,DI,X[K,M-1],X[K,M]);M:=M-1
         "END"
     "END"
 "END" QZVEC;
                                                               "COMMENT"
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 26
                                                                 ;
 
 
 DWARF:=EM[0];EPS:=EM[1];
 HSHDECMUL(N,A,B,DWARF);
 HESTGL3(N,A,B,X);
 QZIT(N,A,B,X,EPS,EPSA,EPSB,ITER);
 QZVAL(N,A,B,X,EPSA,EPSB,ALFR,ALFI,BETA);
 QZVEC(N,A,B,X,EPSA,EPSB,ALFR,ALFI,BETA)
 "END" QZI;
         "EOP"
 
 
 
0"CODE" 34602;
 "PROCEDURE" HSHDECMUL(N,A,B,DWARF);"VALUE"N,DWARF;"INTEGER"N;
 "REAL" DWARF;"ARRAY" A,B;
 "BEGIN"  "ARRAY" V[1:N];"INTEGER" J,K,K1,N1;"REAL" R,T,C;
     K:=1;N1:=N+1;
     "FOR" K1:=2 "STEP" 1 "UNTIL" N1 "DO"
     "BEGIN" R:=TAMMAT(K1,N,K,K,B,B);
         "IF" R>DWARF "THEN"
         "BEGIN" R:="IF" B[K,K]<0 "THEN" -SQRT(R+B[K,K]*B[K,K])
             "ELSE" SQRT(R+B[K,K]*B[K,K]);T:=B[K,K]+R;C:=-T/R;
             B[K,K]:=-R;V[K]:=1;
             "FOR" J:=K1 "STEP" 1 "UNTIL" N "DO" V[J]:=B[J,K]/T;
             HSHVECMAT(K,N,K1,N,C,V,B);HSHVECMAT(K,N,1,N,C,V,A)
         "END";K:=K1
     "END"
 "END" HSHDECMUL;
         "EOP"
 
0"CODE" 34603;
 "PROCEDURE" HESTGL3(N,A,B,X);"VALUE" N;"INTEGER" N;"ARRAY" A,B,X;
 "BEGIN" "INTEGER" NM1,K,L,K1,L1;
     "IF" N>2 "THEN"
     "BEGIN" "FOR" K:=2 "STEP" 1 "UNTIL" N "DO"
         "FOR" L:=1 "STEP" 1 "UNTIL" K-1 "DO" B[K,L]:=0;
         NM1:=N-1;K:=1;
         "FOR" K1:= 2 "STEP" 1 "UNTIL" NM1 "DO"
         "BEGIN" L1:=N;
             "FOR" L:=N-1 "STEP" -1 "UNTIL" K1 "DO"
             "BEGIN"
                 HSH2COL(K,L,N,L,A[L,K],A[L1,K],A,B);A[L1,K]:=0;
                 HSH2ROW3(1,N,L1,N,L,B[L1,L1],B[L1,L],A,B,X);
                 B[L1,L]:=0;L1:=L
             "END";K:=K1
         "END"
     "END"
 "END" HESTGL3
 
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 27
 
 
                                                                  ;
         "EOP"
0"CODE" 34604;
 "PROCEDURE" HESTGL2(N,A,B);"VALUE" N;"INTEGER" N;"ARRAY" A,B;
 "BEGIN" "INTEGER" NM1,K,L,K1,L1;
     "IF" N>2 "THEN"
     "BEGIN" "FOR" K:=2 "STEP" 1 "UNTIL" N "DO"
         "FOR" L:=1 "STEP" 1 "UNTIL" K-1 "DO" B[K,L]:=0;
         NM1:=N-1;K:=1;
         "FOR" K1:= 2 "STEP" 1 "UNTIL" NM1 "DO"
         "BEGIN" L1:=N;
             "FOR" L:=N-1 "STEP" -1 "UNTIL" K1 "DO"
             "BEGIN"
                 HSH2COL(K,L,N,L,A[L,K],A[L1,K],A,B);A[L1,K]:=0;
                 HSH2ROW2(1,1,N,L1,L,B[L1,L1],B[L1,L],A,B);
                 B[L1,L]:=0;L1:=L
             "END";K:=K1
         "END"
     "END"
 "END" HESTGL2;
         "EOP"
 
0"CODE" 34605;
 "PROCEDURE" HSH2COL(LA,LB,U,I,A1,A2,A,B);"VALUE" LA,LB,U,I,A1,A2;
 "INTEGER" LA,LB,U,I;"REAL" A1,A2;"ARRAY" A,B;
 "IF"A2^=0 "THEN"
 "BEGIN" "REAL" R,T,C;"ARRAY" V[I:I+1];
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2) "ELSE" SQRT(A1*A1+A2*A2);
     T:=A1+R;C:=-T/R;V[I]:=1;V[I+1]:=A2/T;
     HSHVECMAT(I,I+1,LA,U,C,V,A);HSHVECMAT(I,I+1,LB,U,C,V,B)
 "END" HSH2COL;
         "EOP"
 
0"CODE" 34606;
 "PROCEDURE" HSH3COL(LA,LB,U,I,A1,A2,A3,A,B);
 "VALUE"LA,LB,U,I,A1,A2,A3;"INTEGER"LA,LB,I,U;"REAL"A1,A2,A3;"ARRAY"A,B;
 "IF" A2^=0 "OR" A3^=0 "THEN"
 "BEGIN" "REAL" R,T,C;"ARRAY" V[I:I+2];
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2+A3*A3)
     "ELSE" SQRT(A1*A1+A2*A2+A3*A3);
     T:=A1+R;C:=-T/R;V[I]:=1;V[I+1]:=A2/T;V[I+2]:=A3/T;
     HSHVECMAT(I,I+2,LA,U,C,V,A);HSHVECMAT(I,I+2,LB,U,C,V,B)
 "END" HSH3COL
 
1SECTION : 3.4.1.2            (JANUARY 1976)                     PAGE 28
 
 
                                                                  ;
         "EOP"
0"CODE" 34607;
 "PROCEDURE" HSH2ROW3(L,UA,UB,UX,J,A1,A2,A,B,X);"VALUE" L,UA,UB,UX,
 J,A1,A2;"INTEGER" L,UA,UB,UX,J;"REAL" A1,A2;"ARRAY" A,B,X;
 "IF"A2^=0 "THEN"
 "BEGIN""REAL" R,T,C;"INTEGER" K;"ARRAY" V[J:J+1];
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2) "ELSE" SQRT(A1*A1+A2*A2);
     T:=A1+R;C:=-T/R;V[J+1]:=1;V[J]:=A2/T;
     HSHVECTAM(L,UA,J,J+1,C,V,A);HSHVECTAM(L,UB,J,J+1,C,V,B);
     HSHVECTAM(1,UX,J,J+1,C,V,X)
 "END" HSH2ROW3;
         "EOP"
 
0"CODE" 34608;
 "PROCEDURE" HSH2ROW2(LA,LB,UA,UB,J,A1,A2,A,B);"VALUE"LA,LB,UA,UB,
 J,A1,A2;"INTEGER" LA,LB,UA,UB,J;"REAL" A1,A2;"ARRAY" A,B;
 "IF"A2^=0 "THEN"
 "BEGIN" "REAL" R,T,C;"INTEGER" K;"ARRAY" V[J:J+1];
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2) "ELSE" SQRT(A1*A1+A2*A2);
     T:=A1+R;C:=-T/R;V[J+1]:=1;V[J]:=A2/T;
     HSHVECTAM(LA,UA,J,J+1,C,V,A);HSHVECTAM(LB,UB,J,J+1,C,V,B)
 "END" HSH2ROW2;
         "EOP"
 
0"CODE" 34609;
 "PROCEDURE" HSH3ROW3(L,U,UX,J,A1,A2,A3,A,B,X);
 "VALUE"L,U,UX,J,A1,A2,A3;"INTEGER"L,J,U,UX;"REAL"A1,A2,A3;"ARRAY"A,B,X;
 "IF" A2^=0 "OR" A3^=0 "THEN"
 "BEGIN" "REAL" R,T,C;"ARRAY" V[J:J+2];"INTEGER" K;
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2+A3*A3)
     "ELSE" SQRT(A1*A1+A2*A2+A3*A3);
     T:=A1+R;C:=-T/R;V[J+2]:=1;V[J+1]:=A2/T;V[J]:=A3/T;
     HSHVECTAM(L,U,J,J+2,C,V,A);HSHVECTAM(L,U,J,J+2,C,V,B);
     HSHVECTAM(L,UX,J,J+2,C,V,X)
 "END" HSH3ROW3;
         "EOP"
 
0"CODE" 34610;
 "PROCEDURE" HSH3ROW2(LA,LB,U,J,A1,A2,A3,A,B);
 "VALUE"LA,LB,U,J,A1,A2,A3;"INTEGER"LA,LB,U,J;"REAL"A1,A2,A3;"ARRAY"A,B;
 "IF" A2^=0 "OR" A3^=0 "THEN"
 "BEGIN" "REAL" R,T,C;"ARRAY" V[J:J+2];
     R:="IF" A1<0 "THEN" -SQRT(A1*A1+A2*A2+A3*A3)
     "ELSE" SQRT(A1*A1+A2*A2+A3*A3);
     T:=A1+R;C:=-T/R;V[J+2]:=1;V[J+1]:=A2/T;V[J]:=A3/T;
     HSHVECTAM(LA,U,J,J+2,C,V,A);HSHVECTAM(LB,U,J,J+2,C,V,B)
 "END" HSH3ROW2;
         "EOP"
1SECTION : 3.5.1.1            (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHORS : G.H.GOLUB AND C.REINSCH
 
 
 CONTRIBUTOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 
 RECEIVED : 731217
 
 
 BRIEF DESCRIPTION :
     THIS   SECTION   CONTAINS   TWO   PROCEDURES,    QRISNGVALBID   AND
     QRISNGVALDECBID. BOTH PROCEDURES CALCULATE THE SINGULAR VALUES OF A
     BIDIAGONAL MATRIX.  MOREOVER,  THE SECOND PROCEDURE  CALCULATES THE
     THE  SINGULAR VALUES DECOMPOSITION  OF A FULL MATRIX  OF WHICH  THE
     BIDIAGONAL AND THE PRE- AND POSTMULTIPLYING MATRICES, AS CALCULATED
     BY HSHREABID ARE GIVEN.
 
 
 KEYWORDS :
     SINGULAR VALUES
     QR ITERATION
     BIDIAGONAL MATRICES
 
 
1SECTION : 3.5.1.1            (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION : QRISNGVALBID
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" QRISNGVALBID(D, B, N, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" D, B, EM;
     "CODE" 34270;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     D:  <ARRAY IDENTIFIER>;
         "ARRAY" D[1:N];
         ENTRY: THE DIAGONAL OF THE BIDIAGONAL MATRIX;
         EXIT: THE SINGULAR VALUES;
     B:  <ARRAY IDENTIFIER>;
         "ARRAY" B[1:N];
         ENTRY: THE SUPER DIAGONAL OF THE BIDIAGONAL MATRIX,IN B[1:N-1];
     N:  <ARITHMETIC EXPRESSION>;
         THE LENGTH OF B AND D;
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[1:7];
         ENTRY: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[2]: THE RELATIVE PRECISION IN THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                    SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
     MOREOVER :
     QRISNGVALBID:=  THE NUMBER OF  SINGULAR VALUES  NOT FOUND,  I.E.  A
         NUMBER NOT  EQUAL TO ZERO  IF THE NUMBER OF  ITERATIONS EXCEEDS
         EM[4].
 
 
 PROCEDURES USED : NONE
 
 REQUIRED CENTRAL MEMORY : NO AUXILIARY ARRAYS ARE DECLARED
 
 
 RUNNING TIME :
     THE RUNNING TIME DEPENDS STRONGLY UPON THE PROPERTIES OF THE MATRIX
 
 
 METHOD AND PERFORMANCE :
     THE METHOD  IS DESCRIBED  IN DETAIL   IN [1].  THIS PROCEDURE  IS A
     REWRITING  OF  PART  OF  THE  PROCEDURE   SVD  PUBLISHED  THERE  BY
     G.H.GOLUB AND C.REINSCH.
 
 
 LANGUAGE : ALGOL 60.
 
 
1SECTION : 3.5.1.1            (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION : QRISNGVALDECBID
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" QRISNGVALDECBID(D, B, M, N, U, V, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" D, B, U, V, EM;
     "CODE" 34271;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     D:  <ARRAY IDENTIFIER>;
         "ARRAY" D[1:N];
         ENTRY: THE DIAGONAL OF THE BIDIAGONAL MATRIX;
         EXIT: THE SINGULAR VALUES;
     B:  <ARRAY IDENTIFIER>;
         "ARRAY" B[1:N];
         ENTRY: THE SUPER DIAGONAL OF THE BIDIAGONAL MATRIX,IN B[1:N-1];
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF THE MATRIX U;
     N:  <ARITHMETIC EXPRESSION>;
         THE LENGTH OF  B  AND  D,  THE NUMBER OF COLUMNS OF  U  AND THE
         NUMBER OF COLUMNS AND ROWS OF V;
     U:  <ARRAY IDENTIFIER>;
         "ARRAY" U[1:M,1:N];
         ENTRY:  THE  PREMULTIPLYING  MATRIX  AS  PRODUCED  BY PRETFMMAT
             (SECTION 3.2.2.1.1);
         EXIT:  THE  PREMULTIPLYING  MATRIX  U  OF  THE  SINGULAR VALUES
             DECOMPOSITION U * S * V';
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         ENTRY:  THE TRANSPOSE OF THE POSTMULTIPLYING MATRIX AS PRODUCED
             BY PSTTFMMAT (SECTION 3.2.2.1.1);
         EXIT:  THE  TRANSPOSE  OF  THE POSTMULTIPLYING MATRIX  V OF THE
             SINGULAR VALUES DECOMPOSITION;
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[1:7];
         ENTRY: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[2]: THE RELATIVE PRECISION IN THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                 SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
     MOREOVER :
     QRISNGVALDECBID:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E.  A
         NUMBER NOT  EQUAL TO ZERO  IF THE NUMBER OF  ITERATIONS EXCEEDS
         EM[4].
 
1SECTION : 3.5.1.1            (DECEMBER 1975)                     PAGE 4
 
 
 
 PROCEDURES USED :
 
     ROTCOL = CP34040
 
 REQUIRED CENTRAL MEMORY : NO AUXILIARY ARRAYS ARE DECLARED
 
 
 RUNNING TIME :
     THE RUNNING TIME DEPENDS STRONGLY UPON THE PROPERTIES OF THE MATRIX
 
 METHOD AND PERFORMANCE :
     THE METHOD  IS DESCRIBED  IN DETAIL   IN [1].  THIS PROCEDURE  IS A
     REWRITING  OF  PART  OF  THE  PROCEDURE   SVD  PUBLISHED  THERE  BY
     G.H.GOLUB AND C.REINSCH.
 
 
 LANGUAGE : ALGOL 60
 
 
 REFERENCES :
     [1] WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL. 2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
 
 
 EXAMPLE OF USE :
     FOR AN EXAMPLE OF USE ONE IS REFERRED TO SECTION  3.5.1.2
 
 
 SOURCE TEXT(S):
0"CODE" 34270;
 "INTEGER" "PROCEDURE" QRISNGVALBID(D, B, N, EM);
 "VALUE" N; "INTEGER" N; "ARRAY" D, B, EM;
 "BEGIN" "INTEGER" N1, K, K1, I, I1, COUNT, MAX, RNK;
     "REAL" TOL, BMAX, Z, X, Y, G, H, F, C, S, MIN;
     TOL:= EM[2] * EM[1]; COUNT:= 0; BMAX:= 0; MAX:= EM[4]; MIN:= EM[6];
     RNK:= N;
 IN: K:= N; N1:= N - 1;
 NEXT: K:= K - 1; "IF" K > 0 "THEN"
     "BEGIN" "IF" ABS(B[K]) >= TOL "THEN"
         "BEGIN" "IF" ABS(D[K]) >= TOL "THEN" "GOTO" NEXT;
             C:= 0; S:= 1;
             "FOR" I:= K "STEP" 1 "UNTIL" N1 "DO"
             "BEGIN" F:= S * B[I]; B[I]:= C * B[I]; I1:= I + 1;
                 "IF" ABS(F) < TOL "THEN" "GOTO" NEGLECT;
                 G:= D[I1]; D[I1]:= H:= SQRT(F * F + G * G);
                 C:= G / H; S:= - F / H
             "END"
1SECTION : 3.5.1.1            (JULY 1974)                         PAGE 5
                                                                  ;
 
 
         NEGLECT:
         "END"
         "ELSE" "IF" ABS(B[K]) > BMAX "THEN" BMAX:= ABS(B[K])
     "END";
     "IF" K = N1 "THEN"
     "BEGIN" "IF" D[N] < 0 "THEN" D[N]:= - D[N];
         "IF" D[N] <= MIN "THEN" RNK:= RNK - 1; N:= N1
     "END"
     "ELSE"
     "BEGIN" COUNT:= COUNT + 1; "IF" COUNT > MAX "THEN" "GOTO" END;
         K1:= K + 1; Z:= D[N]; X:= D[K1]; Y:= D[N1];
         G:= "IF" N1 = 1 "THEN" 0 "ELSE" B[N1 - 1]; H:= B[N1];
         F:= ((Y - Z) * (Y + Z) + (G - H) * (G + H)) / (2 * H * Y);
         G:= SQRT(F * F + 1);
         F:= ((X - Z) * (X + Z) + H * (Y / ("IF" F < 0 "THEN" F - G
         "ELSE" F + G) - H)) / X; C:= S:= 1;
         "FOR" I:= K1 + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" I1:= I - 1; G:= B[I1]; Y:= D[I]; H:= S * G; G:= C * G;
             Z:= SQRT(F * F + H * H); C:= F / Z; S:= H / Z;
             "IF" I1 ^= K1 "THEN" B[I1 - 1]:= Z; F:= X * C + G * S;
             G:= G * C - X * S; H:= Y * S; Y:= Y * C;
             D[I1]:= Z:= SQRT(F * F + H * H); C:= F / Z; S:= H / Z;
             F:= C * G + S * Y; X:= C * Y - S * G
         "END";
         B[N1]:= F; D[N]:= X
     "END";
     "IF" N > 0 "THEN" "GOTO" IN;
 END: EM[3]:= BMAX; EM[5]:= COUNT; EM[7]:= RNK; QRISNGVALBID:= N
 "END" QRISNGVALBID;
         "EOP"
0"CODE" 34271;
 "INTEGER" "PROCEDURE" QRISNGVALDECBID(D, B, M, N, U, V, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" D, B, U, V, EM;
 "BEGIN" "INTEGER" N0, N1, K, K1, I, I1, COUNT, MAX, RNK;
     "REAL" TOL, BMAX, Z, X, Y, G, H, F, C, S, MIN;
 
                                                             "COMMENT"
1SECTION : 3.5.1.1            (JULY 1974)                         PAGE 6
                                                                  ;
 
 
 
     TOL:= EM[2] * EM[1]; COUNT:= 0; BMAX:= 0; MAX:= EM[4]; MIN:= EM[6];
     RNK:= N0:= N;
 IN: K:= N; N1:= N - 1;
 NEXT: K:= K - 1; "IF" K > 0 "THEN"
     "BEGIN" "IF" ABS(B[K]) >= TOL "THEN"
         "BEGIN" "IF" ABS(D[K]) >= TOL "THEN" "GOTO" NEXT;
             C:= 0; S:= 1;
             "FOR" I:= K "STEP" 1 "UNTIL" N1 "DO"
             "BEGIN" F:= S * B[I]; B[I]:= C * B[I]; I1:= I + 1;
                 "IF" ABS(F) < TOL "THEN" "GOTO" NEGLECT;
                 G:= D[I1]; D[I1]:= H:= SQRT(F * F + G * G);
                 C:= G / H; S:= - F / H;
                 ROTCOL(1, M, K, I1, U, C, S)
             "END";
         NEGLECT:
         "END"
         "ELSE" "IF" ABS(B[K]) > BMAX "THEN" BMAX:= ABS(B[K])
     "END";
     "IF" K = N1 "THEN"
     "BEGIN" "IF" D[N] < 0 "THEN"
         "BEGIN" D[N]:= - D[N];
             "FOR" I:= 1 "STEP" 1 "UNTIL" N0 "DO" V[I,N]:= - V[I,N]
         "END";
         "IF" D[N] <= MIN "THEN" RNK:= RNK - 1; N:= N1
     "END"
     "ELSE"
     "BEGIN" COUNT:= COUNT + 1; "IF" COUNT > MAX "THEN" "GOTO" END;
         K1:= K + 1; Z:= D[N]; X:= D[K1]; Y:= D[N1];
         G:= "IF" N1 = 1 "THEN" 0 "ELSE" B[N1 - 1]; H:= B[N1];
         F:= ((Y - Z) * (Y + Z) + (G - H) * (G + H)) / (2 * H * Y);
         G:= SQRT(F * F + 1);
         F:= ((X - Z) * (X + Z) + H * (Y / ("IF" F < 0 "THEN" F - G
         "ELSE" F + G) - H)) / X; C:= S:= 1;
         "FOR" I:= K1 + 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" I1:= I - 1; G:= B[I1]; Y:= D[I]; H:= S * G; G:= C * G;
             Z:= SQRT(F * F + H * H); C:= F / Z; S:= H / Z;
             "IF" I1 ^= K1 "THEN" B[I1 - 1]:= Z; F:= X * C + G * S;
             G:= G * C - X * S; H:= Y * S; Y:= Y * C;
             ROTCOL(1, N0, I1, I, V, C, S);
             D[I1]:= Z:= SQRT(F * F + H * H); C:= F / Z; S:= H / Z;
             F:= C * G + S * Y; X:= C * Y - S * G;
             ROTCOL(1, M, I1, I, U, C, S)
         "END";
         B[N1]:= F; D[N]:= X
     "END";
     "IF" N > 0 "THEN" "GOTO" IN;
 END: EM[3]:= BMAX; EM[5]:= COUNT; EM[7]:= RNK; QRISNGVALDECBID:= N
 "END" QRISNGVALDECBID;
         "EOP"
1SECTION : 3.5.1.2            (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 
 RECEIVED : 731217
 
 
 BRIEF DESCRIPTION :
     THIS SECTION CONTAINS  TWO PROCEDURES,  QRISNGVAL AND QRISNGVALDEC.
     QRISNGVAL  CALCULATES  THE SINGULAR VALUES  OF A GIVEN MATRIX.
     QRISNGVALDEC  CALCULATES  THE  SINGULAR  VALUES  DECOMPOSITION
     U * S * V',  WITH U AND V ORTHOGONAL AND S POSITIVE DIAGONAL.
 
 
 KEYWORDS :
     SINGULAR VALUES
     QR ITERATION
 
 
1SECTION : 3.5.1.2            (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION : QRISNGVAL
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" QRISNGVAL(A, M, N, VAL, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, VAL, EM;
     "CODE" 34272;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE INPUT MATRIX;
         EXIT: DATA CONCERNING THE TRANSFORMATION TO BIDIAGONAL FORM;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N SHOULD SATISFY N <= M;
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         EXIT: THE SINGULAR VALUES;
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
         ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION IN THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                 SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
     MOREOVER :
     QRISNGVAL:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E. A NUMBER
         NOT EQUAL TO ZERO IF THE NUMBER OF ITERATIONS EXCEEDS EM[4].
 
 PROCEDURES USED :
     HSHREABID    = CP34260
     QRISNGVALBID = CP34270
 
 REQUIRED CENTRAL MEMORY : AN AUXILIARY ARRAY OF N REALS IS DECLARED
 
 RUNNING TIME :
     THE RUNNING TIME DEPENDS UPON THE PROPERTIES OF THE MATRIX, HOWEVER
     THE PROCESS OF BIDIAGONALIZATION DOMINATES,  AND ITS RUNNING TIME
     IS PROPORTIONAL TO  (M + N) * N * N
 
 
 METHOD AND PERFORMANCE :
     THE MATRIX IS FIRST TRANSFORMED TO BIDIAGONAL FORM BY THE PROCEDURE
     HSHREABID  (SECTION 3.2.2.1.1) ,  AND THEN  THE SINGULAR VALUES ARE
     CALCULATED BY QRISNGVALBID (SECTION 3.5.1.1).
 
 LANGUAGE : ALGOL 60
1SECTION : 3.5.1.2            (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION : QRISNGVALDEC
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" QRISNGVALDEC(A, M, N, VAL, V, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, VAL, V, EM;
     "CODE" 34273;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE GIVEN MATRIX;
         EXIT:  THE  MATRIX  U  IN  THE  SINGULAR  VALUES  DECOMPOSITION
             U * S * V';
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N SHOULD SATISFY N <= M;
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         EXIT: THE SINGULAR VALUES;
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         EXIT: THE MATRIX V OF THE SINGULAR VALUES DECOMPOSITION
               (A = U . S . V' );
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
         ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION IN THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPER DIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS PERFORMED;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                 SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
     MOREOVER :
     QRISNGVALDEC:=  THE NUMBER OF  SINGULAR VALUES  NOT FOUND,  I.E.  A
         NUMBER NOT  EQUAL TO ZERO  IF THE NUMBER OF  ITERATIONS EXCEEDS
         EM[4].
 
 PROCEDURES USED :
     HSHREABID       = CP34260
     PSTTFMMAT       = CP34261
     PRETFMMAT       = CP34262
     QRISNGVALDECBID = CP34271
 
 
 REQUIRED CENTRAL MEMORY : AN AUXILIARY ARRAY OF N ELEMENTS IS DECLARED
 
 
1SECTION : 3.5.1.2            (DECEMBER 1975)                     PAGE 4
 
 
 
 RUNNING TIME :
     THE RUNNING TIME DEPENDS UPON THE PROPERTIES OF THE MATRIX, HOWEVER
     THE PROCESS OF BIDIAGONALIZATION DOMINATES,  AND ITS RUNNING TIME
     IS PROPORTIONAL TO (M + N) * N * N
 
 METHOD AND PERFORMANCE:
     THE MATRIX IS FIRST TRANSFORMED TO BIDIAGONAL FORM BY THE PROCEDURE
     HSHREABID (SECTION 3.2.2.1.1), THE TWO TRANSFORMING MATRICES ARE
     CALCULATED BY THE PROCEDURES PSTTFMMAT AND PRETFMMAT (SECTIONS
     3.2.2.1.2 AND 3.2.2.1.3 RESPECTIVELY), AND FINALLY THE SINGULAR
     VALUES DECOMPOSITION IS CALCULATED BY QRISNGVALDECBID (SECTION
     3.5.1.1).
 
 LANGUAGE : ALGOL 60
 
 REFERENCES :
         WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL. 2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
 
 EXAMPLE OF USE :
     AS THE PROCEDURE QRISNGVALDEC  CALCULATES THE  SINGULAR VALUES OF A
     MATRIX IN EXACTLY THE SAME WAY AS  QRISNGVAL, WE GIVE  HER ONLY  AN
     EXAMPLE OF  USE OF  THE PROCEDURE  QRISNGVALDEC.  FIRST  WE GIVE  A
     PROGRAM, AND THEN THE RESULTS OF THIS PROGRAM:
 
     "BEGIN" "ARRAY" A[1:6,1:5], V[1:5,1:5], VAL[1:5], EM[0:7];
         "INTEGER" I, J;
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" 6 "DO"
         "FOR" J:= 1 "STEP" 1 "UNTIL" 5 "DO"
         A[I,J]:= 1 / (I + J - 1);
         EM[0]:= "-14; EM[2]:= "-12; EM[4]:= 25; EM[6]:= "-10;
         I:= QRISNGVALDEC(A, 6, 5, VAL, V, EM);
         OUTPUT(61, "("3B, "("NUMBER SINGULAR VALUES NOT FOUND : ")",
         3ZD, /, 3B, "("INFINITY NORM : ")", N, /, 3B,
         "("MAX NEGLECTED SUBDIAGONAL ELEMENT : ")", N, /, 3B,
         "("NUMBER ITERATIONS : ")", 3ZD, /, 3B,
         "("NUMERICAL RANK : ")", 3ZD, /")", I, EM[1], EM[3], EM[5],
         EM[7]);
         OUTPUT(61, "("/, 3B, "("SINGULAR VALUES : ")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 5 "DO"
         OUTPUT(61, "("/, 3B, N")", VAL[I]);
         OUTPUT(61, "("/, /, 3B, "("MATRIX U, FIRST 3 COLUMNS")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 6 "DO"
         OUTPUT(61, "("/, 3B, 3(N)")", A[I,1], A[I,2], A[I,3]);
         OUTPUT(61, "("/, /, 13B, "("LAST 2 COLUMNS")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 6 "DO"
         OUTPUT(61, "("/, 13B, 2(N)")", A[I,4], A[I,5])
     "END"
1SECTION : 3.5.1.2            (JULY 1974)                         PAGE 5
 
 
 
 
     NUMBER SINGULAR VALUES NOT FOUND :    0
     INFINITY NORM : +2.2833333333334"+000
     MAX NEGLECTED SUBDIAGONAL ELEMENT : +5.7786437871158"-014
     NUMBER ITERATIONS :    5
     NUMERICAL RANK :    5
 
     SINGULAR VALUES :
 
     +1.5921172587262"+000
     +2.2449595426097"-001
     +1.3610556101029"-002
     +4.3245382038374"-004
     +6.4001947134260"-006
 
     MATRIX U, FIRST 3 COLUMNS
 
     -7.5497918208386"-001  +6.1011090790645"-001  -2.3287173869184"-001
     -4.3909273679284"-001  -2.2602102994174"-001  +7.0245315582712"-001
     -3.1703146681544"-001  -3.7306964696148"-001  +2.1607293656979"-001
     -2.4999458583084"-001  -3.9557817833576"-001  -1.4665595223684"-001
     -2.0704999076883"-001  -3.8483260608872"-001  -3.6803786187007"-001
     -1.7699734614538"-001  -3.6458192866515"-001  -4.9868122801331"-001
 
               LAST 2 COLUMNS
 
               +5.8625326935176"-002  -1.0184205426735"-002
               -4.8169088124009"-001  +1.7189132301455"-001
               +5.4982292571999"-001  -5.9788920283495"-001
               +4.0633053815463"-001  +4.5989617524697"-001
               -6.1755991033503"-002  +4.3029765325422"-001
               -5.4158416488948"-001  -4.6499203623570"-001
 
 
1SECTION : 3.5.1.2            (JULY 1974)                         PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE" 34272;
 "INTEGER" "PROCEDURE" QRISNGVAL(A, M, N, VAL, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, VAL, EM;
 "BEGIN" "ARRAY" B[1:N];
 
     HSHREABID(A, M, N, VAL, B, EM);
     QRISNGVAL:= QRISNGVALBID(VAL, B, N, EM)
 "END" QRISNGVAL;
         "EOP"
0"CODE" 34273;
 "INTEGER" "PROCEDURE" QRISNGVALDEC(A, M, N, VAL, V, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, VAL, V, EM;
 "BEGIN" "ARRAY" B[1:N];
 
     HSHREABID(A, M, N, VAL, B, EM);
     PSTTFMMAT(A, N, V, B);  PRETFMMAT(A, M, N, VAL);
     QRISNGVALDEC:= QRISNGVALDECBID(VAL, B, M, N, A, V, EM)
 "END" QRISNGVALDEC;
         "EOP"
1SECTION : 3.6.1             (DECEMBER 1978)                      PAGE 1
 
 
 
 AUTHORS:  TH.J. DEKKER AND TH.H.P. REYMER
 
 
 CONTRIBUTOR:  TH.H.P. REYMER
 
 
 INSTITUTE:  UNIVERSITY OF AMSTERDAM
 
 
 RECEIVED:  770427;
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES:
     A) ZERPOL   CALCULATES  ALL  ROOTS   OF  A   POLYNOMIAL  WITH  REAL
        COEFFICIENTS BY MEANS OF LAGUERRE'S METHOD;
     B) BOUNDS   CALCULATES  UPPERBOUNDS FOR THE ABSOLUTE ERROR IN GIVEN
        APPROXIMATED ZEROS OF A POLYNOMIAL WITH REAL COEFFICIENTS;
 
 
 KEYWORDS:
 
     ZEROS;
     REAL POLYNOMIAL;
     LAGUERRE'S METHOD;
     ERROR BOUNDS;
 
 
 SUBSECTION: ZERPOL
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "INTEGER" "PROCEDURE" ZERPOL(N, A, EM, RE, IM, D);
     "VALUE" N; "INTEGER" N; "ARRAY" A, EM, RE, IM, D;
     "CODE" 34501 ;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY:  THE DEGREE OF THE POLYNOMIAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0 : N];
             ENTRY:  THE COEFFICIENTS OF THE POLYNOMIAL, IN  SUCH  A WAY
                     THAT
                     P(Z) = (..(A[N]*Z + A[N-1])*Z +..+ A[1])*Z + A[0];
1SECTION : 3.6.1             (DECEMBER 1979)                      PAGE 2
 
 
 
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0 : 4];
             ENTRY:  EM[0]: MACHINE PRECISION;
                     EM[1]: THE MAXIMAL NUMBER OF ITERATIONS ALLOWED FOR
                            EACH ZERO;
             EXIT:   EM[2]: FAIL INDICATION;
                            0  SUCCESSFUL CALL;
                            1  UPON ENTRY DEGREE N <= 0;
                            2  UPON ENTRY LEADING COEFFICIENT A[N] = 0;
                            3  NUMBER OF ITERATIONS EXCEEDED EM[1];
                     EM[3]: NUMBER OF NEW STARTS IN THE LAST ITERATION;
                     EM[4]: TOTAL NUMBER OF ITERATIONS PERFORMED;
             FOR THE CD CYBER 70 SYSTEM SUITABLE VALUES ARE:
             EM[0]:= "-14;
             EM[1]:= 40; IF, UPON EXIT, EM[2] = 3  AND EM[3] < 5 THEN IT
                         MAY BE  USEFUL TO  START  AGAIN  WITH  A HIGHER
                         VALUE OF EM[1];
     RE, IM: <ARRAY IDENTIFIERS>;
             "ARRAY" RE, IM[1 : N];
             EXIT:   THE  REAL  AND  IMAGINARY PARTS OF THE ZEROS OF THE
                     POLYNOMIAL; THE  MEMBERS  OF  EACH  NONREAL COMPLEX
                     CONJUGATE PAIR ARE CONSECUTIVE;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[0 : N];
             EXIT:   IF THE CALL IS UNSUCCESSFUL AND ONLY N-K ZEROS HAVE
                     BEEN   FOUND,  THEN   D[0 :  K]   CONTAINS   THE
                     COEFFICIENTS   OF   THE   (DEFLATED)    POLYNOMIAL;
                     MOREOVER,  THEN THE ZEROS  FOUND  ARE  DELIVERED IN
                     RE, IM[ K + 1 : N], WHEREAS THE REMAINING  PARTS
                     OF RE AND IM CONTAIN NO INFORMATION;
 
     ZERPOL:= THE NUMBER, K, OF ZEROS NOT FOUND;
 
 
 PROCEDURES USED:
 
     DWARF   = CP30003;
     GIANT   = CP30004;
     COMABS  = CP34340;
     COMSQRT = CP34343;
 
 
 REQUIRED CENTRAL MEMORY:
 
     TOTAL SIZE OF LOCAL ARRAYS IS N + 16 REAL LOCATIONS;
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO N**2;
1SECTION : 3.6.1             (DECEMBER 1978)                      PAGE 3
 
 
 
 METHOD AND PERFORMANCE:
 
     THE  PROCEDURE  USES  LAGUERRE'S  METHOD TO FIND ZEROS OF THE GIVEN
     POLYNOMIAL (SEE [2]);  WHEN A ZERO HAS BEEN FOUND, A COMPOSITE
     DEFLATION TECHNIQUE IS USED TO  OBTAIN A  NEW POLYNOMIAL OF LOWER
     DEGREE (SEE [1], [3], [4]); IF CONVERGENCE IS NOT APPARENT, SEVERAL
     RESTARTS, THE NUMBER OF WHICH DEPENDS ON  EM[1]  BUT HAS A MAXIMUM
     OF  5, ARE MADE IN THE NEIGHBOURHOOD OF THE ABSOLUTE LARGEST ZERO;
     THE  ACCURACY OF THE  CALCULATED  ZEROS  STRONGLY  DEPENDS  ON  THE
     POLYNOMIAL; A ROUGH INDICATION FOR THE ERROR IN A CALCULATED ZERO Z
     FOLLOWS FROM P(Z) / DP(Z), WHERE P DENOTES THE GIVEN POLYNOMIAL AND
     DP ITS  FIRST DERIVATIVE (SEE E.G. [5]); TO FIND A  TRUE UPPERBOUND
     FOR THESE ERRORS, ONE CAN USE PROCEDURE BOUNDS (SEE NEXT
     SUBSECTION); FOR  A MORE  DETAILED DESCRIPTION OF THE PROCEDURE AND
     TEST RESULTS SEE [4];
 
 
 REFERENCES:
 
     [1] D.A. ADAMS, A STOPPING CRITERION FOR POLYNOMIAL ROOT FINDING,
         CACM 10, NO 10, PP. 655-658, OCTOBER 1967;
     [2] T.J. DEKKER, NEWTON-LAGUERRE ITERATION,
         MATHEMATISCH CENTRUM MR82, 1966;
     [3] G. PETERS AND J.H. WILKINSON, PRACTICAL PROBLEMS ARISING IN THE
         SOLUTION OF POLYNOMIAL EQUATIONS,
         J. INST. MATHS APPLICS 1971, NO. 8, PP. 16-35;
     [4] TH.H.P. REYMER, BEREKENING VAN NULPUNTEN VAN REELE POLYNOMEN EN
         FOUTGRENZEN VOOR DEZE NULPUNTEN,
         DOCTORAAL SCRIPTIE UVA, APRIL 1977;
     [5] J.H. WILKINSON, ROUNDING ERRORS IN ALGEBRAIC PROCESSES,
         PRENTICE HALL, 1963;
 
 
 EXAMPLE OF USE:
 
     FOR AN EXAMPLE OF USE SEE PROCEDURE BOUNDS (NEXT SUBSECTION);
 
1SECTION : 3.6.1             (DECEMBER 1979)                      PAGE 4
 
 
 
 SUBSECTION: BOUNDS
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" BOUNDS(N,A,RE,IM,RELE,ABSE,RECENTRE,IMCENTRE,BOUND);
     "VALUE" N, RELE, ABSE; "INTEGER" N; "REAL" RELE, ABSE;
     "ARRAY" A, RE, IM, RECENTRE, IMCENTRE, BOUND;
     "CODE" 34502 ;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:        <ARITHMETIC EXPRESSION>;
               ENTRY:  DEGREE OF THE POLYNOMIAL;
     A:        <ARRAY IDENTIFIER>;
               "ARRAY" A[0 : N];
               ENTRY:  THE  COEFFICIENTS  OF  THE  POLYNOMIAL  OF  WHICH
                       RE[J] + I * IM[J]  ARE  THE  APPROXIMATED  ZEROS,
                       IN SUCH A WAY THAT
                       P(Z) = (..(A[N]*Z + A[N-1])*Z +..+A[1])*Z + A[0]
     RE, IM:   <ARRAY IDENTIFIERS>;
               "ARRAY" RE, IM[1 : N];
               ENTRY:  REAL AND IMAGINARY PARTS OF APPROXIMATED ZEROS OF
                       A  POLYNOMIAL,  SUCH  THAT  THE  MEMBERS  OF EACH
                       NONREAL COMPLEX CONJUGATE PAIR ARE CONSECUTIVE;
               EXIT:   A PERMUTATION OF THE INPUT DATA;
     RELE:     <ARITHMETIC EXPRESSION>;
               ENTRY:  RELATIVE ERROR IN THE  NON-VANISHING COEFFICIENTS
                       A[J] OF THE GIVEN POLYNOMIAL;
     ABSE:     <ARITHMETIC EXPRESSION>;
               ENTRY:  ABSOLUTE ERROR IN THE VANISHING COEFFICIENTS A[J]
                       GIVEN  POLYNOMIAL;  IF  THERE  ARE  NO  VANISHING
                       COEFFICIENTS, ABSE SHOULD BE ZERO;
     RECENTRE, IMCENTRE: <ARRAY IDENTIFIERS>;
               "ARRAY" RECENTRE, IMCENTRE[1 : N];
               EXIT:   REAL  AND IMAGINARY PARTS OF THE CENTERS OF DISKS
                       IN WHICH  SOME  NUMBER OF ZEROS OF THE POLYNOMIAL
                       GIVEN BY A ARE SITUATED;
                       THE NUMBER OF IDENTICAL CENTERS  DENOTES
                       THE NUMBER OF ZEROS IN THAT DISK;
     BOUND:    <ARRAY IDENTIFIER>;
               "ARRAY" BOUND[1 : N];
               EXIT:   RADIUS  OF THE  DISKS  WHOSE  CENTERS  ARE  GIVEN
                       CORRESPONDINGLY IN RECENTRE AND IMCENTRE;
 
 
 PROCEDURES USED:
 
     ARREB = CP30002;
     GIANT = CP30004;
1SECTION : 3.6.1             (DECEMBER 1979)                      PAGE 5
 
 
 
 REQUIRED CENTRAL MEMORY:
 
     TOTAL SIZE OF LOCAL ARRAYS IS AT MOST 7 * N REAL LOCATIONS;
 
 
 RUNNING TIME:
 
     APPROXIMATELY OF ORDER N**2;
 
 METHOD AND PERFORMANCE:
 
     FROM  THE  APPROXIMATED  ZEROS  A  POLYNOMIAL IS  RECONSTRUCTED AND
     COMPARED  WITH  THE  GIVEN  POLYNOMIAL; SUBSEQUENTLY, THE PROCEDURE
     CALCULATES  DISKS  SUCH THAT THE NUMBER OF GIVEN APPROXIMATED ZEROS
     WITHIN EACH DISK EQUALS THE NUMBER OF ZEROS OF THE GIVEN POLYNOMIAL
     WITHIN  THAT  DISK;  UPON  EXIT  EVERY  TWO NON-IDENTICAL DISKS ARE
     DISJOINT;
     FOR A MORE DETAILED DESCRIPTION SEE [1], [2];
 
 
 REFERENCES:
 
     [1] G. PETERS AND J.H. WILKINSON, PRACTICAL PROBLEMS ARISING IN THE
         SOLUTION OF POLYNOMIAL EQUATIONS, J.INST.MATHS APPLICS 1971,
         NO 8, PP. 16-35;
     [2] TH.H.P. REYMER, BEREKENING VAN NULPUNTEN VAN REELE POLYNOMEN EN
         FOUTGRENZEN VOOR DEZE NULPUNTEN,
         DOCTORAAL SCRIPTIE UVA, APRIL 1977;
 
 
 EXAMPLE OF USE:
 
 "BEGIN" "INTEGER" I, J;
   "ARRAY" A, D[0:7], RE, IM[1:7], EM[0:4];
 
   A[7]:= 1; A[6]:= -3; A[5]:= -3; A[4]:= 25; A[3]:= -46;
   A[2]:= 38; A[1]:= -12; A[0]:= 0;
   EM[0]:= "-14; EM[1]:= 40;
   I:= ZERPOL(7, A, EM, RE, IM, D);
   OUTPUT(61,"(""("COEFFICIENTS OF POLYNOMIAL:")",//")");
   "FOR" J:=7 "STEP" -1 "UNTIL" 0 "DO"
   OUTPUT(61,"("-2ZD3B")",A[J]);
   OUTPUT(61,"("//,"("NUMBER NOT FOUND ZEROS ")",3ZD,/,
      "("FAIL INDICATION ")",3ZD,/,"("NUMBER NEW STARTS ")",3ZD,/,
      "("NUMBER OF ITERATIONS ")",3ZD,/")",I,EM[2],EM[3],EM[4]);
   OUTPUT(61,"("/,"("ZEROS: ")",/")");
   "FOR" J:= I+1 "STEP" 1 "UNTIL" 7 "DO" "IF" IM[J] = 0
   "THEN" OUTPUT(61,"("/,N")",RE[J])
   "ELSE" OUTPUT(61,"("/,2(N)")",RE[J],IM[J]);
1SECTION : 3.6.1             (DECEMBER 1979)                      PAGE 6
 
 
 
   "IF" I = 0 "THEN"
   "BEGIN" "ARRAY" RECENTRE, IMCENTRE, BOUND[1:7];
 
     BOUNDS(7, A, RE, IM, 0, 0, RECENTRE, IMCENTRE, BOUND);
     OUTPUT(61,"("2/,"("REAL AND IMAG. PART OF CENTRE + RADIUS")",/")");
     "FOR" J:= 1 "STEP" 1 "UNTIL" 7 "DO"
     OUTPUT(61,"("/,3(N)")",RECENTRE[J],IMCENTRE[J],BOUND[J])
   "END"
 "END"
 
 
 RESULTS :
 
 
 COEFFICIENTS OF POLYNOMIAL:
 
    1     -3     -3     25    -46     38    -12      0
 
 NUMBER NOT FOUND ZEROS    0
 FAIL INDICATION    0
 NUMBER NEW STARTS    0
 NUMBER OF ITERATIONS   11
 
 ZEROS:
 
 +2.0000000000000"+000
 -3.0000000000000"+000
 +1.0000000000000"+000  -1.0000000000000"+000
 +1.0000000000000"+000  +1.0000000000000"+000
 +1.0000000083024"+000
 +9.9999999169752"-001
 +0.0000000000000"+000
 
 REAL AND IMAG. PART OF CENTRE + RADIUS
 
 +2.0000000000000"+000  +0.0000000000000"+000  +1.3238111117716"-011
 -3.0000000000000"+000  +0.0000000000000"+000  +3.8857510604494"-013
 +1.0000000000000"+000  -1.0000000000000"+000  +4.0912729775463"-012
 +1.0000000000000"+000  +1.0000000000000"+000  +4.0912729775463"-012
 +9.9999999999998"-001  +0.0000000000000"+000  +2.2533888428865"-006
 +9.9999999999998"-001  +0.0000000000000"+000  +2.2533888428865"-006
 +0.0000000000000"+000  +0.0000000000000"+000  +0.0000000000000"+000
1SECTION : 3.6.1             (DECEMBER 1979)                      PAGE 7
 
 
 
 SOURCE TEXT(S) :
 
 
 "CODE" 34501;
 "INTEGER""PROCEDURE" ZERPOL(N, A, EM, RE, IM, D);
   "VALUE" N; "INTEGER" N; "ARRAY" A, EM, RE, IM, D;
 "BEGIN" "INTEGER" I, TOTIT, IT, FAIL, START, UP, MAX, GIEX, ITMAX;
    "REAL" X, Y, NEWF, OLDF, MAXRAD, AE, TOL, H1, H2, LN2;
    "ARRAY" F[0 : 5], TRIES[1 : 10];
 
   "BOOLEAN""PROCEDURE" FUNCTION;
   "BEGIN" "INTEGER" K, M1, M2;
     "REAL" P, Q, QSQRT, F01, F02, F03, F11, F12, F13,
            F21, F22, F23, STOP;
     IT:= IT + 1;
     P:= 2 * X; Q:= -(X * X + Y * Y); QSQRT:= SQRT(-Q);
     F01:= F11:= F21:= D[0]; F02:= F12:= F22:= 0;
     M1:= N - 4; M2:= N - 2;
     STOP:= ABS(F01) * 0.8;
     "FOR" K:= 1 "STEP" 1 "UNTIL" M1 "DO"
     "BEGIN" F03:= F02; F02:= F01; F01:= D[K] + P * F02 + Q * F03;
       F13:= F12; F12:= F11; F11:= F01 + P * F12 + Q * F13;
       F23:= F22; F22:= F21; F21:= F11 + P * F22 + Q * F23;
       STOP:= QSQRT * STOP + ABS(F01)
     "END";
     "IF" M1 < 0 "THEN" M1:= 0;
     "FOR" K:= M1 + 1 "STEP" 1 "UNTIL" M2 "DO"
     "BEGIN" F03:= F02; F02:= F01; F01:= D[K] + P * F02 + Q * F03;
       F13:= F12; F12:= F11; F11:= F01 + P * F12 + Q * F13;
       STOP:= QSQRT * STOP + ABS(F01)
     "END";
     "IF" N = 3 "THEN" F21:= 0;
     F03:= F02; F02:= F01; F01:= D[N - 1] + P * F02 + Q * F03;
     F[0]:= D[N] + X * F01 + Q * F02;
     F[1]:= Y * F01;
     F[2]:= F01 - 2 * F12 * Y * Y;
     F[3]:= 2 * Y * (- X * F12 + F11);
     F[4]:= 2 * (- X * F12 + F11) - 8 * Y * Y * (- X * F22 + F21);
     F[5]:= Y * (6 * F12 - 8 * Y * Y * F22);
     STOP:= QSQRT * (QSQRT * STOP + ABS(F01)) + ABS(F[0]);
     NEWF:= F02:= COMABS(F[0], F[1]);
     FUNCTION:= F02 < (2 * ABS(X * F01) - 8 * (ABS(F[0]) + ABS(F01)
        * QSQRT) + 10 * STOP) * TOL * (1 + TOL) ** (4 * N + 3)
   "END" OF FUNCTION;                                          "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1978)                      PAGE 8
                                                                  ;
 
 
   "BOOLEAN""PROCEDURE" CONTROL;
   "IF" IT > ITMAX "THEN"
   "BEGIN" TOTIT:= TOTIT + IT; FAIL:= 3; "GOTO" EXIT "END"
   "ELSE" "IF" IT = 0 "THEN"
   "BEGIN" "INTEGER" I, H; "REAL" H1, SIDE;
     MAXRAD:= 0; MAX:= (GIEX - LN(ABS(D[0])) / LN2) / N;
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" H1:= "IF" D[I] = 0 "THEN" 0
       "ELSE" EXP(LN(ABS(D[I] / D[0])) / I);
       "IF" H1 > MAXRAD "THEN" MAXRAD:= H1
     "END";
     "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
     "IF" D[I] ^= 0 "THEN"
     "BEGIN" H:= (GIEX - LN(ABS(D[I])) / LN2) / (N - I);
       "IF" H < MAX "THEN" MAX:= H
     "END";
     MAX:= MAX * LN2 / LN(N);
     SIDE:= - D[1] / D[0];
     SIDE:= "IF" ABS(SIDE) < TOL "THEN" 0 "ELSE" SIGN(SIDE);
     "IF" SIDE = 0 "THEN"
     "BEGIN" TRIES[7]:= TRIES[2]:= MAXRAD; TRIES[9]:= -MAXRAD;
       TRIES[6]:= TRIES[4]:= TRIES[3]:= MAXRAD / SQRT(2);
       TRIES[5]:= -TRIES[3]; TRIES[10]:= TRIES[8]:= TRIES[1]:= 0
     "END" "ELSE"
     "BEGIN" TRIES[8]:= TRIES[4]:= MAXRAD/ SQRT(2);
        TRIES[1]:= SIDE * MAXRAD; TRIES[3]:= TRIES[4] * SIDE;
        TRIES[6]:= MAXRAD; TRIES[7]:= -TRIES[3];
        TRIES[9]:= -TRIES[1]; TRIES[2]:= TRIES[5]:= TRIES[10]:= 0
     "END";
     "IF" COMABS(X, Y) > 2 * MAXRAD "THEN" X:= Y:= 0;
     CONTROL:= "FALSE"
   "END" "ELSE"
   "BEGIN" "IF" IT > 1 & NEWF >= OLDF "THEN"
     "BEGIN" UP:= UP+ 1;
       "IF" UP = 5 & START < 5 "THEN"
       "BEGIN" START:= START + 1; UP:= 0; X:= TRIES[2 * START - 1];
         Y:= TRIES[2 * START]; CONTROL:= "FALSE"
       "END" "ELSE" CONTROL:= "TRUE"
     "END" "ELSE" CONTROL:= "TRUE"
   "END" OF CONTROL;                                           "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1978)                      PAGE 9
                                                                  ;
 
 
   "PROCEDURE" DEFLATION;
   "IF" X = 0 & Y = 0 "THEN" N:= N - 1 "ELSE"
   "BEGIN" "INTEGER" I, SPLIT; "REAL" H1, H2;
     "ARRAY" B[0 : N - 1];
     "IF" Y = 0 "THEN"
     "BEGIN" N:= N - 1; B[N]:= -D[N + 1] / X;
       "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
       B[N - I]:= (B[N - I + 1] - D[N - I + 1]) / X;
       "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
       D[I]:= D[I] + D[I - 1] * X
     "END" "ELSE"
     "BEGIN" H1:= - 2 * X; H2:= X * X + Y * Y;
       N:= N - 2;
       B[N]:= D[N + 2] / H2; B[N - 1]:= (D[N + 1] - H1 * B[N]) / H2;
       "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
       B[N - I]:=  (D[N - I + 2] - H1 * B[N - I + 1] - B[N - I + 2])/H2;
       D[1]:= D[1] - H1 * D[0];
       "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
       D[I]:= D[I] - H1 * D[I-1] - H2 * D[I-2]
     "END";
     SPLIT:= N;
     H2:= ABS(D[N] - B[N]) / (ABS(D[N]) + ABS(B[N]));
     "FOR" I:= N - 1 "STEP" -1 "UNTIL" 0 "DO"
     "BEGIN" H1:= ABS(D[I]) + ABS(B[I]);
       "IF" H1 > TOL "THEN"
       "BEGIN" H1:= ABS(D[I] - B[I]) / H1;
         "IF" H1 < H2 "THEN" "BEGIN" H2:= H1; SPLIT:= I "END"
       "END"
     "END";
     "FOR" I := SPLIT + 1 "STEP" 1 "UNTIL" N "DO" D[I]:= B[I];
     D[SPLIT]:= (D[SPLIT] + B[SPLIT]) / 2
   "END" OF DEFLATION;
 
   "PROCEDURE" LAGUERRE;
   "BEGIN" "INTEGER" M;
     "REAL" S1RE, S1IM, S2RE, S2IM, DX, DY, H1, H2, H3, H4, H5, H6;
     "IF" ABS(F[0]) > ABS(F[1]) "THEN"
     "BEGIN" H1:= F[0]; H6:= F[1] / H1; H2:= F[2] + H6 * F[3];
       H3:= F[3] - H6 * F[2]; H4:= F[4] + H6 * F[5];
       H5:= F[5] - H6 * F[4]; H6:= H6 * F[1] + H1
     "END" "ELSE"
     "BEGIN" H1:= F[1]; H6:= F[0] / H1; H2:= H6 * F[2] + F[3];
       H3:= H6 * F[3] - F[2]; H4:= H6 * F[4] + F[5];
       H5:= H6 * F[5] - F[4]; H6:= H6 * F[0] + F[1]
     "END";                                                    "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1979)                     PAGE 10
                                                                  ;
 
 
     S1RE:= H2 / H6; S1IM:= H3 / H6;
     H2:= S1RE * S1RE - S1IM * S1IM; H3:= 2 * S1RE * S1IM;
     S2RE:= H2 - H4 / H6; S2IM:= H3 - H5 / H6;
     H1:= S2RE * S2RE + S2IM * S2IM;
     H1:= "IF" H1 ^= 0 "THEN" (S2RE * H2 + S2IM * H3) / H1 "ELSE" 1;
     M:= "IF" H1 >= N - 1 "THEN" ("IF" N > 1 "THEN" N - 1 "ELSE" 1)
         "ELSE" "IF" H1 > 1 "THEN" H1 "ELSE" 1;
     H1:= (N - M) / M;
     COMSQRT(H1 * (N * S2RE - H2), H1 * (N * S2IM - H3), H2, H3);
     "IF" S1RE * H2 + S1IM * H3 < 0 "THEN"
     "BEGIN" H2:= - H2; H3:= - H3 "END";
     H2:= S1RE + H2; H3:= S1IM + H3;
     H1:= H2 * H2 + H3 * H3;
     "IF" H1 = 0 "THEN" "BEGIN" DX:= -N; DY:= N "END" "ELSE"
     "BEGIN" DX:= - N * H2 / H1; DY:= N * H3 / H1 "END";
     H1:= ABS(X) * TOL + AE; H2:= ABS(Y) * TOL+ AE;
     "IF" ABS(DX) < H1 & ABS(DY) < H2 "THEN"
     "BEGIN" DX:= "IF" DX = 0 "THEN" H1 "ELSE" SIGN(DX) * H1;
       DY:= "IF" DY = 0 "THEN" H2 "ELSE" SIGN(DY) * H2
     "END";
     X:= X + DX; Y:= Y + DY;
     "IF" COMABS(X, Y) > 2 * MAXRAD "THEN"
     "BEGIN" H1:= "IF" ABS(X) > ABS(Y) "THEN" ABS(X) "ELSE" ABS(Y);
       H2:= LN(H1) / LN2 + 1 - MAX;
       "IF" H2 > 0 "THEN"
       "BEGIN" H2:= 2 ** H2; X:= X / H2; Y:= Y / H2 "END"
     "END"
   "END" OF LAGUERRE;
 
   TOTIT:= IT:= FAIL:= UP:= START:= 0; LN2:= LN(2);
   NEWF:= GIANT; AE:= DWARF; GIEX:= LN(NEWF) / LN2 - 40;
   TOL:= EM[0]; ITMAX:= EM[1];
   "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I]:= A[N-I];
   "IF" N <= 0 "THEN"
   "BEGIN" FAIL:= 1; "GOTO" EXIT "END"
   "ELSE" "IF" D[0] = 0 "THEN"
   "BEGIN" FAIL:= 2; "GOTO" EXIT "END";
   "FOR" I:= 1 "WHILE" D[N] = 0 & N > 0 "DO"
   "BEGIN" RE[N]:= IM[N]:= 0; N:= N - 1 "END";
   X:= Y:= 0;                                                  "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1979)                     PAGE 11
                                                                  ;
 
 
   "FOR" I:= 1 "WHILE" N > 2 "DO"
   "BEGIN" "IF" CONTROL "THEN" LAGUERRE;
     OLDF:= NEWF;
     "IF" FUNCTION "THEN"
     "BEGIN" "IF" Y ^= 0 & ABS(Y) < .1 "THEN"
       "BEGIN" "REAL" H; H:= Y; Y:= 0;
          "IF" ^ FUNCTION "THEN" Y:= H
       "END";
       RE[N]:= X; IM[N]:= Y;
       "IF" Y ^= 0 "THEN" "BEGIN" RE[N - 1]:= X; IM[N - 1]:= -Y "END";
       DEFLATION; TOTIT:= TOTIT + IT; UP:= START:= IT:= 0
     "END"
   "END";
   "IF" N = 1 "THEN" "BEGIN" RE[1]:= - D[1] / D[0]; IM[1]:= 0 "END"
   "ELSE"
   "BEGIN" "REAL" H1, H2;
     H1:= - 0.5 * D[1] / D[0]; H2:= H1 * H1 - D[2] / D[0];
     "IF" H2 >= 0 "THEN"
     "BEGIN" RE[2]:= "IF" H1 < 0 "THEN" H1 - SQRT(H2)
             "ELSE" H1 + SQRT(H2);
       RE[1]:= D[2] / (D[0] * RE[2]);
       IM[2]:= IM[1]:= 0
     "END" "ELSE"
     "BEGIN" RE[2]:= RE[1]:= H1;
       IM[2]:= SQRT(-H2); IM[1]:= -IM[2]
     "END"
   "END"; N:= 0;
 EXIT:  EM[2]:= FAIL; EM[3]:= START; EM[4]:= TOTIT;
   "FOR" I:= (N-1) "DIV" 2 "STEP" -1 "UNTIL" 0 "DO"
   "BEGIN" TOL := D[I]; D[I]:= D[N-I]; D[N-I]:= TOL
   "END";
   ZERPOL:= N
 "END" OF ZERPOL;
         "EOP"
 
 
 "CODE" 34502;
 "PROCEDURE" BOUNDS(N,A,RE,IM,RELE,ABSE,RECENTRE,IMCENTRE,BOUND);
   "VALUE" N, RELE, ABSE; "INTEGER" N; "REAL" RELE, ABSE;
   "ARRAY" RE, IM, A, RECENTRE, IMCENTRE, BOUND;
 "BEGIN" "INTEGER" I, J, K, L, INDEX1, INDEX2; "BOOLEAN" GOON;
   "REAL" H, MIN, RECENT, IMCENT, GIA, XK, YK, ZK, CORR;
   "ARRAY" RC, C, RCE[0:N], CLUST[1:N];
 
                                                               "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1978)                     PAGE 12
                                                                  ;
 
 
 
   "REAL""PROCEDURE" G(RAD, RECENT, IMCENT, K, M);
     "VALUE" RAD, RECENT, IMCENT, K, M; "REAL" RAD, RECENT, IMCENT;
     "INTEGER" K, M;
   "BEGIN" "REAL" S, H1, H2; "INTEGER" I;
     S:= SQRT(RECENT * RECENT + IMCENT * IMCENT) + RAD;
     H1:= RC[1]; H2:= RC[0];
     "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO" H1:= H1*S + RC[I];
     "FOR" I:= 1 "STEP" 1 "UNTIL" M-1, M+K "STEP" 1 "UNTIL" N "DO"
     H2:= H2 * ABS(SQRT((RE[I]-RECENT)**2 + (IM[I]-IMCENT)**2) - RAD);
     G:= "IF" H1=0 "THEN" 0 "ELSE" "IF" H2=0 "THEN" -10 "ELSE" H1 / H2
   "END";
 
   "PROCEDURE" KCLUSTER(K, M);
     "VALUE" K, M; "INTEGER" K, M;
   "BEGIN" "INTEGER" I, J, STOP, L; "BOOLEAN" NONZERO;
     "REAL" RECENT, IMCENT, D, PROD, RAD, GR, R;
     "ARRAY" DIST[M: M+K-1];
     RECENT:= RE[M]; IMCENT:= IM[M]; STOP:= M+K-1;
     L:= SIGN(IMCENT); NONZERO:= L ^= 0;
     "FOR" I:= M+1 "STEP" 1 "UNTIL" STOP "DO"
     "BEGIN" RECENT:= RECENT+RE[I];
       "IF" NONZERO "THEN"
       "BEGIN" NONZERO:= L = SIGN(IM[I]); IMCENT:= IMCENT+IM[I] "END"
     "END";
     RECENT:= RECENT/K; IMCENT:= "IF" NONZERO "THEN" IMCENT/K "ELSE" 0;
     D:= 0; RAD:= 0;
     "FOR" I:= M "STEP" 1 "UNTIL" STOP "DO"
     "BEGIN" RECENTRE[I]:= RECENT; IMCENTRE[I]:= IMCENT;
       DIST[I]:= SQRT((RE[I] -RECENT)**2 + (IM[I]-IMCENT)**2);
       "IF" D < DIST[I] "THEN" D:= DIST[I]
     "END";
     GR:= ABS(G(0, RECENT, IMCENT, K, M));
     "IF" GR > 0 "THEN"
     "BEGIN" "FOR" J:= 1, 1 "WHILE" PROD <= GR "DO"
       "BEGIN" R:= RAD; RAD:= D + EXP(LN(1.1*GR)/K);
         "IF" RAD = R "THEN" RAD:= EXP(LN(1.1)/K) * RAD;
         GR:= G(RAD, RECENT, IMCENT, K, M);
         PROD:= 1;
         "FOR" I:= M "STEP" 1 "UNTIL" STOP "DO"
         PROD:= PROD*(RAD-DIST[I])
       "END"
     "END";
     "FOR" I:= M "STEP" 1 "UNTIL" STOP "DO"
     "BEGIN" BOUND[I]:= RAD; CLUST[I]:= K "END";
   "END";                                                      "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1979)                     PAGE 13
                                                                  ;
 
 
   "PROCEDURE" SHIFT(INDEX, NEW);
     "VALUE" INDEX, NEW; "INTEGER" INDEX, NEW;
   "BEGIN" "INTEGER" J, PLACE, CLUSTIN;
     "REAL" BOUNDIN, IMCENT, RECENT;
     "REAL""ARRAY" WA1, WA2[1:CLUST[INDEX]];
     CLUSTIN:= CLUST[INDEX]; BOUNDIN:= BOUND[INDEX];
     IMCENT:= IMCENTRE[INDEX]; RECENT:= RECENTRE[INDEX];
     "FOR" J:= 1 "STEP" 1 "UNTIL" CLUSTIN "DO"
     "BEGIN" PLACE:=INDEX+J-1; WA1[J]:= RE[PLACE]; WA2[J]:= IM[PLACE];
     "END";
     "FOR" J:= INDEX-1 "STEP" -1 "UNTIL" NEW "DO"
     "BEGIN" PLACE:= J+CLUSTIN;
       RE[PLACE]:= RE[J]; IM[PLACE]:= IM[J]; CLUST[PLACE]:= CLUST[J];
       BOUND[PLACE]:= BOUND[J]; RECENTRE[PLACE]:= RECENTRE[J];
       IMCENTRE[PLACE]:= IMCENTRE[J]
     "END";
     "FOR" J:= NEW+CLUSTIN-1 "STEP" -1 "UNTIL" NEW "DO"
     "BEGIN" PLACE:= J+1-NEW;
       RE[J]:= WA1[PLACE]; IM[J]:= WA2[PLACE];
       BOUND[J]:= BOUNDIN; CLUST[J]:= CLUSTIN;
       RECENTRE[J]:= RECENT; IMCENTRE[J]:= IMCENT
     "END"
   "END";
 
   GIA:= GIANT;
   RC[0]:= C[0]:= A[N]; RCE[0]:= ABS(C[0]); K:= 0;
   "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
   "BEGIN" RC[I]:= RCE[I]:= 0 ; C[I]:= A[N-I] "END";
   "FOR" I:= 0 "WHILE" K < N "DO"
   "BEGIN" K:= K+1; XK:= RE[K]; YK:= IM[K]; ZK:= XK*XK+YK*YK;
     "FOR" J:= K "STEP" -1 "UNTIL" 1 "DO"
     RCE[J]:= RCE[J]+RCE[J-1]*SQRT(ZK);
     "IF" YK = 0 "THEN"
     "BEGIN" "FOR" J:= K "STEP" -1 "UNTIL" 1 "DO"
        RC[J]:= RC[J]-XK*RC[J-1]
     "END" "ELSE"
     "BEGIN" K:= K+1;
       "IF" K <= N & XK = RE[K] & YK = -IM[K] "THEN"
       "BEGIN" XK:= -2*XK;
         "FOR" J:= K "STEP" -1 "UNTIL" 1 "DO"
         RCE[J]:= RCE[J]+RCE[J-1]*SQRT(ZK);
         "FOR" J:= K "STEP" -1 "UNTIL" 2 "DO"
         RC[J]:= RC[J]+XK*RC[J-1]+ZK*RC[J-2];
         RC[1]:= RC[1]+XK*RC[0]
       "END"
     "END"
   "END";
   RC[0]:= RCE[0]; CORR:= 1.06*ARREB;
   "FOR" I:= 1 "STEP" 1 "UNTIL" N-1 "DO"
   RC[I]:= ABS(RC[I]-C[I])+RCE[I]*CORR*(N+I-2)+RELE*ABS(C[I])+ABSE;
   RC[N]:= ABS(RC[N]-C[N])+RCE[N]*CORR*(N-1)+RELE*ABS(C[N])+ABSE;
   "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" KCLUSTER(1, I);         "COMMENT"
1SECTION : 3.6.1             (DECEMBER 1978)                     PAGE 14
                                                                  ;
 
 
   GOON:= "TRUE";
   "FOR" L:= 1 "WHILE" GOON "DO"
   "BEGIN" INDEX1:= INDEX2:= 0; MIN:= GIANT; I:= N-CLUST[N]+1;
     "FOR" I:= I "WHILE" I >= 2 "DO"
     "BEGIN" J:= I; RECENT:= RECENTRE[I]; IMCENT:= IMCENTRE[I];
       "FOR" J:= J "WHILE" J >= 2 "DO"
       "BEGIN" J:= J-CLUST[J-1];
         H:= SQRT((RECENT-RECENTRE[J])**2 + (IMCENT-IMCENTRE[J])**2);
         "IF" H < BOUND[I] + BOUND[J] & H <= MIN "THEN"
         "BEGIN" INDEX1:= J; INDEX2:= I; MIN:= H "END"
       "END"; I:= I-CLUST[I-1]
     "END";
     "IF" INDEX1 = 0 "THEN" GOON:= "FALSE" "ELSE"
     "BEGIN" "IF" IMCENTRE[INDEX1] = 0 "THEN"
       "BEGIN" "IF" IMCENTRE[INDEX2] ^= 0 "THEN"
         CLUST[INDEX2]:= 2*CLUST[INDEX2]
       "END" "ELSE" "IF" IMCENTRE[INDEX2] = 0 "THEN"
       CLUST[INDEX1]:= 2*CLUST[INDEX1];
       K:= INDEX1+CLUST[INDEX1];
       "IF" K ^= INDEX2 "THEN" SHIFT(INDEX2, K);
       K:= CLUST[INDEX1]+CLUST[K];
       KCLUSTER(K, INDEX1)
     "END"
   "END"
 "END";
         "EOP"
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  1
 
 
 AUTHORS:        M. BAKKER, P.J. HARINGHUIZEN AND C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS:   M. BAKKER, P.J. HARINGHUIZEN,
                 C.G. VAN DER LAAN AND M. VOORINTHOLT.
 
 
 INSTITUTE:      MATHEMATICAL CENTRE AND RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED:       780601.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FIVE PROCEDURES FOR CALCULATING ZEROS OF
     ORTHOGONAL POLYNOMIALS WHICH ARE GIVEN BY THE COEFFICIENTS OF
     THEIR RECURRENCE RELATION:
     ALLZERORTPOL: CALCULATES ALL ZEROS,
     LUPZERORTPOL: CALCULATES A NUMBER OF ADJACENT UPPER OR LOWER ZEROS,
     SELZERORTPOL: CALCULATES A NUMBER OF ADJACENT ZEROS. IT IS
                   EFFICIENT TO USE ALLZERORTPOL IF MORE THAN 50
                   PERCENT OF EXTREME ZEROS OR MORE THAN 25 PERCENT OF
                   SELECTED ZEROS ARE WANTED.
     ALLJACZER   : CALCULATES THE ZEROS OF THE N-TH JACOBIAN POLYNOMIAL.
     ALLLAGZER   : CALCULATES THE ZEROS OF THE N-TH LAGUERRE POLYNOMIAL.
 
 
 KEYWORDS:
 
     ZEROS,
     ORTHOGONAL POLYNOMIALS,
     CHRISTOFFEL ABSCISSAS.
 
 
 REFERENCES:
 
     ABRAMOWITZ, M. AND I.A. STEGUN (1964):
     HANDBOOK OF MATHEMATICAL FUNCTIONS.
     DOVER PUBLICATIONS INC.
 
     GOLUB, G.H. AND J.H. WELSCH (1969):
     CALCULATION OF GAUSS QUADRATURE RULES.
     MATH. COMP. VOL. 23, P.221-230.
 
     LANCZOS, C. (1957):
     APPLIED ANALYSIS.
     PRENTICE HALL.
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  2
 
 
 
     STOER, J. (1972):
     EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK 1.
     HEIDELBERG TASCHENBUECHER 105, SPRINGER.
 
     WILKINSON,J AND REINSCH,C. :
     HANDBOOK OF AUTOMATIC COMPUTATION. VOL. 2.
     LINEAR ALGEBRA
     HEIDELBERG (1971).
 
 
 SUBSECTION:         ALLZERORTPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" ALLZERORTPOL (N, B, C, ZER, EM);
     "VALUE" N; "INTEGER" N; "ARRAY" B, C, ZER, EM;
     "CODE" 31362;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY:  THE DEGREE OF THE ORTHOGONAL POLYNOMIAL OF WHICH
                     THE ZEROS ARE TO BE CALCULATED;
     B, C:   <ARRAY IDENTIFIER>;
             "ARRAY" B, C [0:N-1];
             ENTRY:  THE ELEMENTS B[I] AND C[I], I = 0, 1, ... , N-1,
                     CONTAIN THE COEFFICIENTS OF THE RECURRENCE RELATION
                     P[I+1](X) = (X - B[I]) * P[I](X) - C[I] * P[I-1](X)
                     I = 0, 1, ... , N-1; ASSUMED IS C[0]=0, WHILE THE
                     CONTENTS OF THE ARRAYS ARE PRESERVED;
     ZER:    <ARRAY IDENTIFIER>;
             "ARRAY" ZER[1:N];
             EXIT:   THE ZEROS OF THE N-TH DEGREE ORTHOGONAL POLYNOMIAL;
                     (B MAY BE USED FOR ZER, BUT THEN THIS RECURRENCE
                      COEFFICIENTS ARE OVERWRITTEN BY THE ZEROS AND
                      THE ORIGINAL CONTENTS OF B ARE NOT PRESERVED.)
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0]:  THE MACHINE PRECISION;
                     EM[2]:  THE RELATIVE TOLERANCE OF THE ZEROS;
                     EM[4]:  THE MAXIMUM ALLOWED NUMBER OF ITERATIONS,
                             E.G. 5 * N;
             EXIT:   EM[1]: THE MAXIMUM OF ABS(B[0])+1,C[I]+ABS(B[I])+1,
                             (I=1,...N-2),C[N-1]+ABS(B[N-1]);
                     EM[3]:  INFORMATION CONCERNING THE PROCESS USED;
                             I.E. THE MAXIMUM ABSOLUTE VALUE OF THE
                             CODIAGONAL ELEMENTS NEGLECTED,
                             (SEE ALSO SECTION 3.3.1.1.1.);
                     EM[5]:  THE NUMBER OF ITERATIONS PERFORMED.
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  3
 
 
 
 PROCEDURES USED:
 
     QRIVALSYMTRI    =  CP34160,
     DUPVEC          =  CP31030.
 
 
 METHOD AND PERFORMANCE : SEE SELZERORTPOL (THIS SECTION).
 
 
 EXAMPLE OF USE:
 
     AS A FORMAL TEST OF THE PROCEDURE WE CALCULATE THE ZEROS OF
     THE CHEBYSHEV POLYNOMIAL (OF THE FIRST KIND) OF THE THIRD DEGREE.
     THE RECURRENCE COEFFICIENTS ARE:
     B[I] = 0, I = 0, 1, ....;
     C[0] = 0, C[1] = .5, C[I] = .25 , I = 2, 3, .....
     (IT IS RECOMMENDED TO STORE THE ELEMENTS OF THE ARRAYS B AND C IN
      REVERSED ORDER IF THESE ELEMENTS ARE STRONGLY INCREASING).
 
 "BEGIN" "ARRAY" B, C[0:3], ZER[1:3], EM[0:5];
     EM[0]:= EM[2]:= "-14; EM[4]:=15;
     B[2]:=B[1]:=B[0]:=0;
     C[0]:= 0; C[1]:= .5; C[2]:= .25;
     ALLZERORTPOL (3, B, C, ZER, EM);
     OUTPUT(61,"(""("THE THREE ZEROS:")",/,3(/ZD5B,N),2/,
               "("EM[1]:")",5BD.2D"+2D, /,
               "("EM[3]:")",5BD.2D"+2D, /,"("EM[5]:")",5ZD")",
               1,ZER[1],2,ZER[2],3,ZER[3],EM[1],EM[3],EM[5])
 "END"
 
 
 THE THREE ZEROS:
 
  1     -8.6602540378444"-001
  2     +8.6602540378444"-001
  3     -1.0000000000000"-014
 
 EM[1]:     1.50"+00
 EM[3]:     7.07"-15
 EM[5]:     1
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  4
 
 
 
 SUBSECTION:         LUPZERORTPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" LUPZERORTPOL (N, M, B, C, ZER, EM);
     "VALUE" N, M; "INTEGER" N, M; "ARRAY" B, C, ZER, EM;
     "CODE" 31363;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY:  THE DEGREE OF THE ORTHOGONAL POLYNOMIAL OF WHICH
                     THE ZEROS ARE TO BE CALCULATED;
     M:      <ARITHMETIC EXPRESSION>;
             ENTRY:  THE NUMBER OF ZEROS TO BE CALCULATED;
     B, C:   <ARRAY IDENTIFIER>;
             "ARRAY" B, C [0:N-1];
             ENTRY:  THE ELEMENTS B[I] AND C[I], I = 0, 1, ... , N-1,
                     CONTAIN THE COEFFICIENTS OF THE RECURRENCE RELATION
                     P[I+1](X) = (X - B[I]) * P[I](X) - C[I] * P[I-1](X)
                     I = 0, 1, ... , N-1;
                     ASSUMED IS C[0]=0, WHILE THE CONTENTS
                     OF THE ARRAYS ARE NOT PRESERVED;
     ZER:    <ARRAY IDENTIFIER>;
             "ARRAY" ZER[1:M];
             EXIT:   THE M LOWEST ZEROS ARE DELIVERED;
                     IF HOWEVER THE ARRAY B[0:N-1] CONTAINED THE OPPOSIT
                     VALUES OF THE CORRESPONDING RECURRENCE COEFFICIENTS
                     THEN THE OPPOSITE VALUES OF THE M UPPER ZEROS
                     ARE DELIVERED.
                     IN EITHER CASE, ZER[I]<ZER[I+1], I = 1,...,M-1;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:6];
             ENTRY:  EM[0]:  THE MACHINE PRECISION.
                     EM[2]:  THE RELATIVE TOLERANCE OF THE ZEROS;
                     EM[4]:  THE MAXIMUM ALLOWED NUMBER OF ITERATIONS,
                             E.G. 15 * M;
                     EM[6]:  IF ALL ZEROS ARE KNOWN TO BE POSITIVE
                             THEN 1 ELSE 0;
             EXIT:   EM[1]:  THE MAXIMUM OF ABS(B[0]) + 1 ,
                             C[I]+ABS(B[I])+1,(I=1,...N-2),
                             C[N-1]+ABS(B[N-1]);
                     EM[3]:  INFORMATION CONCERNING THE PROCESS USED,
                             I.E. THE MAXIMUM ABSOLUTE VALUE OF THE
                             THEORETICAL ERRORS OF THE ZEROS
                             (SEE WILKINSON AND REINSCH, 1971, P.263);
                     EM[5]:  THE NUMBER OF ITERATIONS PERFORMED.
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  5
 
 
 
 PROCEDURES USED:
 
     DUPVEC          =  CP31030,
     INFNRMVEC       =  CP31061.
 
 
 METHOD AND PERFORMANCE : SEE SELZERORTPOL (THIS SECTION).
 
 
 EXAMPLE OF USE:
 
     WE CALCULATE THE TWO LOWER AND THE TWO UPPER ZEROS OF THE
     LAGUERRE POLYNOMIAL OF THE THIRD DEGREE.
     THE RECURRENCE COEFFICIENTS ARE OBTAINED FROM [1], P.782:
     B[I] = - A2I / A3I = 2I + 1;
     C[I] = A4I / (A3I * A3(I-1)) * A1(I-1) = I * I, I = 0, 1, 2.
     (IT IS RECOMMENDED TO STORE THE ELEMENTS OF THE ARRAYS B AND C IN
      REVERSED ORDER IF THESE ELEMENTS ARE STRONGLY DECREASING).
 
     "BEGIN" "ARRAY" B, C[0:3], ZER[1:2], EM[0:6];
     "INTEGER" I;
     EM[0]:= EM[2]:= "-14; EM[4]:= 45; EM[6]:= 1;
     "FOR" I:= 0, 1, 2 "DO"
     "BEGIN" B[I]:= 2 * I + 1; C[I]:= I * I "END";
     LUPZERORTPOL (3, 2, B, C, ZER, EM);
     OUTPUT(61,"(""("THE TWO LOWER ZEROS:")",/,2(/ZD5B,N),2/,
               "("EM[1]:")",5BD.2D"+2D, /,
               "("EM[3]:")",5BD.2D"+2D, /,"("EM[5]:")",5ZD")",
               1,ZER[1],2,ZER[2],EM[1],EM[3],EM[5]);
     EM[6]:= 0;
     "FOR" I:= 0, 1, 2 "DO"
     "BEGIN" B[I]:= - 2 * I - 1; C[I]:= I * I "END";
     LUPZERORTPOL (3, 2, B, C, ZER, EM);
     OUTPUT(61,"("3/,"("THE TWO UPPER ZEROS:")",/,2(/ZD5B,N),2/,
               "("EM[1]:")",5BD.2D"+2D, /,
               "("EM[3]:")",5BD.2D"+2D, /,"("EM[5]:")",5ZD")",
               1,-ZER[1],2,-ZER[2],EM[1],EM[3],EM[5]);
     "END"
 
 
     THE TWO LOWER ZEROS:
 
      1     +4.1577455678348"-001
      2     +2.2942803602791"+000
 
     EM[1]:     9.00"+00
     EM[3]:     5.72"-16
     EM[5]:    12
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  6
 
 
 
     THE TWO UPPER ZEROS:
 
      1     +6.2899450829375"+000
      2     +2.2942803602791"+000
 
     EM[1]:     9.00"+00
     EM[3]:     4.70"-20
     EM[5]:    14
 
 
 SUBSECTION:         SELZERORTPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" SELZERORTPOL (N, N1, N2, B, C, ZER, EM);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2; "ARRAY" B, C, ZER, EM;
     "CODE" 31364;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     N,N1,N2:<ARITHMETIC EXPRESSION>;
             ENTRY:  N IS THE DEGREE OF THE ORTHOGONAL POLYNOMIAL OF
                     WHICH THE N1-ST UP TO AND INCLUDING N2-ND ZEROS ARE
                     TO BE CALCULATED(ZER[N1]>=ZER[N2]);
     B, C:   <ARRAY IDENTIFIER>;
             "ARRAY" B,C [0 : N-1];
             ENTRY:  THE ELEMENTS B[I] AND C[I], I = 0, 1, ... , N-1,
                     CONTAIN THE COEFFICIENTS OF THE RECURRENCE RELATION
                     P[I+1](X) = (X - B[I]) * P[I](X) - C[I] * P[I-1](X)
                     I = 0, 1, ... , N-1,
                     ASSUMED IS C[0]=0, WHILE THE CONTENTS
                     OF THE ARRAYS IS PRESERVED;
     ZER:    <ARRAY IDENTIFIER>;
             "ARRAY" ZER [N1:N2];
             EXIT:   THE N2-N1+1 CALCULATED ZEROS IN DECREASING ORDER.
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY" EM[0:5];
             ENTRY:  EM[0]:  THE MACHINE PRECISION.
                     EM[2]:  THE RELATIVE TOLERANCE OF THE ZEROS;
             EXIT:   EM[1]:  THE MAXIMUM OF ABS(B[0]) + 1,
                             C[I]+ABS(B[I])+1 (I=1,...N-2) AND
                             C[N-1]+ABS(B[N-1]);
                     EM[5]:  THE NUMBER OF ITERATIONS PERFORMED.
 
 
 PROCEDURES USED:
 
    VALSYMTRI       =  CP34151.
1SECTION : 3.6.2                  (DECEMBER 1978)                PAGE  7
 
 
 
 METHOD AND PERFORMANCE:
 
     THE ZEROS OF AN ORTHOGONAL POLYNOMIAL ARE THE EIGENVALUES OF A
     SYMMETRIC TRIDIAGONAL MATRIX (SEE GOLUB AND WELSCH (1969),
     LANCZOS (1957),P.375,376, STOER (1972),P.120).
     THE ORTHOGONAL POLYNOMIAL IS DEFINED BY A LINEAR THREE-TERM
     HOMOGENEOUS RECURRENCE RELATION.
 
 
 EXAMPLE OF USE :
 
     WE CALCULATE THE THIRD ZERO OF THE LEGENDRE POLYNOMIAL OF THE
     FOURTH DEGREE. THE RECURRENCE COEFFICIENTS ARE OBTAINED FROM
     ABRAMOWITZ AND STEGUN (1964),P.782:
     B[I] = 0, I = 0, 1, ....;
     C[I] = A4I / (A3I * A3(I-1)) * A1(I-1) = I * I / ( 4 * I * I - 1),
             I = 0, 1, .....
     (IT IS RECOMMENDED TO STORE THE ELEMENTS OF THE ARRAYS B AND C IN
      REVERSED ORDER IF THESE ELEMENTS ARE STRONGLY DECREASING).
 
     "BEGIN" "ARRAY" B, C[0:4], ZER[3:3], EM[0:5];
     "INTEGER" I;
     EM[0]:= EM[2]:= "-14;
     "FOR" I:= 0, 1, 2, 3 "DO"
     "BEGIN" B[I]:= 0; C[I]:= I * I / (4 * I * I - 1) "END";
     SELZERORTPOL (4, 3, 3, B, C, ZER, EM);
     OUTPUT(61,"(""("THE THIRD ZERO:")",2/,ZD5B,N,2/,
               "("EM[1]:")",5BD.2D"+2D, /,
               "("EM[5]:")",5ZD")",3,ZER[3],EM[1],EM[5])
     "END"
 
     THE THIRD ZERO:
 
      3     -3.3998104358486"-001
 
     EM[1]:     1.33"+00
     EM[5]:    12
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE  8
 
 
 
 SUBSECTION: ALL JAC ZER.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" ALL JAC ZER(N, ALFA, BETA, ZER);
     "VALUE" N, ALFA, BETA;
     "INTEGER" N; "REAL" ALFA, BETA; "ARRAY" ZER;
     "CODE" 31370;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE ARRAY ZER; N >= 1;
     ALFA,BETA:
             <ARITHMETIC EXPRESSION>;
             THE PARAMETERS OF THE JACOBI POLYNOMIAL,
             SEE ABRAMOWITZ AND STEGUN (1964);
             ALFA, BETA > - 1;
     ZER:    <ARRAY IDENTIFIER>;
             "ARRAY" ZER[1 : N];
             EXIT: ZER[1], ..., ZER[N] ARE THE ZEROS OF THE N-TH
                   JACOBI POLYNOMIAL WITH PARAMETERS ALFA AND BETA.
 
 
 PROCEDURES USED:
 
     ALL ZER ORT POL = CP 31362.
 
 
 REQUIRED CENTRAL MEMORY:
 
     IF ALFA = BETA THEN TWO AUXILIARY ARRAYS OF N//2 REALS ARE
     USED, OTHERWISE TWO AUXILIARY ARRAYS OF N REALS ARE DECLARED.
 
 
 METHOD AND PERFORMANCE:
 
     THE JACOBI POLYNOMIALS ARE A SPECIAL CASE OF ORTHOGONAL
     POLYNOMIALS (SEE ABRAMOWITZ AND STEGUN (1964)); ALL JAC ZER
     COMPUTES THE COEFFICIENTS OF THE THREE-TERM RECURRENCE RELATION
     AND CALLS THE PROCEDURE ALL ZER ORT POL TO COMPUTE THE ZEROS;
     IF ALFA=BETA, THE POLYNOMIALS ARE ODD OR EVEN, HENCE ONLY THE
     POSITIVE ZEROS ARE CALCULATED; THIS IS DONE BY MEANS OF THE
     FORMULAS
 
           P(2*M, ALFA, ALFA, X) = C(M)*P(M, ALFA, -0.5, 2*X*X - 1),
 
       P(2*M - 1, ALFA, ALFA, X) = D(M)*P(M, ALFA, +0.5, 2*X*X - 1)*X
 
     (SEE ABRAMOWITZ AND STEGUN (1964), FORMULAS 22.5.20 - 22.5.27).
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE  9
 
 
 
 EXAMPLE OF USE:
 
     THE PROGRAM
 
     "BEGIN" "ARRAY" X[1:3];
       ALL JAC ZER(3,-.5,-.5,X);
       OUTPUT(61,"("3(4B-D.13D"-ZD)")",X[1],X[2],X[3])
     "END"
 
     DELIVERS THE FOLOWING RESULTS:
 
     -8.6602540378444"-1    0.0000000000000" 0     8.6602540378444"-1
 
 
 SUBSECTION: ALL LAG ZER.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" ALL LAG ZER(N, ALFA, ZER);
     "VALUE" N, ALFA;
     "INTEGER" N; "REAL" ALFA; "ARRAY" ZER;
     "CODE" 31371;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE ARRAY ZER; N >= 1;
     ALFA:   <ARITHMETIC EXPRESSION>;
             THE PARAMETER OF THE LAGUERRE POLYNOMIAL,
             SEE ABRAMOWITZ AND STEGUN (1964); ALFA > -1;
     ZER:    <ARRAY IDENTIFIER>;
             "ARRAY" ZER[1 : N];
             EXIT: ZER[1], ..., ZER[N] ARE THE ZEROS OF THE N-TH
                   LAGUERRE POLYNOMIAL WITH PARAMETER ALFA.
 
 
 PROCEDURES USED:
 
     ALL ZER ORT POL = CP 31362.
 
 
 REQUIRED CENTRAL MEMORY:
 
     TWO AUXILIARY ARRAYS OF N REALS ARE USED.
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE 10
 
 
 
 METHOD AND PERFORMANCE:
 
     THE LAGUERRE POLYNOMIALS ARE A SPECIAL CASE OF ORTHOGONAL
     POLYNOMIALS (SEE ABRAMOWITZ AND STEGUN (1964)); ALL LAG ZER
     COMPUTES THE COEFFICIENTS OF THE THREE-TERM RECURRENCE RELATION
     AND CALLS THE PROCEDURE ALL ZER ORT POL TO COMPUTE THE ZEROS.
 
 
 EXAMPLE OF USE:
 
     "BEGIN" "ARRAY" X[1:3];
       ALL LAG ZER(3,-.5,X);
       OUTPUT(61,"("3(4B-D.13D"-ZD)")",X[1],X[2],X[3])
     "END"
 
     DELIVERS THE FOLOWING RESULTS:
 
     5.5253437422633" 0.    1.7844927485432" 0     1.9016350919350" -1
 
 
 SOURCE TEXT(S) :
0"CODE"31362;
 "PROCEDURE" ALLZERORTPOL (N, B, C, ZER, EM);
 "VALUE" N; "INTEGER" N; "ARRAY" B, C, ZER, EM;
 "BEGIN" "INTEGER"I;"REAL"NRM;"ARRAY"BB[1:N];
     "PROCEDURE" DUPCEV (L, U, SHIFT, A, B);
     "VALUE"L,U,SHIFT;"INTEGER"L,U,SHIFT;"ARRAY"A,B;
     "FOR" U:=U "STEP" -1 "UNTIL" L "DO" A[U]:=B[U+SHIFT];
     NRM:=ABS(B[0]);
     "FOR"I:=1"STEP"1"UNTIL"N-2"DO""IF"C[I]+ABS(B[I])>NRM"THEN"
          NRM:=C[I]+ABS(B[I]);
      "IF"N>1"THEN"NRM:="IF"NRM+1>=C[N-1]+ABS(B[N-1])"THEN"NRM+1"ELSE"
                        C[N-1]+ABS(B[N-1]);
      EM[1]:=NRM; DUPCEV(1,N,-1,ZER,B);
      DUPVEC(1,N-1,0,BB,C);BB[N]:=0;
      QRIVALSYMTRI(ZER,BB,N,EM)
 "END" ALLZERORTPOL
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE 11
 
 
                                                                  ;
         "EOP"
 "CODE"31363;
 "PROCEDURE" LUPZERORTPOL (N, M, B, C, ZER, EM);
 "VALUE" N, M; "INTEGER" N, M; "ARRAY" B, C, ZER, EM;
 "BEGIN"
 "PROCEDURE" RATQR(N,M,POSDEF,DLAM,EPS)TRANS:(D,B2);
   "VALUE" N,M,POSDEF,DLAM,EPS;
   "INTEGER" N,M;
   "BOOLEAN" POSDEF;
   "REAL" DLAM,EPS;
   "ARRAY" D,B2;
 "COMMENT" QR ALGORITHM FOR THE COMPUTATION OF THE LOWEST EIGENVALUES
   OF A SYMMETRIC TRIDIAGONAL MATRIX. A RATIONAL VARIANT OF THE
   QR TRANSFORMATION IS USED, CONSISTING OF TWO SUCCESSIVE QD STEPS
   PER ITERATION.
   A SHIFT OF THE SPECTRUM AFTER EACH ITERATION GIVES AN ACCELERATED
   RATE OF CONVERGENCE. A NEWTON CORRECTION,DERIVED FROM THE
   CHARACTERISTIC POLYNOMIAL,IS USED AS SHIFT.
    RATQR IS IMPLEMENTED BY REINSCH AND BAUER, SEE WILKINSON AND REINSCH
    ,1971, CONTR. II-6.
   FORMATS: D,B2[1:N];
 "BEGIN"
   "INTEGER" I,J,K,T; "REAL" DELTA,E,EP,ERR,P,Q,QP,R,S,TOT;
 "COMMENT" LOWER BOUND FOR EIGENVALUES FROM GERSHGORIN, INITIAL SHIFT;
   B2[1]:= ERR:= Q:= S:= 0; TOT:= D[1];
   "FOR" I:= N "STEP" -1   "UNTIL" 1 "DO"
   "BEGIN"
     P:= Q; Q:= SQRT(B2[I]); E:= D[I]-P-Q;
     "IF" E < TOT "THEN" TOT:= E
   "END" I;
   "IF" POSDEF & TOT < 0 "THEN" TOT:= 0 "ELSE"
   "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" D[I]:= D[I]-TOT;
   T:= 0;
   "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
   "BEGIN"
 NEXT QR TRANSFORMATION:  T:= T + 1;
   TOT:= TOT + S; DELTA:= D[N]-S; I:= N;
   E:= ABS(EPS*TOT); "IF" DLAM < E "THEN" DLAM:= E;
   "IF" DELTA < = DLAM "THEN" "GOTO" CONVERGENCE;
   E:= B2[N]/DELTA; QP:= DELTA+E; P:= 1;
   "FOR" I:= N-1 "STEP" -1 "UNTIL" K "DO"
   "BEGIN"
     Q:= D[I]-S-E; R:= Q/QP; P:= P*R+1;
     EP:= E*R; D[I+1]:= QP+EP; DELTA:= Q-EP;
     "IF" DELTA < = DLAM "THEN" "GOTO" CONVERGENCE;
     E:= B2[I]/Q;QP:= DELTA+E; B2[I+1]:= QP*EP
   "END" I;
   D[K]:= QP; S:= QP/P;
                                                               "COMMENT"
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE 12
                                                                 ;
 
 
   "IF" TOT+S > TOT "THEN" "GOTO" NEXT QR TRANSFORMATION;
 "COMMENT" IRREGULAR END OF ITERATION,
   DEFLATE MINIMUM DIAGONAL ELEMENT;
   S:= 0; I:= K; DELTA:= QP;
   "FOR" J:= K+1 "STEP" 1 "UNTIL" N "DO"
     "IF" D[J] < DELTA "THEN"
     "BEGIN" I:= J; DELTA:= D[J] "END";
 CONVERGENCE:
   "IF" I < N "THEN" B2[I+1]:= B2[I]*E/QP;
     "FOR" J:= I-1 "STEP" -1 "UNTIL" K "DO"
       "BEGIN" D[J+1]:= D[J]-S; B2[J+1]:= B2[J] "END" J;
     D[K]:= TOT; B2[K]:= ERR:= ERR+ABS(DELTA)
   "END" K;
 EM[5]:=T;EM[3]:=INFNRMVEC(1,M,T,B2);
 "END" RATQR;
     "PROCEDURE" DUPCEV (L, U, SHIFT, A, B);
     "VALUE"L,U,SHIFT;"INTEGER"L,U,SHIFT;"ARRAY"A,B;
     "FOR" U:=U "STEP" -1 "UNTIL" L "DO" A[U]:=B[U+SHIFT];
     "INTEGER" I;"REAL"NRM;
     NRM:=ABS(B[0]);
     "FOR"I:=1"STEP"1"UNTIL"N-2"DO""IF"C[I]+ABS(B[I])>NRM"THEN"
          NRM:=C[I]+ABS(B[I]);
      "IF"N>1"THEN"NRM:="IF"NRM+1>=C[N-1]+ABS(B[N-1])"THEN"NRM+1"ELSE"
                        C[N-1]+ABS(B[N-1]);
      EM[1]:=NRM;
     DUPCEV(1,N,-1,B,B);
     DUPCEV(2,N,-1,C,C);
     RATQR (N, M, EM[6] = 1, EM[2], EM[0], B, C);
     DUPVEC (1, M, 0, ZER, B)
 "END" LUPZERORTPOL;
         "EOP"
 
 
 "CODE"31364;
 "PROCEDURE" SELZERORTPOL (N, N1, N2, B, C, ZER, EM);
 "VALUE" N, N1, N2; "INTEGER" N, N1, N2; "ARRAY" B, C, ZER, EM;
 "BEGIN" "INTEGER"I;"REAL"NRM;"ARRAY"D[1:N];
     "PROCEDURE" DUPCEV (L, U, SHIFT, A, B);
     "VALUE"L,U,SHIFT;"INTEGER"L,U,SHIFT;"ARRAY"A,B;
     "FOR" U:=U "STEP" -1 "UNTIL" L "DO" A[U]:=B[U+SHIFT];
     NRM:=ABS(B[0]);
     "FOR"I:=N-2"STEP"-1"UNTIL"1"DO""IF"C[I]+ABS(B[I])>NRM"THEN"
          NRM:=C[I]+ABS(B[I]);
                                                               "COMMENT"
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE 13
                                                                 ;
 
 
      "IF"N>1"THEN"NRM:="IF"NRM+1>=C[N-1]+ABS(B[N-1])"THEN"NRM+1"ELSE"
                        C[N-1]+ABS(B[N-1]);
      EM[1]:=NRM;
     DUPCEV(1,N,-1,D,B);
     VALSYMTRI (D, C, N, N1, N2, ZER, EM);
     EM[5]:=EM[3]
 "END" SELZERORTPOL;
         "EOP"
 
 
 "CODE" 31370;
     "PROCEDURE" ALL JAC ZER(N, ALFA, BETA, ZER);
     "VALUE" N, ALFA, BETA     ; "INTEGER" N;
     "REAL" ALFA, BETA     ; "ARRAY" ZER;
     "IF" ALFA = BETA "THEN"
     "BEGIN" "INTEGER" I, M;
         "ARRAY" A, B[0:N//2], EM[0:5];
         "REAL" MIN, GAMMA, SUM, ZERI;
         M:= N//2; "IF" N ^= 2*M "THEN"
         "BEGIN" GAMMA:= + 0.5; ZER[M + 1]:= 0 "END"
         "ELSE" GAMMA:= - 0.5;
         MIN:= 0.25 - ALFA*ALFA; SUM:= ALFA + GAMMA + 2;
         A[0]:= (GAMMA - ALFA)/SUM; A[1]:= MIN/SUM/(SUM + 2);
         B[1]:= 4*(1 + ALFA)*(1 + GAMMA)/SUM/SUM/(SUM + 1);
         "FOR" I:= 2 "STEP" 1 "UNTIL" M - 1 "DO"
         "BEGIN" SUM:= I + I + ALFA + GAMMA;
             A[I]:= MIN/SUM/(SUM + 2); SUM := SUM*SUM;
             B[I]:= 4*I*(I + ALFA + GAMMA)*(I + ALFA)*(I + GAMMA)/
             SUM/(SUM - 1)
         "END";
         EM[0]:=ARREB; EM[2]:="-10; EM[4]:= 6*M;
         ALL ZER ORT POL (M, A, B, ZER, EM);
         "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" ZER[I]:= ZERI:= - SQRT((1 + ZER[I])/2);
             ZER[N + 1 - I]:= - ZERI
         "END"
     "END" "ELSE"
     "BEGIN" "INTEGER" I; "REAL" SUM, MIN;
         "ARRAY" A, B[0:N], EM[0:5];
                                                               "COMMENT"
1SECTION : 3.6.2             (DECEMBER 1978)                     PAGE 14
                                                                 ;
 
 
         MIN:= (BETA - ALFA)*(BETA + ALFA);
         SUM:= ALFA + BETA + 2; B[0]:= 0;
         A[0]:= (BETA - ALFA)/SUM;
         A[1]:= MIN/SUM/(SUM + 2);
         B[1]:= 4*(1 + ALFA)*(1 + BETA)/SUM/SUM/(SUM + 1);
         "FOR" I:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" SUM:= I + I + ALFA + BETA;
             A[I]:= MIN/SUM/(SUM + 2); SUM:= SUM*SUM;
             B[I]:= 4*I*(I + ALFA + BETA)*(I + ALFA)*(I + BETA)/
             (SUM - 1)/SUM
         "END";
         EM[0]:=ARREB; EM[2]:= 1.0"-8; EM[4]:= 6*N;
         ALL ZER ORT POL(N, A, B, ZER, EM)
     "END" ALL JAC ZER;
         "EOP"
 
 
 "CODE" 31371;
     "PROCEDURE"  ALL LAG ZER(N, ALFA, ZER);
     "VALUE" N, ALFA     ; "INTEGER"N; "REAL" ALFA     ; "ARRAY" ZER;
     "BEGIN" "INTEGER" I; "ARRAY" A, B[0:N], EM[0:5];
         B[0]:= 0; A[N - 1]:= N + N + ALFA - 1;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" A[I - 1]:= I + I + ALFA - 1;
             B[I]:= I*(I + ALFA)
         "END";
        EM[0]:=ARREB; EM[2]:= "-10;EM[4]:= 6*N;
         ALL ZER ORT POL(N, A, B, ZER, EM)
     "END" ALL LAG ZER;
         "EOP"
1SECTION : 3.6.3              (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR: C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730815.
 
 
 BRIEF DESCRIPTION:
 
     COMKWD CALCULATES THE ROOTS OF A QUADRATIC EQUATION WITH COMPLEX
     COEFFICIENTS.
 
 
 KEYWORDS:
 
     ZEROS,QUADRATIC EQUATION,POLYNOMIAL EQUATION,COMPLEX COEFFICIENTS.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMKWD(PR,PI,QR,QI,GR,GI,KR,KI);
     "VALUE"PR,PI,QR,QI;"REAL"PR,PI,QR,QI,GR,GI,KR,KI;
     "CODE" 34345;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     PR,PI,QR,QI:<ARITHMETIC EXPRESSION>;
                 ENTRY:PR,QR ARE THE REAL PARTS AND PI,QI ARE THE
                       IMAGINARY PARTS OF THE COEFFICIENTS OF THE
                       QUADRATIC EQUATION:
                       X**2-2*(PR+I*PI)*X-(QR+I*QI)=0;
     GR,GI,KR,KI:<VARIABLE>;
                 EXIT:THE REAL PARTS AND THE IMAGINARY PARTS OF THE
                      DINOMIAL ARE DELIVERED IN GR,KR AND GI,KI,
                      RESPECTIVELY;MOREOVER,THE MODULUS OF GR+I*GI IS
                      GREATER OR EQUAL THE MODULUS OF KR+I*KI.
 
 
 PROCEDURES USED:
 
     COMMUL=CP34341;
     COMDIV=CP34342;
     COMSQRT=CP34343.
 
 
 LANGUAGE: ALGOL 60.
 
1SECTION : 3.6.3              (JULY 1974)                         PAGE 2
 
 
 
 
 EXAMPLE OF USE:
 
 "BEGIN""REAL"GR,GI,KR,KI;
 COMKWD(-.1,.3,.11,.02,GR,GI,KR,KI);
 OUTPUT(61,"(""("X**2-2(-.1+.3*I)*X-( .11+.02*I) HAS ROOTS")",/,
     -D.DD,+D.DD,"("*I")",/,
     -D.DD,+D.DD,"("*I")"")",GR,GI,KR,KI)
 "END"
 
 X**2-2(-.1+.3*I)*X-( .11+.02*I) HAS ROOTS
 -0.30+0.40*I
  0.10+0.20*I
 
 
 SOURCE TEXT(S):
0"CODE"34345;
 "PROCEDURE" COMKWD(PR,PI,QR,QI,GR,GI,KR,KI);
 "VALUE" PR,PI,QR,QI;"REAL" PR,PI,QR,QI,GR,GI,KR,KI;
 "BEGIN"
 "IF" QR=0 & QI = 0 "THEN"
 "BEGIN" KR:=KI:=0 ;GR:=PR*2;GI:=PI*2 "END" "ELSE"
 "IF" PR=0 & PI= 0 "THEN"
 "BEGIN" COMSQRT(QR,QI,GR,GI);KR:=-GR;KI:=-GI "END" "ELSE"
 "BEGIN" "REAL" HR,HI;
 "IF" ABS(PR) > 1 "OR" ABS(PI) >1 "THEN" "BEGIN"
 COMDIV(QR,QI,PR,PI,HR,HI);
 COMDIV(HR,HI,PR,PI,HR,HI);
 COMSQRT(1+HR,HI,HR,HI);
 COMMUL(PR,PI,HR+1,HI,GR,GI);
 "END" "ELSE" "BEGIN" COMSQRT(QR+(PR+PI)*(PR-PI),QI+ PR*PI*2,HR,HI);
        "IF" PR * HR + PI * HI > 0 "THEN"
        "BEGIN" GR := PR + HR;GI := PI + HI "END" "ELSE"
        "BEGIN" GR := PR - HR;GI:= PI - HI "END";
 "END";
 COMDIV(-QR,-QI,GR,GI,KR,KI);
 "END"
 "END" COMKWD;
         "EOP"
1SECTION : 4.1                (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR     :    J.W. DANIEL.
 
 
 REVISOR    :    J. KOK.
 
 
 INSTITUTE  :    MATHEMATICAL CENTRE.
 
 
 RECEIVED   :    730528 (EULER).
                 730917 (SUMPOSSERIES).
 
 
 BRIEF DESCRIPTION  :
 
     THIS  SECTION  CONTAINS  TWO  PROCEDURES  FOR  THE  SUMMATION  OF
     CONVERGENT INFINITE SERIES:
 
     EULER PERFORMS THE  SUMMATION OF AN ALTERNATING SERIES.
 
     SUMPOSSERIES   PERFORMS  THE  SUMMATION OF A CONVERGENT SERIES WITH
     POSITIVE MONOTONOUSLY  DECREASING TERMS USING THE VAN WIJNGAARDEN
     TRANSFORMATION OF  THE SERIES TO AN ALTERNATING SERIES.
 
 KEYWORDS   :
 
     SUMMATION,
     SERIES,
     VAN WIJNGAARDEN TRANSFORMATION.
 
 
 SUBSECTION : EULER.
 
 CALLING SEQUENCE   :
 
     THE HEADING OF THE PROCEDURE IS    :
     "REAL""PROCEDURE" EULER(AI, I, EPS, TIM);
     "VALUE" EPS, TIM; "INTEGER" I, TIM; "REAL" AI, EPS;
     "CODE" 32010;
 
     EULER  :    DELIVERS THE COMPUTED SUM OF THE INFINITE SERIES
                 SUM( A[I], I:= 0,1,...  )  .
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AI     :    <ARITHMETIC EXPRESSION>;
                 THE SUMMAND,
                 THIS EXPRESSION WILL BE DEPENDENT ON THE JENSEN
                 PARAMETER I;
                 AI IS THE I-TH TERM OF THE SERIES (I >= 0).
     I      :    <VARIABLE>;
                 JENSEN PARAMETER.
     EPS,TIM:    <ARITHMETIC EXPRESSION>;
                 THE SUMMATION IS CONTINUED UNTIL TIM SUCCESSIVE TERMS
                 OF THE TRANSFORMED SERIES ARE IN ABSOLUTE VALUE LESS
                 THAN EPS.
 
 
 
1SECTION : 4.1                (DECEMBER 1975)                     PAGE 2
 
 
 
 PROCEDURES USED    :    NONE.
 
 
 
 REQUIRED CENTRAL MEMORY    :
 
     EXECUTION FIELD LENGTH     :    25.
 
 
 LANGUAGE   :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     EULER PERFORMS THE SUMMATION OF AN ALTERNATING SEQUENCE BY APPLYING
     EULER'S TRANSFORMATION. BY THIS TRANSFORMATION THE SEQUENCE OF
     TERMS IS REPLACED BY THE SEQUENCE OF MEANS OF TWO SUCCESSIVE TERMS.
     IF NECESSARY THE NEW SEQUENCE IS AGAIN TRANSFORMED BY EULER'S
     TRANSFORMATION. THE SUMMATION STOPS WHEN TIM SUCCESSIVE TERMS OF
     THE (ONCE OR SEVERAL TIMES TRANSFORMED) SEQUENCE ARE IN ABSOLUTE
     VALUE LESS THAN EPS.
 
 
 REFERENCES :
 
     P.NAUR, ED.  :  REVISED REPORT ON THE ALGORITHMIC LANGUAGE
     ALGOL 60. COPENHAGEN (1964).
 
 
 EXAMPLE OF USE     :
 
     THE PROGRAM :
 
     "BEGIN""INTEGER" K;
 
         OUTPUT(61, "("+.8D"+2D")",
             EULER((- 1) ** K / (K + 1) ** 2, K, "- 6, 100))
     "END"
 
     DELIVERS   :
 
           +.82246703"+00.
1SECTION : 4.1                (JULY 1974)                         PAGE 3
 
 
 
 SUBSECTION : SUMPOSSERIES.
 
 CALLING SEQUENCE   :
 
     THE HEADING OF THE PROCEDURE IS    :
 
     "REAL""PROCEDURE" SUMPOSSERIES(AI, I, MAXADDUP, MAXZERO, MAXRECURS,
                                    MACHEXP, TIM);
     "VALUE" MAXADDUP, MAXZERO, MAXRECURS, MACHEXP, TIM;
     "REAL" AI, I, MAXZERO; "INTEGER" MAXADDUP, MAXRECURS, MACHEXP, TIM;
     "CODE" 32020;
 
     SUMPOSSERIES : DELIVERS THE COMPUTED SUM OF THE INFINITE SERIES
                    A[I] , I:= 1,2,....     .
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AI :        <ARITHMETIC EXPRESSION>;
                 THE SUMMAND,
                 THIS EXPRESSION SHOULD BE DEPENDENT ON THE JENSEN
                 PARAMETER I;
                 AI IS THE I-TH TERM OF THE SERIES (I >= 1).
     I :         <VARIABLE>;
                 JENSEN PARAMETER.
     MAXADDUP :  <ARITHMETIC EXPRESSION>;
                 UPPER LIMIT FOR THE NUMBER OF STRAIGHTFORWARD ADDITIONS
                 .
     MAXZERO, TIM :
                 <ARITHMETIC EXPRESSION>;
                 TOLERANCES EPS AND TIM NEEDED FOR A CALL OF THE
                 PROCEDURE EULER (THIS SECTION). MAXZERO IS ALSO USED
                 AS A TOLERANCE FOR MAXADDUP STRAIGHTFORWARD ADDITIONS.
     MAXRECURS : <ARITHMETIC EXPRESSION>;
                 UPPER LIMIT FOR THE RECURSION DEPTH OF THE
                 VAN WIJNGAARDEN TRANSFORMATIONS.
     MACHEXP :   <ARITHMETIC EXPRESSION>;
                 IN ORDER TO AVOID OVERFLOW AND EVALUATION OF THOSE
                 TERMS WHICH CAN BE NEGLECTED, MACHEXP HAS TO BE THE
                 LARGEST ADMISSIBLE VALUE X FOR WHICH TERMS WITH INDEX
                 J = K * (2 ** X) CAN BE COMPUTED (K IS SMALL).
                 OTHERWISE OVERFLOW MIGHT OCCUR IN COMPUTING A VALUE FOR
                 THE JENSEN PARAMETER I, WHICH CAN BE AN UNUSUALLY
                 HIGH POWER OF 2.
 
 
 
 PROCEDURES USED    :    EULER = CP32010.
 
 
 REQUIRED CENTRAL MEMORY    :
 
     EXECUTION FIELD LENGTH :  ABOUT 1000 * RECURSION DEPTH.
 
 
 LANGUAGE   :    ALGOL 60.
 
 
1SECTION : 4.1                (JULY 1974)                         PAGE 4
 
 
 
 METHOD AND PERFORMANCE :
 
     WHEN THE TERMS AI WITH INDICES
     MAXADDUP + 1, ... , MAXADDUP + TIM ARE ALL LESS THAN MAXZERO,
     CONVERGENCE IS ASSUMED AND SUMPOSSERIES DELIVERS THE SUM OF THE
     SERIES BY STRAIGHTFORWARD ADDITION UNTIL TIM SERIAL TERMS ARE LESS
     THAN MAXZERO. OTHERWISE THE VAN WIJNGAARDEN TRANSFORMATION IS
     APPLIED, YIELDING AN ALTERNATING SERIES WHICH IS SUMMED UP WITH
     EULER'S METHOD. SINCE THE TERMS OF THIS ALTERNATING SERIES ARE
     THEMSELVES INFINITE SERIES WITH POSITIVE TERMS, THE HERE DESCRIBED
     PROCESS  IS RECURSIVELY CALLED FOR THE SUMMATION OF EACH
     TERM THAT IS WANTED BY EULER'S METHOD.
     HOWEVER, ONLY STRAIGHTFORWARD ADDITION IS APPLIED IF THE ALLOWED
     RECURSION LEVEL (SPECIFIED BY MAXRECURS) HAS BEEN REACHED.
     IN THE RECURSION THE PROCESS ASKS FOR TERMS AI WITH INDICES OF
     THE TYPE J * (2 ** K), IN WHICH K CAN BE VERY LARGE. IN ORDER
     TO AVOID OVERFLOW AN UPPER BOUND FOR K MUST BE GIVEN IN MACHEXP.
     IF K EXCEEDS THIS BOUND THE CORRESPONDING TERM IS TAKEN TO BE ZERO.
 
 
 
 REFERENCES :
 
     [1] DANIEL, J.W.   :
         SUMMATION OF A SERIES OF POSITIVE TERMS BY CONDENSATION
         TRANSFORMATIONS. MATH. OF COMP. V.23, P.91-96 (1969).
     [2] WIJNGAARDEN, A. VAN  :
         COURSE SCIENTIFIC COMPUTING B, PROCESS ANALYSIS (DUTCH)
         MATHEMATISCH CENTRUM CR-18 (1965).
 
 
 EXAMPLE OF USE :
 
     THE PROGRAM    :
 
     "BEGIN""COMMENT" 730808, EXAMPLE OF THE USE OF SUMPOSSERIES;
 
        "REAL" I;
        OUTPUT(61, "("/, +.12D"+DD")",
        SUMPOSSERIES(1 / I ** 2, I, 100, "- 7, 8, 1068, 10))
     "END"
 
     DELIVERS   :
 
         +.164493406604"+01
         NUMBER OF TERMS USED   :  462,
         RECURSION DEPTH        :    1.
1SECTION : 4.1                (JULY 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S) :
0"CODE" 32010;
 "REAL""PROCEDURE" EULER(AI, I, EPS, TIM);
 "VALUE" EPS, TIM; "INTEGER" I, TIM; "REAL" AI, EPS;
 "BEGIN""INTEGER" K, N, T; "REAL" MN, MP, DS, SUM; "ARRAY" M[0:15];
     N:= T:= 0; I:= 0; M[0]:= AI; SUM:= M[0] / 2;
 NEXT TERM: I:= I + 1; MN:= AI;
     "FOR" K:= 0 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" MP:= (MN + M[K]) / 2; M[K]:= MN; MN:= MP "END";
     "IF" ABS(MN) < ABS(M[N]) & N < 15 "THEN"
     "BEGIN" DS:= MN / 2; N:= N + 1; M[N]:= MN "END" "ELSE" DS:= MN;
     SUM:= SUM + DS; T:= "IF" ABS(DS) < EPS "THEN" T + 1 "ELSE" 0;
     "IF" T < TIM "THEN" "GO TO" NEXT TERM;
     EULER:= SUM
 "END" EULER;
         "EOP"
0"CODE" 32020;
 "REAL" "PROCEDURE" SUMPOSSERIES(AI, I, MAXADDUP, MAXZERO,MAXRECURS,
                                 MACHEXP, TIM);
 "VALUE" MAXADDUP, MAXZERO, MAXRECURS, MACHEXP, TIM;
 "REAL" AI, I, MAXZERO; "INTEGER" MAXADDUP, MAXRECURS, MACHEXP, TIM;
 "BEGIN" "INTEGER" RECURS, VL, VL2, VL4;
 
        "REAL" "PROCEDURE" SUMUP(AI, I); "REAL" AI, I;
        "BEGIN" "INTEGER" J; "REAL" SUM, NEXTTERM;
           I:= MAXADDUP + 1; J:= 1;
        CHECK ADD: "IF" AI <= MAXZERO "THEN"
           "BEGIN""IF" J < TIM "THEN"
              "BEGIN" J:= J + 1; I:= I + 1; "GO TO" CHECK ADD "END"
           "END""ELSE"
           "IF" RECURS ^= MAXRECURS "THEN""GO TO" TRANSFORMSERIES;
           SUM:= 0; I:= 0; J:= 0;
        ADD LOOP: I:= I + 1; NEXTTERM:= AI;
           J:= "IF" NEXTTERM <= MAXZERO "THEN" J + 1 "ELSE" 0;
           SUM:= SUM + NEXTTERM;
           "IF" J < TIM "THEN""GO TO" ADD LOOP;
           SUMUP:= SUM; "GO TO" GOTSUM;
        TRANSFORMSERIES:
           "BEGIN""BOOLEAN" JODD; "INTEGER" J2; "ARRAY" V[1:VL];
 
              "REAL""PROCEDURE" BJK(J, K); "VALUE" J, K; "REAL" K;
              "INTEGER" J;
              "BEGIN""REAL" COEFF;
                 "IF" K > MACHEXP "THEN" BJK:= 0 "ELSE"
                 "BEGIN" COEFF:= 2 ** (K - 1); I:= J * COEFF;
                    BJK:= COEFF * AI
                 "END"
              "END" BJK
1SECTION : 4.1                (JULY 1974)                         PAGE 6
                                                                  ;
 
 
 
              "REAL""PROCEDURE" VJ(J); "VALUE" J; "INTEGER" J;
              "BEGIN""REAL" TEMP, K;
                 "IF" JODD "THEN"
                 "BEGIN" JODD:= "FALSE"; RECURS:= RECURS + 1;
                    TEMP:= VJ:= SUMUP(BJK(J, K), K);
                    RECURS:= RECURS - 1;
                    "IF" J <= VL "THEN" V[J]:= TEMP "ELSE"
                    "IF" J <= VL2 "THEN" V[J - VL]:= TEMP
                 "END""ELSE"
                 "BEGIN" JODD:= "TRUE"; "IF" J > VL4 "THEN"
                    "BEGIN" RECURS:= RECURS + 1;
                       VJ:= - SUMUP(BJK(J, K), K); RECURS:= RECURS - 1
                    "END""ELSE"
                    "BEGIN" J2:= J2 + 1; I:= J2;
                       "IF" J > VL2 "THEN" VJ:= - (V[J2 - VL] - AI) / 2
                       "ELSE"
                       "BEGIN" TEMP:= V["IF" J <= VL "THEN" J "ELSE"
                          J - VL]:= (V[J2] - AI) / 2; VJ:= - TEMP
                       "END"
                    "END"
                 "END"
              "END" VJ;
 
              J2:= 0;
              JODD:= "TRUE"; SUMUP:= EULER(VJ(J + 1), J, MAXZERO, TIM)
           "END" TRANSFORMSERIES;
        GOTSUM:
        "END" SUMUP;
 
        RECURS:= 0; VL:= 1000; VL2:= 2 * VL; VL4:= 2 * VL2;
        SUMPOSSERIES:= SUMUP(AI, I)
     "END" SUMPOSSERIES;
         "EOP"
1SECTION : 4.2.1              (JULY 1974)                         PAGE 1
 
 
 
 SECTION 4.2.1 CONTAINS TWO ALTERNATIVE PROCEDURES FOR THE COMPUTATION
 OF A DEFINITE INTEGRAL.
 
 A.  THE PROCEDURE QADRAT USES HIGH ORDER INTEGRATION RULES (UP TO 16-TH
     ORDER) AND IS APPROPRIATE FOR THE EVALUATION OVER A FINITE
     INTERVAL.
 
 B.  THE PROCEDURE  INTEGRAL  USES A  5-TH  ORDER METHOD AND CAN ALSO BE
     USED TO CALCULATE THE  INTEGRAL OVER A NUMBER OF CONSECUTIVE
     INTERVALS.  MOREOVER THE PROCEDURE CAN BE USED FOR THE COMPUTATION
     OF THE DEFINITE INTEGRAL  OVER AN INFINITE INTERVAL.
 
 FOR A  COMPARISON  OF A  NUMBER OF  PROCEDURES  THAT  EVALUATE DEFINITE
 INTEGRALS : SEE REF[2].
 
 REFERENCES :
 
      [1] T.J.DEKKER AND C.J.ROOTHART.
          INTRODUCTION TO NUMERICAL ANALYSIS. (DUTCH).
          MATH. CENTRE  REPORT CR 244/74, AMSTERDAM.
      [2] C.J.ROOTHART AND H. FIOLET.
          QUADRATURE PROCEDURES.
          MATH. CENTRE  REPORT MR 137/72, AMSTERDAM.
 
 
1SECTION : 4.2.1.A            (JULY 1974)                         PAGE 1
 
 
 
 AUTHORS: C.J.ROOTHART.
 
 
 CONTRIBUTORS: P.W.HEMKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730530.
 
 
 BRIEF DESCRIPTION:
 
     QADRAT  COMPUTES  THE  DEFINITE  INTEGRAL  OF  A  FUNCTION  OF  ONE
     VARIABLE  OVER  A  FINITE  INTERVAL.
 
 
 KEYWORDS:
 
     INTEGRATION,
     QUADRATURE,
     DEFINITE INTEGRAL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" QADRAT (X, A, B, FX, E);
     "VALUE" A, B; "REAL" X, A, B, FX; "ARRAY" E;
     "CODE" 32070;
 
     QADRAT: DELIVERS THE  COMPUTED VALUE OF THE  DEFINITE INTEGRAL FROM
             A TO B  OF THE FUNCTION  F(X);
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             INTEGRATION VARIABLE; X CAN BE USED AS A JENSEN-PARAMETER
             DURING THE EVALUATIONS OF FX;
     A,B:    <ARITHMETIC EXPRESSION>;
             (A,B) DENOTES THE INTERVAL OF INTEGRATION;
             B < A  IS ALLOWED;
     FX:     <ARITHMETIC EXPRESSION>;
             FX  DENOTES  THE INTEGRAND  F(X). THIS  EXPRESSION  WILL BE
             DEPENDENT ON THE JENSEN-PARAMETER X.
     E:      <ARRAY IDENTIFIER>;
             "ARRAY" E[1:3];
             ENTRY: E[1]: THE RELATIVE ACCURACY REQUIRED;
                    E[2]: THE ABSOLUTE ACCURACY REQUIRED;
             EXIT:  E[3]: THE  NUMBER  OF  ELEMENTARY INTEGRATIONS  WITH
                    H < ABS(B-A) * E[1].
 
 
1SECTION : 4.2.1.A            (JULY 1974)                         PAGE 2
 
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA 16 + 9 * RECURSION DEPTH.
 
 
 RUNNING TIME: DEPENDS STRONGLY  ON THE DEFINITE  INTEGRAL  TO  COMPUTE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE REF[1].
 
 
 
 REFERENCES:
 
     [1].C.J.ROOTHART AND H.FIOLET.
         QUADRATURE PROCEDURES.
         MATH.CENTRE, AMSTERDAM. REPORT MR 137/72.
 
 
 EXAMPLE OF USE:
 
     "BEGIN"
         "ARRAY" E[1:3]; "REAL" T,Q;
     EXECUTION FIELD LENGTH: CIRCA 16 + 26 * RECURSION DEPTH.
         E[1]:= E[2]:= "-9;
         Q:= QADRAT(T,0,3.141592653589  ,SIN(T),E);
         OUTPUT(61,"("/,+.15D"+3D,3B,3ZD,/")",Q,E[3]);
     "END"
 
     DELIVERS:
 
     +.200000000000033"+001      0
1SECTION : 4.2.1.A            (NOVEMBER 1976)                     PAGE 3
 
 
 
 SOURCE TEXT(S):
0"CODE" 32070;
    "REAL" "PROCEDURE" QADRAT(X, A, B, FX, E);
    "VALUE" A, B; "REAL" X, A, B, FX; "ARRAY" E;
    "BEGIN" "REAL" F0, F2, F3, F5, F6, F7, F9,
         F14, V, W, HMIN, HMAX, RE, AE;
 
       "REAL" "PROCEDURE" LINT(X0, XN, F0, F2, F3, F5, F6, F7, F9, F14);
       "REAL" X0, XN, F0, F2, F3, F5, F6, F7, F9, F14;
       "BEGIN" "REAL" H, XM, F1, F4, F8, F10, F11, F12, F13;
          XM:= (X0 + XN) / 2; H:= (XN - X0) / 32; X:= XM + 4 * H;
          F8:= FX; X:= XN - 4 * H; F11:= FX; X:= XN - 2 * H; F12:= FX;
          V:= 0.330580178199226 * F7 + 0.173485115707338 * (F6 + F8) +
          0.321105426559972*(F5 + F9) + 0.135007708341042 * (F3 + F11)
          + 0.165714514228223*(F2 + F12) + 0.393971460638127"- 1 * (F0
          + F14); X:= X0 + H; F1:= FX; X:= XN - H; F13:= FX;
          W:= 0.260652434656970 * F7 + 0.239063286684765 * (F6 + F8) +
          0.263062635477467*(F5 + F9) + 0.218681931383057 * (F3 + F11)
          + 0.275789764664284"- 1 * (F2 + F12) + 0.105575010053846* (F1
          + F13) + 0.157119426059518"- 1 * (F0 + F14);
          "IF" ABS(H) < HMIN "THEN" E[3]:= E[3] + 1;
          "IF" ABS(V - W) < ABS(W) * RE + AE "OR" ABS(H) < HMIN
          "THEN" LINT:= H * W "ELSE"
          "BEGIN" X:= X0 + 6 * H; F4:= FX; X:= XN - 6 * H; F10:= FX;
             V:= 0.245673430093324* F7 + 0.255786258286921* (F6 + F8) +
             0.228526063690406*(F5 + F9) + 0.500557131525460"- 1*(F4 +
             F10) + 0.177946487736780*(F3 + F11)+0.584014599347449"- 1
             * (F2 + F12) + 0.874830942871331"- 1 * (F1 + F13) +
             0.189642078648079"- 1 * (F0 + F14);
             LINT:= "IF" ABS(V - W) < ABS(V) * RE + AE "THEN" H * V
                                                       "ELSE"
             LINT(X0, XM, F0, F1, F2, F3, F4, F5, F6, F7) - LINT(XN,
             XM, F14, F13, F12, F11, F10, F9, F8, F7)
          "END"
       "END" LINT;
 
       HMAX:= (B - A) / 16; "IF" HMAX=0 "THEN"
       "BEGIN" QADRAT:= 0; "GOTO" RETURN "END";
       RE:= E[1]; AE:= 2 * E[2] / ABS(B - A); E[3]:= 0;
       HMIN:= ABS(B - A) * RE; X:= A; F0:= FX;
       X:= A + HMAX; F2:= FX; X:= A + 2 * HMAX; F3:= FX;
       X:= A + 4 * HMAX; F5:= FX; X:= A + 6 * HMAX; F6:= FX;
       X:= A + 8 * HMAX; F7:= FX; X:= B - 4 * HMAX; F9:= FX; X:= B;
       F14:= FX;
       QADRAT:= LINT(A, B, F0, F2, F3, F5, F6, F7, F9, F14) * 16;
       RETURN:
    "END" QADRAT;
         "EOP"
1SECTION : 4.2.1.B            (JULY 1974)                         PAGE 1
 
 
 
 AUTHOR: H.N.GLORIE.
 
 
 CONTRIBUTOR: H.FIOLET.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730606.
 
 
 BRIEF DESCRIPTION:
 
     INTEGRAL  CALCULATES  THE DEFINITE INTEGRAL OF A  FUNCTION  OF  ONE
     VARIABLE, OVER  A  FINITE OR INFINITE INTERVAL OR OVER A NUMBER  OF
     CONSECUTIVE INTERVALS.
 
 
 KEYWORDS:
 
     DEFINITE INTEGRAL,
     INFINITE INTERVAL,
     SIMPSON RULE,
     RICHARDSON CORRECTION.
 
 
1SECTION : 4.2.1.B            (JULY 1974)                         PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" INTEGRAL(X,A,B,FX,E,UA,UB);
     "VALUE" A,B;"REAL" X,A,B,FX;"ARRAY" E;"BOOLEAN" UA,UB;
     "CODE" 32051;
 
     INTEGRAL:
 
         DELIVERS THE  COMPUTED  VALUE  OF THE DEFINITE INTEGRAL OF  THE
         FUNCTION  FROM A TO B; AFTER SUCCESSIVE CALLS OF THE PROCEDURE,
         THE  INTEGRAL  OVER  THE TOTAL INTERVAL IS  DELIVERED, I.E. THE
         VALUE  OF  A IN  THE LAST CALL WITH UA="TRUE" IS  THE
         STARTING POINT OF THE INTERVAL.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             INTEGRATION VARIABLE; X IS USED AS JENSEN-PARAMETER
             FOR  FX.
     A,B:    <ARITHMETIC EXPRESSION>;
             THE INTERVAL OF INTEGRATION IS EITHER (A,B) OR
             (A,INFINITY) (SEE PARAMETER UB); B<A IS ALLOWED;
     FX:     <ARITHMETIC EXPRESSION>;
             THE INTEGRAND F(X);
     E:      <ARRAY IDENTIFIER>;
             "ARRAY" E[1:6];
             ENTRY : E[1]:THE RELATIVE ACCURACY REQUIRED;
                     E[2]:THE ABSOLUTE ACCURACY REQUIRED;
                     E[5]:ALTERNATIVE STARTING POINT (SEE PAR. UA);
             EXIT:   E[3]:THE NUMBER OF SKIPPED INTEGRATION STEPS;
                     E[4]:THE VALUE OF THE INTEGRAL FROM A TO B;
                     E[5]:"IF" UB "THEN" B "ELSE" 0;
                     E[6]:"IF" UB "THEN" F(B) "ELSE" 0;
     UA:     <BOOLEAN EXPRESSION>;
             DETERMINES THE STARTING POINT OF THE INTEGRATION;
             STARTING POINT:="IF" UA "THEN" A "ELSE" E[5];
     UB:     <BOOLEAN EXPRESSION>;
             DETERMINES THE FINAL POINT OF THE INTEGRATION;
             FINAL POINT:="IF" UB "THEN" B "ELSE"
                       "IF" B>A "THEN" +INFINITY "ELSE" -INFINITY;
             IN  THE  CASE UB="FALSE" , THE VALUE OF B IS STILL RELEVANT
             (SEE METHOD AND PERFORMANCE).
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA 16 + 5 * RECURSION LEVEL.
 
 
 RUNNING TIME: DEPENDS STRONGLY UPON THE INTEGRAL TO BE COMPUTED.
 
 
1SECTION : 4.2.1.B            (MARCH 1977)                        PAGE 3
 
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     INTEGRAL USES THE  SUBPROCEDURE  QAD  FOR THE  CALCULATION  OF  THE
     DEFINITE INTEGRAL OVER A  FINITE INTERVAL. THIS IS DONE BY MEANS OF
     SIMPSON 'S RULE WITH RICHARDSON CORRECTION.IF THE FOURTH DERIVATIVE
     IS TOO LARGE (AND THUS THE CORRECTION TERM) , THE TOTAL INTERVAL IS
     SPLIT INTO TWO EQUAL PARTS AND  THE  INTEGRATION PROCESS IS INVOKED
     RECURSIVELY. THIS IS DONE IN  SUCH A  WAY  THAT THE TOTAL AMOUNT OF
     RICHARDSON  CORRECTIONS  IS  SLIGHTLY SMALLER  THAN  OR  EQUAL  TO
       E[1] * ABS ( THE INTEGRAL FROM A TO B OF (FX) ) + E[2].
     THE INTEGRATION OVER AN INFINITE INTERVAL REQUIRES TWO CALLS OF THE
     PROCEDURE QAD. IN THE FIRST CALL QAD COMPUTES THE DEFINITE INTEGRAL
     FROM  A  TO  B .  IN  THE  INTERVAL  FROM  B  TO  + OR -  INFINITY
     THE   INTEGRAND  IS  TRANSFORMED  BY   MEANS  OF  THE  SUBSTITUTION
     Z=1/(X+1-B) TO THE DEFINITE INTEGRAL OF F(B-1+1/Z)/Z**2 FROM  0  TO
     1. FOR  THE  INTEGRATION  OF  A  DEFINITE  INTEGRAL  OVER A  FINITE
     INTERVAL  THE  USE OF  QADRAT IS RECOMMENDED ,ESPECIALLY  WHEN HIGH
     ACCURACY IS REQUIRED.
 
 REFERENCES:
 
     [1] T.J.DEKKER AND C.J.ROOTHART.
         INTRODUCTION TO NUMERICAL ANALYSIS.(DUTCH)
         MATH.CENTR. REPORT CR 24/71, AMSTERDAM.
     [2] C.J.ROOTHART AND H.FIOLET.
         QUADRATURE PROCEDURES.
         MATH.CENTR. REPORT MR 137/72, AMSTERDAM.
 
 EXAMPLE OF USE:
 
     "BEGIN"
         "ARRAY" E[1:6];"REAL" A,B,X;"BOOLEAN" UA,UB;
         UA:="TRUE";E[1]:=E[2]:="-14;
         "FOR" B:=2,4,20,100 "DO"
         "BEGIN" UB:=B<50;
             A:=INTEGRAL(X,-1,-B,10/X**2,E,UA,UB);
             OUTPUT(61,"("N,B+DDB,N,2(B+DDDB),/")",
                    A,E[3],E[4],E[5],E[6]);
             UA:="FALSE"
         "END"
     "END"
 
     DELIVERS:
     -4.9999999999999"+000   +00 -4.9999999999999   -002  +003
     -7.4999999999998"+000   +00 -7.4999999999998   -004  +001
     -9.5000000000000"+000   +00 -9.5000000000000   -020  +000
     -9.9999999999998"+000   +01 -9.9999999999998   +000  +000   .
1SECTION : 4.2.1.B            (MARCH 1977)                        PAGE 4
 
 
 
 SOURCE TEXT(S):
0"CODE" 32051;
     "REAL" "PROCEDURE" INTEGRAL(X, A, B, FX, E, UA, UB);
     "VALUE" A,B;"REAL" X, A, B, FX; "ARRAY" E; "BOOLEAN" UA, UB;
     "BEGIN"
         "REAL" "PROCEDURE" TRANSF;
         "BEGIN" Z:= 1 / X; X:= Z + B1; TRANSF:= FX * Z * Z "END";
         "REAL" "PROCEDURE" QAD(FX); "REAL" FX;
         "BEGIN" "REAL" T, V, SUM, HMIN;
             "PROCEDURE" INT;
             "BEGIN" "REAL" X3, X4, F3, F4, H;
                 X4:= X2; X2:= X1; F4:= F2; F2:= F1;
             ANEW: X:= X1:= (X0 + X2) * .5; F1:= FX;
                 X:= X3:= (X2 + X4) * .5; F3:= FX; H:= X4 - X0;
                 V:= (4 * (F1 + F3) +2  * F2 + F0 + F4) * 15;
                 T:= 6 * F2 -4  * (F1 + F3) + F0 + F4;
                 "IF" ABS(T) < ABS(V) * RE + AE "THEN"
                 SUM:=SUM + (V - T) * H "ELSE"
                 "IF" ABS(H) < HMIN "THEN" E[3]:= E[3] +1
                 "ELSE"
                 "BEGIN" INT; X2:= X3; F2:= F3; "GOTO" ANEW "END";
                 X0:= X4; F0:= F4
             "END" INT;
 
             HMIN:= ABS(X0 - X2) * RE; X:= X1:= (X0 + X2) * .5;
             F1:=FX;SUM:= 0; INT; QAD:= SUM / 180
         "END" QAD;
         "REAL" X0, X1, X2, F0, F1, F2, RE, AE, B1, Z;
         RE:= E[1]; "IF" UB "THEN" AE:= E[2] * 180 / ABS(B - A)
         "ELSE" AE:= E[2] * 90 / ABS(B - A); "IF" UA "THEN"
         "BEGIN" E[3]:= E[4]:= 0; X:= X0:= A; F0:= FX "END"
         "ELSE"
         "BEGIN" X:= X0:= A:= E[5]; F0:= E[6] "END";
         E[5]:= X:= X2:= B; E[6]:= F2:= FX; E[4]:= E[4] + QAD(FX);
         "IF"  ^UB "THEN"
         "BEGIN" "IF" A < B "THEN"
             "BEGIN" B1:= B -1 ; X0:= 1 "END"
             "ELSE"
             "BEGIN" B1:= B +1 ; X0:= -1  "END";
             F0:= E[6]; E[5]:= X2:= 0; E[6]:= F2:= 0;
             AE:= E[2] * 90;
             E[4]:= E[4] - QAD(TRANSF)
         "END";
         INTEGRAL:= E[4]
     "END" INTEGRAL;
           "EOP"
1SECTION : 4.2.2              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR : P.W. HEMKER.
 
 
 CONTRIBUTOR : F.GROEN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED : 740620.
 
 
 BRIEF DESCRIPTION :
 
     TRICUB  COMPUTES  THE  DEFINITE  INTEGRAL  OF A  FUNCTION  OF  TWO
     VARIABLES OVER A TRIANGULAR DOMAIN.
 
 KEYWORDS :
 
     INTEGRATION,
     QUADRATURE,
     MOREDIMENSIONAL QUADRATURE,
     CUBATURE,
     DEFINITE INTEGRAL.
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
 
     "REAL" "PROCEDURE" TRICUB ( XI, YI, XJ, YJ, XK, YK, F, RE, AE );
     "VALUE" XI, YI, XJ, YJ, XK, YK, RE, AE;
     "REAL"  XI, YI, XJ, YJ, XK, YK, RE, AE;
     "REAL" "PROCEDURE" F;
     "CODE" 32075;
 
     TRICUB := THE  COMPUTED  VALUE OF THE  DEFINITE  INTEGRAL  OF THE
               FUNCTION  F ( X, Y ) OVER THE  TRIANGULAR DOMAIN T WITH
               VERTICES ( XI, YI ), ( XJ, YJ ) AND ( XK, YK ).
 
1SECTION : 4.2.2              (DECEMBER 1979)                     PAGE 2
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     XI, YI: <ARITHMETIC EXPRESSION>;
             ENTRY : THE  COORDINATES  OF  THE  FIRST  VERTEX  OF  THE
             TRIANGULAR DOMAIN OF INTEGRATION;
     XJ, YJ: <ARITHMETIC EXPRESSION>;
             ENTRY : THE  COORDINATES  OF  THE  SECOND  VERTEX  OF THE
             TRIANGULAR DOMAIN OF INTEGRATION;
     XK, YK: <ARITHMETIC EXPRESSION>;
             ENTRY : THE  COORDINATES  OF  THE  THIRD  VERTEX  OF  THE
             TRIANGULAR DOMAIN OF INTEGRATION;
             REMARK: THE ALGORITHM IS SYMMETRICAL IN THE  VERTICES; THIS
             IMPLIES THAT THE RESULT OF THE PROCEDURE (ON ALL COUNTS) IS
             INVARIANT FOR ANY PERMUTATION OF THE VERTICES.
     F :     <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "REAL" "PROCEDURE" F ( X, Y ); "REAL" X, Y;
             THIS PROCEDURE DEFINES THE INTEGRAND;
     AE, RE: <ARITHMETIC EXPRESSION>;
             ENTRY: THE REQUIRED ABSOLUTE AND RELATIVE ERROR
             RESPECTIVELY. ONE SHOULD TAKE FOR "AE" AND "RE"
             VALUES WHICH ARE GREATER THAN THE ABSOLUTE AND
             RELATIVE ERROR IN THE COMPUTATION OF THE INTEGRAND F.
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY :
 
     THE PROCESS IS PROGRAMMED  RECURSIVELY. AT EACH  RECURSION LEVEL 43
     REAL  NUMBERS ARE USED. HOWEVER, FOR ANY  PROPERLY CHOSEN VALUES OF
     RE AND AE THE RECURSION DEPTH WILL NOT EXCEED THE NUMBER OF BITS IN
     A REAL'S MANTISSA.
 
 
 RUNNING TIME : DEPENDS STRONGLY ON THE INTEGRAL TO COMPUTE.
 
 
 METHOD AND PERFORMANCE :
 
     A NESTED SEQUENCE OF CUBATURE RULES OF ORDER 2, 3, 4 AND 5
     IS APPLIED. IF THE DIFFERENCE BETWEEN THE RESULT WITH THE
     4-TH DEGREE RULE AND THE RESULT WITH THE 5-TH DEGREE RULE
     IS TOO LARGE, THEN THE TRIANGLE IS DIVIDED INTO FOUR CONGRUENT
     TRIANGLES. THIS PROCESS IS APPLIED RECURSIVELY IN ORDER TO
     OBTAIN AN ADAPTIVE CUBATURE ALGORITHM.
 
 
1SECTION : 4.2.2              (OCTOBER 1975)                      PAGE 3
 
 
 
 REFERENCES :
 
     [1].P.W.HEMKER,
         A SEQUENCE OF NESTED CUBATURE RULES,
         MATH.CENTRE, AMSTERDAM, REPORT NW 3/73.
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM EVALUATES THE INTEGRAL OF
     F ( X, Y ) = COS ( X ) * COS ( Y )  OVER THE TRIANGLE T WITH
     VERTICES  ( 0, 0 ), ( O, PI/2 ) AND  ( PI/2, PI/2 ).
     ON EACH LINE ARE LISTED :
         A: THE REQUIRED RELATIVE AND ABSOLUTE PRECISION;
         B: THE COMPUTED VALUE OF THE INTEGRAL;
         C: THE NUMBER OF CALLS OF THE FUNCTION F,
 
     "BEGIN"
         "INTEGER" N,C,I,K; "REAL" PI,ACC,R,S;
         "REAL" "PROCEDURE" E(X,Y); "REAL" X,Y;
         "BEGIN" C:= C+1;
                "IF" C> 20000 "THEN" "GOTO" CC;
                E:= COS(X) * COS(Y);
         "END" E;
 
         PI:= 3.14159265359;
         "FOR" ACC:= "-1,"-2,"-3,"-4,"-5,"-6,"-7,"-8,"-9,"-10,"-11 "DO"
         "BEGIN" C:=0; OUTPUT(61,"("+.D"+ZD,2B,+.14D"+2ZD,2B,10ZD,/")",
                   ACC, TRICUB(0,0,0,PI/2,PI/2,PI/2,E,ACC,ACC) ,C);
         "END";
         CC: OUTPUT(61,"("*")");
     "END"
 
     RESULTS:
 
     +.1" +0  +.50063973801970"  +0          7
     +.1" -1  +.50063973801970"  +0          7
     +.1" -2  +.50063973801970"  +0          7
     +.1" -3  +.49999110261504"  +0         10
     +.1" -4  +.49999848959226"  +0         13
     +.1" -5  +.49999848959226"  +0         13
     +.1" -6  +.49999997378240"  +0         43
     +.1" -7  +.49999999209792"  +0        133
     +.1" -8  +.49999999893172"  +0        313
     +.1" -9  +.49999999985571"  +0        733
     +.1"-10  +.49999999998692"  +0       1723
1SECTION : 4.2.2              (DECEMBER 1979)                     PAGE 4
 
 
 
 SOURCE TEXT(S):
0"CODE" 32075;
 "REAL" "PROCEDURE" TRICUB(XI,YI,XJ,YJ,XK,YK,G,RE,AE);
 "VALUE" XI,YI,XJ,YJ,XK,YK,RE,AE;
 "REAL" XI,YI,XJ,YJ,XK,YK,RE,AE; "REAL" "PROCEDURE" G;
 "BEGIN" "REAL" SURF,SURFMIN,XZ,YZ,GI,GJ,GK;
 
    "REAL" "PROCEDURE" INT(AX1,AY1,AF1,AX2,AY2,AF2,AX3,AY3,AF3,
                  BX1,BY1,BF1,BX2,BY2,BF2,BX3,BY3,BF3,
                  PX,PY,PF);
    "VALUE" BX1,BY1,BF1,BX2,BY2,BF2,BX3,BY3,BF3,PX,PY,PF;
    "REAL"  BX1,BY1,BF1,BX2,BY2,BF2,BX3,BY3,BF3,PX,PY,PF,
            AX1,AY1,AF1,AX2,AY2,AF2,AX3,AY3,AF3;
    "BEGIN" "REAL" E,I3,I4,I5,A,B,C,SX1,SY1,SX2,SY2,SX3,SY3,
        CX1,CY1,CF1,CX2,CY2,CF2,CX3,CY3,CF3,
        DX1,DY1,DF1,DX2,DY2,DF2,DX3,DY3,DF3;
 
        A:= AF1 + AF2 + AF3; B:= BF1 + BF2 + BF3;
        I3:= 3 * A + 27 * PF + 8 * B;
        E:= ABS(I3) * RE + AE;
 
        "IF" SURF < SURFMIN "OR" ABS(5 * A + 45 * PF - I3) < E
        "THEN" INT:= I3 * SURF "ELSE"
        "BEGIN" CX1:= AX1 + PX; CY1:= AY1 + PY; CF1:= G(CX1,CY1);
              CX2:= AX2 + PX; CY2:= AY2 + PY; CF2:= G(CX2,CY2);
              CX3:= AX3 + PX; CY3:= AY3 + PY; CF3:= G(CX3,CY3);
              C:= CF1 + CF2 + CF3;
              I4:= A + 9 * PF + 4 * B + 12 * C;
 
            "IF" ABS(I3 - I4) < E "THEN" INT:= I4 * SURF "ELSE"
            "BEGIN" SX1:= .5 * BX1; SY1:= .5 * BY1;
                DX1:= AX1 + SX1; DY1:= AY1 + SY1; DF1:= G(DX1,DY1);
                SX2:=  .5 * BX2; SY2:=  .5 * BY2;
                DX2:= AX2 + SX2; DY2:= AY2 + SY2; DF2:= G(DX2,DY2);
                SX3:=  .5 * BX3; SY3:=  .5 * BY3;
                DX3:= AX3 + SX3; DY3:= AY3 + SY3; DF3:= G(DX3,DY3);
 
                I5:= (51 * A + 2187 * PF + 276 * B + 972 * C -
                      768 * (DF1 + DF2 + DF3))/63;
                                                               "COMMENT"
1SECTION : 4.2.2              (OCTOBER 1975)                      PAGE 5
                                                                  ;
 
 
                "IF" ABS(I4 - I5) < E "THEN" INT:= I5 * SURF "ELSE"
                "BEGIN" SURF:= .25 * SURF;
 
                    INT:=
 
                    INT(SX1,SY1,BF1,SX2,SY2,BF2,SX3,SY3,BF3,
                        DX1,DY1,DF1,DX2,DY2,DF2,DX3,DY3,DF3,
                        PX,PY,PF) +
 
                    INT(AX1,AY1,AF1,SX3,SY3,BF3,SX2,SY2,BF2,DX1,DY1,DF1,
                        AX1 + SX2,AY1 + SY2,G(AX1 + SX2,AY1 + SY2),
                        AX1 + SX3,AY1 + SY3,G(AX1 + SX3,AY1 + SY3),
                        .5 * CX1,.5 * CY1,CF1) +
                    INT(AX2,AY2,AF2,SX3,SY3,BF3,SX1,SY1,BF1,DX2,DY2,DF2,
                        AX2 + SX1,AY2 + SY1,G(AX2 + SX1,AY2 + SY1),
                        AX2 + SX3,AY2 + SY3,G(AX2 + SX3,AY2 + SY3),
                        .5 * CX2,.5 * CY2,CF2) +
                    INT(AX3,AY3,AF3,SX1,SY1,BF1,SX2,SY2,BF2,DX3,DY3,DF3,
                        AX3 + SX2,AY3 + SY2,G(AX3 + SX2,AY3 + SY2),
                        AX3 + SX1,AY3 + SY1,G(AX3 + SX1,AY3 + SY1),
                        .5 * CX3,.5 * CY3,CF3);
 
                    SURF:= 4 * SURF
                "END"
            "END"
        "END"
    "END" INT;
 
    SURF:= 0.5 * ABS(XJ * YK - XK * YJ + XI * YJ -
                     XJ * YI + XK * YI - XI * YK);
    SURFMIN:= SURF*RE; RE:= 30*RE; AE:= 30*AE/SURF;
    XZ:= (XI + XJ + XK)/3; YZ:= (YI + YJ + YK)/3;
    GI:= G(XI,YI); GJ:= G(XJ,YJ); GK:= G(XK,YK);
    XI:= XI*.5; YI:= YI*.5; XJ:= XJ*.5;
    YJ:= YJ*.5; XK:= XK*.5; YK:= YK*.5;
 
    TRICUB:= INT(XI,YI,GI,XJ,YJ,GJ,XK,YK,GK,
                 XJ+XK,YJ+YK,G(XJ+XK,YJ+YK),
                 XK+XI,YK+YI,G(XK+XI,YK+YI),
                 XI+XJ,YI+YJ,G(XI+XJ,YI+YJ),
                 .5 * XZ,.5 * YZ,G(XZ,YZ))/60
 "END" TRICUB;
         "EOP"
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 1
 
 
 
 AUTHOR:         C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS:   C.G. VAN DER LAAN AND M. VOORINTHOLT.
 
 
 INSTITUTE:      REKENCENTRUM RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED:       780601.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THE PROCEDURES GSSWTS, GSSWTSSYM AND RECCOF.
     RECCOF CALCULATES FROM A GIVEN WEIGHT FUNCTION ON [-1,1] THE
     RECURRENCE COEFFICIENTS OF THE CORRESPONDING ORTHOGONAL
     POLYNOMIALS; GSSWTS AND GSSWTSSYM CALCULATE FROM THE RECURRENCE
     COEFFICIENTS THE GAUSSIAN WEIGHTS OF THE CORRESPONDING WEIGHT
     FUNCTION.
 
 
 KEYWORDS:
 
     RECURRENCE COEFFICIENTS ORTHOGONAL POLYNOMIALS,
     GAUSSIAN WEIGHTS,
     GAUSSIAN QUADRATURE.
 
 
 SUBSECTION: RECCOF.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" RECCOF(N,M,X,WX,B,C,L,SYM);
     "VALUE" N,M,SYM; "INTEGER" N,M; "BOOLEAN" SYM;
     "REAL" X,WX; "ARRAY" B,C,L;
     "CODE" 31254;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:       <ARITHMETIC EXPRESSION>;
              ENTRY: UPPER BOUND FOR THE INDICES OF THE ARRAYS B, C, L
                     (N>=0);
     M:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE NUMBER OF POINTS USED IN THE GAUSS-CHEBYSHEV
                     QUADRATURE RULE FOR CALCULATING THE APPROXIMATION
                     OF THE INTEGRAL REPRESENTATIONS OF B[K],C[K]
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 2
 
 
 
     SYM:     <BOOLEAN EXPRESSION>;
              ENTRY: "IF" SYM
                         "THEN" WEIGHT FUNCTION ON [-1,1] IS EVEN
                         "ELSE" WEIGHT FUNCTION ON [-1,1] IS NOT EVEN;
     X,WX:    <ARITHMETIC EXPRESSION>;
              ENTRY: JENSEN VARIABLES WITH WX AN EXPRESSION OF X
                     DENOTING THE WEIGHT FUNCTION ON [-1,1];
     B,C,L:   <ARRAY IDENTIFIER>;
              "ARRAY" B,C,L[0:N];
              EXIT:  THE APPROXIMATE RECURRENCE COEFFICIENTS FOR
                     P[K+1](X) = (X-B[K])*P[K](X) - C[K]*P[K-1](X),
                                                      K=0,1,2,...N,
                     AND THE APPROXIMATE SQUARE LENGTHS
                             X = +1
                     L[K] = INTEGRAL ( W(X) * P[K](X) **  2 ) DX
                             X = -1
 
 
 PROCEDURES USED:    ORTPOL = CP31044.
 
 
 RUNNING TIME:       PROPORTIONAL TO M*N**2.
 
 
 METHOD AND PERFORMANCE:
 
     THE RECURRENCE COEFFICIENTS ARE REPRESENTED BY
                        X = +1
              B[K] = ( INTEGRAL ( W(X) * X * P[K](X) ** 2 ) DX ) / L[K],
                        X = -1
 
              C[K] = L[K] / L[K-1]],
     WHERE P[K](X) IS THE K-TH ORTHOGONAL POLYNOMIAL.
     THE INTEGRALS ARE APPROXIMATED BY THE M-POINTS GAUSS-CHEBYSHEV
     RULE AS
           X = +1                       M
         INTEGRAL(F(X))DX := PI / M * SUM SIN(THETA[J])*F(COS(THETA[J]))
           X = -1                      J=1
     WITH THETA[J] = (2*J-1) * PI / (2*M)      (SEE GAUTSCHI, 1968A).
     THE VALUE OF M IS TO BE SUPPLIED BY THE USER.
 
 
 REFERENCES:
 
     GAUTSCHI, W. (1968A):
     CONTRUCTION OF GAUSS-CHRISTOFFEL FORMULAS.
     MATH. COMP., 22,P.251-270.
 
     GAUTSCHI, W. (1968B):
     GAUSSIAN QUADRATURE FORMULAS.
     COMM. ACM. CALGO 331.
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 3
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM DELIVERS AN APPROXIMATION
     FOR THE RECURSION COEFFICIENTS C[1] AND C[2], OF THE CHEBYSHEV
     POLYNOMIALS OF THE SECOND KIND;
 
     "BEGIN"
         "REAL" X; "ARRAY" B,C,L[0:2];
         RECCOF(2,200,X,SQRT(1 - X**2),B,C,L,"TRUE");
         OUTPUT(61,"("2/,2(3B,-ZD.3D)")",C[1],C[2]);
     "END";
 
     RESULTS:
 
          0.250     0.250
 
 
 SUBSECTION: GSSWTS.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" GSSWTS(N,ZER,B,C,W);
     "VALUE" N; "INTEGER" N; "ARRAY" ZER,B,C,W;
     "CODE" 31253;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE NUMBER OF WEIGHTS TO BE COMPUTED; UPPER
                     BOUND FOR THE ARRAYS Z AND W (N>=1);
     ZER:     <ARRAY IDENTIFIER>;
              "ARRAY" ZER[1:N];
              ENTRY: THE ZEROS OF THE N-TH DEGREE ORTHOGONAL POLYNOMIAL;
     B,C:     <ARRAY IDENTIFIER>;
              "ARRAY" B[0:N-1], C[1:N-1];
              ENTRY: THE RECURRENCE COEFFICIENTS;
     W:       <ARRAY IDENTIFIER>;
              "ARRAY" W[1:N];
              EXIT : THE GAUSSIAN WEIGHTS DIVIDED BY THE
                     INTEGRAL OVER THE WEIGHT FUNCTION.
 
 
 PROCEDURES USED:    ALLORTPOL = CP 31045.
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 4
 
 
 
 METHOD AND PERFORMANCE:
 
     THE GAUSSIAN WEIGHTS OF AN N-POINTS RULE DIVIDED BY THE INTEGRAL
     OF THE WEIGHT FUNCTION MAY BE REPRESENTED AS
             W[K] = 1/(...((P[N-1](Z)**2/C[N-1]+P[N-2](Z)**2)/C[N-2]+...
                                  ...+P[1](Z)**2)/C[1]+1)  , K=1,2,...N
     WITH    Z= K-TH ZERO OF P[N](X).  (GAUTSCHI, 1970).
 
     ALLZERORTPOL AND GSSWTS MAY BE USED TO GENERATE GAUSSIAN
     QUADRATURE RULES PROVIDED THE RECURRENCE COEFFICIENTS AND THE
     INTEGRAL OF THE WEIGHT FUNCTION ARE KNOWN.
     FOR EXAMPLE THE GAUSS-LAGUERRE QUADRATURE RULE APPLIED TO F
     MAY BE OBTAINED BY THE CALLS
 
              "FOR" K:=1 "STEP" 1 "UNTIL" N-1 "DO"
              "BEGIN"
                 B[K]:=2*K+ALPHA+1;
                 C[K]:=K*(K+ALPHA)
              "END";
              B[0]:=ALPHA+1;
              ALLZERORTPOL(N,ZER,B,C);
              GSSWTS(N,ZER,B,C,W);
              GAUSSRULE:=0;
              "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
              GAUSSRULE:=GAUSSRULE+W[K]*F(ZER[K]);
              GAUSSRULE:=GAUSSRULE*GAMMA(ALPHA+1)
 
     GAUSSRULE CONTAINS THE VALUE OF THE APPOXIMATING GAUSS
     QUADRATURE RULE AND ZER[1:N],W[1:N] CONTAIN THE GAUSSIAN
     ABSCISSA AND WEIGHTS.
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 5
 
 
 
     IN THE FOLLOWING TABEL WE SUMMARIZE CLASSICAL QUADRATURE RULES
 
            :  WEIGHT   :    RECURRENCE COEFFICIENTS    :   INTEGRAL
  GAUSSIAN  : FUNCTION  :---------------:---------------:      OF
 QUADRATURE :   W(X)    :      B[K]     :     C[K]      :WEIGHT FUNCTION
 -----------:-----------:---------------:---------------:---------------
            :           :               :               :
 LEGENDRE   :     1     :       0       :K**2*(4*K**2-1):      2
            :           :               :               :
  CHEBYSHEV : 1/SQRT(1- :       0       :  1/2  ,  K=1  :      PI
 (1-ST KIND): X**2)     :               :  1/4  ,  K>1  :
            :           :               :               :
  CHEBYSHEV : SQRT(1-   :       0       :      1/4      :    PI/2
 (2-ND KIND): X**2)     :               :               :
            :           :               :               :
 JACOBI     : (1-X)**   : -(ALPHA**2-   : 4*(1+ALPHA)*  : 2**(ALPHA+
            : ALPHA*(1+ : BETA**2)/((2* : (1+BETA)/     : BETA+1)*
            : X)**BETA  : K+ALPHA+BETA)*: ((ALPHA+BETA+ : GAMMA(ALPHA+
            :           : (2*K+ALPHA+   : 2)**2*(ALPHA+ : 1)*GAMMA(BETA+
            :           : BETA+2))      : BETA+3)) ,K=1 : 1)/GAMMA(ALPHA
            :           :               :               : +BETA+2)
            :           :               : 4*K*(K+ALPHA)*:
            :           :               : (K+BETA)*(K+  :
            :           :               : ALPHA+BETA)/  :
            :           :               : ((2*K+ALPHA+  :
            :           :               : BETA)**2*     :
            :           :               : ((2*K+ALPHA+  :
            :           :               : BETA)**2-1))  :
            :           :               :          ,K>1 :
            :           :               :               :
            :           :               :(ALPHA,BETA>-1):
            :           :               :               :
 LAGUERRE   : EXP(-X)*  : 2*K+ALPHA+1   : K*(K+ALPHA)   : GAMMA(ALPHA+1)
            : X**ALPHA  :               :               :
            :           :               :               :
 HERMITE    : EXP(-X**2):       0       :      K/2      :   SQRT(PI)
 
 (THE INTEGRATION INTERVALS ARE:  [-INFINITY,INFINITY]  FOR HERMITE;
                                          [0,INFINITY]  FOR LAGUERRE;
                                         [-1,1]         FOR THE OTHERS.)
 FOR NON-CLASSICAL WEIGHT FUNCTIONS ON A FINITE INTERVAL THE RECURSION
 COEFFICIENTS (AND THE SQUARE LENGTHS OF THE CORRESPONDING ORTHOGONAL-
 POLYNOMIALS) CAN BE OBTAINED BY THE PROCEDURE RECCOF (THIS SECTION).
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 6
 
 
 
 REFERENCES:
 
     GAUTSCHI, W. (1970):
     GENERATION OF GAUSSIAN QUADRATURE RULES AND
     ORTHOGONAL POLYNOMIALS.
     IN:  COLLOQUIUM APPROXIMATIETHEORIE,
          MC SYLLABUS 14.
 
 
 EXAMPLE OF USE: SEE SUBSECTION GSSWTSSYM.
 
 
 SUBSECTION: GSSWTSSYM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" GSSWTSSYM(N,ZER,C,W);
     "VALUE" N; "INTEGER" N; "ARRAY" ZER,C,W;
     "CODE" 31252;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE WEIGHTS OF AN N-POINTS GAUSS RULE ARE
                     TO BE CALCULATED (BECAUSE OF SYMMETRY ONLY
                     (N+1)//2 OF THE VALUES ARE DELIVERED);
     ZER:     <ARRAY IDENTIFIER>;
              "ARRAY" ZER[1:N//2]
              ENTRY: THE NEGATIVE ZEROS OF THE N-TH DEGREE ORTHOGONAL
                     POLYNOMIAL (ZER[I] < ZER[I+1], I=1,2,...,N//2-1);
              (IF N IS ODD THEN 0 IS ALSO A ZERO.)
     C:       <ARRAY IDENTIFIER>;
              "ARRAY" C[1:N-1];
              ENTRY: THE RECURRENCE COEFFICIENTS;
     W:       <ARRAY IDENTIFIER>;
              "ARRAY" W[1:(N+1)//2];
              EXIT : PART OF THE GAUSSIAN WEIGHTS DIVIDED BY THE
                     INTEGRAL OF THE WEIGHT FUNCTION.
              (NOTE THAT W[N+1-K]=W[K]  , K=1,2,...,(N+1)//2.)
 
 
 PROCEDURES USED:    ALLORTPOLSYM = CP 31049.
 
 
 METHOD AND PERFORMANCE: SEE SUBSECTION GSSWTS; THIS PROCEDURE IS
                         SUPPLIED FOR STORAGE ECONOMICAL REASONS.
 
 
 REFERENCES:  SEE SUBSECTION GSSWTS.
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 7
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM DELIVERS THE GAUSSIAN WEIGHTS
     FOR THE 5-POINTS GAUSS-CHEBYSHEV QUADRATURE RULE BY MEANS OF
     THE PROCEDURE GSSWTSSYM (C[1]=0.5; C[K]=0.25, K=2,3,...;
     ZER[I] = COS((2*(N-I) - 1) / (2*N) * PI), I=1,2,...,N//2.
 
     "BEGIN"
         "REAL" PI; "INTEGER" I;
         "ARRAY" ZER[1:2], W[1:3], C[1:4];
         PI:=4*ARCTAN(1);
         C[1]:=.5;
         "FOR" I:=2 "STEP" 1 "UNTIL" 4 "DO"
         C[I]:=.25;
         ZER[1]:=COS(.9*PI);
         ZER[2]:=COS(.7*PI);
         GSSWTSSYM(5,ZER,C,W);
         OUTPUT(61,"("2/,5(3B,-ZD.3D)")",W[1]*PI,W[2]*PI,W[3]*PI,
                                                 W[2]*PI,W[1]*PI);
     "END";
 
     RESULTS:
          0.628     0.628     0.628     0.628     0.628
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 8
 
 
 
 SOURCE TEXT(S):
0"CODE" 31254;
 "PROCEDURE" RECCOF(N,M,X,WX,B,C,L,SYM);
 "VALUE" N,M,SYM;"INTEGER" N,M; "BOOLEAN" SYM;
 "REAL" X,WX;"ARRAY" B,C,L;
 "BEGIN" "INTEGER" I,J,UP;"REAL" R,S,PIM,H,HH,ARG,SA;
 PIM:=4*ARCTAN(1)/M;
 "IF" SYM "THEN" "BEGIN"
 "FOR" J:=0 "STEP" 1 "UNTIL" N"DO"
 "BEGIN" R:=B[J]:=0;UP:=M "DIV" 2;
    "FOR" I:=1 "STEP" 1 "UNTIL" UP"DO"
    "BEGIN" ARG:=(I-.5)*PIM;X:=COS(ARG);
       R:=R+SIN(ARG)*WX*ORTPOL(J,X,B,C)**2;
    "END";"IF" UP*2=M "THEN" L[J]:=2*R*PIM "ELSE"
    "BEGIN" X:=0;L[J]:=(2*R+WX*ORTPOL(J,0,B,C)**2)*PIM "END";
    C[J]:="IF" J=0 "THEN" 0 "ELSE" L[J]/L[J-1];
 "END" "END" "ELSE"
 "FOR" J:=0 "STEP" 1 "UNTIL" N "DO"
 "BEGIN" R:=S:=0;UP:=M"DIV" 2;
    "FOR" I:=1 "STEP" 1 "UNTIL" UP "DO"
    "BEGIN" ARG:=(I-.5)*PIM;SA:=SIN(ARG);X:=COS(ARG);
       H:=WX*ORTPOL(J,X,B,C)**2;X:=-X;HH:=WX*ORTPOL(J,X,B,C)**2;
       R:=R+(H+HH)*SA;S:=S+(HH-H)*X*SA;
    "END";B[J]:=S*PIM;
    "IF" UP*2=M "THEN" L[J]:=R*PIM"ELSE"
    "BEGIN" X:=0;L[J]:=(R+WX*ORTPOL(J,0,B,C)**2)*PIM "END";
    C[J]:="IF" J=0 "THEN" 0 "ELSE" L[J]/L[J-1];
 "END";
 "END" RECCOF
1SECTION : 4.2.3.1            (NOVEMBER 1978)                     PAGE 9
 
 
                                                                   ;
         "EOP"
 "CODE" 31253;
 "PROCEDURE" GSSWTS(N,ZER,B,C)RESULTS:(W);
 "VALUE" N; "INTEGER" N;
 "ARRAY" ZER,B,C,W;
 "BEGIN"
     "INTEGER" J,K; "REAL" S; "ARRAY" P[0:N-1];
     "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN"
         ALLORTPOL(N-1,ZER[J],B,C,P);
         S:=0.0;
         "FOR" K:=N-1 "STEP" -1 "UNTIL" 1 "DO"
         S:=(S+P[K]**2)/C[K];
         W[J]:=1/(1+S);
     "END"
 "END" GSSWTS;
         "EOP"
 
 
 "CODE" 31252;
 "PROCEDURE" GSSWTSSYM(N,ZER,C)RESULTS:(W);
 "VALUE" N; "INTEGER" N;
 "ARRAY" ZER,C,W;
 "BEGIN"
    "INTEGER" LOW,UP,DUMMY;
    "ARRAY" P[0:N-1];
    LOW:=1; UP:=N;
       "FOR" DUMMY:=1
    "WHILE" LOW < UP "DO"
       "BEGIN" "INTEGER" I; "REAL" S;
       ALLORTPOLSYM( N-1,ZER[LOW],C,P );
       S:=P[N-1]**2;
       "FOR" I:=N-1 "STEP" -1 "UNTIL" 1 "DO"
          S:=S/C[I] + (P[I-1])**2;
       W[LOW]:=1/S; LOW:=LOW+1; UP:=UP-1;
       "END";
    "IF" LOW = UP
    "THEN" "BEGIN" "INTEGER" TWOI; "REAL" S; S:=1.0;
       "FOR" TWOI:=N-1 "STEP" -2 "UNTIL" 2 "DO"
          S:=S*C[TWOI-1]/C[TWOI]+1;
       W[LOW]:=1/S;
       "END";
 "END" GSSWTSSYM;
         "EOP"
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 1
 
 
 
 AUTHOR: M.BAKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE, AMSTERDAM.
 
 
 RECEIVED: 760131.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THE FOLLOWING PROCEDURES:
 
     (1)  GSS JAC WGHTS:
 
     GIVEN THE TWO PARAMETERS ALFA AND BETA,THIS PROCEDURE
     CALCULATES THE N ZEROS OF THE N-TH JACOBI POLYNOMIAL
     AND THE CORRESPONDING GAUSS-CHRISTOFFEL NUMBERS NEEDED FOR
     THE N-POINT GAUSS-JACOBI QUADRATURE OVER [-1,+1]
     WITH WEIGHT FUNCTION
 
         W(X) = (1-X)**ALFA*(1+X)**BETA;
 
     (2)  GSS LAG WGHTS:
 
     GIVEN THE PARAMETER ALFA,THIS PROCEDURE
     CALCULATES THE N ZEROS OF THE N-TH LAGUERRE POLYNOMIAL
     AND THE GAUSS-CHRISTOFFEL NUMBERS NEEDED FOR THE
     N-POINT GAUSS-LAGUERRE QUADRATURE OF F(X) OVER
     (0, INFINITY) WITH RESPECT TO THE WEIGHT FUNCTION
 
         W(X) = X**ALFA*EXP(-X).
 
 
     THESE PROCEDURES CAN BE USED FOR GAUSSIAN QUADRATURE-
     RULES OF THE JACOBI AND LAGUERRE TYPE.LET THE WEIGHT
     FUNCTION W(X) AND THE INTERVAL(A,B) DETERMINE THE
     SYSTEM OF POLYNOMIALS ORTHOGONAL ON (A,B) WITH RESPECT
     TO W(X).THEN THE N-POINT GAUSSIAN QUADRATURE RULE
     APPROXIMATES THE INTEGRAL
                 TO X=B
                INTEGRAL F(X) W(X) DX
                FROM X=A
     BY THE EXPRESSION
                    J=N
                    SUM  W[J] F(X[J])
                    J=1
     WHERE THE ABSCISSAS X[J] ARE THE ZEROS OF THE N-TH
     POLYNOMIAL AND W[J] ARE THE CORRESPONDING GAUSS-CHRISTOFFEL
     NUMBERS.
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 2
 
 
 
 KEYWORDS:
 
     GAUSSIAN QUADRATURE,
     ZEROS OF ORTHOGONAL POLYNOMIALS,
     GAUSS-CHRISTOFFEL NUMBERS,
     GAUSSIAN WEIGHTS.
 
 
 LANGUAGE: ALGOL 60.
 
 
 REFERENCES:
 
     [1] M.ABRAMOWITZ AND I.A. STEGUN.
         HANDBOOK OF MATHEMATICAL FUNCTIONS, CH.22,
 
     [2] J.STOER,
         EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK 1,
         SPRINGER VERLAG, BERLIN, HEIDELBERG, GOETTINGEN.
 
 
 SUBSECTION: GSS JAC WGHTS.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" GSS JAC WGHTS(N, ALFA, BETA, X, W);
     "VALUE" N, ALFA, BETA;
     "INTEGER" N; "REAL" ALFA, BETA; "ARRAY" X, W;
     "CODE" 31425;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:  <ARITHMETIC EXPRESSION>;
         THE UPPER BOUND OF THE ARRAYS X AND W; N>=1;
     ALFA, BETA:  <ARITHMETIC EXPRESSION>;
         THE PARAMETERS OF THE WEIGHT FUNCTION FOR
         THE JACOBI POLYNOMIALS; ALFA, BETA > -1;
     X;  <ARRAY IDENTIFIER>;
         "ARRAY" X[1:N];
         EXIT: X[I] IS THE I-TH ZERO OF THE N-TH JACOBI POLYNOMIAL;
     W:  <ARRAY IDENTIFIER>;
         "ARRAY" W[1:N];
         EXIT: W[I] IS THE GAUSS-CHRISTOFFEL NUMBER
         ASSOCIATED WITH THE I-TH ZERO OF THE N-TH JACOBI POLYNOMIAL.
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 3
 
 
 
 PROCEDURES USED:
 
     GAMMA          = CP 35061;
     ALL JAC ZER    = CP 31370.
 
 
 
 REQUIRED CENTRAL MEMORY:
 
     TWO AUXILIARY ARRAYS OF N REALS ARE USED.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 METHOD AND PERFORMANCE:
 
     AS IS WELL-KNOWN,THE GAUSSIAN QUADRATURE RULES ARE
     BASED ON THE ZEROS OF ORTHOGONAL POLYNOMIALS.
     PROCEDURES FOR THE COMPUTATION OF THESE ZEROS CAN
     BE FOUND IN SECTION 3.6.2.
     AFTER THE COMPUTATION OF THE ZEROS OF THE JACOBI POLYNOMIAL
     THE GAUSSIAN WEIGHTS ARE COMPUTED OF THE FORMULA
                    J=N-1
           W[I]=1/(  SUM   P(J, ALFA, BETA, X[I])**2)
                    J=0
     WHERE P(J, ALFA, BETA, X[I]) IS THE J-TH ORTHONORMAL
     JACOBI POLYNOMIAL;SEE FURTHER [2],CH.III.
 
 
 EXAMPLE OF USE:
 
     THE PROGRAM
 
     "BEGIN""COMMENT" EVALUATION OF THE INTEGRAL
       TO X=1
      INTEGRAL  (1+X)**2 * (1-X) * EXP(X) DX
      FROM X=-1
     BY MEANS OF FIVE POINT GAUSS-JACOBI QUADRATURE.
     THE EXACT VALUE IS 2*EXP(1)-10/EXP(1);
     "REAL" ALFA, BETA, INT; "INTEGER" N; "ARRAY" X, W[1:5];
     "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X; F:=EXP(X);
     ALFA:= 1; BETA:= 2; N:= 5; INT:= 0;
     GSS JAC WGHTS( N, ALFA, BETA, X, W);
     "FOR" N:= 1 "STEP" 1 "UNTIL" 5 "DO" INT:= INT + W[N] * F(X[N]);
     OUTPUT(61, "(" /, 4B+D. 4D"+ZD")", INT - 2 * EXP(1) + 10 / EXP(1))
     "END"
 
     PRINTS THE FOLOWING RESULT:
 
      -1.5932"-10
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 4
 
 
 
 SUBSECTION: GSS LAG WGHTS.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" GSS LAG WGHTS (N, ALFA, X, W);
     "VALUE" N, ALFA;
     "INTEGER" N; "REAL" ALFA;  "ARRAY" X, W;
     "CODE" 31427;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:  <ARITHMETIC EXPRESSION>;
         THE UPPER BOUND OF THE ARRAYS X AND W; N>=1;
     ALFA:  <ARITHMETIC EXPRESSION>;
         THE PARAMETER OF THE WEIGHT FUNCTION FOR THE
         LAGUERRE POLYNOMIALS;
         ALFA>-1;
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[1: N];
         EXIT:  X[I] IS THE I-TH ZERO OF THE N-TH
         LAGUERRE POLYNOMIAL;
     W:  <ARRAY IDENTIFIER>;
         "ARRAY" W[1: N];
         EXIT:  W[I] IS THE GAUSSIAN WEIGHT CORRESPONDING
         WITH THE I-TH ZERO OF THE N-TH LAGUERRE POLYNOMIAL.
 
 
 PROCEDURES USED:
 
     GAMMA          = CP 35061,
     ALL LAG ZER    = CP 31371.
 
 
 REQUIRED CENTRAL MEMORY:
 
     TWO AUXILIARY ARRAYS OF N REALS ARE USED.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 METHOD AND PERFORMANCE:
 
     THE ZEROS AND WEIGHTS ARE COMPUTED IN THE SAME
     WAY AS IN THE PROCEDURE GSS JAC WGHTS.
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 5
 
 
 
 EXAMPLE OF USE:
 
     THE PROGRAM
 
     "BEGIN" "COMMENT" COMPUTATION OF THE INTEGRAL FROM 0 TO INFINITY OF
        SIN(X)*EXP(-X) BY MEANS OF A TEN POINT GAUSS-LAGUERRE
        QUADRATURE.THE EXACT VALUE IS 0.5;
        "REAL" INT;"INTEGER" N;"ARRAY" X, W[1:10];
        "REAL""PROCEDURE" F(X); "VALUE"X; "REAL"X; F:=SIN(X);
        GSS LAG WGHTS(10, 0, X, W);  INT:=0;
        "FOR" N:=10 "STEP" -1 "UNTIL" 1 "DO" INT:= INT + W[N] * F(X[N]);
        OUTPUT(61, "("-D.4D"-ZD")", INT-0.5)
      "END"
 
      PRINTS THE RESULT:
 
      2.0497" -7
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 6
 
 
 
 SOURCE TEXTS:
0"CODE" 31425;
     "PROCEDURE" GSS JAC WGHTS(N, ALFA, BETA, X, W);
     "VALUE" N, ALFA, BETA; "INTEGER" N; "REAL" ALFA, BETA;
     "ARRAY" X, W;
     "IF" ALFA = BETA "THEN"
     "BEGIN" "INTEGER" I, J, M;
         "ARRAY" B[1:N - 1]; "REAL" R0, R1, R2, S, H0, ALFA2, XI;
 
         ALL JAC ZER(N, ALFA, ALFA, X); ALFA2:= 2*ALFA;
         H0:= 2**(ALFA2 + 1)*GAMMA(1 + ALFA)**2/GAMMA(ALFA2 + 2);
         B[1]:= 1/SQRT(3 + ALFA2); M:= N - (N//2);
         "FOR" I:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
         B[I]:= SQRT(I*(I + ALFA2)/(4*(I + ALFA)**2 - 1));
         "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" XI:= ABS(X[I]); R0:= 1; R1:= XI/B[1];
             S:= 1 + R1*R1;
             "FOR" J:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
             "BEGIN" R2:= (XI*R1 - B[J - 1]*R0)/B[J];
                 R0:= R1; R1:= R2; S:= S + R2*R2
             "END";
             W[I]:= W[N + 1 - I]:= H0/S
         "END"
     "END" "ELSE"
     "BEGIN" "INTEGER" I, J; "ARRAY" A, B[0:N];
         "REAL" MIN, SUM, H0, R0, R1, R2, XI, ALFABETA;
         ALFABETA:= ALFA + BETA; MIN:= (BETA - ALFA)*ALFABETA;
         B[0]:= 0; SUM:= ALFABETA + 2; A[0]:= (BETA - ALFA)/SUM;
         A[1]:= MIN /SUM/(SUM + 2);
         B[1]:= 2*SQRT((1 + ALFA)*(1 + BETA)/(SUM + 1))/SUM;
         "FOR" I:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" SUM:= I + I + ALFABETA;
             A[I]:= MIN/SUM/(SUM + 2);
             B[I]:= (2/SUM)*
             SQRT(I*(SUM - I)*(I + ALFA)*(I + BETA)/(SUM*SUM - 1))
         "END";
         H0:= 2**(ALFABETA + 1)*GAMMA(1 + ALFA)*GAMMA(1 + BETA)/
                                   GAMMA(2 + ALFABETA);
         ALL JAC ZER(N, ALFA, BETA, X);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" XI:= X[I]; R0:= 1; R1:= (XI - A[0])/B[1];
             SUM:= 1 + R1*R1;
             "FOR" J:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
             "BEGIN" R2:= ((XI - A[J - 1])*R1 - B[J - 1]*R0)/B[J];
                 SUM:= SUM + R2*R2; R0:= R1; R1:= R2
             "END";
             W[I]:= H0/SUM
         "END"
     "END" GSS JAC WGHTS
1SECTION : 4.2.3.2            (NOVEMBER 1976)                     PAGE 7
 
 
                                                                   ;
          "EOP"
 "CODE" 31427;
     "PROCEDURE" GSS LAG WGHTS(N, ALFA, X, W);
     "VALUE" N, ALFA; "INTEGER" N; "REAL" ALFA; "ARRAY" X, W;
     "BEGIN" "INTEGER" I, J; "REAL" H0, S, R0, R1, R2, XI;
         "ARRAY" A, B[0:N];
         A[0]:= 1 + ALFA; A[1]:= 3 + ALFA; B[1]:= SQRT(A[0]);
         "FOR" I:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" A[I]:= I + I + ALFA + 1;
             B[I]:= SQRT(I*(I + ALFA))
         "END";
         ALL LAG ZER(N, ALFA, X); H0:= GAMMA(1 + ALFA);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" XI:= X[I]; R0:= 1;
             R1:= (XI - A[0])/B[1]; S:= 1 + R1*R1;
             "FOR" J:= 2 "STEP" 1 "UNTIL" N - 1 "DO"
             "BEGIN" R2:= ((XI - A[J - 1])*R1 - B[J - 1]*R0)/B[J];
                 R0:= R1; R1:= R2; S:= S + R2*R2
                 "END";
             W[I]:= H0/S
         "END"
     "END" GSS LAG WGHTS;
          "EOP"
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR: J.C.P.BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740218.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS PROCEDURES FOR CALCULATING THE DERIVATIVES OF
     FUNCTIONS OF MORE VARIABLES, USING DIFFERENCE FORMULAS;
     JACOBNNF   CALCULATES  THE  JACOBIAN  MATRIX  OF  AN  N-DIMENSIONAL
         FUNCTION OF N VARIABLES USING FORWARD DIFFERENCES;
     JACOBNMF   CALCULATES  THE  JACOBIAN  MATRIX  OF  AN  N-DIMENSIONAL
         FUNCTION OF M VARIABLES USING FORWARD DIFFERENCES;
     JACOBNBNDF  CALCULATES  THE  JACOBIAN  MATRIX  OF AN  N-DIMENSIONAL
         FUNCTION OF  N  VARIABLES,  IF THIS JACOBIAN  IS KNOWN TO BE  A
         BAND MATRIX AND HAVE TO BE STORED ROW-WISE IN A ONE-DIMENSIONAL
         ARRAY.
 
 
 KEYWORDS:
 
     NUMERICAL DIFFERENTIATION,
     FUNCTIONS OF MORE VARIABLES,
     DIFFERENCE FORMULAS.
 
 
 
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 2
 
 
 
 SUBSECTION: JACOBNNF.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS:
     "PROCEDURE" JACOBNNF(N, X, F, JAC, I, DI, FUNCT);
     "VALUE" N; "INTEGER" I, N; "REAL" DI; "ARRAY" X, F, JAC;
     "PROCEDURE" FUNCT;
     "CODE" 34437;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER  OF INDEPENDENT VARIABLES  AND  THE DIMENSION OF
             THE FUNCTION;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1:N];
             ENTRY: THE POINT AT WHICH THE JACOBIAN HAS TO BE CALCULATED
     F:      <ARRAY IDENTIFIER>;
             "ARRAY" F[1:N];
             ENTRY : THE VALUES OF THE FUNCTION-COMPONENTS AT THE POINT
             GIVEN IN ARRAY X;
     JAC:    <ARRAY IDENTIFIER>;
             "ARRAY" JAC[1:N, 1:N];
             EXIT : THE JACOBIAN MATRIX IN SUCH A WAY THAT THE PARTIAL
             DERIVATIVE OF  F[I] TO  X[J] IS  GIVEN IN
             JAC[I, J], I, J = 1, ..., N;
     I:      <INTEGER VARIABLE>;
             A JENSEN PARAMETER; DI MAY BE DEPENDENT OF I;
     DI:     <ARITHMETIC EXPRESSION>;
             THE  PARTIAL DERIVATIVES  TO  X[I]  ARE  APPROXIMATED  WITH
             FORWARD  DIFFERENCES,   USING  AN  INCREMENT  TO  THE  I-TH
             VARIABLE THAT EQUALS THE VALUE OF DI, I = 1, ..., N;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE SHOULD READ:
             "PROCEDURE" FUNCT(N, X, F);
             "VALUE" N; "INTEGER" N; "ARRAY" X, F;
             THE MEANING OF THE FORMAL PARAMETERS IS:
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF INDEPENDENT VARIABLES OF THE FUNCTION  F;
             X:  <ARRAY IDENTIFIER>;
                 THE INDEPENDENT VARIABLES ARE GIVEN IN X[1:N];
             F:  <ARRAY IDENTIFIER>;
                 AFTER A CALL OF FUNCT THE FUNCTION COMPONENTS SHOULD BE
                 GIVEN IN F[1:N].
 
 
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 3
 
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY :
 
     EXECUTION FIELD LENGTH: JACOBNNF DECLARES ONE  AUXILIARY  ARRAY  OF
                             ORDER N.
 
 
 RUNNING TIME: PROPORTIONAL TO  N ** 2.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     JACOBNNF   CALCULATES  THE  JACOBIAN  MATRIX  OF  AN  N-DIMENSIONAL
     FUNCTION OF N VARIABLES; THE ELEMENTS OF THIS MATRIX, WHICH ARE THE
     PARTIAL DERIVATIVES OF THE FUNCTION,  ARE CALCULATED  USING FORWARD
     DIFFERENCES WITH AN INCREMENT TO THE I-TH  VARIABLE OF  DI, (I = 1,
     ..., N).
 
 
 EXAMPLE OF USE:
 
     LET F BE DEFINED BY:
             F[1]= X[1] ** 3 + X[2],
             F[2]= 10 * X[2];
     THE JACOBIAN MATRIX  AT  THE POINT  (2, 1)  MAY  BE CALCULATED  AND
     PRINTED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" I; "ARRAY" JAC[1:2, 1:2], X, F[1:2];
         "PROCEDURE" F1(N, X, F); "VALUE" N; "INTEGER" N; "ARRAY" X, F;
         "BEGIN" F[1]:= X[1] ** 3 + X[2]; F[2]:= X[2] * 10 "END" F1;
         X[1]:= 2; X[2]:= 1; F1(2, X, F);
         JACOBNNF(2, X, F, JAC, I, "IF" I = 1 "THEN" "-6 "ELSE" 1, F1);
         OUTPUT(71, "("/,4B,"("THE CALCULATED JACOBIAN IS:")",//,
         2(4B,2(N),/)")", JAC[1, 1], JAC[1, 2], JAC[2, 1], JAC[2, 2])
     "END"
 
     RESULTS:
 
     THE CALCULATED JACOBIAN IS:
 
     +1.2000005938262"+001  +1.0000000000000"+000
     +0.0000000000000"+000  +1.0000000000000"+001
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 4
 
 
 
 SUBSECTION: JACOBNMF.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS:
     "PROCEDURE" JACOBNMF(N, M, X, F, JAC, I, DI, FUNCT);
     "VALUE" N, M; "INTEGER" I, N, M; "REAL" DI; "ARRAY" X, F, JAC;
     "PROCEDURE" FUNCT;
     "CODE" 34438;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF FUNCTION COMPONENTS;
     M:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF INDEPENDENT VARIABLES;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1:M];
             ENTRY: THE POINT AT WHICH THE JACOBIAN HAS TO BE CALCULATED
     F:      <ARRAY IDENTIFIER>;
             "ARRAY" F[1:N];
             ENTRY: THE VALUES OF THE FUNCTION-COMPONENTS AT THE POINT
             GIVEN IN ARRAY X;
     JAC:    <ARRAY IDENTIFIER>;
             "ARRAY" JAC[1:N, 1:M];
             EXIT : THE JACOBIAN MATRIX IN SUCH A WAY THAT THE PARTIAL
             DERIVATIVE OF  F[I] TO  X[J] IS  GIVEN IN
             JAC[I, J], I = 1, ..., N, J = 1, ... M;
     I:      <INTEGER VARIABLE>;
             A JENSEN PARAMETER; DI MAY BE DEPENDENT OF I;
     DI:     <ARITHMETIC EXPRESSION>;
             THE  PARTIAL DERIVATIVES  TO  X[I]  ARE  APPROXIMATED  WITH
             FORWARD  DIFFERENCES,   USING  AN  INCREMENT  TO  THE  I-TH
             VARIABLE THAT EQUALS THE VALUE OF DI, I = 1, ..., M;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS :
             "PROCEDURE" FUNCT(N, M, X, F);
             "VALUE" N, M; "INTEGER" N, M; "ARRAY" X, F;
             THE MEANING OF THE FORMAL PARAMETERS IS :
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF FUNCTION COMPONENTS;
             M:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF INDEPENDENT VARIABLES OF THE FUNCTION  F;
             X:  <ARRAY IDENTIFIER>;
                 THE INDEPENDENT VARIABLES ARE GIVEN IN X[1:M];
             F:  <ARRAY IDENTIFIER>;
                 AFTER A CALL OF FUNCT THE FUNCTION COMPONENTS SHOULD BE
                 GIVEN IN F[1:N].
 
 
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 5
 
 
 
 PROCEDURES USED: NONE.
 
 
 EXECUTION FIELD LENGTH: JACOBNMF   DECLARES   ONE  AUXILIARY  ARRAY  OF
                         ORDER N.
 
 
 RUNNING TIME: PROPORTIONAL TO  N * M.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     JACOBNMF   CALCULATES  THE  JACOBIAN  MATRIX  OF  AN  N-DIMENSIONAL
     FUNCTION OF M VARIABLES; THE ELEMENTS OF THIS MATRIX, WHICH ARE THE
     PARTIAL DERIVATIVES OF THE FUNCTION,  ARE CALCULATED  USING FORWARD
     DIFFERENCES  WITH AN INCREMENT TO THE I-TH  VARIABLE OF  DI,(I = 1,
     ..., M).
 
 
 EXAMPLE OF USE:
 
     LET F BE DEFINED BY:
             F[1]= X[1] ** 3 + X[2],
             F[2]= 10 * X[2] + X[2] * X[1],
             F[3]= X[1] * X[2];
     THE  JACOBIAN MATRIX  AT  THE POINT  (2, 1)  MAY BE CALCULATED  AND
     PRINTED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" I; "ARRAY" JAC[1:3, 1:2], X[1:2], F[1:3];
         "PROCEDURE" F1(N, M, X, F); "VALUE" N, M; "INTEGER" N, M;
         "ARRAY" X, F;
         "BEGIN" F[1]:= X[1] ** 3 + X[2];
             F[2]:= X[2] * 10 + X[2] * X[1] ** 2; F[3]:= X[1] * X[2]
         "END" F1;
         X[1]:= 2; X[2]:= 1; F1(3, 2, X, F);
         JACOBNMF(3, 2, X, F, JAC, I, "IF" I=2 "THEN" 1 "ELSE" "-5, F1);
         OUTPUT(71, "("/,4B,"("THE CALCULATED JACOBIAN IS:")",//,
         3(4B,2(N),/)")", JAC[1, 1], JAC[1, 2], JAC[2, 1], JAC[2, 2],
         JAC[3, 1], JAC[3, 2])
     "END"
 
     RESULTS:
 
     THE CALCULATED JACOBIAN IS:
 
     +1.2000060002038"+001  +1.0000000000000"+000
     +4.0000100000270"+000  +1.4000000000000"+001
     +1.0000000003174"+000  +2.0000000000000"+000
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 6
 
 
 
 SUBSECTION: JACOBNBNDF.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS :
     "PROCEDURE" JACOBNBNDF(N, LW, RW, X, F, JAC, I, DI, FUNCT);
     "VALUE" N, LW, RW; "INTEGER" N, I, LW, RW; "REAL" DI;
     "ARRAY" X, F, JAC; "PROCEDURE" FUNCT;
     "CODE" 34439;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER  OF INDEPENDENT VARIABLES  AND  THE DIMENSION OF
             THE FUNCTION;
     LW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS  TO THE LEFT OF THE MAIN DIAGONAL
             OF THE JACOBIAN MATRIX, WHICH IS KNOWN TO BE A BAND MATRIX;
     RW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS TO THE RIGHT OF THE MAIN DIAGONAL
             OF THE JACOBIAN MATRIX;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1:N];
             ENTRY: THE POINT AT WHICH THE JACOBIAN HAS TO BE CALCULATED
     F:      <ARRAY IDENTIFIER>;
             "ARRAY" F[1:N];
             ENTRY: THE VALUES OF THE FUNCTION-COMPONENTS AT THE POINT
             GIVEN IN ARRAY X;
     JAC:    <ARRAY IDENTIFIER>;
             "ARRAY" JAC [1 : (LW + RW ) * (N - 1) + N];
             EXIT: THE JACOBIAN MATRIX  IN SUCH A WAY THAT THE (I, J)-TH
             ELEMENT OF THE JACOBIAN, I.E. THE PARTIAL DERIVATIVE OF
             F[I] TO X[J], IS  GIVEN IN
             JAC[(LW + RW) * (I - 1) + J], FOR I = 1, ..., N
             J= MAX(1, I - LW), ..., MIN(N, I + RW);
     I:      <INTEGER VARIABLE>;
             A JENSEN PARAMETER; DI MAY BE DEPENDENT OF I;
     DI:     <ARITHMETIC EXPRESSION>;
             THE  PARTIAL DERIVATIVES  TO  X[I]  ARE  APPROXIMATED  WITH
             FORWARD  DIFFERENCES,   USING  AN  INCREMENT  TO  THE  I-TH
             VARIABLE THAT EQUALS THE VALUE OF DI, I = 1, ..., N;
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 7
 
 
 
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS :
             "PROCEDURE" FUNCT(N, L, U, X, F);
             "VALUE" N, L, U; "INTEGER" N, L, U; "ARRAY" X, F;
             THE MEANING OF THE FORMAL PARAMETERS IS :
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF FUNCTION COMPONENTS;
             L,U:<ARITHMETIC EXPRESSION>;
                 LOWER  AND  UPPER  BOUND   OF  THE  FUNCTION  COMPONENT
                 SUBSCRIPT;
             X:  <ARRAY IDENTIFIER>;
                 THE INDEPENDENT VARIABLES ARE GIVEN IN X[1:N];
             F:  <ARRAY IDENTIFIER>;
                 AFTER  A CALL  OF  FUNCT  THE FUNCTION COMPONENTS F[I],
                 I = L, ..., U, SHOULD BE GIVEN IN F[L:U].
 
 
 PROCEDURES USED: NONE.
 
 
 EXECUTION FIELD LENGTH: JACOBNMF   DECLARES   ONE  AUXILIARY  ARRAY  OF
                         MAXIMUM ORDER LW + RW + 1;
 
 
 RUNNING TIME: PROPORTIONAL TO  N * (LW + RW + 1).
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     JACOBNBNDF   CALCULATES  THE  JACOBIAN MATRIX  OF AN  N-DIMENSIONAL
     FUNCTION OF  N  VARIABLES,  IF THIS JACOBIAN IS KNOWN TO BE  A BAND
     MATRIX AND HAVE TO BE STORED  ROW-WISE  IN A ONE-DIMENSIONAL ARRAY;
     THE ELEMENTS OF THIS JACOBIAN MATRIX ARE CALCULATED  USING  FORWARD
     DIFFERENCES, WITH AN INCREMENT TO THE I-TH VARIABLE OF DI,  (I = 1,
     ..., N).
 
 
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 8
 
 
 
 EXAMPLE OF USE:
 
     LET F BE DEFINED BY:
     F[1] = (3 - 2 * X[1]) * X[1] + 1 - 2 * X[2],
     F[I] = (3 - 2 * X[I]) * X[I] + 1 - X[I-1] - 2 * X[I+1], I= 2, 3, 4,
     F[5] = 4 - 2 * X[5] - X[4];
     THE TRIDIAGONAL JACOBIAN MATRIX AT THE POINT X, GIVEN BY X[I] = -1,
     I = 1, ..., 5,  MAY  BE  CALCULATED  AND  PRINTED  BY THE FOLLOWING
     PROGRAM:
 
     "BEGIN"
         "INTEGER" I; "ARRAY" JAC[1:13], X, F[1:5];
         "PROCEDURE" F1(N, L, U, X, F); "VALUE" N, L, U;
         "INTEGER" N, L, U; "ARRAY" X, F;
         "BEGIN" "INTEGER" I;
             "FOR" I:= L "STEP" 1 "UNTIL" ("IF" U = 5 "THEN" 4 "ELSE" U)
             "DO"
             "BEGIN" F[I]:= (3 - 2 * X[I]) * X[I] + 1 - 2 * X[I + 1];
                 "IF" I ^= 1 "THEN" F[I]:= F[I] - X[I - 1]
             "END";
             "IF" U = 5 "THEN" F[5]:= 4 - X[4] - X[5] * 2
         "END" F1;
 
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             ITEM("("THE CALCULATED TRIDIAGONAL JACOBIAN IS:")");
             "FOR" I:= 1 "STEP" 1 "UNTIL" 13 "DO" ITEM(JAC[I])
          "END" LIST;
 
         "PROCEDURE" LAYOUT;
         FORMAT("("//,4B,40S,//,4B,2(+.5D"+D2B),/,4B,3(+.5D"+D2B),/,
         16B,3(+.5D"+D2B),/,28B,3(+.5D"+D2B),/,40B,2(+.5D"+D2B),/")");
         "FOR" I := 1 "STEP" 1 "UNTIL" 5 "DO" X[I]:= -1;
         F1(5, 1, 5, X, F);
         JACOBNBNDF(5, 1, 1, X, F, JAC, I, "IF" I = 5 "THEN" 1 "ELSE"
         "-6, F1);
         OUTLIST(71, LAYOUT, LIST)
     "END"
 
     RESULTS:
 
     THE CALCULATED TRIDIAGONAL JACOBIAN IS:
 
     +.70000"+1  -.20000"+1
     -.10000"+1  +.70000"+1  -.20000"+1
                 -.10000"+1  +.70000"+1  -.20000"+1
                             -.10000"+1  +.70000"+1  -.20000"+1
                                         -.10000"+1  -.20000"+1
1SECTION : 4.3.2.1            (OCTOBER 1974)                      PAGE 9
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 34437;
 "PROCEDURE" JACOBNNF(N, X, F, JAC, I, DI, FUNCT); "VALUE" N;
 "INTEGER" N, I; "REAL" DI; "ARRAY" X, F, JAC; "PROCEDURE" FUNCT;
 "BEGIN" "INTEGER" J; "REAL" STEP, AID; "ARRAY" F1[1:N];
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" STEP:= DI; AID:= X[I]; X[I]:= AID + STEP;
         STEP:= 1 / STEP; FUNCT(N, X, F1);
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         JAC[J,I]:= (F1[J] - F[J]) * STEP; X[I]:= AID
     "END"
 "END" JACOBNNF;
         "EOP"
 
 "CODE" 34438;
 "PROCEDURE" JACOBNMF(N, M, X, F, JAC, I, DI, FUNCT); "VALUE" N, M;
 "INTEGER" N, M, I; "REAL" DI; "ARRAY" X, F, JAC; "PROCEDURE" FUNCT;
 "BEGIN" "INTEGER" J; "REAL" STEP, AID; "ARRAY" F1[1:N];
     "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
     "BEGIN" STEP:= DI; AID:= X[I]; X[I]:= AID + STEP;
         STEP:= 1 / STEP; FUNCT(N, M, X, F1);
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         JAC[J,I]:= (F1[J] - F[J]) * STEP; X[I]:= AID
     "END"
 "END" JACOBNMF;
         "EOP"
 
 "CODE" 34439;
     "PROCEDURE" JACOBNBNDF(N, LW, RW, X, F, JAC, I, DI, FUNCT);
     "VALUE" N, LW, RW; "INTEGER" I, N, LW, RW; "REAL" DI;
     "ARRAY" X, F, JAC; "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" J, K, L, U, T, B; "REAL" AID, STEPI;
         L:= 1; U:= LW + 1; T:= RW + 1; B:= LW + RW;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "ARRAY" F1[L:U];
             STEPI:= DI; AID:= X[I]; X[I]:= AID + STEPI;
             FUNCT(N, L, U, X, F1); X[I]:= AID;
             K:= I + ("IF" I <= T "THEN" 0 "ELSE" I - T) * B;
             "FOR" J:= L "STEP" 1 "UNTIL" U "DO"
             "BEGIN" JAC[K]:= (F1[J] - F[J]) / STEPI; K:=K + B "END";
             "IF" I >= T "THEN" L:= L + 1;
             "IF" U < N "THEN" U:= U + 1
         "END"
     "END" JACOBNBNDF;
         "EOP"
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHORS: J. C. P. BUS AND  T. J. DEKKER.
 
 
 CONTRIBUTOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 750615.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES  FOR FINDING A ZERO OF A GIVEN
     FUNCTION IN A GIVEN INTERVAL;
     ZEROIN    APPROXIMATES A ZERO  MAINLY  BY LINEAR INTERPOLATION  AND
               EXTRAPOLATION;
     ZEROINRAT APPROXIMATES  A  ZERO  BY  INTERPOLATION   WITH  RATIONAL
               FUNCTIONS.
     ZEROIN IS PREFERABLE FOR SIMPLE (I.E. CHEAPLY TO CALCULATE)
     FUNCTIONS AND/OR WHEN NO HIGH PRECISION IS REQUIRED. ZEROINRAT IS
     PREFERABLE FOR COMPLICATED (I.E. EXPENSIVE) FUNCTIONS WHEN A ZERO
     IS REQUIRED IN RATHER HIGH PRECISION AND ALSO FOR FUNCTIONS HAVING
     A POLE NEAR THE ZERO. WHEN THE ANALYTIC DERIVATIVE OF THE FUNCTION
     IS EASILY OBTAINED, THEN ZEROINDER (SECTION 5.1.1.1.2) SHOULD BE
     TAKEN INTO CONSIDERATION.
 
 
 KEYWORDS:
 
     ZERO SEARCHING,
     ANALYTIC EQUATIONS,
     SINGLE NON-LINEAR EQUATION.
 
 
 
 
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 2
 
 
 
 SUBSECTION: ZEROIN.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS :
     "BOOLEAN" "PROCEDURE" ZEROIN(X, Y, FX, TOLX);
     "REAL" X, Y, FX, TOLX;
     "CODE" 34150;
 
     ZEROIN  SEARCHES FOR A ZERO OF A REAL FUNCTION  F  DEFINED ON A
             CERTAIN INTERVAL J;
             ZEROIN := "TRUE" WHEN A (SUFFICIENTLY SMALL) SUBINTERVAL OF
             J CONTAINING A  ZERO OF  F HAS  BEEN  FOUND;  OTHERWISE,
             ZEROIN := "FALSE";
             LET A REAL FUNCTION T DEFINED ON J, DENOTE A TOLERANCE
             FUNCTION DEFINING THE REQUIRED PRECISION OF THE ZERO;
             (FOR INSTANCE
                           T(X) = ABS(X) * RE + AE,
             WHERE  RE  AND  AE  ARE THE REQUIRED  RELATIVE AND ABSOLUTE
             PRECISION RESPECTIVELY);
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <REAL VARIABLE>;
             A JENSEN VARIABLE;  THE ACTUAL PARAMETERS FOR  FX AND TOLX
             (MAY) DEPEND ON THE ACTUAL PARAMETER FOR X;
             ENTRY:  ONE  ENDPOINT OF INTERVAL  J  IN  WHICH  A  ZERO IS
                     SEARCHED FOR;
             EXIT:   A VALUE APPROXIMATING THE ZERO WITHIN THE TOLERANCE
                     2 * T(X) WHEN ZEROIN HAS THE VALUE "TRUE", AND A
                     PRESUMABLY WORTHLESS ARGUMENT VALUE OTHERWISE;
     Y:      <REAL VARIABLE>;
             ENTRY:  THE OTHER ENDPOINT OF INTERVAL J IN WHICH A ZERO IS
                     SEARCHED FOR;  UPON ENTRY X < Y AS WELL AS Y < X IS
                     ALLOWED;
             EXIT:   THE  OTHER  STRADDLING  APPROXIMATION  OF THE ZERO,
                     I.E.  UPON  EXIT  THE  VALUES  OF  Y AND X  SATISFY
                     1. F(X) * F(Y) <= 0,  2. ABS(X - Y) <= 2 * T(X) AND
                     3. ABS(F(X)) <= ABS(F(Y)) WHEN ZEROIN HAS THE
                     VALUE "TRUE", AND  A  PRESUMABLY WORTHLESS ARGUMENT
                     VALUE  SATISFYING  CONDITIONS  2  AND  3  BUT NOT 1
                     OTHERWISE;
     FX:     <ARITHMETIC EXPRESSION>;
             DEFINES  FUNCTION F AS A FUNCTION  DEPENDING ON THE  ACTUAL
             PARAMETER FOR X;
     TOLX:   <ARITHMETIC EXPRESSION>;
             DEFINES THE  TOLERANCE  FUNCTION T WHICH MAY  DEPEND ON THE
             ACTUAL PARAMETER FOR X;
             ONE SHOULD CHOOSE TOLX  POSITIVE AND NEVER SMALLER THAN THE
             PRECISION OF THE  MACHINE'S  ARITHMETIC  AT X, I.E. IN THIS
             ARITHMETIC  X + TOLX  AND  X - TOLX   SHOULD  ALWAYS  YIELD
             VALUES  DISTINCT  FROM  X; OTHERWISE  THE PROCEDURE MAY GET
             INTO A LOOP.
 
 
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 3
 
 
 
 PROCEDURES USED: DWARF = CP30003;
 
 
 EXECUTION FIELD LENGTH: NO AUXILIARY ARRAYS ARE DECLARED IN ZEROIN.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IS DESCRIBED IN DETAIL IN [1].
     THE NUMBER OF EVALUATIONS OF FX AND TOLX IS AT MOST
             4 * LOG(ABS(X - Y)) / TAU,
     WHERE X AND Y ARE THE ARGUMENT VALUES GIVEN UPON ENTRY, LOG DENOTES
     THE BASE 2 LOGARITHM AND TAU IS THE MINIMUM OF THE TOLERANCE
     FUNCTION TOLX ON THE INITIAL INTERVAL. IF UPON ENTRY X AND Y
     SATISFY F(X) * F(Y) <= 0, THEN CONVERGENCE IS GUARANTEED AND THE
     ASYMPTOTIC ORDER OF CONVERGENCE IS 1.618 FOR SIMPLE ZEROES.
 
 
 EXAMPLE OF USE:
 
     THE ZERO OF THE FUNCTION   EXP(-X * 3) * (X - 1) + X ** 3,  IN  THE
     INTERVAL [0, 1], MAY BE CALCULATED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "REAL" X, Y;
         "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X;
         F:= EXP(-X * 3) * ( X - 1) + X ** 3;
         X:= 0; Y:= 1;
         "IF" ZEROIN(X, Y, F(X), ABS(X) * "-14 + "-14) "THEN"
         OUTPUT(71, "("/4B,"("CALCULATED ZERO:")"B+.15D"+3D")", X)
         "ELSE" OUTPUT(71, "("/4B,"("NO ZERO FOUND")"")")
     "END"
 
     RESULT:
 
     CALCULATED ZERO: +.489702748548240"+000
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 4
 
 
 
 SUBSECTION: ZEROINRAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS:
     "BOOLEAN" "PROCEDURE" ZEROINRAT(X, Y, FX, TOLX);
     "REAL" X, Y, FX, TOLX;
     "CODE" 34436;
 
     ZEROINRAT SEARCHES FOR A ZERO OF A REAL FUNCTION  F DEFINED ON A
             CERTAIN INTERVAL J;
             ZEROINRAT := "TRUE" WHEN A (SUFFICIENTLY SMALL) SUBINTERVAL
             OF J CONTAINING A  ZERO OF  F HAS  BEEN  FOUND;  OTHERWISE,
             ZEROINRAT := "FALSE";
             LET A REAL FUNCTION T DEFINED ON J, DENOTE A TOLERANCE
             FUNCTION DEFINING THE REQUIRED PRECISION OF THE ZERO;
             (FOR INSTANCE
                           T(X) = ABS(X) * RE + AE,
             WHERE  RE  AND  AE  ARE THE REQUIRED  RELATIVE AND ABSOLUTE
             PRECISION RESPECTIVELY);
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <REAL VARIABLE>;
             A JENSEN VARIABLE;  THE ACTUAL PARAMETERS FOR  FX AND TOLX
             (MAY) DEPEND ON THE ACTUAL PARAMETER FOR X;
             ENTRY:  ONE  ENDPOINT OF INTERVAL  J  IN  WHICH  A  ZERO IS
                     SEARCHED FOR;
             EXIT:   A VALUE APPROXIMATING THE ZERO WITHIN THE TOLERANCE
                     2 * T(X) WHEN ZEROINRAT HAS THE VALUE "TRUE", AND A
                     PRESUMABLY WORTHLESS ARGUMENT VALUE OTHERWISE;
     Y:      <REAL VARIABLE>;
             ENTRY:  THE OTHER ENDPOINT OF INTERVAL J IN WHICH A ZERO IS
                     SEARCHED FOR;  UPON ENTRY X < Y AS WELL AS Y < X IS
                     ALLOWED;
             EXIT:   THE  OTHER  STRADDLING  APPROXIMATION  OF THE ZERO,
                     I.E.  UPON  EXIT  THE  VALUES  OF  Y AND X  SATISFY
                     1. F(X) * F(Y) <= 0,  2. ABS(X - Y) <= 2 * T(X) AND
                     3. ABS(F(X)) <= ABS(F(Y))  WHEN  ZEROINRAT  HAS THE
                     VALUE "TRUE", AND  A  PRESUMABLY WORTHLESS ARGUMENT
                     VALUE  SATISFYING  CONDITIONS  2  AND  3  BUT NOT 1
                     OTHERWISE;
     FX:     <ARITHMETIC EXPRESSION>;
             DEFINES  FUNCTION F AS A FUNCTION  DEPENDING ON THE  ACTUAL
             PARAMETER FOR X;
     TOLX:   <ARITHMETIC EXPRESSION>;
             DEFINES THE  TOLERANCE  FUNCTION T WHICH MAY  DEPEND ON THE
             ACTUAL PARAMETER FOR X;
             ONE SHOULD CHOOSE TOLX  POSITIVE AND NEVER SMALLER THAN THE
             PRECISION OF THE  MACHINE'S  ARITHMETIC  AT X, I.E. IN THIS
             ARITHMETIC  X + TOLX  AND  X - TOLX   SHOULD  ALWAYS  YIELD
             VALUES  DISTINCT  FROM  X; OTHERWISE  THE PROCEDURE MAY GET
             INTO A LOOP.
 
 
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 5
 
 
 
 PROCEDURES USED: DWARF = CP30003;
 
 
 EXECUTION FIELD LENGTH: NO AUXILIARY ARRAYS ARE DECLARED IN ZEROINRAT.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IS DESCRIBED IN DETAIL IN [1].
     THE NUMBER OF EVALUATIONS OF FX AND TOLX IS AT MOST
             5 * LOG(ABS(X - Y)) / TAU,
     WHERE X AND Y ARE THE ARGUMENT VALUES GIVEN UPON ENTRY, LOG DENOTES
     THE BASE 2 LOGARITHM AND TAU IS THE MINIMUM OF THE TOLERANCE
     FUNCTION TOLX ON THE INITIAL INTERVAL. IF UPON ENTRY X AND Y
     SATISFY F(X) * F(Y) <= 0, THEN CONVERGENCE IS GUARANTEED AND THE
     ASYMPTOTIC ORDER OF CONVERGENCE IS 1.839 FOR SIMPLE ZEROES.
 
 
 EXAMPLE OF USE:
 
     THE ZERO OF THE FUNCTION   EXP(-X * 3) * (X - 1) + X ** 3,  IN  THE
     INTERVAL [0, 1], MAY BE CALCULATED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "REAL" X, Y;
         "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X;
         F:= EXP(-X * 3) * ( X - 1) + X ** 3;
         X:= 0; Y:= 1;
         "IF" ZEROINRAT(X, Y, F(X), ABS(X) * "-14 + "-14) "THEN"
         OUTPUT(71, "("/4B,"("CALCULATED ZERO:")"B+.15D"+3D")", X)
         "ELSE" OUTPUT(71, "("/4B,"("NO ZERO FOUND")"")")
     "END"
 
     RESULT:
 
     CALCULATED ZERO: +.489702748548240"+000
 
 
 
 REFERENCES:
 
     [1]: BUS, J.C.P. AND  DEKKER, T.J.,
         TWO EFFICIENT ALGORITHMS WITH GUARANTEED CONVERGENCE FOR
         FINDING A ZERO OF A FUNCTION.
         MATHEMATICAL CENTRE, REPORT NW 13/74, AMSTERDAM (1974),
         (ALSO TO APPEAR IN TOMS 1975).
 
 
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE" 34150;
 "BOOLEAN" "PROCEDURE" ZEROIN(X, Y, FX, TOLX);
 "REAL" X, Y, FX, TOLX;
 "BEGIN" "INTEGER" EXT;
         "REAL" C, FC, B, FB, A, FA, D, FD, FDB, FDA, W, MB,
         TOL, M, P, Q, DW;
         DW:= DWARF; B:= X; FB:= FX; A:= X:= Y; FA:= FX;
     INTERPOLATE: C:= A; FC:= FA; EXT:= 0;
     EXTRAPOLATE: "IF" ABS(FC) < ABS(FB) "THEN"
         "BEGIN" "IF" C ^= A "THEN" "BEGIN" D:= A; FD:= FA "END";
             A:= B; FA:= FB; B:= X:= C; FB:= FC; C:= A; FC:= FA
         "END" INTERCHANGE;
         TOL:= TOLX; M:= (C + B) * 0.5; MB:= M - B;
         "IF" ABS(MB) > TOL "THEN"
         "BEGIN" "IF" EXT > 2 "THEN" W:= MB "ELSE"
             "BEGIN" TOL:= TOL * SIGN(MB);
                 P:= (B - A) * FB; "IF" EXT <= 1 "THEN"
                 Q:= FA - FB "ELSE"
                 "BEGIN" FDB:= (FD - FB) / (D - B);
                     FDA:= (FD - FA) / (D - A);
                     P:= FDA * P; Q:= FDB * FA - FDA * FB
                 "END"; "IF" P < 0 "THEN"
                 "BEGIN" P:= -P; Q:= -Q "END";
                 W:= "IF" P < DW "OR" P <= Q * TOL "THEN" TOL "ELSE"
                 "IF" P < MB * Q "THEN" P / Q "ELSE" MB
             "END"; D:= A; FD:= FA; A:= B; FA:= FB;
             X:= B:= B + W; FB:= FX;
             "IF" ("IF" FC >= 0 "THEN" FB >= 0 "ELSE" FB <= 0) "THEN"
             "GOTO" INTERPOLATE "ELSE"
             "BEGIN" EXT:= "IF" W = MB "THEN" 0 "ELSE" EXT + 1;
                 "GOTO" EXTRAPOLATE
             "END"
         "END"; Y:= C;
         ZEROIN:= "IF" FC >= 0 "THEN" FB <= 0 "ELSE" FB >= 0
 "END" ZEROIN
1SECTION : 5.1.1.1.1          (OCTOBER 1975)                      PAGE 7
 
 
                                                                   ;
         "EOP"
 "CODE" 34436;
 "BOOLEAN" "PROCEDURE" ZEROINRAT(X, Y, FX, TOLX);
 "REAL" X, Y, FX, TOLX;
 "BEGIN" "INTEGER" EXT; "BOOLEAN" FIRST;
         "REAL" B, FB, A, FA, D, FD, C, FC, FDB, FDA, W,
         MB, TOL, M, P, Q, DW;
         DW:= DWARF; B:= X; FB:= FX; A:= X:= Y; FA:= FX; FIRST:= "TRUE";
     INTERPOLATE: C:= A; FC:= FA; EXT:= 0;
     EXTRAPOLATE: "IF" ABS(FC) < ABS(FB) "THEN"
         "BEGIN" "IF" C ^= A "THEN" "BEGIN" D:= A; FD:= FA "END";
             A:= B; FA:= FB; B:= X:= C; FB:= FC; C:= A; FC:= FA
         "END" INTERCHANGE;
         TOL:= TOLX; M:= (C + B) * .5; MB:= M - B;
         "IF" ABS(MB) > TOL "THEN"
         "BEGIN" "IF" EXT > 3 "THEN" W:= MB "ELSE"
             "BEGIN" TOL:= TOL * SIGN(MB);
                 P:= (B - A) * FB; "IF" FIRST "THEN"
                 "BEGIN" Q:= FA - FB; FIRST:= "FALSE" "END" "ELSE"
                 "BEGIN" FDB:= (FD - FB) / (D - B);
                     FDA:= (FD - FA) / (D - A);
                     P:= FDA * P; Q:= FDB * FA - FDA * FB
                 "END"; "IF" P < 0 "THEN"
                 "BEGIN" P:= -P; Q:= -Q "END";
                 "IF" EXT = 3 "THEN" P:= P * 2;
                 W:= "IF" P < DW "OR" P <= Q * TOL "THEN" TOL "ELSE"
                 "IF" P < MB * Q "THEN" P / Q "ELSE" MB
             "END"; D:= A; FD:= FA; A:= B; FA:= FB;
             X:= B:= B + W; FB:= FX;
             "IF" ("IF" FC >= 0 "THEN" FB >= 0 "ELSE" FB <= 0) "THEN"
             "GOTO" INTERPOLATE "ELSE"
             "BEGIN" EXT:= "IF" W = MB "THEN" 0 "ELSE" EXT + 1;
                 "GOTO" EXTRAPOLATE
             "END"
         "END"; Y:= C;
         ZEROINRAT:= "IF" FC >= 0 "THEN" FB <= 0 "ELSE" FB >= 0
 "END" ZEROINRAT;
         "EOP"
1SECTION : 5.1.1.1.2          (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHOR: T.J. DEKKER.
 
 
 CONTRIBUTORS: T.J. DEKKER AND T.H.P. REYMER.
 
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED: 750615.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS ONE PROCEDURE FOR FINDING A ZERO OF A GIVEN
     DIFFERENTIABLE FUNCTION IN A GIVEN INTERVAL;
     ZEROINDER APPROXIMATES A ZERO MAINLY BY MEANS OF CONFLUENT 3-POINT
               RATIONAL INTERPOLATION USING NOT ONLY VALUES OF THE
               GIVEN FUNCTION BUT ALSO OF ITS DERIVATIVE.
     ZEROINDER IS TO PREFER TO ZEROIN OR ZEROINRAT (SECTION 5.1.1.1.1),
     IF THE DERIVATIVE IS (MUCH) CHEAPER TO EVALUATE THAN THE FUNCTION.
 
 
 KEYWORDS:
 
     ZERO SEARCHING,
     ANALYTIC EQUATIONS,
     SINGLE NONLINEAR EQUATION,
     DERIVATIVE AVAILABLE.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS:
     "BOOLEAN" "PROCEDURE" ZEROINDER(X, Y, FX, DFX, TOLX);
     "REAL" X, Y, FX, DFX, TOLX;
     "CODE" 34453;
 
     ZEROINDER SEARCHES FOR A ZERO OF A  DIFFERENTIABLE REAL FUNCTION  F
             DEFINED ON A CERTAIN INTERVAL J;
             ZEROINDER := "TRUE" WHEN A (SUFFICIENTLY SMALL) SUBINTERVAL
             OF J CONTAINING A  ZERO OF  F HAS  BEEN  FOUND;  OTHERWISE,
             ZEROINDER := "FALSE";
             LET DF AND T DENOTE  REAL FUNCTIONS  DEFINED ON J, WHERE DF
             IS THE DERIVATIVE OF F  AND T A TOLERANCE FUNCTION DEFINING
             THE  REQUIRED   PRECISION  OF  THE  ZERO;  ( FOR   INSTANCE
                           T(X) = ABS(X) * RE + AE,
             WHERE  RE  AND  AE  ARE THE REQUIRED  RELATIVE AND ABSOLUTE
             PRECISION RESPECTIVELY);
 
1SECTION : 5.1.1.1.2          (OCTOBER 1975)                      PAGE 2
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <REAL VARIABLE>;
             A JENSEN VARIABLE;  THE ACTUAL PARAMETERS FOR  FX, DFX  AND
             TOLX (MAY) DEPEND ON THE ACTUAL PARAMETER FOR X;
             ENTRY:  ONE  ENDPOINT OF INTERVAL  J  IN  WHICH  A  ZERO IS
                     SEARCHED FOR;
             EXIT:   A VALUE APPROXIMATING THE ZERO WITHIN THE TOLERANCE
                     2 * T(X) WHEN ZEROINDER HAS THE VALUE "TRUE", AND A
                     PRESUMABLY WORTHLESS ARGUMENT VALUE OTHERWISE;
     Y:      <REAL VARIABLE>;
             ENTRY:  THE OTHER ENDPOINT OF INTERVAL J IN WHICH A ZERO IS
                     SEARCHED FOR;  UPON ENTRY X < Y AS WELL AS Y < X IS
                     ALLOWED;
             EXIT:   THE  OTHER  STRADDLING  APPROXIMATION  OF THE ZERO,
                     I.E.  UPON  EXIT  THE  VALUES  OF  Y AND X  SATISFY
                     1. F(X) * F(Y) <= 0,  2. ABS(X - Y) <= 2 * T(X) AND
                     3. ABS(F(X)) <= ABS(F(Y))  WHEN  ZEROINDER  HAS THE
                     VALUE "TRUE", AND  A  PRESUMABLY WORTHLESS ARGUMENT
                     VALUE  SATISFYING  CONDITIONS  2  AND  3  BUT NOT 1
                     OTHERWISE;
     FX:     <ARITHMETIC EXPRESSION>;
             DEFINES  FUNCTION F AS A FUNCTION  DEPENDING ON THE  ACTUAL
             PARAMETER FOR X;
     DFX:    <ARITHMETIC EXPRESSION>;
             DEFINES THE  DERIVATIVE DF OF F AS A FUNCTION  DEPENDING ON
             THE ACTUAL PARAMETER FOR X;
     TOLX:   <ARITHMETIC EXPRESSION>;
             DEFINES THE  TOLERANCE  FUNCTION T WHICH MAY  DEPEND ON THE
             ACTUAL PARAMETER FOR X;
             ONE SHOULD CHOOSE TOLX  POSITIVE AND NEVER SMALLER THAN THE
             PRECISION OF THE  MACHINE'S  ARITHMETIC  AT X, I.E. IN THIS
             ARITHMETIC  X + TOLX  AND  X - TOLX   SHOULD  ALWAYS  YIELD
             VALUES  DISTINCT  FROM  X; OTHERWISE  THE PROCEDURE MAY GET
             INTO A LOOP.
 
 
 PROCEDURES USED: DWARF = CP30003;
 
 
 REQUIRED CENTRAL MEMORY: NO AUXILIARY ARRAYS ARE DECLARED IN ZEROINDER.
 
 
 RUNNING TIME: SEE METHOD AND PERFORMANCE.
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 5.1.1.1.2          (OCTOBER 1975)                      PAGE 3
 
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IS  CONFLUENT  3-POINT RATIONAL INTERPOLATION, I.E.
     THE INTERPOLATION FUNCTION OF THE FORM (X - A) / (BX + C) IS FITTED
     EXACTLY AT 3 POINTS  2 OF WHICH ARE  COINCIDING; MOREOVER, IN ORDER
     TO   IMPROVE  THE   GLOBAL   BEHAVIOUR  OF  THE   PROCESS,   LINEAR
     INTERPOLATION ON THE FUNCTION  F / DF  OR BISECTION ARE INCLUDED IN
     SOME STEPS;
     THE PERFORMANCE IS AS FOLLOWS:
     THE  NUMBER  OF  EVALUATIONS  OF  FX,  DFX  AND  TOLX  IS  AT  MOST
                        4 LOG(ABS(X - Y)) / TAU,
     WHERE X AND Y ARE THE ARGUMENT VALUES GIVEN UPON ENTRY, LOG DENOTES
     THE  BASE  2  LOGARITHM, AND  TAU IS THE  MINIMUM OF THE  TOLERANCE
     FUNCTION  ON  J (I.E. ZEROINDER REQUIRES AT MOST 4 TIMES THE NUMBER
     OF  STEPS  REQUIRED FOR  BISECTION); IF UPON ENTRY X AND Y  SATISFY
     F(X) * F(Y) <= 0, THEN CONVERGENCE TO A ZERO IS GUARANTEED, SO THAT
     UPON EXIT  X  AND  Y  SATISFY CONDITION 1 TO 3 MENTIONED ABOVE (SEE
     PARAMETER Y) AND ZEROINDER HAS THE VALUE "TRUE";
     FOR  A  SIMPLE  ZERO  OF  F, THE  ASYMPTOTIC  ORDER  OF CONVERGENCE
     APPROXIMATELY EQUALS 2.414.
 
 
 EXAMPLE OF USE:
 
     THE ZERO OF THE FUNCTION   EXP(-X * 3) * (X - 1) + X ** 3,  IN  THE
     INTERVAL [0, 1], MAY BE CALCULATED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "REAL" X, Y;
         "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X;
         F:= EXP(-X * 3) * ( X - 1) + X ** 3;
         "REAL" "PROCEDURE" DF(X); "VALUE" X; "REAL" X;
         DF:= EXP(-X * 3) * (-3 * X + 4) + 3 * X ** 2;
         X:= 0; Y:= 1;
         "IF" ZEROINDER(X, Y, F(X), DF(X), ABS(X) * "-14 + "-14) "THEN"
         OUTPUT(71, "("/4B,"("CALCULATED ZERO AND FUNCTION VALUE:")",
             /8B, 2(B+.15D"+3D4B), /4B,
             "("OTHER STRADDLING APPROXIMATION AND FUNCTION VALUE:")",
             /8B, 2(B+.15D"+3D4B)")", X, F(X), Y, F(Y))
         "ELSE" OUTPUT(71, "("/4B, "("NO ZERO FOUND")"")")
     "END"
 
     RESULT:
 
     CALCULATED ZERO AND FUNCTION VALUE:
          +.489702748548240"+000     -.444089209850060"-015
     OTHER STRADDLING APPROXIMATION AND FUNCTION VALUE:
          +.489702748548250"+000     +.177635683940030"-013
1SECTION : 5.1.1.1.2          (OCTOBER 1975)                      PAGE 4
 
 
 
 REFERENCES:
 
     [1]: BUS, J.C.P. AND  DEKKER, T.J.,
         TWO EFFICIENT ALGORITHMS WITH GUARANTEED CONVERGENCE FOR
         FINDING A ZERO OF A FUNCTION.
         MATHEMATICAL CENTRE, REPORT NW 13/74, AMSTERDAM (1974),
         (ALSO TO APPEAR IN TOMS 1975).
 
     [2]: OSTROWSKI, A.M.,
         SOLUTION OF EQUATIONS AND SYSTEMS OF EQUATIONS.
         ACADEMIC PRESS 1966. CHAPTERS 3 AND 11.
 
 
 
 SOURCE TEXT(S):
0"CODE" 34453;
     "BOOLEAN" "PROCEDURE" ZEROINDER(X, Y, FX, DFX, TOLX);
     "REAL" X, Y, FX, DFX, TOLX;
     "BEGIN" "INTEGER" EXT;
         "REAL" B, FB, DFB, A, FA, DFA, C, FC, DFC, D, W, MB,
         TOL, M, P, Q, DW;
         DW:= DWARF;
         B:= X; FB:= FX; DFB:= DFX; A:= X:= Y; FA:= FX; DFA:= DFX;
     INTERPOLATE: C:= A; FC:= FA; DFC:= DFA; EXT:= 0;
     EXTRAPOLATE: "IF" ABS(FC) < ABS(FB) "THEN"
         "BEGIN" A:= B; FA:= FB; DFA:= DFB; B:= X:= C; FB:= FC;
             DFB:= DFC; C:= A; FC:= FA; DFC:= DFA
         "END" INTERCHANGE;
         TOL:= TOLX; M:= (C + B) * 0.5; MB:= M - B;
         "IF" ABS(MB) > TOL "THEN"
         "BEGIN" "IF" EXT > 2 "THEN" W:= MB "ELSE"
             "BEGIN" TOL:= TOL * SIGN(MB);
                 D:= "IF" EXT = 2 "THEN" DFA "ELSE" (FB - FA) / (B - A);
                 P:= FB * D * (B - A);
                 Q:= FA * DFB - FB * D;
                 "IF" P < 0 "THEN" "BEGIN" P:= -P; Q:= -Q "END";
                 W:= "IF" P < DW "OR" P <= Q * TOL "THEN" TOL "ELSE"
                     "IF" P < MB * Q "THEN" P / Q "ELSE" MB;
             "END"; A:= B; FA:= FB; DFA:= DFB;
             X:= B:= B + W; FB:= FX; DFB:= DFX;
             "IF" ("IF" FC >= 0 "THEN" FB >= 0 "ELSE" FB <= 0) "THEN"
             "GOTO" INTERPOLATE "ELSE"
             "BEGIN" EXT:= "IF" W = MB "THEN" 0 "ELSE" EXT + 1;
                 "GOTO" EXTRAPOLATE
             "END"
         "END"; Y:= C;
         ZEROINDER:= "IF" FC >= 0 "THEN" FB <= 0 "ELSE" FB >= 0
     "END" ZEROINDER;
         "EOP"
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR: J.C.P.BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740218.
 
 
 BRIEF DESCRIPTION:
 
     THIS  SECTION  CONTAINS  TWO  PROCEDURES  FOR  SOLVING  SYSTEMS  OF
     NON-LINEAR EQUATIONS, OF WHICH THE JACOBIAN IS KNOWN TO BE A BAND
     MATRIX.
     QUANEWBND  ASKS FOR AN APPROXIMATION OF THE JACOBIAN AT THE INITIAL
     GUESS.
     QUANEWBND1  CALCULATES AN APPROXIMATION  OF THE JACOBIAN AT THE
     INITIAL GUESS, USING FORWARD DIFFERENCES.
 
 
 KEYWORDS:
 
     NON-LINEAR EQUATIONS,
     SYSTEMS OF EQUATIONS,
     NO EXPLICIT JACOBIAN.
 
 
 
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 2
 
 
 
 SUBSECTION: QUANEWBND.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS :
 
     "PROCEDURE" QUANEWBND(N, LW, RW, X, F, JAC, FUNCT, IN, OUT);
     "VALUE" N, LW, RW; "INTEGER" N, LW, RW;
     "ARRAY" X, F, JAC, IN, OUT; "BOOLEAN" "PROCEDURE" FUNCT;
     "CODE" 34430;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE  NUMBER  OF   INDEPENDENT  VARIABLES;   THE  NUMBER  OF
             EQUATIONS SHOULD ALSO BE EQUAL TO N;
     LW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS  TO THE LEFT OF THE MAIN DIAGONAL
             OF THE JACOBIAN;
     RW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS TO THE RIGHT OF THE MAIN DIAGONAL
             OF THE JACOBIAN;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1:N];
             ENTRY:  AN INITIAL ESTIMATE  OF THE SOLUTION  OF THE SYSTEM
                     THAT HAS TO BE SOLVED;
             EXIT:   THE CALCULATED SOLUTION OF THE SYSTEM;
     F:      <ARRAY IDENTIFIER>;
             "ARRAY" F[1:N];
             ENTRY:  THE  VALUES  OF  THE  FUNCTION  COMPONENTS  AT  THE
                     INITIAL GUESS;
             EXIT:   THE  VALUES  OF  THE  FUNCTION  COMPONENTS  AT  THE
                     CALCULATED SOLUTION;
     JAC:    <ARRAY IDENTIFIER>;
             "ARRAY" JAC[1:(LW + RW) * (N - 1) + N];
             ENTRY:  AN APPROXIMATION  OF  THE JACOBIAN  AT  THE INITIAL
                     ESTIMATE OF THE SOLUTION;
             EXIT:   AN APPROXIMATION OF THE JACOBIAN  AT THE CALCULATED
                     SOLUTION;
             AN APPROXIMATION OF THE (I, J)-TH  ELEMENT  OF THE JACOBIAN
             IS GIVEN IN JAC[(LW + RW) * (I - 1) + J], FOR I = 1, ..., N
             AND J = MAX(1, I - LW), ..., MIN(N, I + RW);
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 3
 
 
 
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS :
             "BOOLEAN" "PROCEDURE" FUNCT(N, L, U, X, F);
             "VALUE" N, L, U; "INTEGER" N, L, U; "ARRAY" X, F;
             THE MEANING OF THE FORMAL PARAMETERS IS :
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF INDEPENDENT VARIABLES OF THE FUNCTION  F;
             L, U: <ARITHMETIC EXPRESSION>;
                 LOWER  AND  UPPER  BOUND   OF  THE  FUNCTION  COMPONENT
                 SUBSCRIPT;
             X:  <ARRAY IDENTIFIER>;
                 THE INDEPENDENT VARIABLES ARE GIVEN IN X[1:N];
             F:  <ARRAY IDENTIFIER>;
                 AFTER  A CALL OF  FUNCT  THE FUNCTION COMPONENTS  F[I],
                 I = L, ..., U, SHOULD BE GIVEN IN F[L:U];
             IF  THE VALUE  OF  THE PROCEDURE IDENTIFIER  EQUALS  FALSE,
             THEN THE EXECUTION OF  QUANEWBND  WILL BE TERMINATED, WHILE
             THE VALUE OF OUT[5] IS SET EQUAL TO 2;
     IN:     <ARRAY IDENTIFIER>;
             "ARRAY" IN[0:4];
             ENTRY :
             IN  THIS  AUXILIARY  ARRAY  ONE  SHOULD  GIVE THE FOLLOWING
             VALUES FOR CONTROLLING THE PROCESS:
             IN[0]:  THE MACHINE PRECISION;
             IN[1]:  THE RELATIVE PRECISION ASKED FOR;
             IN[2]:  THE ABSOLUTE PRECISION  ASKED FOR;  IF  THE  VALUE,
                     DELIVERED IN  OUT[5]  EQUALS ZERO,  THEN  THE  LAST
                     CORRECTION VECTOR  D, SAY,  WHICH  IS A MEASURE FOR
                     THE ERROR IN THE SOLUTION,  SATIFIES THE INEQUALITY
                     NORM(D) <= NORM(X) * IN[1] + IN[2],
                     WHEREBY X DENOTES THE CALCULATED SOLUTION, GIVEN IN
                     ARRAY  X  AND  NORM(.)  DENOTES THE EUCLIDIAN NORM;
                     HOWEVER,WE CAN NOT GUARANTEE THAT THE TRUE ERROR IN
                     THE SOLUTION SATISFIES THIS INEQUALITY,  ESPECIALLY
                     IF  THE  JACOBIAN  IS  (NEARLY)  SINGULAR   AT  THE
                     SOLUTION;
             IN[3]:  THE  MAXIMUM  VALUE  OF  THE NORM  OF  THE RESIDUAL
                     VECTOR ALLOWED; IF  OUT[5] = 0,  THEN THIS RESIDUAL
                     VECTOR F, SAY, SATIFIES: NORM(F) <= IN[3];
             IN[4]:  THE   MAXIMUM   NUMBER    OF   FUNCTION   COMPONENT
                     EVALUATIONS ALLOWED;  L - U + 1  FUNCTION COMPONENT
                     EVALUATIONS    ARE    COUNTED    EACH    CALL    OF
                     FUNCT(N, L, U, X, F); IF OUT[5]=1, THEN THE PROCESS
                     IS TERMINATED,  BECAUSE  THE NUMBER  OF EVALUATIONS
                     EXCEEDED THE VALUE GIVEN IN IN[4];
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 4
 
 
 
     OUT:    <ARRAY IDENTIFIER>;
             "ARRAY" OUT[1:5];
             EXIT :
             OUT[1]: THE EUCLIDIAN NORM OF THE LAST STEP ACCEPTED;
             OUT[2]: THE EUCLIDIAN NORM  OF  THE RESIDUAL VECTOR  AT THE
                     CALCULATED SOLUTION;
             OUT[3]: THE  NUMBER   OF   FUNCTION  COMPONENT  EVALUATIONS
                     PERFORMED;
             OUT[4]: THE NUMBER OF ITERATIONS CARRIED OUT;
             OUT[5]: THE INTEGER VALUE DELIVERED IN  OUT[5]  GIVES  SOME
                     INFORMATION  ABOUT THE TERMINATION  OF THE PROCESS;
                     OUT[5] = 0: THE PROCESS  IS TERMINATED  IN A NORMAL
                                 WAY; THE LAST STEP AND  THE NORM OF THE
                                 RESIDUAL VECTOR SATISFY  THE CONDITIONS
                                 (SEE IN[2], IN[3]);
                     IF  OUT[5] ^= 0,  THEN  THE PROCESS  IS  TERMINATED
                     PREMATURALY;
                     OUT[5] = 1: THE   NUMBER   OF   FUNCTION  COMPONENT
                                 EVALUATIONS  EXCEEDS THE VALUE GIVEN IN
                                 IN[4];
                     OUT[5] = 2: A CALL OF  FUNCT  DELIVERED  THE  VALUE
                                 FALSE;
                     OUT[5] = 3: THE  APPROXIMATION   OF   THE  JACOBIAN
                                 MATRIX TURNS OUT TO BE SINGULAR.
 
 
 PROCEDURES USED:
 
     MULVEC      = CP31020,
     DUPVEC      = CP31030,
     VECVEC      = CP34010,
     ELMVEC      = CP34020,
     DECSOLBND   = CP34322.
 
 
 EXECUTION FIELD LENGTH:
 
     THE MAXIMUM NUMBER OF WORDS, NECESSARY  FOR THE ARRAYS  DECLARED IN
     QUANEWBND EQUALS  MAX(N * 3 + (N - 1) * (LW + RW), 4N).
 
 
 RUNNING TIME: PROPORTIONAL TO  N * LW * ( LW + RW + 1).
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 5
 
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN QUANEWBND IS THE SAME AS GIVEN IN [1];  THE SAME
     PROBLEMS HAVE BEEN TESTED AND THE RESULTS ARE  THE SAME  OR  BETTER
     THAN THOSE REPORTED IN  [1];  CITING  [1],  WE CAN SAY  THAT  "THIS
     METHOD OFFERS A USEFUL IF MODEST IMPROVEMENT UPON  NEWTON'S METHOD,
     BUT THIS IMPROVEMENT TENDS TO VANISH  AS THE NONLINEARITIES  BECOME
     MORE PRONOUNCED".
 
 
 EXAMPLE OF USE: SEE QUANEWBND1 (THIS SECTION).
 
 
 REFERENCES:
 
     [1] BROYDEN C.G.
         THE CONVERGENCE  OF  AN ALGORITHM  FOR SOLVING SPARSE NONLINEAR
         SYSTEMS.
         MATH. COMP., VOL.25 (1971).
 
 
 
 SUBSECTION: QUANEWBND1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE READS :
 
     "PROCEDURE" QUANEWBND1(N, LW, RW, X, F, FUNCT, IN, OUT);
     "VALUE" N, LW, RW; "INTEGER" N, LW, RW;
     "ARRAY" X, F, IN, OUT; "BOOLEAN" "PROCEDURE" FUNCT;
     "CODE" 34431;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE  NUMBER  OF   INDEPENDENT  VARIABLES;   THE  NUMBER  OF
             EQUATIONS SHOULD ALSO BE EQUAL TO N;
     LW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS  TO THE LEFT OF THE MAIN DIAGONAL
             OF THE JACOBIAN;
     RW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF CODIAGONALS TO THE RIGHT OF THE MAIN DIAGONAL
             OF THE JACOBIAN;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1:N];
             ENTRY:  AN INITIAL ESTIMATE  OF THE SOLUTION  OF THE SYSTEM
                     THAT HAS TO BE SOLVED;
             EXIT:   THE CALCULATED SOLUTION OF THE SYSTEM;
     F:      <ARRAY IDENTIFIER>;
             "ARRAY" F[1:N];
             EXIT:   THE  VALUES  OF  THE  FUNCTION  COMPONENTS  AT  THE
                     CALCULATED SOLUTION;
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 6
 
 
 
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS :
             "BOOLEAN" "PROCEDURE" FUNCT(N, L, U, X, F);
             "VALUE" N, L, U; "INTEGER" N, L, U; "ARRAY" X, F;
             THE MEANING OF THE FORMAL PARAMETERS IS :
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF INDEPENDENT VARIABLES OF THE FUNCTION  F;
             L, U: <ARITHMETIC EXPRESSION>;
                 LOWER  AND  UPPER  BOUND   OF  THE  FUNCTION  COMPONENT
                 SUBSCRIPT;
             X:  <ARRAY IDENTIFIER>;
                 THE INDEPENDENT VARIABLES ARE GIVEN IN X[1:N];
             F:  <ARRAY IDENTIFIER>;
                 AFTER  A CALL OF  FUNCT  THE FUNCTION COMPONENTS  F[I],
                 I = L, ..., U, SHOULD BE GIVEN IN F[L:U];
             IF  THE VALUE  OF  THE PROCEDURE IDENTIFIER  EQUALS  FALSE,
             THEN THE EXECUTION OF  QUANEWBND  WILL BE TERMINATED, WHILE
             THE VALUE OF OUT[5] IS SET EQUAL TO 2;
     IN:     <ARRAY IDENTIFIER>;
             "ARRAY" IN[0:4];
             ENTRY :
             IN  THIS  AUXILIARY  ARRAY  ONE  SHOULD  GIVE THE FOLLOWING
             VALUES FOR CONTROLLING THE PROCESS:
             IN[0]:  THE MACHINE PRECISION;
             IN[1]:  THE RELATIVE PRECISION ASKED FOR;
             IN[2]:  THE ABSOLUTE PRECISION  ASKED FOR;  IF  THE  VALUE,
                     DELIVERED IN  OUT[5]  EQUALS ZERO,  THEN  THE  LAST
                     CORRECTION VECTOR  D, SAY,  WHICH  IS A MEASURE FOR
                     THE ERROR IN THE SOLUTION,  SATIFIES THE INEQUALITY
                     NORM(D) <= NORM(X) * IN[1] + IN[2],
                     WHEREBY X DENOTES THE CALCULATED SOLUTION, GIVEN IN
                     ARRAY  X  AND  NORM(.)  DENOTES THE EUCLIDIAN NORM;
                     HOWEVER,WE CAN NOT GUARANTEE THAT THE TRUE ERROR IN
                     THE SOLUTION SATISFIES THIS INEQUALITY,  ESPECIALLY
                     IF  THE  JACOBIAN  IS  (NEARLY)  SINGULAR   AT  THE
                     SOLUTION;
             IN[3]:  THE  MAXIMUM  VALUE  OF  THE NORM  OF  THE RESIDUAL
                     VECTOR ALLOWED; IF  OUT[5] = 0,  THEN THIS RESIDUAL
                     VECTOR F, SAY, SATIFIES: NORM(F) <= IN[3];
             IN[4]:  THE   MAXIMUM   NUMBER    OF   FUNCTION   COMPONENT
                     EVALUATIONS ALLOWED;  L - U + 1  FUNCTION COMPONENT
                     EVALUATIONS    ARE    COUNTED    EACH    CALL    OF
                     FUNCT(N, L, U, X, F); IF OUT[5]=1, THEN THE PROCESS
                     IS TERMINATED,  BECAUSE  THE NUMBER  OF EVALUATIONS
                     EXCEEDED THE VALUE GIVEN IN IN[4];
             IN[5]:  THE  JACOBIAN  MATRIX  AT  THE  INITIAL  GUESS   IS
                     APPROXIMATED  USING  FORWARD DIFFERENCES,  WITH  AN
                     FIXED INCREMENT TO EACH VARIABLE  THAT  EQUALS  THE
                     VALUE GIVEN IN IN[5];
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 7
 
 
 
     OUT:    <ARRAY IDENTIFIER>;
             "ARRAY" OUT[1:5];
             EXIT :
             OUT[1]: THE EUCLIDIAN NORM OF THE LAST STEP ACCEPTED;
             OUT[2]: THE EUCLIDIAN NORM  OF  THE RESIDUAL VECTOR  AT THE
                     CALCULATED SOLUTION;
             OUT[3]: THE  NUMBER   OF   FUNCTION  COMPONENT  EVALUATIONS
                     PERFORMED;
             OUT[4]: THE NUMBER OF ITERATIONS CARRIED OUT;
             OUT[5]: THE INTEGER VALUE DELIVERED IN  OUT[5]  GIVES  SOME
                     INFORMATION  ABOUT THE TERMINATION  OF THE PROCESS;
                     OUT[5] = 0: THE PROCESS  IS TERMINATED  IN A NORMAL
                                 WAY; THE LAST STEP AND  THE NORM OF THE
                                 RESIDUAL VECTOR SATISFY  THE CONDITIONS
                                 (SEE IN[2], IN[3]);
                     IF  OUT[5] ^= 0,  THEN  THE PROCESS  IS  TERMINATED
                     PREMATURALY;
                     OUT[5] = 1: THE   NUMBER   OF   FUNCTION  COMPONENT
                                 EVALUATIONS  EXCEEDS THE VALUE GIVEN IN
                                 IN[4];
                     OUT[5] = 2: A CALL OF  FUNCT  DELIVERED  THE  VALUE
                                 FALSE;
                     OUT[5] = 3: THE  APPROXIMATION   OF   THE  JACOBIAN
                                 MATRIX TURNS OUT TO BE SINGULAR.
 
 
 PROCEDURES USED:
 
     JACOBNBNDF  = CP34439,
     QUANEWBND   = CP34430.
 
 
 EXECUTION FIELD LENGTH:
 
     QUANEWBND1  DECLARES AN AUXILIARY ARRAY OF DIMENSION ONE  AND ORDER
     N + (N - 1) * (LW + RW).
 
 
 RUNNING TIME: PROPORTIONAL TO  N * LW * ( LW + RW + 1).
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     QUANEWBND1  USES  JACOBNBNDF  (SECTION  4.3.2.1)  TO  CALCULATE  AN
     INITIAL APPROXIMATION OF THE JACOBIAN MATRIX   AT THE INITIAL GUESS
     GIVEN  IN  X[1:N]  AND  SOLVES  THE  NONLINEAR  SYSTEM  BY  CALLING
     QUANEWBND (THIS SECTION).
 
 
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 8
 
 
 
 EXAMPLE OF USE:
 
     LET THE FUNCTION F BE DEFINED BY (SEE [1]):
     F[1] = (3 - 2 * X[1]) * X[1] + 1 - 2 * X[2],
     F[I] = (3 - 2 * X[I]) * X[I] + 1 - X[I - 1] - 2 * X[I + 1],  I = 2,
     ..., N - 1,
     F[N] = (3 - 2 * X[N]) * X[N] + 1 - X[N - 1];
     LET AN INITIAL ESTIMATE OF THE SOLUTION OF THE SYSTEM  F(X) = 0  BE
     GIVEN BY X[I] = -1, I = 1, ..., N;  THEN THE FOLLOWING PROGRAM  MAY
     SOLVE THIS SYSTEM FOR N = 600 AND PRINTS SOME RESULTS.
 
     "BEGIN"
         "BOOLEAN" "PROCEDURE" FUN(N, L, U, X, F); "VALUE" N, L, U;
         "INTEGER" N, L, U; "ARRAY" X, F;
         "BEGIN" "INTEGER" I; "REAL" X1, X2, X3;
             X1:= "IF" L = 1 "THEN" 0 "ELSE" X[L - 1]; X2:= X[L];
             X3:= "IF" L = N "THEN" 0 "ELSE" X[L + 1];
             "FOR" I:= L "STEP" 1 "UNTIL" U "DO"
             "BEGIN" F[I]:= (3 - 2 * X2) * X2 + 1 - X1 - X3 * 2;
                 X1:= X2; X2:= X3;
                 X3:= "IF" I <= N - 2 "THEN" X[I + 2] "ELSE" 0
             "END"; FUN:= "TRUE"
         "END" FUN;
 
         "INTEGER" I; "ARRAY" X, F[1:600], IN[0:5], OUT[1:5];
         "FOR" I := 1 "STEP" 1 "UNTIL" 600 "DO" X[I]:= -1;
         IN[0]:= "-14; IN[1]:= IN[2]:= IN[3]:= "-6; IN[4]:= 20000;
         IN[5]:= 0.001;
         QUANEWBND1(600, 1, 1, X, F, FUN, IN, OUT);
         OUTPUT(71, "("//,"(" NORM RESIDUALVECTOR: ")"+.15D"+3D,/,
         "(" LENGTH OF LAST STEP: ")"+.15D"+3D,/,
         "(" NUMBER OF FUNCTION COMPONENT EVALUATIONS: ")"5ZD,/,
         "(" NUMBER OF ITERATIONS: ")"4ZD/,"("REPORT: ")"D/")",
         OUT[2], OUT[1], OUT[3], OUT[4], OUT[5])
     "END"
 
     RESULTS:
 
     NORM RESIDUALVECTOR: +.221010684482660"-006
     LENGTH OF LAST STEP: +.302712457332660"-006
     NUMBER OF FUNCTION COMPONENT EVALUATIONS:   6598
     NUMBER OF ITERATIONS:     7
     REPORT: 0
 
 
 REFERENCES:
 
     [1] BROYDEN C.G.
         THE CONVERGENCE  OF  AN ALGORITHM  FOR SOLVING SPARSE NONLINEAR
         SYSTEMS.
         MATH. COMP., VOL.25 (1971).
 
 
 
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                      PAGE 9
 
 
 
 SOURCE TEXT(S):
0"CODE" 34430;
     "PROCEDURE" QUANEWBND(N, LW, RW, X, F, JAC, FUNCT, IN, OUT);
     "VALUE" N, LW, RW; "INTEGER" N, LW, RW;
     "ARRAY" X, F, JAC, IN, OUT; "BOOLEAN" "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" L, IT, FCNT, FMAX, ERR, B;
         "REAL" MACHEPS, RELTOL, ABSTOL, TOLRES, ND, MZ, RES;
         "ARRAY" DELTA[1:N];
 
 
         "REAL" "PROCEDURE" EVALUATE(N, X, F); "VALUE" N;
         "INTEGER" N; "ARRAY" X, F;
         "BEGIN" FCNT:= FCNT + N; "IF" ^ FUNCT(N, 1, N, X, F) "THEN"
             "BEGIN" ERR:= 2; "GOTO" EXIT "END";
             "IF" FCNT > FMAX "THEN" ERR:= 1;
             EVALUATE:= SQRT(VECVEC(1, N, 0, F, F))
         "END" EVAL;
 
         "BOOLEAN" "PROCEDURE" DIRECTION;
         "BEGIN" "ARRAY" LU[1:L], AUX[1:5]; AUX[2]:= MACHEPS;
             MULVEC(1, N, 0, DELTA, F, -1); DUPVEC(1, L, 0, LU, JAC);
             DECSOLBND(LU, N, LW, RW, AUX, DELTA);
             DIRECTION:= AUX[3] = N
         "END" SOLLINSYS;
 
         "BOOLEAN" "PROCEDURE" TEST(ND, TOLD, NRES, TOLRES, ERR);
         "VALUE" ND, TOLD; "INTEGER" ERR; "REAL" ND, TOLD, NRES, TOLRES;
         TEST:= ERR ^= 0 "OR" (NRES < TOLRES "AND" ND < TOLD);
 
         "PROCEDURE" UPDATE JAC;
         "BEGIN" "INTEGER"  I, J, K, R, M; "REAL" MUL, CRIT;
             "ARRAY" PP, S[1:N];
             CRIT:= ND * MZ;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" PP[I]:= DELTA[I] ** 2;
             R:= 1; K:= 1; M:= RW + 1;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" MUL:= 0; "FOR" J:= R "STEP" 1 "UNTIL" M "DO"
                 MUL:= MUL + PP[J]; J:= R - K;
                 "IF" ABS(MUL) > CRIT "THEN"
                 ELMVEC(K, M - J, J, JAC, DELTA, F[I] / MUL); K:= K + B;
                 "IF" I > LW "THEN" R:= R + 1 "ELSE" K:= K - 1;
                 "IF" M < N "THEN" M:= M + 1
             "END"
         "END" UPDATEJAC
1SECTION : 5.1.1.2.2          (OCTOBER 1974)                     PAGE 10
 
 
 
                                                                  ;
         MACHEPS:= IN[0]; RELTOL:= IN[1]; ABSTOL:= IN[2];
         TOLRES:= IN[3]; FMAX:= IN[4]; MZ:= MACHEPS ** 2;
         IT:= FCNT:= 0; B:= LW + RW; L:= (N - 1) * B + N; B:= B + 1;
         RES:= SQRT(VECVEC(1, N, 0, F, F)); ERR:= 0;
     ITERATE: "IF" ^ TEST(SQRT(ND), SQRT(VECVEC(1, N, 0, X, X)) * RELTOL
         + ABSTOL, RES, TOLRES, ERR) "THEN"
         "BEGIN" IT:= IT + 1; "IF" IT ^= 1 "THEN" UPDATEJAC;
             "IF" ^ DIRECTION "THEN" ERR:= 3 "ELSE"
             "BEGIN" ELMVEC(1, N, 0, X, DELTA, 1);
                 ND:= VECVEC(1, N, 0, DELTA, DELTA);
                 RES:= EVALUATE(N, X, F); "GOTO" ITERATE
              "END"
         "END";
     EXIT: OUT[1]:= SQRT(ND); OUT[2]:=RES; OUT[3]:= FCNT;
         OUT[4]:= IT; OUT[5]:= ERR
     "END" QUANEWBND;
         "EOP"
 
 "CODE" 34431;
     "PROCEDURE" QUANEWBND1(N, LW, RW, X, F, FUNCT, IN, OUT);
     "VALUE" N, LW, RW; "INTEGER" N, LW, RW; "ARRAY" X, F, IN, OUT;
     "BOOLEAN" "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" I, K; "REAL" S;
         "ARRAY" JAC[1:(LW + RW) * (N - 1) + N];
         FUNCT(N, 1, N, X, F); S:= IN[5];
         K:= (LW + RW)*(N - 1) + N*2 - ((LW - 1)*LW + (RW - 1)*RW) // 2;
         IN[4]:= IN[4] - K;
         JACOBNBNDF(N, LW, RW, X, F, JAC, I, S, FUNCT);
         QUANEWBND(N, LW, RW, X, F, JAC, FUNCT, IN, OUT);
         IN[4]:= IN[4] + K; OUT[3]:= OUT[3] + K
     "END" QUANEWBND1;
         "EOP"
1SECTION : 5.1.2.1.1         ( DECEMBER 1978 )                    PAGE 1
 
 
 
 AUTHOR : J. C. P. BUS
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED : 741101.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURE MININ, FOR MINIMIZING
     A FUNCTION OF ONE VARIABLE IN A GIVEN INTERVAL;
 
 
 KEYWORDS :
 
     MINIMIZATION,
     FUNCTIONS OF ONE VARIABLE.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THIS PROCEDURE IS :
     "REAL" "PROCEDURE" MININ(X, A, B, FX, TOLX);
     "REAL" X, A, B, FX, TOLX;
     "CODE" 34433;
 
     MININ   DELIVERS THE CALCULATED MINIMUM VALUE OF THE FUNCTION,
             DEFINED BY FX, ON THE INTERVAL WITH ENDPOINTS A AND B.
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     X :     <REAL VARIABLE>;
             A JENSEN VARIABLE; THE ACTUAL PARAMETERS FOR FX AND TOLX
             DEPEND ON X;
             EXIT : THE CALCULATED APPROXIMATION OF THE POSITION OF THE
                    MINIMUM;
     A, B :  <REAL VARIABLE>;
             ENTRY :  THE ENDPOINTS OF THE INTERVAL ON WHICH A MINIMUM
                      IS SEARCHED FOR;
            EXIT :   THE ENDPOINTS OF THE INTERVAL WITH LENGTH LESS THAN
                      4 * TOL(X)  SUCH THAT  A < X < B;
     FX :    <ARITHMATIC EXPRESSION>;
             THE FUNCTION ISGIVEN BY THE ACTUAL PARAMETER FX, WHICH
             DEPENDS ON X;
     TOLX :  <ARITHMETIC EXPRESSION>;
          THE TOLERANCE IS GIVEN BY THE ACTUAL PARAMETER TOLX, WHICH MAY
        DEPEND ON X; A SUITABLE TOLERANCE FUNCTION IS : ABS(X)*RE + AE,
        WHERE RE IS THE RELATIVE PRECISION DESIRED AND AE IS AN ABSOLUTE
             PRECISION WHICH SHOULD NOT BE CHOSEN EQUAL TO ZERO.
1SECTION : 5.1.2.1.1         ( DECEMBER 1978 )                    PAGE 2
 
 
 
 DATA AND RESULTS :
     THE USER SHOULD BE AWARE OF THE FACT THAT THE CHOICE OF TOLX MAY
     HIGHLY AFFECT THE BEHAVIOUR OF THE ALGORITHM, ALTHOUGH CONVERGENCE
     TO A POINT FOR WHICH THE GIVEN FUNCTION IS MINIMAL ON  THE INTERVAL
    IS ASSURED; THE ASYMPTOTIC BEHAVIOUR WILL USUALLY BE FINE AS LONG AS
     THE NUMERICAL FUNCTION IS STRICTLY DELTA-UNIMODAL ON THE GIVEN
 INTERVAL (SEE [1]) AND THE TOLERANCE FUNCTION SATISFIES TOL(X)>=DELTA,
     FOR ALL X IN THE  GIVEN INTERVAL.
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY : NO AUXILIARY ARRAYS ARE DECLARED IN MININ.
 
 
 METHOD AND PERFORMANCE :
     MININ IS A SLIGHTLY MODIFIED VERSION OF THE ALGORITHM GIVEN IN [1].
 
 
 EXAMPLE OF USE:
 
    THE FOLLOWING PROGRAM MAY BE USED TO CALCULATE THE MINIMUM OF THE
    FUNCTION F(X) = SUM(((I * 2 - 5)/(X - I ** 2)) ** 2; I = 1 (1) 20)
    ON THE INTERVAL [1 + TOL, 4 - TOL] (SEE [1]).
 
    "BEGIN"
        "REAL" M, X, A, B; "INTEGER" CNT;
        "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X;
        "BEGIN" "INTEGER" I; "REAL" S;
            S:= 0; "FOR" I:= 1 "STEP" 1 "UNTIL" 20 "DO"
            S:= S + ((I * 2 - 5) / (X - I ** 2)) ** 2;
            CNT:= CNT + 1; F:= S
        "END" F;
        "REAL" "PROCEDURE" TOL(X); "VALUE" X; "REAL" X;
        TOL:= ABS(X) * "-7 + "-7;
        A:= 1 + TOL(1); B:= 4 - TOL(4); CNT:= 0;
        M:= MININ(X, A, B, F(X), TOL(X));
        OUTPUT(61, "("4B,"("MINIMUM IS ")",N,/4B,
        "("FOR X IS ")",N,/4B,
        "("IN THE INTERVAL WITH ENDPOINTS ")",/8B,2(N),/4B,
        "("THE NUMBER OF FUNCTION EVALUATIONS NEEDED IS ")",2ZD,/")",
        M, X, A, B, CNT)
    "END"
1SECTION : 5.1.2.1.1         ( DECEMBER 1978 )                    PAGE 3
 
 
 
    RESULTS :
 
    MINIMUM IS +3.6766990169019"+000
    FOR X IS +3.0229153387991"+000
    IN THE INTERVAL WITH ENDPOINTS
        +3.0229149365075"+000  +3.0229157410906"+000
    THE NUMBER OF FUNCTION EVALUATIONS NEEDED IS  13
 
 
 SOURCE TEXT:
0"CODE" 34433;
    "REAL" "PROCEDURE" MININ(X, A, B, FX, TOLX);
    "REAL" X, A, B, FX, TOLX;
    "BEGIN" "COMMENT" SEE BRENT, 1973, P79;
        "REAL" Z, C, D, E, M, P, Q, R, TOL, T, U, V, W, FU, FV, FW, FZ;
        C:= (3 - SQRT(5)) / 2; "IF" A > B "THEN"
        "BEGIN" Z:= A; A:= B; B:= Z "END";
        W:= X:= A; FW:= FX; Z:= X:= B; FZ:= FX; "IF" FZ > FW "THEN"
        "BEGIN" Z:= W; W:= X; V:= FZ; FZ:= FW; FW:= V "END";
        V:= W; FV:= FW; E:= 0;
    LOOP: M:= (A + B) * 0.5; TOL:= TOLX; T:= TOL * 2;
        "IF" ABS(Z - M) > T - (B - A) * 0.5 "THEN"
        "BEGIN" P:= Q:= R:= 0; "IF" ABS(E) > TOL "THEN"
            "BEGIN" R:= (Z - W) * (FZ - FV);
                Q:= (Z - V) * (FZ - FW); P:= (Z - V) * Q - (Z - W) * R;
                Q:= (Q - R) * 2; "IF" Q>0 "THEN" P:= -P "ELSE" Q:= -Q;
                R:= E; E:= D
            "END";
            "IF" ABS(P) < ABS(Q * R * 0.5) "AND" P > (A - Z) * Q
            "AND" P < (B - Z) * Q "THEN"
            "BEGIN" D:= P / Q; U:= Z + D;
                "IF" U - A < T "OR" B - U < T "THEN"
                D:= "IF" Z < M "THEN" TOL "ELSE" -TOL
            "END" "ELSE"
            "BEGIN" E:= ("IF" Z < M "THEN" B "ELSE" A) - Z; D:= C * E
            "END";
            U:= X:= Z + ("IF" ABS(D) >= TOL "THEN" D "ELSE" "IF" D > 0
            "THEN" TOL "ELSE" -TOL); FU:= FX;
            "IF" FU <= FZ "THEN"
            "BEGIN" "IF" U < Z "THEN" B:= Z "ELSE" A:= Z;
                V:= W; FV:= FW; W:= Z; FW:= FZ; Z:= U; FZ:= FU
            "END" "ELSE"
            "BEGIN" "IF" U < Z "THEN" A:= U "ELSE" B:= U;
                "IF" FU <= FW "THEN"
                "BEGIN" V:= W; FV:= FW; W:= U; FW:= FU "END" "ELSE"
                "IF" FU <= FV "OR" V = W "THEN"
                "BEGIN" V:= U; FV:= FU "END"
            "END"; "GOTO" LOOP
        "END"; X:= Z; MININ:= FZ
    "END" MININ;
         "EOP"
1SECTION : 5.1.2.1.2          (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 741101.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION  CONTAINS  THE PROCEDURE  MININDER,  FOR  MINIMIZING A
     FUNCTION OF ONE VARIABLE IN A GIVEN INTERVAL,  WHEN  THE ANALYTICAL
     DERIVATIVE OF THE FUNCTION IS AVAILABLE.
 
 
 KEYWORDS :
     MINIMIZATION,
     FUNCTIONS OF ONE VARIABLE.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "REAL" "PROCEDURE" MININDER(X, Y, FX, DFX, TOLX);
     "REAL" X, Y, FX, DFX, TOLX;
     "CODE" 34435;
 
     MININDER DELIVERS  THE CALCULATED  MINIMUM VALUE  OF  THE FUNCTION,
             DEFINED BY FX, ON THE INTERVAL WITH END POINTS A AND B.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <REAL VARIABLE>;
             A JENSEN VARIABLE; THE ACTUAL PARAMETERS FOR FX, DFX AND
             TOLX DEPEND ON X;
             ENTRY:  ONE OF THE END POINTS OF THE INTERVAL ON WHICH THE
                     FUNCTION HAS TO BE MINIMIZED;
             EXIT:   THE CALCULATED APPROXIMATION OF THE POSITION OF THE
                     MINIMUM;
     Y:      <REAL VARIABLE>;
             ENTRY:  THE OTHER END POINT OF THE INTERVAL ON WHICH THE
                     FUNCTION HAS TO BE MINIMIZED;
             EXIT:   A VALUE SUCH THAT ABS(X - Y) <= TOL(X) * 3;
     FX:     <ARITHMETIC EXPRESSION>;
             THE FUNCTION IS GIVEN BY THE ACTUAL PARAMETER FX WHICH
             DEPENDS ON X;
     DFX:    <ARITHMETIC EXPRESSION>;
             THE DERIVATIVE OF THE FUNCTION IS GIVEN BY THE ACTUAL
             PARAMETER DFX WHICH DEPENDS ON X; FX AND DFX ARE  EVALUATED
             SUCCESSIVELY FOR A CERTAIN VALUE OF X;
     TOLX:   <ARITHMETIC EXPRESSION>;
             THE TOLERANCE IS GIVEN BY THE ACTUAL PARAMETER TOLX,  WHICH
             MAY  DEPEND   ON  X;  A  SUITABLE  TOLERANCE  FUNCTION  IS:
             ABS(X) * RE + AE,   WHERE  RE  IS  THE  RELATIVE  PRECISION
             DESIRED AND  AE  IS AN ABSOLUTE PRECISION  WHICH SHOULD NOT
             BE CHOSEN EQUAL TO ZERO.
 
 
1SECTION : 5.1.2.1.2          (OCTOBER 1975)                      PAGE 2
 
 
 
 DATA AND RESULTS:
 
     THE  USER  SHOULD  BE  AWARE OF THE FACT  THAT THE  CHOICE OF  TOLX
     MAY  HIGHLY   AFFECT  THE  BEHAVIOUR  OF  THE  ALGORITHM,  ALTHOUGH
     CONVERGENCE  TO  A  POINT  FOR  WHICH  THE  GIVEN  FUNCTION  IS
     MINIMAL ON THE  GIVEN  INTERVAL  IS  ASSURED;  THE  ASYMPTOTIC
     BEHAVIOUR WILL USUALLY BE FINE AS LONG AS THE NUMERICAL FUNCTION IS
     STRICTLY DELTA-UNIMODAL ON THE GIVEN INTERVAL (SEE [1]) AND THE
     TOLERANCE FUNCTION SATISFIES TOL(X) >= DELTA, FOR ALL X IN THE
     GIVEN INTERVAL; LET THE VALUE OF DFX AT THE BEGIN AND END POINT OF
     THE INITIAL INTERVAL BE DENOTED BY DFA AND DFB, RESPECTIVELY, THEN,
     FINDING A GLOBAL MINIMUM IS ONLY GUARANTEED IF THE FUNCTION IS
     CONVEX AND DFA <= 0 AND DFB >= 0; IF THESE CONDITIONS ARE NOT
     SATISFIED, THEN A LOCAL MINIMUM OR A MINIMUM AT ONE OF THE END
     POINTS MIGHT BE FOUND.
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY: NO AUXILIARY ARRAYS ARE DECLARED IN MININDER.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     MININDER HAS ALMOST THE SAME STRUCTURE AS THE PROCEDURE GIVEN IN
     [1]; HOWEVER, CUBIC INTERPOLATION (SEE [2]) IS USED INSTEAD OF
     QUADRATIC INTERPOLATION TO APPROXIMATE THE MINIMIUM.
 
 
 REFERENCES:
 
     [1]: BRENT, R.P.
          ALGORITHMS FOR MINIMIZATION WITHOUT DERIVATIVES. CH.5.
          PRENTICE HALL, 1973.
     [2]: DAVIDON, W.C.
          VARIABLE METRIC METHODS FOR MINIMIZATION.
          REP. A.N.L. 5990, 1959.
 
 
1SECTION : 5.1.2.1.2          (OCTOBER 1975)                      PAGE 3
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM MAY BE USED TO CALCULATE THE MINIMUM OF THE
     FUNCTION F(X) = SUM(((I * 2 - 5)/(X - I ** 2)) ** 2; I = 1 (1) 20)
     ON THE INTERVAL [1.01,3.99] (SEE [1]).
 
     "BEGIN"
         "REAL" M, X, Y; "INTEGER" CNT;
 
         "REAL" "PROCEDURE" F(X); "VALUE" X; "REAL" X;
         "BEGIN" "INTEGER" I; "REAL" S;
             S:= 0; "FOR" I:= 1 "STEP" 1 "UNTIL" 20 "DO"
             S:= S + ((I * 2 - 5) / (X - I ** 2)) ** 2;
             CNT:= CNT + 1; F:= S
         "END" F;
 
         "REAL" "PROCEDURE" DF(X); "VALUE" X; "REAL" X;
         "BEGIN" "INTEGER" I; "REAL" S;
             S:= 0; "FOR" I:= 1 "STEP" 1 "UNTIL" 20 "DO"
             S:= S + (I * 2 - 5) ** 2 / (X - I ** 2) ** 3;
             DF:= -S * 2
         "END" DF;
 
         "REAL" "PROCEDURE" TOL(X); "VALUE" X; "REAL" X;
         TOL:= ABS(X) * "-7 + "-7;
 
         X:= 1.01; Y:= 3.99; CNT:= 0;
         M:= MININDER(X, Y, F(X), DF(X),TOL(X));
         OUTPUT(61 ,"("4B,"("MINIMUM IS ")",N,/4B,
         "("FOR X IS ")",N,/4B,
         "("AND Y IS ")",N,/4B,
         "("THE NUMBER OF FUNCTION EVALUATIONS NEEDED IS ")",2ZD,/")",
         M, X, Y, CNT)
     "END"
 
     RESULTS:
 
     MINIMUM IS +3.6766990169021"+000
     FOR X IS +3.0229155250302"+000
     AND Y IS +3.0229151227386"+000
     THE NUMBER OF FUNCTION EVALUATIONS NEEDED IS   9
1SECTION : 5.1.2.1.2          (NOVEMBER 1976)                     PAGE 4
 
 
 
 SOURCE TEXT(S):
 
 "CODE"34435;
     "REAL" "PROCEDURE" MININDER(X, Y, FX, DFX, TOLX);
     "REAL" X, Y, FX, DFX, TOLX;
     "BEGIN" "COMMENT" THE FUNCTION IS APPROXIMATED BY A CUBIC AS
         GIVEN BY DAVIDON, 1958, THE STRUCTURE IS SIMILAR TO THE
         STRUCTURE OF THE PROGRAM GIVEN BY BRENT, 1973, THIS IS
         A REVISION OF 760407;
 
         "INTEGER" SGN;
         "REAL" A, B, C, FA, FB, FU, DFA, DFB, DFU, E, D, TOL, BA,
         Z, P, Q, S;
 
         "IF" X <= Y "THEN"
         "BEGIN" A:= X; FA:= FX; DFA:= DFX;
             B:= X:= Y; FB:= FX; DFB:= DFX
         "END" "ELSE"
         "BEGIN" B:= X; FB:= FX; DFB:= DFX;
             A:= X:= Y; FA:= FX; DFA:= DFX
         "END";
         C:= (3 - SQRT(5)) / 2; D:= B - A; E:= D * 2; Z:= E * 2;
     LOOP: BA:= B - A; TOL:= TOLX; "IF" BA >= TOL * 3 "THEN"
         "BEGIN" "IF" ABS(DFA) <= ABS(DFB) "THEN"
             "BEGIN" X:=A; SGN:= 1 "END" "ELSE"
             "BEGIN" X:= B; SGN:= -1 "END";
             "IF" DFA <= 0 "AND" DFB >= 0 "THEN"
             "BEGIN" Z:= (FA - FB) * 3 / BA + DFA + DFB;
                 S:= SQRT(Z ** 2 - DFA * DFB);
                 P:= "IF" SGN = 1 "THEN" DFA - S - Z "ELSE"
                 DFB + S - Z; P:= P * BA;
                 Q:= DFB - DFA + S * 2; Z:= E; E:= D;
                 D:= "IF" ABS(P) <= ABS(Q) * TOL "THEN" TOL * SGN
                 "ELSE" -P / Q
             "END" "ELSE" D:= BA;
             "IF" ABS(D) >= ABS(Z * 0.5) "OR" ABS(D) > BA * 0.5 "THEN"
             "BEGIN" E:= BA; D:= C * BA * SGN "END";
             X:= X + D; FU:= FX; DFU:= DFX;
             "IF" DFU >= 0 "OR" (FU >= FA "AND" DFA <= 0) "THEN"
             "BEGIN" B:= X; FB:= FU; DFB:= DFU "END" "ELSE"
             "BEGIN" A:= X; FA:= FU; DFA:= DFU "END";
             "GOTO" LOOP
         "END"; "IF" FA <= FB "THEN"
         "BEGIN" X:= A; Y:= B; MININDER:= FA "END" "ELSE"
         "BEGIN" X:= B; Y:= A; MININDER:= FB "END"
     "END" MININDER;
         "EOP"
1SECTION : 5.1.2.2.1          (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR: J.C.P.BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730620.
 
 BRIEF DESCRIPTION:
     THIS SECTION CONTAINS FOUR PROCEDURES, LINEMIN, RNK1UPD, DAVUPD AND
     FLEUPD, THAT ARE AUXILIARY PROCEDURES FOR THE PROCEDURES RNK1MIN
     AND FLEMIN (SECTION 5.1.2.2.2).
 
 
 KEYWORDS:
     AUXILIARY PROCEDURE.
 
 
 SUBSECTION: LINEMIN.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS AUXILIARY PROCEDURE IS:
     "PROCEDURE" LINEMIN(N, X, D, ND, ALFA, G, FUNCT, F0, F1, DF0, DF1,
     EVLMAX, STRONGSEARCH, IN);
     "VALUE" N, ND, F0, DF0, STRONGSEARCH;
     "INTEGER" N, EVLMAX; "BOOLEAN" STRONGSEARCH;
     "REAL" ND, ALFA, F0, F1, DF0, DF1;
     "ARRAY" X, D, G, IN; "REAL" "PROCEDURE" FUNCT;"CODE" 34210;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF VARIABLES OF THE GIVEN FUNCTION F;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1 : N];
             ENTRY:  A VECTOR  X0, SUCH THAT  F  IS DECREASING IN X0, IN
                     THE DIRECTION GIVEN BY D;
             EXIT:   THE  CALCULATED  APPROXIMATION  OF  THE  VECTOR FOR
                     WHICH F IS MINIMAL ON THE LINE DEFINED BY:
                     X0 + ALFA * D, (ALFA > 0);
     D:      <ARRAY IDENTIFIER>;
             "ARRAY" D[1 : N];
             ENTRY:  THE DIRECTION  OF THE LINE  ON WHICH  F  HAS  TO BE
                     MINIMIZED;
     ND:     <ARITHMETIC EXPRESSION>;
             ENTRY:  THE EUCLIDEAN NORM OF THE VECTOR GIVEN IN D[1 : N];
     ALFA:   <VARIABLE>;
             THE INDEPENDENT VARIABLE, THAT DEFINES  THE POSITION ON THE
             LINE ON WHICH F HAS TO BE MINIMIZED;
             THIS LINE IS DEFINED BY X0 + ALFA * D, (ALFA > 0);
             ENTRY:  AN ESTIMATE ALFA0 OF THE VALUE FOR WHICH
                     H(ALFA) = F(X0 + ALFA * D), (ALFA > 0), IS MINIMAL;
             EXIT:   THE CALCULATED APPROXIMATION ALFAM OF THE VALUE FOR
                     WHICH H(ALFA) IS MINIMAL;
1SECTION : 5.1.2.2.1          (FEBRUARY 1979)                     PAGE 2
 
 
 
     G:      <ARRAY IDENTIFIER>;
             "ARRAY" G[1 : N];
             EXIT:   THE GRADIENT OF  F  AT THE CALCULATED APPROXIMATION
                     OF THE MINIMUM;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE SHOULD BE:
             "REAL" "PROCEDURE" FUNCT(N, X, G); "VALUE" N;
             "INTEGER" N; "ARRAY" X, G;
             A CALL OF FUNCT SHOULD EFFECTUATE :
             1:  FUNCT:= F(X);
             2:  THE VALUE OF G[I], (I = 1, ..., N),  BECOMES  THE VALUE
                 OF THE I - TH COMPONENT OF THE GRADIENT OF F AT X;
     F0:     <ARITHMETIC EXPRESSION>;
             ENTRY:  THE VALUE OF H(0), (SEE ALFA);
     F1:     <VARIABLE>;
             ENTRY:  THE VALUE OF H(ALFA0);
             EXIT:   THE VALUE OF H(ALFAM), (SEE ALFA);
     DF0:    <ARITHMETIC EXPRESSION>;
             ENTRY:  THE VALUE OF THE DERIVATIVE OF H AT ALFA = 0;
     DF1:    <VARIABLE>;
             ENTRY:  THE VALUE OF THE DERIVATIVE OF H AT ALFA = ALFA0;
             EXIT:   THE VALUE OF THE DERIVATIVE OF H AT ALFA = ALFAM;
     EVLMAX: <VARIABLE>;
             ENTRY:  THE MAXIMUM ALLOWED NUMBER OF CALLS OF FUNCT;
             EXIT:   THE NUMBER OF TIMES FUNCT HAS BEEN CALLED;
     STRONGSEARCH:
             <BOOLEAN EXPRESSION>;
             IF  THE VALUE OF STRONGSEARCH IS  TRUE,  THEN  THE  PROCESS
             MAKES USE OF TWO STOPPING CRITERIA:
             A:  THE NUMBER OF TIMES FUNCT HAS BEEN CALLED EXCEEDS THE
                 GIVEN VALUE OF EVLMAX;
             B:  AN INTERVAL IS FOUND  WITH LENGTH  LESS  THAN TWO TIMES
                 THE PRESCRIBED PRECISION,ON WICH A MINIMUM IS EXPECTED;
             IF THE VALUE OF STRONGSEARCH  IS FALSE,  THE PROCESS  MAKES
             ALSO USE OF A THIRD STOPPING CRITERION :
             C:  MU <= (H(ALFAK) - H(ALFA0)) / (ALFAK * DF0) <= 1 - MU,
                 WHEREBY ALFAK IS THE CURRENT ITERATE AND MU A
                 PRESCRIBED CONSTANT;
     IN:     <ARRAY IDENTIFIER>;
             ENTRY:
             "ARRAY" IN[1:3];
             IN[1]:  THE  RELATIVE  PRECISION,  EPSR,  NECESSARY FOR THE
                     STOPPING CRITERION B, (SEE STRONGSEARCH);
             IN[2]:  THE  ABSOLUTE  PRECISION,  EPSA,  NECESSARY FOR THE
                     STOPPING CRITERION B, (SEE STRONGSEARCH);
             THE PRESCRIBED PRECISION, EPS, AT ALFA = ALFAK IS GIVEN BY:
             EPS = NORM ( X0 + ALPHA * D ) * EPSR + EPSA, WHERE
             NORM ( . ) DENOTES THE EUCLIDEAN NORM.
             IN[3]: THE PARAMETER MU NECESSARY FOR STOPPING CRITERION C;
                    THIS  PARAMETER  MUST  SATISFY:   0 < MU < 0.5 ; IN
                    PRACTICE,A CHOICE OF MU = 0.0001 IS ADVISED.
 
 
1SECTION : 5.1.2.2.1          (FEBRUARY 1979)                     PAGE 3
 
 
 
 DATA AND RESULTS:
 
     LINEMIN   CALCULATES   AN    APPROXIMATION   OF   A  MINIMUM  OF  A
     HIGHER - DIMENSIONAL FUNCTION ON A GIVEN LINE;
     THE QUANTITY DF0 MUST SATIFY: DF0 < 0;
     IF MOREOVER DF1 > 0,  THEN  THE PROCEDURE WILL YIELD A RESULT  THAT
     SATISFIES ONE OF THE CHOSEN STOPPING CRITERIA, (SEE STRONGSEARCH),
     OTHERWISE WE CAN NOT GUARANTEE SUCH A RESULT.
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     ELMVEC = CP34020,
     DUPVEC = CP31030.
 
 
 REQUIRED CENTRAL MEMORY:
     N WORDS.
 
 
 
 METHOD AND PERFORMANCE:
 
     AN APPROXIMATION TO THE MINIMUM  ON  THE  GIVEN LINE  IS CALCULATED
     WITH CUBIC INTERPOLATION ([2]);THE STOPPING CRITERION USED WHEN THE
     VALUE OF STRONGSEARCH IS FALSE  IS DESCRIBED  IN  [3]  AND  [4];  A
     DETAILED DESCRIPTION OF THIS PROCEDURE IS GIVEN IN [1].
 
 
 REFERENCES:
     [1] BUS, J. C. P.
         MINIMIZATION OF FUNCTIONS OF SEVERAL VARIABLES (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, NR 29/72 (1972).
     [2] DAVIDON, W. C.
         VARIABLE METRIC METHOD FOR MINIMIZATION.
         ARGONNE NAT. LAB. REPORT, ANL 5990 (1959).
     [3] FLETCHER, R.
         A NEW APPROACH TO VARIABLE METRIC ALGORITHMS.
         COMP. J. 6, (1963), P.163 - 168.
     [4] GOLDSTEIN, A. A. AND PRICE, J. F.
         AN EFFECTIVE ALGORITHM FOR MINIMIZATION.
         NUMER. MATH. 10, (1967), P.184 - 189.
 
 
1SECTION : 5.1.2.2.1          (FEBRUARY 1979)                     PAGE 4
 
 
 
 SUBSECTION: RNK1UPD.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS AUXILIARY PROCEDURE IS:
     "PROCEDURE" RNK1UPD(H, N, V, C); "VALUE" N, C;
     "INTEGER" N; "REAL" C; "ARRAY" H, V;
     "CODE" 34211;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE  SYMMETRIC  MATRIX, WHOSE UPPERTRIANGLE IS
             STORED COLUMNWISE IN THE ONE - DIMENSIONAL ARRAY H;
     C:      <ARITHMETIC EXPRESSION>;
             SEE V;
     V:      <ARRAY IDENTIFIER>;
             "ARRAY" V[1 : N];
             THE GIVEN MATRIX IS UPDATED (ANOTHER MATRIX IS ADDED TO IT)
             WITH A SYMMETRIC MATRIX , U, OF RANK ONE, DEFINED BY:
                        U[I,J] = C * V[I] * V[J];
     H:      <ARRAY IDENTIFIER>;
             "ARRAY" H[1 : N * (N + 1) // 2];
             ENTRY:  THE  UPPERTRIANGLE   (STORED  COLUMNWISE, I.E. :
                     A[I,J] = H[(J-1)*J//2+I], 1 <= I <= J <= N)
                     OF THE  SYMMETRIC MATRIX THAT HAS TO BE UPDATED;
             EXIT:   THE  UPPERTRIANGLE   (STORED  COLUMNWISE)   OF  THE
                     UPDATED MATRIX.
 
 
 PROCEDURES USED:
 
     ELMVEC = CP34020.
 
 
 REQUIRED CENTRAL MEMORY:
 
     NO AUXILIARY ARRAYS ARE DECLARED IN RNK1UPD.
 
 
1SECTION : 5.1.2.2.1          (FEBRUARY 1979)                     PAGE 5
 
 
 
 SUBSECTION: DAVUPD.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS AUXILIARY PROCEDURE IS:
     "PROCEDURE" DAVUPD(H, N, V, W, C1, C2); "VALUE" N, C1, C2;
     "INTEGER" N; "REAL" C1, C2; "ARRAY" H, V, W;
     "CODE" 34212;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER  OF  THE  SYMMETRIC MATRIX WHOSE UPPERTRIANGLE IS
             STORED COLUMNWISE IN THE ONE - DIMENSIONAL ARRAY H;
     C1:     <ARITHMETIC EXPRESSION>;
             SEE W;
     C2:     <ARITHMETIC EXPRESSION>;
             SEE W;
     V:      <ARRAY IDENTIFIER>;
             "ARRAY" V[1 : N];
             SEE W;
     W:      <ARRAY IDENTIFIER>;
             "ARRAY" W[1 : N];
             THE GIVEN MATRIX  IS UPDATED  WITH  A SYMMETRIC MATRIX U OF
             RANK TWO, DEFINED BY:
             U[I,J] = C1 * V[I] * V[J] - C2 * W[I] * W[J];
     H:      <ARRAY IDENTIFIER>;
             "ARRAY" H[1 : N * (N + 1) // 2];
             ENTRY:  THE UPPERTRIANGLE (STORED COLUMNWISE, I.E. :
                     A[I,J] = H[(J - 1) * J // 2 + I], 1 <= I <= J <= N)
                     OF THE MATRIX  THAT HAS TO BE UPDATED;
             EXIT:   THE  UPPERTRIANGLE   (STORED  COLUMNWISE)   OF  THE
                     UPDATED MATRIX.
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     NO AUXILIARY ARRAYS ARE DECLARED IN DAVUPD.
 
 
1SECTION : 5.1.2.2.1          (FEBRUARY 1979)                     PAGE 6
 
 
 
 SUBSECTION: FLEUPD.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS AUXILIARY PROCEDURE IS:
     "PROCEDURE" FLEUPD(H, N, V, W, C1, C2); "VALUE" N, C1, C2;
     "INTEGER" N; "REAL" C1, C2; "ARRAY" H, V, W;
     "CODE" 34213;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE SYMMETRIC MATRIX  WHOSE  UPPERTRIANGLE  IS
             STORED COLUMNWISE IN THE ONE - DIMENSIONAL ARRAY H;
     C1:     <ARITHMETIC EXPRESSION>;
             SEE W;
     C2:     <ARITHMETIC EXPRESSION>;
             SEE W;
     V:      <ARRAY IDENTIFIER>;
             "ARRAY" V[1 : N];
             SEE W;
     W:      <ARRAY IDENTIFIER>;
             "ARRAY" W[1 : N];
             THE GIVEN MATRIX IS UPDATED  WITH A SYMMETRIC MATRIX  U  OF
             RANK TWO, DEFINED BY:
             U[I,J]= C2 * V[I] * V[J] - C1 *(V[I] * W[J] + W[I] * V[J]);
     H:      <ARRAY IDENTIFIER>;
             "ARRAY" H[1 : N * (N + 1) // 2];
             ENTRY:  THE UPPERTRIANGLE (STORED COLUMNWISE, I.E. :
                     A[I,J] = H[(J - 1) * J // 2 + I], 1 <= I <= J <= N)
                     OF THE MATRIX THAT HAS TO BE UPDATED;
             EXIT:   THE  UPPERTRIANGLE   (STORED  COLUMNWISE)   OF  THE
                     UPDATED MATRIX.
 
 
 PROCEDURE USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     NO AUXILIARY ARRAYS ARE DECLARED IN FLEUPD.
1SECTION : 5.1.2.2.1          (DECEMBER 1975)                     PAGE 7
 
 
 
 SOURCE TEXT(S):
0"CODE" 34210;
     "PROCEDURE" LINEMIN(N, X, D, ND, ALFA, G, FUNCT, F0, F1, DF0, DF1,
     EVLMAX, STRONGSEARCH, IN); "VALUE" N, ND, F0, DF0, STRONGSEARCH;
     "INTEGER" N, EVLMAX; "BOOLEAN" STRONGSEARCH;
     "REAL" ND, ALFA, F0, F1, DF0, DF1;
     "ARRAY" X, D, G, IN;
     "REAL" "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" I, EVL;
         "BOOLEAN" NOTININT;
         "REAL" F,OLDF,DF,OLDDF,MU,ALFA0,Q,W,Y,Z,RELTOL,ABSTOL
         ,EPS, AID;
         "ARRAY" X0[1:N];
 
         RELTOL:= IN[1]; ABSTOL:= IN[2]; MU:= IN[3]; EVL:= 0;
         ALFA0:= 0; OLDF:= F0; OLDDF:= DF0; Y:= ALFA; NOTININT:= "TRUE";
         DUPVEC(1, N, 0, X0, X);
         EPS:= (SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL) / ND;
         Q:= (F1 - F0) / (ALFA * DF0);
     INT: "IF" NOTININT "THEN" NOTININT:= DF1 < 0 "AND" Q > MU;
         AID:= ALFA; "IF" DF1 >= 0 "THEN"
         "BEGIN" Z:= 3 * (OLDF - F1) / ALFA + OLDDF + DF1;
             W:= SQRT(Z ** 2 - OLDDF * DF1);
             ALFA:= ALFA * (1 - (DF1 + W - Z) / (DF1 - OLDDF + W * 2));
             "IF" ALFA < EPS "THEN" ALFA:= EPS "ELSE"
             "IF" AID - ALFA < EPS "THEN" ALFA:= AID - EPS
         "END" CUBIC INTERPOLATION
         "ELSE" "IF" NOTININT "THEN"
         "BEGIN" ALFA0:= ALFA:= Y; OLDDF:= DF1; OLDF:= F1 "END"
         "ELSE" ALFA:= 0.5 * ALFA; Y:= ALFA + ALFA0;
         DUPVEC(1, N, 0, X, X0); ELMVEC(1, N, 0, X, D, Y);
         EPS:= (SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL) / ND;
         F:= FUNCT(N, X, G); EVL:= EVL +1 ; DF:= VECVEC(1, N, 0, D, G);
         Q:= (F - F0) / (Y * DF0);
         "IF" ("IF" NOTININT "OR" STRONGSEARCH "THEN" "TRUE" "ELSE"
         Q < MU "OR" Q > 1 - MU) "AND" EVL < EVLMAX "THEN"
         "BEGIN" "IF" NOTININT "OR" DF > 0 "OR" Q < MU "THEN"
             "BEGIN" DF1:= DF; F1:= F "END"
             "ELSE"
             "BEGIN" ALFA0:= Y; ALFA:= AID - ALFA; OLDDF:= DF; OLDF:= F
             "END";
             "IF" ALFA > EPS * 2 "THEN" "GOTO" INT
         "END";
         ALFA:= Y; EVLMAX:= EVL; DF1:= DF; F1:= F
     "END" LINEMIN
1SECTION : 5.1.2.2.1          (DECEMBER 1975)                     PAGE 8
 
                                                                   ;
         "EOP"
0"CODE" 34211;
    "PROCEDURE" RNK1UPD(H, N, V, C);"VALUE" N, C; "INTEGER" N;
    "REAL" C;"ARRAY" H, V;
     "BEGIN" "INTEGER" J, K;
         K:= 0;
         "FOR" J:= 1, J + K "WHILE" K < N "DO"
         "BEGIN" K:= K +1 ;
             ELMVEC(J, J + K - 1, 1 - J, H, V, V[K] * C)
         "END"
     "END" RNK1UPD;
         "EOP"
0"CODE" 34212;
     "PROCEDURE" DAVUPD(H, N, V, W, C1, C2); "VALUE" N, C1, C2;
     "INTEGER" N; "REAL" C1, C2; "ARRAY" H, V, W;
     "BEGIN" "INTEGER" I, J, K;
         "REAL" VK, WK;
         K:= 0;
         "FOR" J:= 1, J + K "WHILE" K < N "DO"
         "BEGIN" K:= K +1 ; VK:= V[K] * C1; WK:= W[K] * C2;
             "FOR" I:= 0 "STEP" 1 "UNTIL" K -1  "DO"
             H[I + J]:= H[I + J] + V[I + 1] * VK - W[I + 1] * WK
         "END"
     "END" DAVUPD;
         "EOP"
0"CODE" 34213;
     "PROCEDURE" FLEUPD(H, N, V, W, C1, C2); "VALUE" N, C1, C2;
     "INTEGER" N; "REAL" C1, C2; "ARRAY" H, V, W;
     "BEGIN" "INTEGER" I, J, K;
         "REAL" VK, WK;
         K:= 0; "FOR" J:= 1, J + K "WHILE" K < N "DO"
         "BEGIN" K:= K +1; VK:= - W[K] * C1 + V[K] * C2; WK:= V[K] * C1;
             "FOR" I:= 0 "STEP" 1 "UNTIL" K - 1  "DO"
             H[I + J]:= H[I + J] + V[I + 1] * VK -W[I + 1] * WK
         "END"
     "END" FLEUPD;
         "EOP"
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR: J.C.P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED:  741101.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THE PROCEDURE PRAXIS;
     PRAXIS MINIMIZES A FUNCTION OF SEVERAL VARIABLES.
 
 
 KEYWORDS:
 
     MINIMIZATION,
     FUNCTION OF SEVERAL VARIABLES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" PRAXIS(N, X, FUNCT, IN, OUT); "VALUE" N;
     "INTEGER" N; "ARRAY" X, IN, OUT; "REAL" "PROCEDURE" FUNCT;
     "CODE" 34432;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF VARIABLES OF THE FUNCTION TO BE MINIMIZED;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1 : N];
             THE VARIABLES OF THE FUNCTION;
             ENTRY: AN APPROXIMATION OF THE POSITION OF THE MINIMUM;
             EXIT:  THE CALCULATED POSITION OF THE MINIMUM;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE SHOULD BE:
             "REAL" "PROCEDURE" FUNCT(N, X); "VALUE" N;
             "INTEGER" N; "ARRAY" X;
 
             FUNCT SHOULD DELIVER THE VALUE OF THE FUNCTION TO BE
                    MINIMIZED, AT THE POINT GIVEN BY X[1:N];
 
             THE MEANING OF THE FORMAL PARAMETERS IS:
             N:  <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF VARIABLES;
             X:  <ARRAY IDENTIFIER>; "ARRAY" X[1:N];
                 THE VALUES OF THE VARIABLES FOR WHICH THE FUNCTION HAS
                 TO BE EVALUATED;
     IN:     <ARRAY IDENTIFIER>;
             "ARRAY" IN[0:9];
             ENTRY:
                 IN[0]:  THE MACHINE PRECISION; FOR THE CYBER 73  A
                         SUITABLE VALUE IS "-14;
1SECTION : 5.1.2.2.2          (OCTOBER 1975)                      PAGE 2
 
 
 
                 IN[1], IN[2]: RELATIVE AND ABSOLUTE TOLERANCE,
                         RESPECTIVELY, FOR THE STEPVECTOR
                         (RELATIVE TO THE CURRENT ESTIMATES OF
                         THE VARIABLES); THE PROCESS IS TERMINATED WHEN
                         IN IN[8] + 1 SUCCESSIVE ITERATION STEPS THE
                         EUCLIDEAN NORM OF THE STEP VECTOR IS LESS THAN
                         (IN[1] * NORM(X) + IN[2]) * 0.5;
                         IN[1] SHOULD BE CHOSEN IN AGREEMENT WITH THE
                         PRECISION IN WHICH THE FUNCTION IS CALCULATED;
                         USUALLY IN[1] SHOULD BE CHOSEN SUCH THAT
                         IN[1] >= SQRT(IN[0]); IN[0] SHOULD BE CHOSEN
                         DIFFERENT FROM ZERO.
                 IN[3], IN[4] ARE NEITHER USED NOR CHANGED;
                 IN[5]:  THE MAXIMUM NUMBER OF FUNCTION EVALUATIONS
                         ALLOWED (I.E. CALLS OF FUNCT);
                 IN[6]:  THE MAXIMUM STEP SIZE; IN[6] SHOULD BE EQUAL TO
                         THE MAXIMUM EXPECTED DISTANCE BETWEEN THE GUESS
                         AND THE MINIMUM; IF IN[6] IS TOO SMALL OR TOO
                         LARGE, THEN THE INITIAL RATE OF CONVERGENCE
                         WILL BE SLOW;
                 IN[7]:  THE MAXIMUM SCALING FACTOR; THE VALUE OF IN[7]
                         MAY BE USED TO OBTAIN AUTOMATIC SCALING OF THE
                         VARIABLES; HOWEVER, THIS SCALING IS WORTHWHILE
                         BUT MAY BE UNRELIABLE; THEREFORE, THE USER
                         SHOULD TRY TO SCALE HIS PROBLEM HIMSELF AS WELL
                         AS POSSIBLE AND SET IN[7]:= 1; IN EITHER CASE,
                         IN[7] SHOULD NOT BE CHOSEN GREATER THAN 10;
                 IN[8]:  THE PROCESS TERMINATES IF NO SUBSTANTIAL
                         IMPROVEMENT OF THE VALUES OF THE VARIABLES IS
                         OBTAINED IN IN[8] + 1 SUCCESSIVE ITERATION
                         STEPS (SEE IN[1], IN[2]); IN[8] = 4  IS VERY
                         CAUTIOUS; USUALLY, IN[8] = 1 IS SATISFACTORY;
                 IN[9]:  IF THE PROBLEM IS KNOWN TO BE ILL-CONDITIONED
                         (SEE [1]), THEN THE VALUE OF IN[9] SHOULD BE
                         NEGATIVE, OTHERWISE IN[9] >= 0;
     OUT:    <ARRAY IDENTIFIER>;
             "ARRAY" OUT[1:6];
             EXIT:
                 OUT[1]: THIS VALUE GIVES INFORMATION ABOUT THE
                         TERMINATION OF THE PROCESS;
                         OUT[1] = 0: NORMAL TERMINATION;
                         OUT[1] = 1: THE PROCESS IS BROKEN OFF, BECAUSE,
                                     AT THE END OF AN ITERATION STEP,
                                     THE NUMBER OF CALLS OF FUNCT
                                     EXCEEDED THE VALUE GIVEN IN IN[5];
                         OUT[1] = 2: THE PROCESS IS BROKEN OFF, BECAUSE
                                     THE CONDITION OF THE PROBLEM IS TOO
                                     BAD;
                 OUT[2]: THE CALCULATED MINIMUM OF THE FUNCTION;
                 OUT[3]: THE VALUE OF THE FUNCTION AT THE INITIAL GUESS;
                 OUT[4]: THE NUMBER OF FUNCTION EVALUATIONS NEEDED TO
                         OBTAIN THIS RESULT;
                 OUT[5]: THE NUMBER OF LINE SEARCHES (SEE [1]);
                 OUT[6]: THE STEP SIZE IN THE LAST ITERATION STEP.
 
 
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 3
 
 
 
 PROCEDURES USED:
 
     INIVEC       = CP31010,
     INIMAT       = CP31011,
     DUPVEC       = CP31030,
     DUPMAT       = CP31035,
     DUPCOLVEC    = CP31034,
     MULROW       = CP31021,
     MULCOL       = CP31022,
     VECVEC       = CP34010,
     TAMMAT       = CP34014,
     MATTAM       = CP34015,
     ICHROWCOL    = CP34033,
     ELMVECCOL    = CP34021,
     QRISNGVALDEC = CP34273,
     SETRANDOM    = CP11014,
     RANDOM       = CP11015,
     DWARF        = CP30003.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: ONE ARRAY OF LENGTH  N SQUARED AND FIVE
                             ARRAYS OF LENGTH  N  ARE DECLARED;
 
 
 RUNNING TIME:
 
     THE NUMBER OF ITERATION STEPS DEPENDS STRONGLY ON THE PROBLEM TO BE
     SOLVED.
 
 
 METHOD AND PERFORMANCE:
 
     THIS PROCEDURE IS ADOPTED FROM [1].
 
 
 
 REFERENCES:
 
     [1] R. P. BRENT,
         ALGORITHMS FOR MINIMIZATION WITHOUT DERIVATIVES, CH. 7.
         PRENTICE HALL, 1973.
 
 
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM MAY BE USED TO CALCULATE THE MINIMUM OF THE
     FUNCTION F(X) = 100 * (X[2] - X[1] ** 2) ** 2 + (1 - X[1]) ** 2,
     USING (-1.2, 1) AS AN INITIAL ESTIMATE.
 
     "BEGIN"
 
        "ARRAY" X[1:2], IN[0:9], OUT[1:6];
 
        "REAL" "PROCEDURE" F(N, X); "VALUE" N; "INTEGER" N; "ARRAY" X;
        F:= (X[2] - X[1] ** 2) ** 2 * 100 + (1 - X[1]) ** 2;
 
        IN[0]:= "-14; IN[1]:= IN[2]:= "-6; IN[5]:= 250;
        IN[6]:= 1; IN[7]:= 1; IN[8]:= 1; IN[9]:= 1;
 
        X[1]:= -1.2; X[2]:= 1;
        PRAXIS(2, X, F, IN, OUT);
        "IF" OUT[1] = 0 "THEN" OUTPUT(61,"(""("    NORMAL TERMINATION")"
        ,//")");
        OUTPUT(61, "("4B,"("MINIMUM IS ")",N,/,4B,
        "("FOR X IS ")", 2(N),/,4B,
        "("THE INITIAL FUNCTION VALUE WAS ")" ,N,/,4B,
        "("THE NUMBER OF FUNCTION EVALUATIONS NEEDED WAS ")",3ZD,/,4B,
        "("THE NUMBER OF LINE SEARCHES WAS ")",3ZD,/,4B,
        "("THE STEP SIZE IN THE LAST ITERATION STEP WAS ")", N,/")",
        OUT[2], X[1], X[2], OUT[3], OUT[4], OUT[5], OUT[6])
     "END"
 
     RESULTS:
 
     NORMAL TERMINATION
 
     MINIMUM IS +1.5694986738789"-021
     FOR X IS +1.0000000000389"+000  +1.0000000000785"+000
     THE INITIAL FUNCTION VALUE WAS +2.4200000000001"+001
     THE NUMBER OF FUNCTION EVALUATIONS NEEDED WAS  189
     THE NUMBER OF LINE SEARCHES WAS   72
     THE STEP SIZE IN THE LAST ITERATION STEP WAS +5.3830998470105"-009
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 5
 
 
 
 SOURCE TEXT(S):
 
0"CODE" 34432;
  "PROCEDURE" PRAXIS(N, X, FUNCT, IN, OUT);
  "VALUE" N; "INTEGER" N;
  "ARRAY" X, IN, OUT;
  "REAL" "PROCEDURE" FUNCT;
  "BEGIN"
     "COMMENT"THIS PROCEDURE MINIMIZES FUNCT(N,X),WITH THE
     PRINCIPAL AXIS METHOD (SEE BRENT,R.P, 1973, ALGORITHMS
     FOR MINIMIZATION WITHOUT DERIVATIVES,CH.7);
 
     "PROCEDURE" SORT;
     "BEGIN" "INTEGER" I, J, K; "REAL" S;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" K:= I; S:= D[I];
             "FOR" J:= I+1 "STEP" 1 "UNTIL" N "DO" "IF" D[J]>S "THEN"
             "BEGIN" K:= J; S:= D[J] "END";
             "IF" K>I "THEN"
             "BEGIN" D[K]:= D[I]; D[I]:= S;
                 "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" S:=V[J,I]; V[J,I]:= V[J,K]; V[J,K]:= S
                 "END"
             "END"
         "END"
     "END" SORT
 
1SECTION : 5.1.2.2.2          (OCTOBER 1975)                      PAGE 6
                                                                  ;
 
 
     "PROCEDURE" MIN(J, NITS, D2, X1, F1, FK); "VALUE" J, NITS, FK;
     "INTEGER" J, NITS; "REAL" D2, X1, F1; "BOOLEAN" FK;
     "BEGIN"
         "REAL" "PROCEDURE" FLIN(L); "VALUE" L; "REAL" L;
         "BEGIN" "INTEGER" I; "ARRAY" T[1:N];
             "IF" J > 0 "THEN"
             "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 T[I]:= X[I] + L * V[I,J]
             "END" "ELSE"
             "BEGIN" "COMMENT" SEARCH ALONG PARABOLIC SPACE CURVE;
                 QA:= L * (L - QD1) / (QD0 * (QD0 + QD1));
                 QB:= (L + QD0) * (QD1 - L) /(QD0 * QD1);
                 QC:= L * (L + QD0) / (QD1 * (QD0 + QD1));
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 T[I]:= QA * Q0[I] +QB * X[I] + QC * Q1[I]
             "END";
             NF:= NF + 1; FLIN:= FUNCT(N, T)
         "END" FLIN;
 
         "INTEGER" K; "BOOLEAN" DZ;
         "REAL" X2, XM, F0, F2, FM, D1, T2, S, SF1, SX1;
         SF1:= F1; SX1:= X1;
         K:= 0; XM:= 0; F0:= FM:= FX; DZ:= D2 < RELTOL;
         S:= SQRT(VECVEC(1,N,0,X,X));
         T2:= M4 * SQRT(ABS(FX) / ("IF" DZ "THEN" DMIN "ELSE" D2)
         + S * LDT) + M2 * LDT; S:= S * M4 + ABSTOL;
         "IF" DZ "AND" T2 > S "THEN" T2:= S;
         "IF"T2<SMALL"THEN"T2:= SMALL;
         "IF"T2>0.01*H "THEN"T2:= 0.01*H;
         "IF"FK"AND"F1<=FM "THEN"
         "BEGIN"XM:=X1; FM:= F1 "END";
         "IF" ^ FK"OR"ABS(X1)<T2"THEN"
         "BEGIN"X1:="IF"X1>0 "THEN"T2"ELSE"-T2;
             F1:= FLIN(X1)
         "END";
         "IF"F1<= FM"THEN"
         "BEGIN"XM:= X1; FM:= F1 "END";
     L0: "IF" DZ "THEN"
         "BEGIN" "COMMENT"EVALUATE FLIN AT ANOTHER POINT
             AND ESTIMATE THE SECOND DERIVATIVE;
             X2:= "IF" F0 < F1 "THEN" -X1 "ELSE" X1 * 2;
             F2:= FLIN(X2); "IF"F2 <= FM "THEN"
             "BEGIN" XM:= X2; FM:= F2 "END";
             D2:=(X2*(F1-F0)-X1*(F2-F0))/(X1*X2*(X1-X2))
         "END";
         "COMMENT"ESTIMATE FIRST DERIVATIVE AT 0;
         D1:=(F1-F0)/X1-X1*D2; DZ:="TRUE";
         X2:= "IF"D2<=SMALL"THEN"
         ("IF"D1<0"THEN"H"ELSE"-H)
         "ELSE"-0.5*D1/D2;
         "IF"ABS(X2)>H"THEN"X2:="IF"X2>0"THEN"H"ELSE"-H;
                                                               "COMMENT"
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 7
                                                                  ;
 
 
     L1: F2:=FLIN(X2);
         "IF"K<NITS"AND"F2>F0"THEN"
         "BEGIN"K:=K+1;
             "IF"F0<F1"AND"X1*X2>0"THEN" "GOTO"L0;
             X2:= 0.5*X2; "GOTO"L1
         "END";
         NL:= NL+1;
         "IF"F2>FM"THEN"X2:=XM"ELSE"FM:=F2;
         D2:="IF"ABS(X2*(X2-X1))>SMALL"THEN"
         (X2*(F1-F0)-X1*(FM-F0))/(X1*X2*(X1-X2))
         "ELSE" "IF"K>0"THEN"0"ELSE"D2;
         "IF"D2<=SMALL"THEN"D2:=SMALL;
         X1:=X2; FX:=FM;
         "IF"SF1<FX"THEN"
         "BEGIN" FX:=SF1; X1:=SX1 "END";
         "IF"J>0"THEN"ELMVECCOL(1,N,J,X,V,X1)
     "END" MIN;
 
     "PROCEDURE"QUAD;
     "BEGIN" "INTEGER" I; "REAL" L, S;
         S:= FX; FX:= QF1; QF1:= S; QD1:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN"S:=X[I]; X[I]:= L:= Q1[I]; Q1[I]:= S;
             QD1:= QD1 + (S - L) ** 2
         "END";
         L:=QD1:=SQRT(QD1); S:= 0;
         "IF"(QD0*QD1>DWARF)"AND"NL>=3*N*N"THEN"
         "BEGIN"MIN(0,2,S,L,QF1,"TRUE");
             QA:= L*(L-QD1)/(QD0*(QD0+QD1));
             QB:=(L+QD0)*(QD1-L)/(QD0*QD1);
             QC:= L*(L+QD0)/(QD1*(QD0+QD1))
         "END" "ELSE"
         "BEGIN" FX:= QF1; QA:= QB:= 0; QC:= 1 "END";
         QD0:= QD1;"FOR"I:= 1"STEP"1"UNTIL"N"DO"
         "BEGIN"S:=Q0[I]; Q0[I]:=X[I];
             X[I]:= QA*S + QB*X[I]+QC*Q1[I]
         "END"
     "END" QUAD;
 
     "BOOLEAN" ILLC;
     "INTEGER" I, J, K, K2, NL, MAXF, NF, KL, KT, KTM;
     "REAL" S, SL, DN, DMIN, FX, F1, LDS, LDT, SF, DF, QF1, QD0,
     QD1, QA, QB, QC, M2, M4, SMALL, VSMALL, LARGE, VLARGE, SCBD,
     LDFAC,T2, MACHEPS, RELTOL, ABSTOL, H;
     "ARRAY" V[1:N,1:N], D, Y, Z, Q0, Q1[1:N];
 
     MACHEPS:= IN[0]; RELTOL:= IN[1]; ABSTOL:= IN[2]; MAXF:= IN[5];
     H:= IN[6]; SCBD:= IN[7]; KTM:= IN[8]; ILLC:= IN[9] < 0;
     SMALL:= MACHEPS ** 2; VSMALL:= SMALL ** 2;
     LARGE:= 1/SMALL; VLARGE:= 1/VSMALL;
     M2:= RELTOL; M4:= SQRT(M2); SETRANDOM(0.5);
     LDFAC:= "IF" ILLC "THEN" 0.1 "ELSE" 0.01;
     KT:=NL:=0; NF:=1; OUT[3]:= QF1:=FX:=FUNCT(N,X);
                                                               "COMMENT"
1SECTION : 5.1.2.2.2          (DECEMBER 1979)                     PAGE 8
                                                                  ;
 
 
     ABSTOL:=T2:= SMALL+ABS(ABSTOL); DMIN:= SMALL;
     "IF" H<ABSTOL*100"THEN"H:=ABSTOL*100; LDT:=H;
     INIMAT(1,N,1,N,V,0);
     "FOR"I:=1"STEP"1"UNTIL"N"DO"V[I,I]:= 1;
     D[1]:= QD0:= 0; DUPVEC(1,N,0,Q1,X);
     INIVEC(1,N,Q0,0);
 
 
     "COMMENT"MAIN LOOP;
 L0: SF:=D[1]; D[1]:= S:= 0;
     MIN(1,2,D[1],S,FX,"FALSE");
     "IF" S <= 0 "THEN" MULCOL(1, N, 1, 1, V, V, -1);
     "IF" SF <= 0.9 * D[1] "OR" 0.9 * SF >= D[1] "THEN"
     INIVEC(2,N,D,0);
     "FOR" K:= 2"STEP"1"UNTIL"N"DO"
     "BEGIN" DUPVEC(1,N,0,Y,X); SF:=FX;
         ILLC:= ILLC "OR" KT>0;
     L1: KL:=K; DF:= 0; "IF" ILLC "THEN"
         "BEGIN" "COMMENT"RANDOM STOP TO GET OFF
             RESULTION VALLEY;
             "FOR"I:= 1 "STEP"1"UNTIL"N"DO"
             "BEGIN"S:=Z[I]:=(0.1*LDT+T2*10**KT)
                 *(RANDOM-0.5);
                 ELMVECCOL(1,N,I,X,V,S)
             "END";
             FX:= FUNCT(N,X); NF:= NF+1
         "END";
         "FOR"K2:= K "STEP" 1 "UNTIL" N "DO"
         "BEGIN" SL:=FX; S:= 0;
             MIN (K2, 2, D[K2], S, FX, "FALSE");
             S:="IF" ILLC "THEN" D[K2] * (S + Z[K2]) ** 2
             "ELSE"SL-FX;"IF"DF<S"THEN"
             "BEGIN"DF:=S;KL:= K2"END";
         "END";
         "IF" ^ILLC "AND" DF < ABS(100 * MACHEPS * FX) "THEN"
         "BEGIN" ILLC:= "TRUE"; "GOTO" L1 "END";
         "FOR" K2:= 1"STEP" 1"UNTIL"K-1"DO"
         "BEGIN" S:= 0; MIN(K2, 2, D[K2], S, FX, "FALSE") "END";
         F1:= FX; FX:= SF; LDS:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" SL:= X[I]; X[I]:= Y[I]; SL:= Y[I]:= SL - Y[I];
             LDS:= LDS + SL * SL
         "END"; LDS:= SQRT(LDS);
         "IF" LDS > SMALL "THEN"
         "BEGIN" "FOR" I:= KL - 1 "STEP" -1 "UNTIL" K "DO"
             "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
                 V[J, I + 1]:= V[J,I]; D[I + 1]:= D[I]
             "END";
             D[K]:= 0; DUPCOLVEC(1, N, K, V, Y);
             MULCOL(1, N, K, K, V, V, 1 / LDS);
             MIN(K, 4, D[K], LDS, F1, "TRUE"); "IF" LDS <= 0 "THEN"
             "BEGIN" LDS:= LDS; MULCOL(1, N, K, K, V, V, -1) "END"
         "END";
         LDT:= LDFAC * LDT; "IF" LDT < LDS "THEN" LDT:= LDS;
         T2:= M2 * SQRT(VECVEC(1, N, 0, X, X)) + ABSTOL;
                                                               "COMMENT"
1SECTION : 5.1.2.2.2          (OCTOBER 1975)                      PAGE 9
                                                                  ;
 
 
         KT:= "IF" LDT > 0.5 * T2 "THEN" 0 "ELSE" KT + 1;
         "IF" KT > KTM "THEN" "BEGIN" OUT[1]:= 0; "GOTO" L2 "END"
     "END";
     QUAD;
     DN:= 0;"FOR"I:= 1"STEP"1"UNTIL"N"DO"
     "BEGIN"D[I]:= 1/SQRT(D[I]);
         "IF"DN<D[I]"THEN"DN:=D[I]
     "END";
     "FOR"J:= 1"STEP"1"UNTIL"N"DO"
     "BEGIN"S:= D[J]/DN; MULCOL(1,N,J,J,V,V,S)"END";
     "IF"SCBD>1"THEN"
     "BEGIN"S:=VLARGE; "FOR"I:=1 "STEP"1"UNTIL"N"DO"
         "BEGIN" SL:= Z[I]:= SQRT(MATTAM(1, N, I, I, V, V));
             "IF"SL<M4"THEN"Z[I]:= M4;
             "IF" S>SL "THEN" S:= SL
         "END";
         "FOR"I:=1"STEP"1"UNTIL"N"DO"
         "BEGIN"SL:=S/Z[I];Z[I]:= 1/SL;
             "IF"Z[I]>SCBD"THEN"
             "BEGIN"SL:=1/SCBD; Z[I]:= SCBD"END";
             MULROW(1, N, I, I, V, V, SL)
         "END"
     "END";
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     ICHROWCOL(I + 1, N, I, I, V);
     "BEGIN" "ARRAY" A[1:N,1:N], EM[0:7];
         EM[0]:= EM[2]:= MACHEPS;
         EM[4]:= 10 * N; EM[6]:= VSMALL;
         DUPMAT(1, N, 1, N, A, V);
         "IF" QRISNGVALDEC(A, N, N, D, V, EM) ^= 0 "THEN"
         "BEGIN" OUT[1]:= 2; "GOTO" L2 "END";
     "END";
     "IF"SCBD>1"THEN"
     "BEGIN" "FOR"I:=1"STEP"1"UNTIL"N"DO"
         MULROW(1,N,I,I,V,V,Z[I]);
         "FOR"I:= 1"STEP"1"UNTIL"N"DO"
         "BEGIN"S:= SQRT(TAMMAT(1,N,I,I,V,V));
             D[I]:= S*D[I]; S:= 1/S;
             MULCOL(1,N,I,I,V,V,S)
         "END"
     "END";
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" S:= DN * D[I];
         D[I]:= "IF" S > LARGE "THEN" VSMALL "ELSE"
         "IF" S < SMALL "THEN" VLARGE "ELSE" S ** (-2)
     "END";
     SORT;
     DMIN:= D[N]; "IF" DMIN < SMALL "THEN" DMIN:= SMALL;
     ILLC:= (M2 * D[1]) > DMIN;
     "IF" NF < MAXF "THEN" "GOTO" L0 "ELSE" OUT[1]:= 1;
 L2: OUT[2]:= FX;
     OUT[4]:= NF; OUT[5]:= NL; OUT[6]:= LDT
 "END"PRAXIS;
         "EOP"
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR: J.C.P.BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730620.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES, RNK1MIN AND FLEMIN, FOR
     MINIMIZING A GIVEN DIFFERENTIABLE FUNCTION OF SEVERAL VARIABLES;
     BOTH PROCEDURES USE A VARIABLE METRIC METHOD; THE USER HAS TO
     PROGRAM THE EVALUATION OF THE FUNCTION AND ITS GRADIENT;
     THE CHOICE OF RNK1MIN AND FLEMIN IS DEPENDENT ON THE PROBLEM
     INVOLVED; IF THE NUMBER OF VARIABLES OF THE FUNCTION TO BE
     MINIMIZED IS VERY LARGE AND THE CALCULATION OF THE FUNCTION AND ITS
     GRADIENT IS RELATIVELY CHEAP (THE NUMBER OF ARITHMETIC OPERATIONS
     IS OF ORDER AT MOST N ** 2),THEN THE USER IS ADVISED TO USE FLEMIN;
     IF THE HESSIAN OF THE FUNCTION IS EXPECTED TO BE (ALMOST) SINGULAR
     AT THE MINIMUM, THEN RNK1MIN IS PREFERRED;
 
 
 KEYWORDS:
 
     OPTIMIZATION,
     HIGHER - DIMENSIONAL,
     UNCONSTRAINED,
     VARIABLE METRIC METHOD.
 
 
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION: RNK1MIN.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "REAL" "PROCEDURE" RNK1MIN(N, X, G, H, FUNCT, IN, OUT);
     "VALUE" N; "INTEGER" N;
     "ARRAY" X, G, H, IN, OUT;
     "REAL" "PROCEDURE" FUNCT;
    "CODE" 34214;
 
     RNK1MIN: DELIVERS THE CALCULATED LEAST VALUE OF THE GIVEN FUNCTION;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF VARIABLES OF THE FUNCTION TO BE MINIMIZED;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1 : N];
             THE INDEPENDENT VARIABLES;
             ENTRY:  AN APPROXIMATION OF A MINIMUM OF THE FUNCTION;
             EXIT:   THE CALCULATED MINIMUM OF THE FUNCTION;
     G:      <ARRAY IDENTIFIER>;
             "ARRAY" G[1 : N];
             EXIT:   THE GRADIENT  OF  THE FUNCTION  AT  THE  CALCULATED
                     MINIMUM;
     H:      <ARRAY IDENTIFIER>;
             "ARRAY" H[1 : N * (N + 1) // 2];
             THE  UPPERTRIANGLE  OF  AN  APPROXIMATION  OF  THE  INVERSE
             HESSIAN IS STORED COLUMNWISE IN H (I.E. THE I,J-TH ELEMENT=
             H[ (J - 1) * J // 2 + I], 1 <= I<= J <= N );
             IF  IN[6] > 0  INITIALIZING OF H WILL BE DONE AUTOMATICALLY
             AND  THE INITIAL APPROXIMATION  OF THE INVERSE HESSIAN WILL
             EQUAL THE UNITMATRIX MULTIPLIED WITH THE VALUE OF IN[6];
             IF IN[6] < 0 NO INITIALIZING OF H WILL BE DONE AND THE USER
             SHOULD GIVE IN  H  AN APPROXIMATION OF THE INVERSE HESSIAN,
             AT THE STARTING POINT;THE UPPERTRIANGLE OF AN APPROXIMATION
             OF  THE  INVERSE  HESSIAN  AT  THE  CALCULATED  MINIMUM  IS
             DELIVERED IN H;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE SHOULD BE:
             "REAL" "PROCEDURE" FUNCT(N, X, G); "VALUE" N;
             "INTEGER" N; "ARRAY" X, G;
             A CALL OF FUNCT MUST EFFECTUATE IN:
             1:  FUNCT BECOMES THE VALUE OF THE FUNCTION TO BE MINIMIZED
                 AT THE POINT X;
             2:  THE VALUE OF G[I], (I = 1, ..., N),  BECOMES  THE VALUE
                 OF THE I - TH COMPONENT OF THE GRADIENT OF THE FUNCTION
                 AT X;
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 3
 
 
 
     IN:     <ARRAY IDENTIFIER>;
             "ARRAY" IN[0 : 8];
             ENTRY:
             IN[0]:  THE MACHINE PRECISION;
                     FOR THE CYBER 73-26 A SUITABLE VALUE IS "-14;
             IN[1]:  THE RELATIVE TOLERANCE FOR THE SOLUTION;
                     THIS TOLERANCE SHOULD  NOT  BE CHOSEN  SMALLER THAN
                     IN[0];
             IN[2]:  THE ABSOLUTE TOLERANCE FOR THE SOLUTION;
             IN[3];  A PARAMETER USED FOR  CONTROLLING LINEMINIMIZATION,
                     ([3], [4]); USUALLY A SUITABLE VALUE IS: 0.0001;
             IN[4]:  THE ABSOLUTE  TOLERANCE  FOR  THE EUCLIDEAN NORM OF
                     THE GRADIENT AT THE SOLUTION;
             IN[5]:  A LOWERBOUND FOR THE FUNCTIONVALUE;
             IN[6]:  THIS PARAMETER  CONTROLS  THE INITIALIZATION OF THE
                     APPROXIMATION  OF  THE  INVERSE  HESSIAN  (METRIC),
                     SEE H; USUALLY THE CHOICE IN[6] = 1  WILL GIVE GOOD
                     RESULTS;
             IN[7]:  THE MAXIMUM ALLOWED NUMBER OF CALLS OF FUNCT;
             IN[8]:  A PARAMETER USED FOR  CONTROLLING  THE UPDATING  OF
                     THE METRIC; IT IS USED  TO AVOID  UNBOUNDEDNESS  OF
                     THE METRIC (SEE: [6], FORMULA (19));
                     THE VALUE OF IN[8] SHOULD SATISFY:
                     SQRT(IN[0] / IN[1]) / N < IN[8] < 1;
                     USUALLY A SUITABLE VALUE WILL BE 0.01;
     OUT:    <ARRAY IDENTIFIER>;
             "ARRAY" OUT[0:4];
             EXIT:
             OUT[0]: THE EUCLIDEAN NORM OF THE PRODUCT OF THE METRIC AND
                     THE GRADIENT AT THE CALCULATED MINIMUM;
             OUT[1]: THE  EUCLIDEAN  NORM   OF   THE  GRADIENT   AT  THE
                     CALCULATED MINIMUM;
             OUT[2]: THE NUMBER OF CALLS OF FUNCT,  NECESSARY  TO ATTAIN
                     THIS RESULT;
             OUT[3]: THE NUMBER OF ITERATIONS  IN WHICH A LINESEARCH WAS
                     NECESSARY;
             OUT[4]: THE NUMBER OF ITERATIONS  IN WHICH A DIRECTION  HAD
                     TO  BE  CALCULATED  WITH  THE METHOD  GIVEN IN [5];
                     IN  SUCH  AN  ITERATION   A    CALCULATION  OF  THE
                     EIGENVALUES  AND  EIGENVECTORS  OF  THE  METRIC  IS
                     NECESSARY.
 
 DATA AND RESULTS:
 
     USUALLY THE CALCULATED SOLUTION WILL SATISFY:
     NORM ( XMIN - XCAL ) < NORM ( XCAL ) * IN[1] + IN[2].
     WHERE AT  XMIN THE GIVEN FUNCTION IS MINIMAL,  XCAL THE  CALCULATED
     APPROXIMATION OF XMIN AND NORM( . ) DENOTES THE EUCLIDEAN NORM
     OF X;  HOWEVER,  WE CANNOT GUARANTEE SUCH A RESULT;  THE CALCULATED
     SOLUTION  POSSIBLY WILL  NOT  SATISFY  THE ABOVE INEQUALITY  IF THE
     PROBLEM IS VERY ILL - CONDITIONED;  THE USER  CAN DISCOVER  SUCH  A
     SITUATION BY LOOKING AT THE EUCLIDEAN NORM OF THE METRIC, DELIVERED
     IN H; THE PROBLEM IS ILL - CONDITIONED IF  THIS  NORM  IS  LARGE
     RELATIVE TO 1.
 
 
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 4
 
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     MATVEC = CP34011,
     TAMVEC = CP34012,
     SYMMATVEC = CP34018,
     INIVEC = CP31010,
     INISYMD = CP31013,
     MULVEC = CP31020,
     DUPVEC = CP31030,
     EIGSYM1 = CP34156,
     LINEMIN = CP34210,
     RNK1UPD = CP34211,
     DAVUPD = CP34212,
     FLEUPD = CP34213.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: VARIES FROM 5 * N + 26 TO
                         N ** 2 + N * (N + 1) // 2 + 5 * N + 35 WORDS.
 
 
 RUNNING TIME:
 
     DEPENDS STRONGLY ON THE PROBLEM TO BE SOLVED;
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     RNK1MIN  CALCULATES  AN APPROXIMATION  OF  A  MINIMUM  OF  A  GIVEN
     FUNCTION  BY  MEANS  OF  A  VARIABLE METRIC METHOD;  THE RANK - ONE
     UPDATING  FORMULA,  USED  IN  THIS  ALGORITHM   IS  GIVEN  IN  [6],
     (FORMULA (4));  TO AVOID  UNBOUNDEDNESS  OF  THE  METRIC (SEE [8]),
     SOMETIMES  A  RANK - TWO UPDATING  FORMULA IS USED  ([3],
     FORMULAS (1) AND (5)); TO AVOID LINESEARCHES AS MUCH AS POSSIBLE  A
     STRATEGY GIVEN IN [4] IS USED;  IF IN AN ITERATION  THE FUNCTION IS
     INCREASING IN THE DIRECTION GIVEN BY THE VARIABLE METRIC ALGORITHM,
     BECAUSE THE METRIC IS NOT POSITIVE DEFINITE, THEN A METHOD GIVEN IN
     [5] IS USED TO CALCULATE A NEW DIRECTION;  THIS METHOD REQUIRES
     THE CALCULATION OF THE EIGENVECTORS  AND EIGENVALUES OF THE METRIC;
     USUALLY,THE NUMBER OF TIMES SUCH A CALCULATION IS NECESSARY IS VERY
     SMALL RELATIVE TO THE NUMBER OF ITERATIONS (AND OFTEN EQUALS ZERO);
     IF THE NUMBER OF VARIABLES  OF THE FUNCTION  IS  VERY LARGE AND THE
     CALCULATION OF THE FUNCTION  AND  ITS GRADIENT  IS RELATIVELY CHEAP
     (THE NUMBER OF ARITHMETICAL OPERATIONS IS OF ORDER AT MOST N ** 2),
     THEN THE USER IS ADVISED TO USE FLEMIN (CP32105);
     A DETAILED DESCRIPTION OF THE ALGORITHM  AND SOME RESULTS ABOUT ITS
     CONVERGENCE IS GIVEN IN [1].
 
 
 
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 5
 
 
 
 SUBSECTION: FLEMIN.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "REAL" "PROCEDURE" FLEMIN(N, X, G, H, FUNCT, IN, OUT);
     "VALUE" N; "INTEGER" N;
     "ARRAY" X, G, H, IN, OUT; "REAL" "PROCEDURE" FUNCT;
    "CODE" 34215;
 
     FLEMIN: DELIVERS THE CALCULATED LEAST VALUE OF THE GIVEN FUNCTION;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF VARIABLES OF THE FUNCTION TO BE MINIMIZED;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[1 : N];
             THE INDEPENDENT VARIABLES;
             ENTRY:  AN APPROXIMATION OF A MINIMUM OF THE FUNCTION;
             EXIT:   THE CALCULATED MINIMUM OF THE FUNCTION;
     G:      <ARRAY IDENTIFIER>;
             "ARRAY" G[1 : N];
             EXIT:   THE GRADIENT  OF  THE  FUNCTION  AT  THE CALCULATED
                     MINIMUM;
     H:      <ARRAY IDENTIFIER>;
             "ARRAY" H[1 : N * (N + 1) // 2];
             THE  UPPERTRIANGLE  OF  AN  APPROXIMATION  OF  THE  INVERSE
             HESSIAN IS STORED COLUMNWISE IN H (I.E. THE I,J-TH ELEMENT=
             H[ (J - 1) * J // 2 + I], 1 <= I <= J <= N);
             IF IN[6] > 0  INITIALIZING OF  H WILL BE DONE AUTOMATICALLY
             AND  THE INITIAL APPROXIMATION  OF THE INVERSE HESSIAN WILL
             EQUAL THE UNITMATRIX MULTIPLIED WITH THE VALUE OF IN[6]; IF
             IN[6] < 0  NO INITIALIZING OF  H  WILL BE DONE AND THE USER
             SHOULD GIVE IN  H  AN APPROXIMATION OF  THE INVERSE HESSIAN
             AT THE STARTING POINT;
             THE  UPPERTRIANGLE  OF  AN  APPROXIMATION  OF  THE  INVERSE
             HESSIAN AT THE CALCULATED MINIMUM IS DELIVERED IN H;
     FUNCT:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE SHOULD BE :
             "REAL" "PROCEDURE" FUNCT(N, X, G); "VALUE" N;
             "INTEGER" N; "ARRAY" X, G;
             A CALL OF FUNCT SHOULD EFFECTUATE IN:
             1:  FUNCT BECOMES THE VALUE OF THE FUNCTION TO BE MINIMIZED
                 AT THE POINT X;
             2:  THE VALUE OF G[I], (I = 1, ..., N),  BECOMES  THE VALUE
                 OF THE I - TH COMPONENT OF THE GRADIENT OF THE FUNCTION
                 AT X;
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 6
 
 
 
     IN:     <ARRAY IDENTIFIER>;
             "ARRAY" IN[1 : 7];
             ENTRY:
             IN[1]:  THE RELATIVE TOLERANCE FOR THE SOLUTION;
             IN[2]:  THE ABSOLUTE TOLERANCE FOR THE SOLUTION;
             IN[3]:  A PARAMETER  USED FOR CONTROLLING LINEMINIMIZATION
                     ([3], [4]); USUALLY A SUITABLE VALUE IS 0.0001;
             IN[4]:  THE ABSOLUTE TOLERANCE  FOR  THE EUCLIDEAN  NORM OF
                     THE GRADIENT AT THE SOLUTION;
             IN[5]:  A LOWERBOUND FOR THE FUNCTION VALUE;
             IN[6]:  THIS  PARAMETER  CONTROLS THE INITIALIZATION OF THE
                     APPROXIMATION OF THE INVERSE HESSIAN (METRIC) (SEE
                     H); USUALLY IN[6] = 1 WILL GIVE GOOD RESULTS;
             IN[7]:  THE MAXIMUM ALLOWED NUMBER OF CALLS OF FUNCT;
     OUT:    <ARRAY IDENTIFIER>;
             "ARRAY" OUT[0:4];
             EXIT:
             OUT[0]: THE EUCLIDEAN NORM OF THE PRODUCT OF THE METRIC AND
                     THE GRADIENT AT THE CALCULATED MINIMUM;
             OUT[1]: THE  EUCLIDEAN  NORM    OF  THE  GRADIENT  AT   THE
                     CALCULATED MINIMUM;
             OUT[2]: THE NUMBER OF CALLS OF FUNCT,  NECESSARY  TO ATTAIN
                     THESE RESULTS;
             OUT[3]: THE NUMBER OF ITERATIONS IN WHICH A LINESEARCH  WAS
                     NECESSARY;
             OUT[4]: IF OUT[4] = - 1,  THEN  THE  PROCESS  IS BROKEN OFF
                     BECAUSE  NO DOWNHILL DIRECTION COULD BE CALCULATED;
                     THE PRECISION  ASKED FOR MAY NOT BE ATTAINED AND IS
                     POSSIBLY CHOSEN TOO HIGH;
                     NORMALLY OUT[4] = 0;
 
 
 DATA AND RESULTS:
 
     USUALLY THE CALCULATED SOLUTION WILL SATISFY:
     NORM ( XMIN - XCAL ) < NORM ( XCAL ) * IN[1] + IN[2].
     WHERE AT XMIN THE GIVEN FUNCTION IS MINIMAL,  XCAL THE  CALCULATED
     APPROXIMATION OF XMIN AND NORM ( . )  DENOTES THE EUCLIDEAN  NORM
     OF X;  HOWEVER, WE CAN NOT GUARANTEE SUCH A RESULT;  THE CALCULATED
     SOLUTION POSSIBLY WILL NOT SATISFY  THE  ABOVE  INEQUALITY  IF  THE
     PROBLEM IS VERY ILL - CONDITIONED;  THE  USER  CAN  DISCOVER SUCH A
     SITUATION BY LOOKING AT THE EUCLIDEAN NORM OF THE METRIC, DELIVERED
     IN H;  THE  PROBLEM IS ILL - CONDITIONED  IF  THIS  NORM  IS  LARGE
     RELATIVE TO 1.
 
 
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 7
 
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     ELMVEC = CP34020,
     SYMMATVEC = CP34018,
     INIVEC = CP31010,
     INISYMD = CP31013,
     MULVEC = CP31020,
     DUPVEC = CP31030,
     LINEMIN = CP34210,
     DAVUPD = CP34212,
     FLEUPD = CP34213.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: 3 * N + 19 WORDS.
 
 
 RUNNING TIME:
 
     DEPENDS STRONGLY ON THE PROBLEM TO BE SOLVED;
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     FLEMIN CALCULATES AN APPROXIMATION OF A MINIMUM OF A GIVEN FUNCTION
     BY MEANS OF THE VARIABLE METRIC ALGORITHM GIVEN IN [3],  EXCEPT FOR
     SOME DETAILS (SEE [1]).
 
 REFERENCES:
     [1] BUS, J. C. P.
         MINIMIZATION OF FUNCTIONS OF SEVERAL VARIABLES (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, NR 29/72 (1972).
     [2] DAVIDON, W. C.
         VARIABLE METRIC METHOD FOR MINIMIZATION.
         ARGONNE NAT. LAB. REPORT, ANL 5990 (1959).
     [3] FLETCHER, R.
         A NEW APPROACH TO VARIABLE METRIC ALGORITHMS.
         COMP. J. 6, (1963), P.163 - 168.
     [4] GOLDSTEIN, A. A. AND PRICE, J. F.
         AN EFFECTIVE ALGORITHM FOR MINIMIZATION.
         NUMER. MATH. 10, (1967), P.184 - 189.
     [5] GREENSTADT, J. L.
         ON THE RELATIVE EFFICIENCIES OF GRADIENT METHODS.
         MATH. COMP. 21, (1967), P.360 - 367.
     [6] POWELL, M. J. D.
         RANK ONE METHODS FOR UNCONSTRAINED OPTIMIZATION.
         IN: ABADIE, J. (ED.)
             INTEGER AND NONLINEAR PROGRAMMING.
             NORTH - HOLLAND, (1970).
 
 
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 8
 
 
 
 
 EXAMPLE OF USE:
 
     THE MINIMUM OF THE FUNCTION:
     F(X) = (X[2] - X[1] ** 2) ** 2 * 100 + (1 - X[1]) ** 2,
     CALCULATED WITH BOTH  RNK1MIN  AND  FLEMIN  MAY  BE OBTAINED BY THE
     FOLLOWING PROGRAM:
 
 "BEGIN"
     "REAL" "PROCEDURE" ROSENBROCK(N, X, G); "VALUE" N;
     "INTEGER" N; "ARRAY" X, G;
     "BEGIN" ROSENBROCK:= (X[2] - X[1] ** 2) ** 2 * 100
         + (1 - X[1]) ** 2;
         G[1]:= ((X[1] ** 2 - X[2]) * 400 + 2) * X[1] - 2;
         G[2]:=(X[2] - X[1] ** 2) * 200
     "END" ROSENBROCK;
     "INTEGER" I; "BOOLEAN" AGAIN; "REAL" F;
     "ARRAY" X, G[1:2], H[1:3], IN[0:8], OUT[0:4];
 
     IN[0]:= "-14; IN[1]:= "-5; IN[2]:= "-5; IN[3]:= "-4;
     IN[4]:= "-5; IN[5]:= -10; IN[6]:= 1; IN[7]:= 100; IN[8]:= 0.01;
     X[1]:= -1.2; X[2]:= 1; AGAIN:= "TRUE";
     F:= RNK1MIN(2, X, G, H, ROSENBROCK, IN, OUT);
     "GOTO" PRINT;
 NEXT: X[1]:= -1.2; X[2]:= 1; AGAIN:= "FALSE";
     F:= FLEMIN(2, X, G, H, ROSENBROCK, IN, OUT);
 PRINT: OUTPUT(61, "(""("LEAST VALUE:")"B+.15D"+3D,//, "("X:")",
     2(B+.15D"+3DB),//,"("GRADIENT:")", 2(B+.15D"+3DB),//, "("METRIC:")"
     ,2(B+.15D"+3DB),/,32B+.15D"+3D,//,"("OUT:")", 5(B+.15D"+3DB,/),///
     ")",F, X[1], X[2], G[1], G[2], H[1], H[2], H[3], OUT[0], OUT[1],
     OUT[2], OUT[3], OUT[4]);
     "IF" AGAIN "THEN" "GOTO" NEXT
 "END"
 
     DELIVERS:
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                     PAGE 9
 
 
 
     LEAST VALUE: +.200699798801180"-018
 
     X: +.999999999944840"+000  +.999999999845220"+000
 
     GRADIENT: +.176731305145950"-007  -.889173179530190"-008
 
     METRIC: +.499982414863250"+000  +.999957383810230"+000
                                     +.200489757679290"+001
 
     OUT: +.164157123774660"-009
          +.197838933606480"-007
          +.550000000000000"+002
          +.800000000000000"+001
          +.400000000000000"+001
 
 
 
     LEAST VALUE: +.811973499921290"-016
 
     X: +.999999999758770"+000  +.999999998616780"+000
 
     GRADIENT: +.359826657359010"-006  -.180154557938290"-006
 
     METRIC: +.501085356975550"+000  +.100198139199600"+001
                                     +.200861655543510"+001
 
     OUT: +.133802289387830"-008
          +.402406371833370"-006
          +.440000000000000"+002
          +.700000000000000"+001
          +.000000000000000"+000
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                    PAGE 10
 
 
 
 SOURCE TEXT(S):
0"CODE" 34214;
     "REAL" "PROCEDURE" RNK1MIN(N, X, G, H, FUNCT, IN, OUT);
     "VALUE" N;
     "INTEGER" N; "ARRAY" X, G, H, IN, OUT;
     "REAL" "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" I, IT, N2, CNTL, CNTE, EVL, EVLMAX;
         "BOOLEAN" OK;
         "REAL" F, F0, FMIN, MU, DG, DG0, GHG, GS, NRMDELTA, ALFA,
         MACHEPS, RELTOL, ABSTOL, EPS, TOLG, ORTH, AID;
         "ARRAY" V, DELTA, GAMMA, S, P[1:N];
 
         MACHEPS:= IN[0]; RELTOL:= IN[1]; ABSTOL:= IN[2];
         MU:= IN[3]; TOLG:= IN[4]; FMIN:= IN[5]; IT := 0;
         ALFA:= IN[6]; EVLMAX:= IN[7]; ORTH:= IN[8];
         N2:= N * (N + 1) // 2; CNTL:= CNTE:= 0; "IF" ALFA > 0 "THEN"
         "BEGIN" INIVEC(1, N2, H, 0); INISYMD(1, N, 0, H, ALFA) "END";
         F:= FUNCT(N, X, G); EVL:= 1; DG:= SQRT(VECVEC(1, N, 0, G, G));
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         DELTA[I]:= - SYMMATVEC(1, N, I, H, G);
         NRMDELTA:= SQRT(VECVEC(1, N, 0, DELTA, DELTA));
         DG0:= VECVEC(1, N, 0, DELTA, G); OK:= DG0 < 0;
         EPS:= SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL;
         "FOR" IT:= IT + 1  "WHILE"
         (NRMDELTA > EPS "OR" DG > TOLG "OR" ^ OK) "AND" EVL < EVLMAX
         "DO"
         "BEGIN" "IF" ^OK "THEN"
             "BEGIN" "ARRAY" VEC[1:N,1:N], TH[1:N2], EM[0:9];
                 EM[0]:= MACHEPS; EM[2]:= AID:= SQRT(MACHEPS * RELTOL);
                 EM[4]:= ORTH; EM[6]:= AID * N; EM[8]:= 5;
                 CNTE:= CNTE + 1; DUPVEC(1, N2, 0, TH, H);
                 EIGSYM1(TH,N,N,V,VEC,EM);
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" AID:= - TAMVEC(1, N, I, VEC, G);
                     S[I]:= AID * ABS(V[I]); V[I]:= AID * SIGN(V[I])
                 "END"
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                    PAGE 11
                                                                 ;
 
 
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" DELTA[I]:= MATVEC(1, N, I, VEC, S);
                     P[I]:= MATVEC(1, N, I, VEC, V)
                 "END";
                 DG0:= VECVEC(1, N, 0, DELTA, G);
                 NRMDELTA:= SQRT(VECVEC(1, N, 0, DELTA, DELTA))
             "END" CALCULATING GREENSTADTS DIRECTION;
             DUPVEC(1, N, 0, S, X); DUPVEC(1, N, 0, V, G);
             "IF" IT > N "THEN" ALFA:= 1 "ELSE"
             "BEGIN" "IF" IT ^= 1 "THEN" ALFA:= ALFA / NRMDELTA "ELSE"
                 "BEGIN" ALFA:= 2 * (FMIN - F) / DG0;
                 "IF" ALFA > 1 "THEN" ALFA:= 1
                 "END"
             "END";
             ELMVEC(1, N, 0, X, DELTA, ALFA);
             F0:= F; F:= FUNCT(N, X, G); EVL:= EVL +1 ;
             DG:= VECVEC(1, N, 0, DELTA, G);
             "IF" IT = 1 "OR" F0 - F < -MU * DG0 * ALFA "THEN"
             "BEGIN" I:= EVLMAX - EVL; CNTL:= CNTL +1 ;
                 LINEMIN(N, S, DELTA, NRMDELTA, ALFA, G, FUNCT, F0, F,
                 DG0, DG, I, "FALSE", IN); EVL:= EVL + I;
                 DUPVEC(1, N, 0, X, S);
             "END" LINEMINIMIZATION;
             DUPVEC(1, N, 0, GAMMA, G); ELMVEC(1, N, 0, GAMMA, V, -1);
             "IF" ^ OK "THEN" MULVEC(1, N, 0, V, P, -1);
             DG:= DG - DG0; "IF" ALFA ^= 1 "THEN"
             "BEGIN" MULVEC(1, N, 0, DELTA, DELTA, ALFA);
                 MULVEC(1, N, 0, V, V, ALFA);
                 NRMDELTA:= NRMDELTA * ALFA; DG:= DG * ALFA
             "END";
             DUPVEC(1, N, 0, P, GAMMA); ELMVEC(1, N, 0, P, V, 1);
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             V[I]:= SYMMATVEC(1, N, I, H, GAMMA);
             DUPVEC(1, N, 0, S, DELTA); ELMVEC(1, N, 0, S, V, -1);
             GS:= VECVEC(1, N, 0, GAMMA, S);
             GHG:= VECVEC(1, N, 0, V, GAMMA);
             AID:= DG / GS;
             "IF" VECVEC(1, N, 0, DELTA, P) ** 2 > VECVEC(1, N, 0, P, P)
             * (ORTH * NRMDELTA) ** 2 "THEN" RNK1UPD(H, N, S, 1 / GS)
             "ELSE" "IF" AID >= 0 "THEN"
             FLEUPD(H, N, DELTA, V, 1 / DG, (1 + GHG / DG) / DG) "ELSE"
             DAVUPD(H, N, DELTA, V, 1 / DG, 1 / GHG);
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             DELTA[I]:= -SYMMATVEC(1, N, I, H, G);
             ALFA:= NRMDELTA;
             NRMDELTA:= SQRT(VECVEC(1, N, 0, DELTA, DELTA));
             EPS:= SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL;
             DG:= SQRT(VECVEC(1, N, 0, G, G));
             DG0:= VECVEC(1, N, 0, DELTA, G); OK:= DG0 <= 0
         "END" ITERATION;
         OUT[0]:= NRMDELTA; OUT[1]:= DG; OUT[2]:= EVL;
         OUT[3]:= CNTL; OUT[4]:= CNTE; RNK1MIN:= F
     "END" RNK1MIN
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                    PAGE 12
 
                                                                  ;
         "EOP"
0"CODE" 34215;
     "REAL" "PROCEDURE" FLEMIN(N, X, G, H, FUNCT, IN, OUT);
     "VALUE" N;
     "INTEGER" N; "ARRAY" X, G, H, IN, OUT;
     "REAL" "PROCEDURE" FUNCT;
     "BEGIN" "INTEGER" I, IT, CNTL, EVL, EVLMAX;
         "REAL" F,F0,FMIN,MU,DG,DG0,NRMDELTA,ALFA,RELTOL,ABSTOL,
         EPS, TOLG, AID;
         "ARRAY" V, DELTA, S[1:N];
 
         RELTOL:= IN[1]; ABSTOL:= IN[2]; MU:= IN[3];
         TOLG:= IN[4]; FMIN:= IN[5]; ALFA:= IN[6];
         EVLMAX:= IN[7]; OUT[4]:= 0; IT := 0;
         F:= FUNCT(N, X, G); EVL:= 1; CNTL:= 0;"IF" ALFA > 0 "THEN"
         "BEGIN" INIVEC(1, N * (N + 1) // 2, H, 0);
             INISYMD(1, N, 0, H, ALFA)
         "END";
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         DELTA[I]:= - SYMMATVEC(1, N, I, H, G);
         DG:= SQRT(VECVEC(1, N, 0, G, G));
         NRMDELTA:= SQRT(VECVEC(1, N, 0, DELTA, DELTA));
         EPS:= SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL;
         DG0:= VECVEC(1, N, 0, DELTA, G);"COMMENT"
1SECTION : 5.1.2.2.3          (DECEMBER 1975)                    PAGE 13
                                                                 ;
 
 
         "FOR" IT := IT +1  "WHILE"
         (NRMDELTA > EPS "OR" DG > TOLG ) "AND" EVL < EVLMAX "DO"
         "BEGIN" DUPVEC(1, N, 0, S, X); DUPVEC(1, N, 0, V, G);
             "IF" IT >= N "THEN" ALFA:= 1 "ELSE"
             "BEGIN" "IF" IT ^= 1 "THEN" ALFA:= ALFA / NRMDELTA "ELSE"
                 "BEGIN" ALFA:= 2 * (FMIN - F) / DG0;
                     "IF" ALFA > 1 "THEN" ALFA:= 1
                 "END"
             "END";
             ELMVEC(1, N, 0, X, DELTA, ALFA);
             F0:= F; F:= FUNCT(N, X, G); EVL:= EVL +1 ;
             DG:= VECVEC(1, N, 0, DELTA, G);
             "IF" IT = 1 "OR" F0 - F < - MU * DG0 * ALFA "THEN"
             "BEGIN" I:= EVLMAX - EVL; CNTL:= CNTL +1 ;
                 LINEMIN(N, S, DELTA, NRMDELTA, ALFA, G, FUNCT, F0, F,
                 DG0, DG, I, "FALSE", IN); EVL:= EVL + I;
                 DUPVEC(1, N, 0, X, S);
             "END" LINEMINIMIZATION;
             "IF" ALFA ^= 1 "THEN" MULVEC(1, N, 0, DELTA, DELTA, ALFA);
             MULVEC(1, N, 0, V, V, -1); ELMVEC(1, N, 0, V, G, 1);
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             S[I]:= SYMMATVEC(1, N, I, H, V);
             AID:= VECVEC(1, N, 0, V, S); DG:= (DG - DG0) * ALFA;
             "IF" DG > 0 "THEN"
             "BEGIN" "IF" DG >= AID "THEN"
                 FLEUPD(H, N, DELTA, S, 1 / DG, (1 + AID / DG) / DG)
                 "ELSE" DAVUPD(H, N, DELTA, S, 1 / DG, 1 / AID)
             "END" UPDATING;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             DELTA[I]:= -SYMMATVEC(1, N, I, H, G);
             ALFA:= NRMDELTA * ALFA;
             NRMDELTA:= SQRT(VECVEC(1, N, 0, DELTA, DELTA));
             EPS:= SQRT(VECVEC(1, N, 0, X, X)) * RELTOL + ABSTOL;
             DG:= SQRT(VECVEC(1, N, 0, G, G));
             DG0:= VECVEC(1, N, 0, DELTA, G); "IF" DG0 > 0 "THEN"
             "BEGIN" OUT[4]:= -1 ; "GOTO" EXIT "END"
         "END" ITERATION;
     EXIT: OUT[0]:= NRMDELTA; OUT[1]:= DG; OUT[2]:= EVL;
         OUT[3]:= CNTL; FLEMIN:= F
     "END" FLEMIN;
         "EOP"
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHORS: J.C.P. BUS, B. VAN DOMSELAAR, J. KOK.
 
 
 CONTRIBUTORS:  B. VAN DOMSELAAR, J. KOK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED:  741101.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES;
     MARQUARDT CALCULATES THE LEAST SQUARES SOLUTION OF AN
     OVERDETERMINED SYSTEM OF NONLINEAR EQUATIONS WITH MARQUARDT'S
     METHOD;
     GSSNEWTON CALCULATES THE LEAST SQUARES SOLUTION OF AN
     OVERDETERMINED SYSTEM OF NONLINEAR EQUATIONS WITH THE GAUSS-NEWTON
     METHOD;
     THE USER HAS TO PROGRAM THE EVALUATION OF THE RESIDUAL VECTOR OF
     THE SYSTEM AND THE JACOBIAN MATRIX OF ITS PARTIAL DERIVATIVES.
 
 
 KEYWORDS:
 
     NONLINEAR EQUATIONS,
     LEAST SQUARES SOLUTION,
     OVERDETERMINED SYSTEM,
     MARQUARDT'S METHOD,
     GAUSS-NEWTON METHOD,
     CURVE FITTING.
 
 
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION: MARQUARDT.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" MARQUARDT(M, N, PAR, RV, JJINV, FUNCT, JACOBIAN, IN,
        OUT); "VALUE" M, N; "INTEGER" M, N;
     "ARRAY" PAR, RV, JJINV, IN, OUT; "BOOLEAN" "PROCEDURE" FUNCT;
     "PROCEDURE" JACOBIAN;
     "CODE" 34440;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     M:        <ARITHMETIC EXPRESSION>;
               THE NUMBER OF EQUATIONS;
     N:        <ARITHMETIC EXPRESSION>;
               THE NUMBER OF UNKNOWN VARIABLES; N SHOULD SATISFY N<=M;
     PAR:      <ARRAY IDENTIFIER>;
               "ARRAY" PAR[1 : N];
               THE UNKNOWN VARIABLES OF THE SYSTEM;
               ENTRY: AN APPROXIMATION TO A LEAST SQUARES SOLUTION
                      OF THE SYSTEM;
               EXIT:  THE CALCULATED LEAST SQUARES SOLUTION;
     RV:       <ARRAY IDENTIFIER>;
               "ARRAY" RV[1 : M];
               EXIT:  THE RESIDUAL VECTOR AT  THE CALCULATED SOLUTION;
     JJINV:    <ARRAY IDENTIFIER>;
               "ARRAY" JJINV[1 : N, 1 : N];
               EXIT:  THE INVERSE OF THE MATRIX  J' * J  WHERE J DENOTES
                      THE MATRIX OF PARTIAL DERIVATIVES DRV[I] / DPAR[J]
                      (I=1,...,M; J=1,...,N) AND  J'  DENOTES THE
                      TRANSPOSE OF J.
     FUNCT:    <PROCEDURE IDENTIFIER>;
               THE HEADING OF THIS PROCEDURE SHOULD BE:
               "BOOLEAN" "PROCEDURE" FUNCT(M, N, PAR, RV); "VALUE" M, N;
               "INTEGER" M, N; "ARRAY" PAR, RV;
               ENTRY: M, N, PAR;
                      M, N  HAVE THE SAME MEANING AS IN THE PROCEDURE
                      MARQUARDT;
                      "ARRAY" PAR[1:N] CONTAINS THE CURRENT VALUES OF
                      THE UNKNOWNS AND SHOULD NOT BE ALTERED;
               EXIT:  "ARRAY" RV[1 : M];
                      UPON COMPLETION OF A CALL OF FUNCT, THIS ARRAY  RV
                      SHOULD CONTAIN THE RESIDUAL VECTOR, OBTAINED WITH
                      THE CURRENT VALUES OF THE UNKNOWNS;
                      E.G. IN CURVE FITTING PROBLEMS:
                      RV[I] := THEORETICAL VALUE  F(X[I], PAR) -
                              OBSERVED VALUE  Y[I];
               AFTER A SUCCESSFUL CALL OF FUNCT, THE BOOLEAN PROCEDURE
               SHOULD DELIVER THE VALUE TRUE;
               HOWEVER, IF FUNCT DELIVERS THE VALUE FALSE, THEN IT IS
               ASSUMED THAT THE CURRENT ESTIMATES OF THE UNKNOWNS LIE
               OUTSIDE A FEASIBLE REGION AND THE PROCESS IS TERMINATED
               (SEE OUT[1]);
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 3
 
 
 
               HENCE, PROPER PROGRAMMING OF FUNCT MAKES IT POSSIBLE TO
               AVOID CALCULATION OF A RESIDUAL VECTOR WITH VALUES OF THE
               UNKNOWN VARIABLES WHICH MAKE NO SENSE OR WHICH EVEN MAY
               CAUSE OVERFLOW IN THE COMPUTATION;
     JACOBIAN: <PROCEDURE IDENTIFIER>;
               THE HEADING OF THIS PROCEDURE SHOULD BE:
               "PROCEDURE" JACOBIAN(M, N, PAR, RV, JAC, LOCFUNCT);
               "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, RV, JAC;
               "PROCEDURE" LOCFUNCT;
               ENTRY: M, N, PAR, RV, LOCFUNCT;
                      FOR M,N,PAR SEE: FUNCT;
                      RV CONTAINS THE RESIDUAL VECTOR OBTAINED WITH THE
                      CURRENT VALUES OF THE UNKNOWNS AND SHOULD NOT BE
                      ALTERED;
                      A CALL OF LOCFUNCT(M,N,PAR,RV) IS EQUIVALENT WITH
                      A CALL OF THE USER-DEFINED PROCEDURE
                      FUNCT(M,N,PAR,RV), BUT, IN ADDITION, THIS CALL IS
                      COUNTED TO THE TOTAL NUMBER OF CALLS OF FUNCT
                      (SEE OUT[4]) AND, MOREOVER, IF FUNCT DELIVERS THE
                      VALUE FALSE THEN THE PROCESS IS TERMINATED;
               EXIT:  "ARRAY" JAC[1 : M, 1 : N];
                      UPON COMPLETION OF A CALL OF JACOBIAN, JAC SHOULD
                      CONTAIN THE PARTIAL DERIVATIVES  DRV[I] / DPAR[J],
                      OBTAINED WITH THE CURRENT VALUES OF THE UNKNOWN
                      VARIABLES GIVEN IN PAR[1:N];
               IT IS A PREREQUISITE FOR THE PROPER OPERATION OF THE
               PROCEDURE MARQUARDT THAT THE PRECISION OF THE ELEMENTS OF
               THE MATRIX JAC  IS AT LEAST THE PRECISION DEFINED BY
               IN[3] AND IN[4];
     IN:       <ARRAY IDENTIFIER>;
               "ARRAY" IN[0 : 6];
               ENTRY:  IN THIS ARRAY THE USER SHOULD GIVE SOME DATA TO
               CONTROL THE PROCESS;
               IN[0]:  THE MACHINE PRECISION;
                       FOR THE CYBER 73 A SUITABLE VALUE IS "-14;
               IN[1], IN[2] ARE NOT USED BY THE PROCEDURE  MARQUARDT;
               IN[3], IN[4]:
                       THE RELATIVE AND ABSOLUTE TOLERANCE FOR THE
                       DIFFERENCE BETWEEN THE EUCLIDEAN NORM OF THE
                       ULTIMATE AND PENULTIMATE RESIDUAL VECTOR;
                       THE PROCESS IS TERMINATED IF THE IMPROVEMENT OF
                       THE SUM OF SQUARES IS LESS THAN
                       IN[3] * (SUM OF SQUARES) + IN[4] * IN[4];
                       THESE TOLERANCES SHOULD BE CHOSEN GREATER THAN
                       THE CORRESPONDING ERRORS OF THE CALCULATED
                       RESIDUAL VECTOR;
                       NOTE THAT THE EUCLIDEAN NORM OF THE RESIDUAL
                       VECTOR IS DEFINED AS THE SQUARE ROOT OF THE SUM
                       OF SQUARES;
               IN[5]:  THE MAXIMUM NUMBER OF CALLS OF FUNCT ALLOWED;
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 4
 
 
 
               IN[6]:  A STARTING VALUE USED FOR THE RELATION BETWEEN
                       THE GRADIENT AND THE GAUSS-NEWTON DIRECTION (SEE
                       [2]);  IF THE PROBLEM IS WELL CONDITIONED THEN A
                       SUITABLE VALUE FOR IN[6] WILL BE  0.01; IF THE
                       PROBLEM IS ILL CONDITIONED THEN IN[6] SHOULD BE
                       GREATER, BUT THE VALUE OF IN[6] SHOULD SATISFY:
                       IN[0] < IN[6] <= 1/IN[0];
     OUT:      <ARRAY IDENTIFIER>; "ARRAY" OUT[1 : 7];
               EXIT :  IN ARRAY  OUT  SOME BY-PRODUCTS ARE DELIVERED;
               OUT[1]: THIS VALUE GIVES INFORMATION ABOUT THE
                       TERMINATION OF THE PROCESS;
                       OUT[1]=0:  NORMAL TERMINATION;
                       OUT[1]=1:  THE PROCESS HAS BEEN BROKEN OFF,
                                  BECAUSE THE NUMBER OF CALLS OF FUNCT
                                  EXCEEDED THE NUMBER GIVEN IN IN[5];
                       OUT[1]=2:  THE PROCESS HAS BEEN BROKEN OFF,
                                  BECAUSE A CALL OF FUNCT DELIVERED THE
                                  VALUE FALSE;
                       OUT[1]=3:  FUNCT BECAME FALSE WHEN CALLED WITH
                                  THE INITIAL ESTIMATES OF PAR[1:N];
                                  THE ITERATION PROCESS WAS NOT STARTED
                                  AND SO JJINV[1:N,1:N] CAN NOT BE USED;
                       OUT[1]=4:  THE PROCESS HAS BEEN BROKEN OFF,
                                  BECAUSE THE PRECISION ASKED FOR CAN
                                  NOT BE ATTAINED; THIS PRECISION IS
                                  POSSIBLY CHOSEN TOO HIGH, RELATIVE TO
                                  THE PRECISION IN WHICH THE RESIDUAL
                                  VECTOR IS CALCULATED (SEE IN[3]);
               OUT[2]: THE EUCLIDEAN NORM OF THE RESIDUAL VECTOR
                       CALCULATED WITH VALUES OF THE UNKNOWNS DELIVERED;
               OUT[3]: THE EUCLIDEAN NORM OF THE RESIDUAL VECTOR
                       CALCULATED WITH THE INITIAL VALUES OF THE
                       UNKNOWN VARIABLES;
               OUT[4]: THE NUMBER OF CALLS OF FUNCT NECESSARY TO OBTAIN
                       THE CALCULATED RESULT;
               OUT[5]: THE TOTAL NUMBER OF ITERATIONS PERFORMED; NOTE
                       THAT IN EACH ITERATION ONE EVALUATION OF THE
                       JACOBIAN MATRIX HAD TO BE MADE;
               OUT[6]: THE  IMPROVEMENT OF THE EUCLIDEAN NORM OF THE
                       RESIDUAL VECTOR IN THE LAST ITERATION STEP;
               OUT[7]: THE CONDITION NUMBER OF  J' * J , I.E. THE RATIO
                       OF ITS LARGEST TO SMALLEST EIGENVALUES;
 
 DATA AND RESULTS:
 
     IF THIS PROCEDURE IS USED FOR CURVE FITTING THEN THE RELATIVE
     ACCURACY IN THE CALCULATION OF THE RESIDUAL VECTOR DEPENDS STRONGLY
     ON THE ERRORS IN THE EXPERIMENTAL DATA AND THIS SHOULD BE REFLECTED
     IN THE PARAMETERS IN[3] AND IN[4];
     THE MATRIX  JJINV  CAN BE USED IF SOME STATISTICAL INFORMATION
     ABOUT THE FITTED PARAMETERS IS REQUIRED; THE STANDARD DEVIATION,
     COVARIANCE MATRIX AND CORRELATION MATRIX MAY BE CALCULATED EASILY
     FROM  JJINV ;
 
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 5
 
 
 
 PROCEDURES USED:
 
     MULCOL = CP31022,
     DUPVEC = CP31030,
     VECVEC = CP34010,
     MATVEC = CP34011,
     TAMVEC = CP34012,
     MATTAM = CP34015,
     QRISNGVALDEC = CP34273.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: ONE ARRAY OF LENGTH  M * N  AND FOUR
                             ARRAYS OF LENGTH  N  ARE DECLARED;
 
 
 RUNNING TIME:
 
     THE NUMBER OF ITERATION STEPS DEPENDS STRONGLY ON THE PROBLEM TO BE
     SOLVED; HOWEVER, THE WORK DONE EACH ITERATION STEP IS PROPORTIONAL
     TO N CUBED;
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     MARQUARDT USES MARQUARDT'S METHOD; FOR DETAILS SEE [2];
 
 
 
 REFERENCES:
 
     [1] D. W. MARQUARDT,
         AN ALGORITHM FOR LEAST-SQUARES ESTIMATION OF NONLINEAR
         PARAMETERS,
         J. SIAM 11 (1963), PP.431-441.
 
     [2] J. C. P. BUS, B. VAN DOMSELAAR, J. KOK,
         NONLINEAR LEAST SQUARES ESTIMATION,
         MATHEMATICAL CENTRE, AMSTERDAM. (TO APPEAR)
 
 
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     THE PARAMETERS PAR[1 : 3] IN THE CURVE FITTING PROBLEM:
     RV[I] = PAR[1] + PAR[2] * EXP(PAR[3] * X[I]) - Y[I]
     WITH  (X[I], Y[I]), I=1,...,6  AS THE EXPERIMENTAL DATA, MAY BE
     OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
        "INTEGER" I;
        "ARRAY" IN[0:6],OUT[0:7],X,Y,RV[1:6],JJINV[1:3,1:3],PAR[1:3];
 
        "BOOLEAN" "PROCEDURE" EXPFUNCT(M,N,PAR,RV);
            "VALUE" M,N; "INTEGER" M,N; "ARRAY" PAR,RV;
            "BEGIN" "INTEGER" I;
                    "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
                    "BEGIN" "IF" PAR[3]*X[I]>680 "THEN"
                            "BEGIN" EXPFUNCT:="FALSE";
                                    "GOTO" STOP
                            "END";
                            RV[I]:=PAR[1]+PAR[2]*EXP(PAR[3]*X[I])-Y[I]
                    "END"; EXPFUNCT:="TRUE";
                STOP:
           "END" EXPFUNCT;
 
        "PROCEDURE" JACOBIAN(M,N,PAR,RV,JAC,LOCFUNCT);
           "VALUE" M,N; "INTEGER" M,N; "ARRAY" PAR,RV,JAC;
           "PROCEDURE" LOCFUNCT;
           "BEGIN" "INTEGER" I; "REAL" EX;
                   "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
                   "BEGIN" JAC[I,1]:=1;
                           JAC[I,2]:=EX:=EXP(PAR[3]*X[I]);
                           JAC[I,3]:=X[I]*PAR[2]*EX
                   "END"
           "END" JACOBIAN;
 
        IN[0]:="-14; IN[3]:="-4; IN[4]:="-1; IN[5]:=75; IN[6]:="-2;
        "FOR" I:=1 "STEP" 1 "UNTIL" 6 "DO"
        "BEGIN" INREAL(70,X[I]); INREAL(70,Y[I]) "END";
        PAR[1]:=580; PAR[2]:=-180; PAR[3]:=-0.160;
        MARQUARDT(6,3,PAR,RV,JJINV,EXPFUNCT,JACOBIAN,IN,OUT);
        OUTPUT(61,"("3/,"("X[I]     Y[I]")",/,6(B,+D,5B,3D.D,/),2/,
        "("PARAMETERS")",/,3(+D.3D"+ZD,/),2/,"("OUT:")",/,7(5B+D.6D"+ZD,
        /),2/,"("LAST RESIDUAL VECTOR")",/,6(6B+3Z.D,/)")",X[1],Y[1],
        X[2],Y[2],X[3],Y[3],X[4],Y[4],X[5],Y[5],X[6],Y[6],PAR[1],PAR[2],
        PAR[3],OUT[7],OUT[2],OUT[6],OUT[3],OUT[4],OUT[5],OUT[1],RV[1],
        RV[2],RV[3],RV[4],RV[5],RV[6])
     "END"
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 7
 
 
 
     WITH THE DATA GIVEN IN THE  X - Y - TABLE THIS PROGRAM DELIVERS:
 
     X[I]     Y[I]
      -5     127.0
      -3     151.0
      -1     379.0
      +1     421.0
      +3     460.0
      +5     426.0
 
 
     PARAMETERS
     +5.232" +2
     -1.568" +2
     -1.998" -1
 
 
     OUT:
          +7.220828" +7
          +1.157156" +2
          +1.728008" -3
          +1.654588" +2
          +2.300000" +1
          +2.200000" +1
          +0.000000" +0
 
 
     LAST RESIDUAL VECTOR
            -29.6
            +86.6
            -47.3
            -26.2
            -22.9
            +39.5
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 8
 
 
 
 SUBSECTION  :  GSSNEWTON.
 
 
 CALLING SEQUENCE    :
 
     THE HEADING OF THE PROCEDURE READS :
 
     "PROCEDURE" GSSNEWTON(M, N, PAR, RV, JJINV, FUNCT, JACOBIAN, IN,
         OUT);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, RV, JJINV, IN, OUT;
     "BOOLEAN""PROCEDURE" FUNCT; "PROCEDURE" JACOBIAN;
     "CODE" 34441;
 
     THE MEANING OF THE FORMAL PARAMETERS IS  :
     M       :   <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF EQUATIONS;
     N       :   <ARITHMETIC EXPRESSION>;
                 THE NUMBER OF UNKNOWNS IN THE M EQUATIONS  (N <= M);
     PAR     :   <ARRAY IDENTIFIER>; "ARRAY" PAR[1 : N];
                 THE UNKNOWNS OF THE EQUATIONS.
                 ENTRY :  AN APPROXIMATION TO A LEAST SQUARES SOLUTION
                     OF THE SYSTEM.
                 EXIT  :  THE CALULATED LEAST SQUARES SOLUTION;
     RV      :   <ARRAY IDENTIFIER>; "ARRAY" RV[1 : M];
                 EXIT  :  THE RESIDUAL VECTOR OF THE SYSTEM AT THE
                     CALCULATED SOLUTION;
     JJINV   :   <ARRAY IDENTIFIER>; "ARRAY" JJINV[1 : N,1 : N];
                 EXIT  :  THE INVERSE OF THE MATRIX  J' * J, WHERE  J
                     IS THE JACOBIAN MATRIX AT THE SOLUTION AND J' IS
                     J TRANSPOSED;
 
     FUNCT :     <PROCEDURE IDENTIFIER>;
                 THE HEADING OF THIS PROCEDURE SHOULD BE :
 
                 "BOOLEAN""PROCEDURE" FUNCT(M, N, PAR, RV); "VALUE" M,
                 N; "INTEGER" M, N; "ARRAY" PAR, RV;
 
                 ENTRY: M, N, PAR;
                      M, N  HAVE THE SAME MEANING AS IN THE PROCEDURE
                      GSSNEWTON;
                      "ARRAY" PAR[1:N] CONTAINS THE CURRENT VALUES OF
                      THE UNKNOWNS AND SHOULD NOT BE ALTERED.
                 EXIT:  "ARRAY" RV[1 : M];
                      UPON COMPLETION OF A CALL OF FUNCT, THIS ARRAY  RV
                      SHOULD CONTAIN THE RESIDUAL VECTOR, OBTAINED WITH
                      THE CURRENT VALUES OF THE UNKNOWNS.
                 THE PROGRAMMER OF FUNCT MAY DECIDE THAT SOME CURRENT
                 ESTIMATES OF THE UNKNOWNS LIE OUTSIDE A FEASIBLE
                 REGION; IN THIS CASE  FUNCT  SHOULD DELIVER THE VALUE
                 FALSE AND THE PROCESS IS TERMINATED (SEE OUT[1]).
                 OTHERWISE  FUNCT  SHOULD DELIVER THE VALUE TRUE;
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                     PAGE 9
 
 
 
     JACOBIAN  : <PROCEDURE IDENTIFIER>;
                 THE HEADING OF THIS PROCEDURE SHOULD BE :
 
                 "PROCEDURE" JACOBIAN(M, N, PAR, RV, JAC, LOCFUNCT);
                 "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, RV, JAC;
                 "PROCEDURE" LOCFUNCT;
 
                 THE MEANING OF THE PARAMETERS OF JACOBIAN IS :
 
                 M, N : SEE GSSNEWTON.
                 PAR : <ARRAY IDENTIFIER>; "ARRAY" PAR[1 : N];
                     ENTRY :  CURRENT ESTIMATES OF THE UNKNOWNS.
                     THESE VALUES SHOULD NOT BE CHANGED.
                 RV  : <ARRAY IDENTIFIER>; "ARRAY" RV[1 : M];
                     ENTRY :  THE RESIDUAL VECTOR OF THE SYSTEM OF
                     EQUATIONS CORRESPONDING TO THE VECTOR OF UNKNOWNS
                     AS GIVEN IN PAR.
                     EXIT  :  THE ENTRY VALUES.
                 JAC : <ARRAY IDENTIFIER>; "ARRAY" JAC[1 : M, 1 : N];
                     EXIT  :  THE JACOBIAN MATRIX AT THE CURRENT
                     ESTIMATES GIVEN IN  PAR, I.E. THE MATRIX OF PARTIAL
                     DERIVATIVES
                     D(RV)[I] / DPAR[J], I = 1(1)M, J = 1(1)N.
                 LOCFUNCT : <PROCEDURE IDENTIFIER>; THE HEADING OF THIS
                     PROCEDURE IS THE SAME AS THE HEADING OF FUNCT.
 
                 A CALL OF THE PROCEDURE JACOBIAN SHOULD DELIVER THE
                 JACOBIAN MATRIX EVALUATED WITH THE CURRENT ESTIMATES
                 OF THE UNKNOWN VARIABLES GIVEN IN  PAR
                 IN SUCH A WAY, THAT THE PARTIAL DERIVATIVE
                 D(RV)[I] / DPAR[J] IS DELIVERED IN JAC[I,J], I = 1(1)M,
                 J = 1(1)N.
                 FOR THE CALCULATION OF THE DERIVATIVES ONE CAN USE THE
                 VALUES OF THE CURRENT ESTIMATES OF THE
                 UNKNOWNS AS GIVEN IN PAR AND THE RESIDUAL VECTOR AS
                 GIVEN IN  RV.
                 ONE CAN ALSO USE THE PROCEDURE  FUNCT
                 (PARAMETER OF GSSNEWTON) THROUGH CALLS OF THE PROCEDURE
                 LOCFUNCT (PARAMETER OF JACOBIAN). THIS PARAMETER OF
                 JACOBIAN MAY BE USED WHEN THE JACOBIAN MATRIX IS
                 APPROXIMATED USING (FORWARD) DIFFERENCES.
                 AN APPROPRIATE PROCEDURE TO THIS PURPOSE IS  JACOBNMF
                 (SECTION 4.3.2.1). SUCH A PROCEDURE MAY BE USED ONLY IF
                 THE MATRIX ELEMENTS ARE COMPUTED SUFFICIENTLY ACCURATE;
 
     IN      :   <ARRAY IDENTIFIER>; "ARRAY" IN[0 : 7];
                 IN THIS ARRAY TOLERANCES AND CONTROL PARAMETERS SHOULD
                 BE GIVEN.
                 ENTRY  :
                 IN[0] : THE MACHINE PRECISION. FOR CALCULATION ON THE
                     CYBER 73 A SUITABLE VALUE IS "-14.
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 10
 
 
 
                 IN[1], IN[2] :
                     RELATIVE AND ABSOLUTE TOLERANCE FOR THE STEP VECTOR
                     (RELATIVE TO THE VECTOR OF CURRENT ESTIMATES IN
                     PAR).
                     THE PROCESS IS TERMINATED IF IN SOME ITERATION (BUT
                     NOT THE FIRST) THE EUCLIDEAN NORM OF THE CALCULATED
                     NEWTON STEP IS LESS THAN IN[1] * NORM(PAR) + IN[2].
                     IN[1] SHOULD NOT BE CHOSEN SMALLER THAN IN[0].
                 IN[3] IS NOT USED BY THE PROCEDURE  GSSNEWTON;
                 IN[4] : ABSOLUTE TOLERANCE FOR THE EUCLIDEAN NORM OF
                     THE RESIDUAL VECTOR. THE PROCESS IS TERMINATED WHEN
                     THIS NORM IS LESS THAN IN[4].
                 IN[5] : THE MAXIMUM ALLOWED NUMBER OF FUNCTION
                     EVALUATIONS (I.E. CALLS OF FUNCT).
                 IN[6] : THE MAXIMUM ALLOWED NUMBER OF HALVINGS OF A
                     CALCULATED NEWTON STEP VECTOR (SEE METHOD AND
                     PERFORMANCE). A SUITABLE VALUE IS 15.
                 IN[7] : THE MAXIMUM ALLOWED NUMBER OF SUCCESSIVE IN[6]
                     TIMES HALVED STEP VECTORS. SUITABLE VALUES ARE 1
                     AND 2;
 
     OUT     :   <ARRAY IDENTIFIER>; "ARRAY" OUT[1 : 9];
                 IN ARRAY OUT INFORMATION ABOUT THE TERMINATION OF THE
                 PROCESS IS DELIVERED.
                 EXIT  :
                 OUT[1] :
                     THE PROCESS WAS TERMINATED BECAUSE (OUT[1] = )
                   1.THE NORM OF THE RESIDUAL VECTOR IS SMALL WITH
                     RESPECT TO IN[4],
                   2.THE CALCULATED NEWTON STEP IS SUFFICIENTLY SMALL
                     (SEE IN[1], IN[2]),
                   3.THE CALCULATED STEP WAS COMPLETELY DAMPED (HALVED)
                     IN  IN[7]  SUCCESSIVE ITERATIONS,
                   4.OUT[4] EXCEEDS IN[5], THE MAXIMUM ALLOWED NUMBER OF
                     CALLS OF FUNCT,
                   5.THE JACOBIAN WAS NOT FULL-RANK (SEE OUT[8]),
                   6.FUNCT DELIVERED FALSE AT A NEW VECTOR OF
                     ESTIMATES OF THE UNKNOWNS,
                   7.FUNCT DELIVERED FALSE IN A CALL FROM JACOBIAN.
                 OUT[2] : THE EUCLIDEAN NORM OF THE LAST RESIDUAL
                     VECTOR.
                 OUT[3] : THE EUCLIDEAN NORM OF THE INITIAL RESIDUAL
                     VECTOR.
                 OUT[4] : THE TOTAL NUMBER OF CALLS OF FUNCT.
                     OUT[4] WILL BE LESS THAN IN[5] + IN[6].
                 OUT[5] : THE TOTAL NUMBER OF ITERATIONS.
                 OUT[6] : THE EUCLIDEAN NORM OF THE LAST STEP VECTOR.
                 OUT[7] : ITERATION NUMBER OF THE LAST ITERATION IN
                     WHICH THE NEWTON STEP WAS HALVED.
                 OUT[8], OUT[9] :
                     RANK AND MAXIMUM COLUMN NORM OF THE JACOBIAN MATRIX
                     IN THE LAST ITERATION, AS DELIVERED BY  LSQORTDEC
                     (SECTION 3.1.1.2.1.1) IN AUX[3] AND AUX[5].
 
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 11
 
 
 
 DATA AND RESULTS    :
 
     THE PROCEDURE GSSNEWTON CAN BE USED FOR APPROXIMATING AN EXACT OR A
     LEAST SQUARES SOLUTION OF A SYSTEM OF NONLINEAR EQUATIONS. WHEN AN
     EXACT SOLUTION IS REQUIRED, THE PROCEDURE MAY TERMINATE ONLY WITH
     OUT[1] = 1, AND VERY SMALL VALUES SHOULD BE ASSIGNED TO IN[1] AND
     IN[2]. WHEN A LEAST SQUARES SOLUTION IS REQUIRED, POSITIVE RESULTS
     OF THE PROCEDURE ARE SIGNALED BY OUT[1] = 1 OR 2. WHENEVER THE
     PROCEDURE TERMINATES WITH OUT[1] < 5, THEN THE INVERSE OF  J' * J
     (SEE MEANING OF THE PARAMETER  JJINV) IS DELIVERED IN  JJINV. IN
     THAT CASE THE COVARIANCE MATRIX AND THE STANDARD DEVIATIONS OF THE
     SOLUTION CAN BE CALCULATED.
 
     FOR A CURVE FITTING PROBLEM, SAY :
        "ESTIMATE PARAMETERS  PAR[1], ... , PAR[N] OF A FUNCTION
        "Y = F(X; PAR[1], ... , PAR[N]), WHEN A SET OF DATA (X[I],Y[I]),
        "I = 1(1)M, HAS TO BE FITTED,"
     THE FOLLOWING SYSTEM OF  M  EQUATIONS IN THE  N  UNKNOWN PARAMETERS
     PAR[1], ... , PAR[N] CAN BE DERIVED :
 
     F(X[I]; PAR[1], ... , PAR[N]) - Y[I] = 0, I = 1(1)M.
 
 PROCEDURES USED :
 
     VECVEC    = CP34010,
     DUPVEC    = CP31030,
     ELMVEC    = CP34020,
     LSQORTDEC = CP34134,
     LSQSOL    = CP34131,
     LSQINV    = CP34136.
 
 REQUIRED CENTRAL MEMORY  :
     EXECUTION FIELD LENGTH :  AN ARRAY OF  (M + 1) * N ELEMENTS, FOUR
     ARRAYS OF  N ELEMENTS AND ONE ARRAY OF  M ELEMENTS ARE DECLARED.
 
 RUNNING TIME    :
     THE RUNNING TIME IS PROPORTIONAL TO THE TOTAL NUMBER OF CALLS OF
     FUNCT. BESIDES, IN EACH ITERATION A LINEAR LEAST SQUARES SYSTEM
     IS SOLVED (NUMBER OF OPERATIONS PROPORTIONAL TO  M * (N SQUARED)).
 
 LANGUAGE    :  ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
     THE PROCEDURE GSSNEWTON IS BASED UPON THE GAUSS-NEWTON METHOD FOR
     CALCULATING A LEAST SQUARES SOLUTION OF A SYSTEM OF NONLINEAR
     EQUATIONS (SEE E.G. [1], [2]). IN SEVERAL ITERATIONS A STEP VECTOR
     (FOR THE VECTOR OF UNKNOWNS) IS OBTAINED BY SOLVING A LINEARIZED
     SYSTEM OF EQUATIONS. THIS STEP IS PERFORMED ONLY IF THE NORM OF THE
     RESIDUAL VECTOR DECREASES. OTHERWISE THE NEWTON STEP VECTOR IS
     HALVED A NUMBER OF TIMES UNTIL THE NORM OF THE RESIDUAL VECTOR IS
     SMALLER THAN THE NORMS OF THE LAST AND SUBSEQUENT RESIDUAL VECTORS
     (THIS PROCESS IS CALLED STEP SIZE CONTROL).
     FOR FURTHER DETAILS SEE [3] (SEE ALSO [2]).
 
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 12
 
 
 
 REFERENCES  :
 
     [1] H.O. HARTLEY :
         THE MODIFIED GAUSS-NEWTON METHOD.
         TECHNOMETRICS, V.3 (1961), PP. 269 - 280.
     [2] H. SPAETH :
         THE DAMPED TAYLOR'S SERIES METHOD FOR MINIMIZING A SUM OF
         SQUARES AND FOR SOLVING SYSTEMS OF NONLINEAR EQUATIONS.
         ALGORITHM 315, COLLECTED ALGORITHMS FROM  CACM,
         COMMUNICATIONS OF THE ACM, VOL. 10 (NOV. 1967), PP. 726 - 728.
     [3] J.C.P. BUS, B. VAN DOMSELAAR, J. KOK :
         NONLINEAR LEAST SQUARES ESTIMATION.
         MATHEMATICAL CENTRE (TO APPEAR).
 
 
 EXAMPLE OF USE  :
 
     THE PARAMETERS PAR[1 : 3] IN THE CURVE FITTING PROBLEM:
     G[I] = PAR[1] + PAR[2] * EXP(PAR[3] * X[I]) - Y[I]
     WITH  (X[I], Y[I]), I=1,...,6  AS THE EXPERIMENTAL DATA, MAY BE
     OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
        "INTEGER" I;
        "ARRAY" IN[0:7], OUT[1:9], X, Y, G[1:6], V[1:3, 1:3], PAR[1:3];
 
        "BOOLEAN""PROCEDURE" EXPFUNCT(M, N, PAR, G);
        "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, G;
        "BEGIN""INTEGER" I;
            "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
            "BEGIN""IF" PAR[3] * X[I] > 680 "THEN"
                "BEGIN" EXPFUNCT:= "FALSE"; "GO TO" STOP "END";
                G[I]:= PAR[1] + PAR[2] * EXP(PAR[3] * X[I]) - Y[I]
            "END"; EXPFUNCT:="TRUE";
        STOP:
        "END" EXPFUNCT;
 
        "PROCEDURE" JACOBIAN(M, N, PAR, G, JAC, LOCFUNCT);
        "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, G, JAC;
        "PROCEDURE" LOCFUNCT;
        "BEGIN" "INTEGER" I; "REAL" EX;
            "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
            "BEGIN" JAC[I,1]:=1; JAC[I,2]:= EX:= EXP(PAR[3] * X[I]);
                JAC[I,3]:= X[I] * PAR[2] * EX
            "END"
        "END" JACOBIAN;
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 13
 
 
 
        IN[0]:= "-14; IN[1]:= IN[2]:= "-6; IN[5]:= 75; IN[4]:="-10;
        IN[6]:= 14; IN[7]:= 1;
        "FOR" I:= 1 "STEP" 1 "UNTIL" 6 "DO"
        "BEGIN" INREAL(70,X[I]); INREAL(70,Y[I]) "END";
        PAR[1]:= 580; PAR[2]:= - 180; PAR[3]:= - 0.160;
        GSSNEWTON(6, 3, PAR, G, V, EXPFUNCT, JACOBIAN, IN, OUT);
        OUTPUT(61,"("3/4B,"("X[I]     Y[I]")",/, 6(5B+D, 5B3D.D, /), 2/,
        4B"("PARAMETERS")",/,3(4B+D.3D"+ZD,/),2/,4B"("OUT:")",/,
        3(9B+D.6D"+ZD,/), 5(14B3ZD,/), 9B+D.6D"+ZD,2/4B,
        "("LAST RESIDUAL VECTOR")",/,6(10B+3Z.D,/)")", X[1], Y[1],
        X[2],Y[2],X[3],Y[3],X[4],Y[4],X[5],Y[5],X[6],Y[6],PAR[1],PAR[2],
        PAR[3],OUT[6],OUT[2],OUT[3],OUT[4],OUT[5],OUT[1],OUT[7],OUT[8],
        OUT[9], G[1],G[2],G[3],G[4],G[5],G[6])
     "END"
 
      WITH THE DATA GIVEN IN THE  X - Y - TABLE THIS PROGRAM DELIVERS:
 
      X[I]     Y[I]
       -5     127.0
       -3     151.0
       -1     379.0
       +1     421.0
       +3     460.0
       +5     426.0
 
 
      PARAMETERS
      +5.233" +2
      -1.569" +2
      -1.997" -1
 
 
      OUT:
           +5.260478" -4
           +1.157156" +2
           +1.654588" +2
                  16
                  16
                   2
                   0
                   3
           +2.339529" +3
 
      LAST RESIDUAL VECTOR
             -29.6
             +86.6
             -47.3
             -26.2
             -22.9
             +39.5
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 14
 
 
 
 SOURCE TEXTS    :
0"CODE" 34440;
  "PROCEDURE" MARQUARDT(M,N,PAR,G,V,FUNCT,JACOBIAN,IN,OUT);
  "VALUE" M,N; "INTEGER" M,N; "ARRAY" PAR,G,V,IN,OUT;
  "BOOLEAN" "PROCEDURE" FUNCT; "PROCEDURE" JACOBIAN;
  "BEGIN" "INTEGER" MAXFE,FE,IT,I,J,ERR;
          "REAL" VV,WW,W,MU,RES,FPAR,FPARPRES,LAMBDA,LAMBDAMIN,
                 P,PW,RELTOLRES,ABSTOLRES;
          "ARRAY" EM[0:7],VAL,B,BB,PARPRES[1:N],JAC[1:M,1:N];
 
         "PROCEDURE" LOCFUNCT(M,N,PAR,G); "VALUE" M, N;
         "INTEGER" M,N; "ARRAY" PAR,G;
         "BEGIN" FE:= FE+1; "IF" FE >= MAXFE "THEN" ERR:= 1 "ELSE"
                 "IF" "NOT" FUNCT(M,N,PAR,G) "THEN" ERR:= 2;
                 "IF" ERR^=0 "THEN" "GOTO" EXIT
         "END" LOCFUNCT;
 
         VV:=10; W:=0.5; MU:= 0.01;
         WW:=("IF" IN[6]<"-7 "THEN" "-8 "ELSE" "-1*IN[6]);
         EM[0]:=EM[2]:=EM[6]:=IN[0]; EM[4]:=10*N;
         RELTOLRES:=IN[3]; ABSTOLRES:=IN[4]**2; MAXFE:=IN[5];
         ERR:= 0; FE:= IT:= 1; P:=FPAR:= RES:= 0;
         PW:=-LN(WW*IN[0])/2.30;
 
         "IF" "NOT" FUNCT(M,N,PAR,G) "THEN"
         "BEGIN" ERR:= 3; "GOTO" ESCAPE "END";
         FPAR:= VECVEC(1,M,0,G,G); OUT[3]:=SQRT(FPAR);
 
         "FOR" IT:= 1, IT+1 "WHILE" FPAR > ABSTOLRES "AND"
                       RES > RELTOLRES*FPAR+ABSTOLRES "DO"
         "BEGIN" JACOBIAN(M,N,PAR,G,JAC,LOCFUNCT);
                 I:=QRISNGVALDEC(JAC,M,N,VAL,V,EM);
                 "IF" IT=1 "THEN"
                       LAMBDA:= IN[6] * VECVEC(1,N,0,VAL,VAL) "ELSE"
                 "IF" P =0 "THEN" LAMBDA:= LAMBDA*W "ELSE" P:= 0;
 
                 "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                 B[I]:=VAL[I]*TAMVEC(1,M,I,JAC,G);
                                                               "COMMENT"
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 15
                                                                 ;
 
 
            L:   "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                 BB[I]:=B[I]/(VAL[I]*VAL[I]+LAMBDA);
                 "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                 PARPRES[I]:= PAR[I] - MATVEC(1,N,I,V,BB);
                 LOCFUNCT(M,N,PARPRES,G);
                 FPARPRES:= VECVEC(1,M,0,G,G);
                 RES:=FPAR-FPARPRES;
                 "IF" RES < MU * VECVEC(1,N,0,B,BB) "THEN"
                 "BEGIN" P:= P+1; LAMBDA:= VV * LAMBDA;
                     "IF" P=1 "THEN"
                     "BEGIN" LAMBDAMIN:= WW * VECVEC(1,N,0,VAL,VAL);
                         "IF" LAMBDA<LAMBDAMIN "THEN" LAMBDA:= LAMBDAMIN
                     "END";
                     "IF" P<PW "THEN" "GOTO" L "ELSE"
                     "BEGIN" ERR:= 4;
                             "GOTO" EXIT
                     "END";
                 "END";
 
                 DUPVEC(1,N,0,PAR,PARPRES);
                 FPAR:=FPARPRES
           "END" ITERATION;
 
      EXIT:
           "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
           MULCOL(1,N,I,I,JAC,V,1/(VAL[I]+IN[0]));
           "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
           "FOR" J:=1 "STEP" 1 "UNTIL" I "DO"
           V[I,J]:= V[J,I]:= MATTAM(1,N,I,J,JAC,JAC);
 
           LAMBDA:= LAMBDAMIN:= VAL[1];
           "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
           "IF" VAL[I]>LAMBDA    "THEN" LAMBDA   := VAL[I] "ELSE"
           "IF" VAL[I]<LAMBDAMIN "THEN" LAMBDAMIN:= VAL[I];
 
           OUT[7]:=(LAMBDA/(LAMBDAMIN+IN[0]))**2;
           OUT[2]:=SQRT(FPAR);
           OUT[6]:=SQRT(RES+FPAR)-OUT[2];
      ESCAPE:
           OUT[4]:=FE;
           OUT[5]:=IT-1;
           OUT[1]:=ERR
      "END" MARQUARDT
 
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 16
 
 
                                                                  ;
         "EOP"
0"CODE" 34441;
     "PROCEDURE" GSSNEWTON(M, N, PAR, RV, JJINV, FUNCT, JACOBIAN,
       IN, OUT);
     "VALUE" M, N; "INTEGER" M, N;
     "ARRAY" PAR, RV, JJINV, IN, OUT;
     "BOOLEAN" "PROCEDURE" FUNCT;
     "PROCEDURE" JACOBIAN;
 
     "BEGIN" "INTEGER" I, J, INR, MIT, TEXT,
         IT, ITMAX, INRMAX, TIM, FEVAL, FEVALMAX;
         "REAL" RHO, RES1, RES2, RN, RELTOLPAR, ABSTOLPAR, ABSTOLRES,
            STAP, NORMX;
         "BOOLEAN" CONV, TESTTHF, DAMPING ON;
         "ARRAY" JAC[1:M + 1,1:N], PR, AID, SOL[1 : N], FU2[1 : M],
            AUX[2 : 5];
         "INTEGER""ARRAY" CI[1:N];
 
         "BOOLEAN""PROCEDURE" LOC FUNCT(M, N, PAR, RV);
         "VALUE" M, N; "INTEGER" M, N; "ARRAY" PAR, RV;
         "BEGIN" LOC FUNCT:= TEST THF:= FUNCT(M, N, PAR, RV)
             "AND" TEST THF; FEVAL:= FEVAL + 1
         "END" LOC FUNCT;
 
 
         ITMAX:= FEVALMAX:= IN[5]; AUX[2]:= N * IN[0]; TIM:= IN[7];
         RELTOLPAR:= IN[1] ** 2; ABSTOLPAR:= IN[2] ** 2;
         ABSTOLRES:= IN[4] ** 2; INRMAX:= IN[6];
         DUPVEC(1, N, 0, PR, PAR);
         "IF" M < N "THEN"
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" JAC[M + 1, I]:= 0;
         TEXT:= 4; MIT:= 0; TEST THF:= "TRUE";
         RES2:= STAP:= OUT[5]:= OUT[6]:= OUT[7]:= 0;
         FUNCT(M, N, PAR, FU2); RN:= VECVEC(1, M, 0, FU2, FU2);
         OUT[3]:= SQRT(RN); FEVAL:= 1; DAMPING ON:= "FALSE";
         "FOR" IT:= 1, IT + 1 "WHILE" IT <= ITMAX "AND"
                FEVAL < FEVALMAX "DO"
         "BEGIN" OUT[5]:= IT; JACOBIAN(M, N, PAR, FU2, JAC, LOCFUNCT);
            "IF" "NOT" TEST THF "THEN"
            "BEGIN" TEXT:= 7; "GO TO" FAIL "END";
            LSQORTDEC(JAC, M, N, AUX, AID, CI);
            "IF" AUX[3] ^= N "THEN"
            "BEGIN" TEXT:= 5; "GO TO" FAIL "END";
            LSQSOL(JAC, M, N, AID, CI, FU2); DUPVEC(1, N, 0, SOL, FU2);
            STAP:= VECVEC(1, N, 0, SOL, SOL);
            RHO:= 2; NORMX:= VECVEC(1, N, 0, PAR, PAR);
                                                               "COMMENT"
1SECTION : 5.1.3.1.3          (DECEMBER 1975)                    PAGE 17
                                                                 ;
 
 
            "IF" STAP > RELTOLPAR * NORMX + ABSTOLPAR
               "OR" IT = 1 "AND" STAP > 0 "THEN"
            "BEGIN""FOR" INR:= 0, INR + 1
               "WHILE""IF" INR = 1 "THEN" DAMPING ON "OR" RES2 >= RN
               "ELSE""NOT" CONV "AND" (RN <= RES1 "OR" RES2 < RES1) "DO"
               "BEGIN""COMMENT" DAMPING STOPS WHEN
                  R0 > R1 "AND" R1 <= R2 (BEST RESULT IS X1, R1)
                  WITH  X1 = X0 + I * DX, I:= 1, .5, .25, .125, ETC.  ;
                  RHO:= RHO / 2; "IF" INR > 0 "THEN"
                  "BEGIN" RES1:= RES2; DUPVEC(1, M, 0, RV, FU2);
                     DAMPING ON:= INR > 1
                  "END";
                  "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                  PR[I]:= PAR[I] - SOL[I] * RHO;
                  FEVAL:= FEVAL + 1;
                  "IF" "NOT" FUNCT(M, N, PR, FU2) "THEN"
                  "BEGIN" TEXT:= 6; "GO TO" FAIL "END";
                  RES2:= VECVEC(1, M, 0, FU2, FU2); CONV:= INR >= INRMAX
               "END" DAMPING OF STEP VECTOR;
               "IF" CONV "THEN"
               "BEGIN""COMMENT" RESIDUE CONSTANT; MIT:= MIT + 1;
                  "IF" MIT < TIM "THEN" CONV:= "FALSE"
               "END" "ELSE" MIT:= 0;
               "IF" INR > 1 "THEN"
               "BEGIN" RHO:= RHO * 2; ELMVEC(1, N, 0, PAR, SOL, - RHO);
                  RN:= RES1; "IF" INR > 2 "THEN" OUT[7]:= IT
               "END""ELSE"
               "BEGIN" DUPVEC(1, N, 0, PAR, PR); RN:= RES2;
                  DUPVEC(1, M, 0, RV, FU2)
               "END";
 
               "IF" RN <= ABSTOLRES "THEN"
               "BEGIN" TEXT:= 1; ITMAX:= IT "END""ELSE"
               "IF" CONV "AND" INRMAX > 0 "THEN"
               "BEGIN" TEXT:= 3; ITMAX:= IT "END"
               "ELSE" DUPVEC(1, M, 0, FU2, RV)
            "END" ITERATION WITH DAMPING AND TESTS "ELSE"
            "BEGIN" TEXT:= 2; RHO:= 1; ITMAX:= IT "END"
         "END" OF ITERATIONS;
 
         LSQINV(JAC, N, AID, CI);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" JJINV[I,I]:= JAC[I,I];
             "FOR" J:= I + 1 "STEP" 1 "UNTIL" N "DO"
             JJINV[I,J]:= JJINV[J,I]:= JAC[I,J]
         "END" CALCULATION OF INVERSE MATRIX OF NORMAL EQUATIONS;
     FAIL :
         OUT[6]:= SQRT(STAP) * RHO; OUT[2]:= SQRT(RN); OUT[4]:= FEVAL;
         OUT[1]:= TEXT; OUT[8]:= AUX[3]; OUT[9]:= AUX[5]
     "END" GSSNEWTON;
         "EOP"
1SECTION : 5.2.1.1.1.1        (DECEMBER 1979)                     PAGE 1
 
 
 
 SECTION 5.2.1.1.1.1 CONTAINS NINE PROCEDURES FOR INTIAL-VALUE PROBLEMS
 FOR FIRST ORDER  ORDINARY DIFERENTIAL EQUATIONS.
 
 A.  RK1 SOLVES AN IVP FOR A SINGLE ODE BY MEANS OF A
     5-TH ORDER RUNGE-KUTTA METHOD.
 
 B.  RKE SOLVES AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF A
     5-TH ORDER RUNGE-KUTTA METHOD.
 
 C.  RK4A SOLVES AN IVP FOR A SINGLE ODE BY MEANS OF A 5-TH ORDER
     RUNGE-KUTTA METHOD. RK4A INTERCHANGES THE DEPENDENT AND
     INDEPENDENT VARIABLE.
 
 D.  RK4NA SOLVES AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF A
     5-TH ORDER RUNGE-KUTTA METHOD. RK4NA INTERCHANGES THE
     INDEPENDENT AND ONE DEPENDENT VARIABLE.
 
 E.  RK5NA SOLVES AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF A
     5-TH ORDER RUNGE-KUTTA METHOD. RK5NA USES THE ARC LENGTH
     AS INTEGRATION VARIABLE.
 
 F.  MULTISTEP  SOLVES  AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF A
     LINEAR MULTISTEP METHOD. IT USES EITHER THE BACKWARD
     DIFFERENTIATION METHODS, OR THE ADAMS-BASHFORTH-MOULTON-METHOD.
 
 G.  DIFFSYS  SOLVES AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF
     A HIGH ORDER EXTRAPOLATION METHOD BASED ON THE MODIFIED
     MIDPOINT RULE.
 
 H.  ARK SOLVES AN IVP FOR A LARGE SYSTEM OF ODE'S WHICH IS OBTAINED
     FROM SEMI-DISCRETIZATION OF AN INITIAL BOUNDARY VALUE PROBLEM
     FOR A PARABOLIC OR HYPERBOLIC EQUATION. ARK IS BASED ON
     STABILIZED, EXPLICIT RUNGE-KUTTA METHODS OF LOW ORDER.
 
 I.  EFRK  SOLVES  AN IVP FOR A SYSTEM OF ODE'S BY MEANS OF AN
     EXPONENTIALLY FITTED EXPLICIT RUNGE-KUTTA METHOD OF FIRST,
     SECOND OR THIRD ORDER.
 
 
 
 RK1 AND RKE ARE INTENDED FOR NON-STIFF EQUATIONS,WHILE RK4A, RK4NA
 AND RK5NA   ARE INTENDED FOR NON-STIFF EQUATIONS WHERE DERIVATIVES
 BECOME VERY LARGE, SUCH AS IN THE NEIGHBOURHOOD OF SINGULARITIES.
 MULTISTEP CAN BE USED FOR NON-STIFF, AS WELL AS STIFF EQUATIONS.
 DIFFSYS SHOULD BE USED FOR PROBLEMS FOR WHICH A VERY HIGH ACCURACY
 IS DESIRED. ARK IS RECOMMENDED FOR THE INTEGRATION OF SEMI-DISCRETE
 PARABOLIC OR HYPERBOLIC PROBLEMS. EFRK IS A SPECIAL PURPOSE PROCEDURE
 FOR STIFF EQUATIONS WITH A KNOWN, CLUSTERED EIGENVALUE SPECTRUM.
 EXCEPT EFRK, ALL PROCEDURES PERFORM STEPSIZE CONTROL.
1SECTION : 5.2.1.1.1.1.A      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : RK1
 
 
 AUTHOR:J.A.ZONNEVELD.
 
 
 CONTRIBUTORS: M.BAKKER AND I.BRINK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730715.
 
 
 BRIEF DESCRIPTION:
 
     RK1 SOLVES AN INITIAL VALUE PROBLEM FOR A SINGLE FIRST ORDER
     ORDINARY DIFFERENTIAL EQUATION    DY / DX  = F(X,Y).
     THE EQUATION IS SUPPOSED TO BE NON-STIFF.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM.
     SINGLE FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" RK1(X,A,B,Y,YA,FXY,E,D,FI);
     "VALUE" B,FI;
     "REAL" X,A,B,Y,YA,FXY;
     "BOOLEAN" FI;
     "ARRAY" E,D;
     "CODE" 33010;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:    <VARIABLE>;
           THE INDEPENDENT VARIABLE.
           UPON COMPLETION OF A CALL
           X IS EQUAL TO B;
     A:    <ARITHMETIC EXPRESSION>;
           ENTRY: THE INITIAL VALUE OF X;
     B:    <ARITHMETIC EXPRESSION>;
           ENTRY: A VALUE PARAMETER,GIVING THE END VALUE OF X;
     Y:    <VARIABLE>;
           THE DEPENDENT VARIABLE;
1SECTION : 5.2.1.1.1.1.A      (FEBRUARY 1979)                     PAGE 2
 
 
 
     YA:   <ARITHMETIC EXPRESSION>;
           ENTRY :  THE VALUE OF Y AT X=A;
     FXY:  <ARITHMETIC EXPRESSION>;
           AN EXPRESSION,DEPENDING ON X AND Y,GIVING THE VALUE OF DY/DX;
     E:    <ARRAY IDENTIFIER>;
           "ARRAY" E[1:2];
           ENTRY:
           E[1] : A RELATIVE TOLERANCE,
           E[2] : AN ABSOLUTE TOLERANCE ;
     D:    <ARRAY IDENTIFIER>;
           "ARRAY" D[1:4];
           EXIT:
           ENTIER(D[1]+.5) GIVES THE NUMBER OF STEPS SKIPPED;
           D[2] : EQUALS THE STEP LENGTH;
           D[3] : IS EQUAL TO B;
           D[4] : IS EQUAL TO Y(B);
     FI:   <BOOLEAN EXPRESSION>;
          IF FI="TRUE" RK1 INTEGRATES FROM X=A TO X=B WITH INITIAL VALUE
          VALUE Y(A)=YA AND TRIAL STEP B-A. IF FI="FALSE" RK1 INTEGRATES
           FROM X=D[3] TO X=B WITH INITIAL VALUE Y(D[3])=D[4]  AND FIRST
           STEP H=D[2]*SIGN(B-D[3]), WHILE A AND YA ARE IGNORED.
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY : NEGLIGIBLE SMALL.
 
 
 METHOD AND PERFORMANCE:
 RK1 IS BASED ON AN EXPLICIT, 5-TH ORDER RUNGE-KUTTA METHOD AND
 IS PROVIDED WITH STEPLENGTH AND ERRORCONTROL. THE ERRORCONTROL
 IS BASED ON THE LAST TERM OF THE TAYLOR SERIES WICH IS TAKEN INTO
 ACCOUNT. A STEP IS REJECTED IF THE ABSOLUTE VALUE OF THIS LAST TERM
 GREATER THAN  (ABS(FXY)*E[1]+E[2])*ABS(H)/INT, WHERE
 INT = ABS( B-( "IF" FI "THEN" A "ELSE" D[3])) DENOTES THE LENGTH
 OF THE INTEGRATION INTERVAL, OTHERWISE, A STEP IS ACCEPTED.
 RK1 USES AS ITS MINIMAL ABBSOLUTE STEPLENGTH  HMIN = E[1]*INT+E[2].
 IF A STEP OF LENGTH ABS(H) = HMIN  IS REJECTED,  THE STEP IS SKIPPED.
 FOR FURTHER DETAILS SEE [1].
1SECTION : 5.2.1.1.1.1.A      (FEBRUARY 1979)                     PAGE 3
 
 
 
 
 REFERENCES:
     [1]J.A.ZONNEVELD.
          AUTOMATIC NUMERICAL INTEGRATION.
          MATHEMATICAL CENTRE TRACT 8(1970).
 
 
 EXAMPLE OF USE:
 
     THE SOLUTION OF THE DIFFERENTIAL EQUATION DY/DX=-Y
     WITH INITIAL CONDITION Y(0)=1 AT X=1 IS COMPUTED
     BY MEANS OF THE FOLLOWING PROGRAM:
 
     "BEGIN"
     "REAL" X,Y;
     "BOOLEAN" FI,FIRST;
     "REAL" "ARRAY" E[1:2],D[1:4];
 
     E[1]:=+"-4;E[2]:=+"-4;FIRST:="TRUE";
     RK1(X,0.0,1,Y,1.0,-Y,E,D,FIRST);
     OUTPUT(61,"("//10B"("X=")".12D"2D,//10B"("Y=")".12D"2D,
     10B"("YEXACT=")".12D"2D")",X,Y,EXP(-X));
     "END"
 
     IT DELIVERS WITH E[1]=E[2]="-4:
           X=.100000000000"01
 
 
           Y=.367876846355"00          YEXACT=.367879441171"00
 
 
 SOURCE TEXT(S):
0"CODE" 33010;
    "PROCEDURE" RK1(X, A, B, Y, YA, FXY, E, D, FI);
    "VALUE" B, FI; "REAL" X, A, B, Y, YA, FXY; "BOOLEAN" FI;
    "ARRAY" E, D;
    "BEGIN" "REAL" E1, E2, XL, YL, H, INT, HMIN, ABSH, K0, K1,
       K2, K3, K4, K5, DISCR, TOL, MU, MU1, FH, HL;
       "BOOLEAN" LAST, FIRST, REJECT;                          "COMMENT"
1SECTION : 5.2.1.1.1.1.A      (AUGUST 1974)                       PAGE 4
                                                                  ;
 
 
       "IF" FI "THEN"
       "BEGIN" D[3]:= A; D[4]:= YA "END";
       D[1]:= 0; XL:= D[3]; YL:= D[4];
       "IF" FI "THEN" D[2]:= B - D[3]; ABSH:= H:= ABS(D[2]);
       "IF" B - XL < 0 "THEN" H:= - H; INT:= ABS(B - XL);
       HMIN:= INT * E[1] + E[2]; E1:= E[1] / INT;
       E2:= E[2] / INT; FIRST:= "TRUE"; "IF" FI "THEN"
       "BEGIN" LAST:= "TRUE"; "GOTO" STEP "END";
    TEST: ABSH:= ABS(H); "IF" ABSH < HMIN "THEN"
       "BEGIN" H:= "IF" H > 0 "THEN" HMIN "ELSE" - HMIN; ABSH:= HMIN
       "END";
       "IF" H >= B - XL "EQV" H >= 0 "THEN"
       "BEGIN" D[2]:= H; LAST:= "TRUE"; H:= B - XL;
          ABSH:= ABS(H)
       "END"
       "ELSE" LAST:= "FALSE";
    STEP: X:= XL; Y:= YL; K0:= FXY * H;
       X:= XL + H / 4.5; Y:= YL + K0 / 4.5;
       K1:= FXY * H; X:= XL + H / 3;
       Y:= YL + (K0 + K1 * 3) / 12; K2:= FXY * H;
       X:= XL + H * .5; Y:= YL + (K0 + K2 * 3) / 8;
       K3:= FXY * H; X:= XL + H * .8;
       Y:= YL + (K0 * 53 - K1 * 135 + K2 * 126 + K3 * 56)
       / 125; K4:= FXY * H; X:= "IF" LAST "THEN" B "ELSE" XL + H;
       Y:= YL + (K0 * 133 - K1 * 378 + K2 * 276 + K3 * 112
       + K4 * 25) / 168; K5:= FXY * H;
       DISCR:= ABS(K0 * 21 - K2 * 162 + K3 * 224 - K4 * 125
       + K5 * 42) / 14; TOL:= ABS(K0) * E1 + ABSH * E2;
       REJECT:= DISCR > TOL; MU:= TOL / (TOL + DISCR) + .45;
       "IF" REJECT "THEN"
       "BEGIN" "IF" ABSH <= HMIN "THEN"
          "BEGIN" D[1]:= D[1] + 1; Y:= YL; FIRST:= "TRUE";
             "GOTO" NEXT
          "END";
          H:= MU * H; "GOTO" TEST
       "END";
       "IF" FIRST "THEN"
       "BEGIN" FIRST:= "FALSE"; HL:= H; H:= MU * H; "GOTO" ACC
       "END";
       FH:= MU * H / HL + MU - MU1; HL:= H; H:= FH * H;
    ACC: MU1:= MU;
       Y:= YL + ( - K0 * 63 + K1 * 189 - K2 * 36 - K3 * 112
       + K4 * 50) / 28; K5:= FXY * HL;
       Y:= YL + (K0 * 35 + K2 * 162 + K4 * 125 + K5 * 14)
       / 336;
 
    NEXT: "IF" B ^= X "THEN"
       "BEGIN" XL:= X; YL:= Y; "GOTO" TEST "END";
       "IF" "NOT"LAST "THEN" D[2]:= H; D[3]:= X; D[4]:= Y
    "END" RK1;
         "EOP"
1SECTION : 5.2.1.1.1.1.B      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : RKE.
 
 
 AUTHOR: P.A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740520.
 
 
 BRIEF DESCRIPTION:
 
     RKE  SOLVES AN INITIAL VALUE PROBLEM FOR A SYSTEM OF FIRST
     ORDER ORDINARY DIFFERENTIAL EQUATIONS  DY / DX = F(X,Y).
     THE SYSTEM IS SUPPOSED TO BE NON-STIFF.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM.
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS.
 
1SECTION : 5.2.1.1.1.1.B      (FEBRUARY 1979)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
 
     "PROCEDURE" RKE (X, XE, N, Y, DER, DATA, FI, OUT);
     "VALUE" N, FI; "INTEGER" N; "REAL" X, XE; "BOOLEAN" FI;
     "ARRAY" Y, DATA;
     "PROCEDURE" DER, OUT;
     "CODE" 33033;
 
     RKE  INTEGRATES  THE  SYSTEM OF ORDINARY DIFFERENTIAL  EQUATIONS
      DY / DX = F(X, Y),  FROM X = X0 TO X = XE WHERE Y(X0) = Y0.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE;
             ENTRY: THE INITIAL VALUE X0;
     XE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X;
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS OF THE SYSTEM;
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1 : N];
             THE DEPENDENT VARIABLES;
             ENTRY: THE INITIAL VALUES AT X = X0;
             EXIT : THE VALUES OF THE SOLUTION AT X = XE;
     DER:    <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DER (T, V); "VALUE" T; "REAL" T; "ARRAY" V;
             THIS PROCEDURE  PERFORMS  AN  EVALUATION OF THE RIGHT HAND
             SIDE  OF THE SYSTEM WITH DEPENDENT VARIABLES V[1 : N]  AND
             INDEPENDENT  VARIABLE  T; UPON  COMPLETION  OF DER
             THE  RIGHT HAND SIDE SHOULD BE  OVERWRITTEN  ON  V[1 : N];
     DATA:   <ARRAY IDENTIFIER>;
             "ARRAY" DATA[1 : 6];
             IN ARRAY DATA ONE SHOULD GIVE:
                 DATA[1]: THE RELATIVE TOLERANCE;
                 DATA[2]: THE ABSOLUTE TOLERANCE;
             AFTER  EACH  STEP DATA[3:6] CONTAINS :
                 DATA[3]: THE   STEPLENGTH   USED  FOR THE  LAST  STEP;
                 DATA[4]: THE  NUMBER  OF INTEGRATION STEPS  PERFORMED;
                 DATA[5]: THE  NUMBER  OF  INTEGRATION STEPS  REJECTED;
                 DATA[6]: THE  NUMBER  OF  INTEGRATION  STEPS  SKIPPED;
                          IF  UPON  COMPLETION  OF   RKE  DATA[6] > 0 ,
                          RESULTS SHOULD BE CONSIDERED MOST CRITICALLY;
     FI:     <BOOLEAN EXPRESSION>;
             IF  FI = "TRUE"  THE  INTEGRATION  STARTS  AT  X0  WITH  A
             TRIAL  STEP  XE - X0; IF  FI = "FALSE"  THE INTEGRATION IS
             CONTINUED   WITH   A  STEPLENGTH  DATA[3] * SIGN(XE - X0);
     OUT:    <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" OUT;
             AFTER  EACH INTEGRATION STEP PERFORMED OUT CAN BE USED TO
           OBTAIN INFORMATION FROM THE SOLUTION PROCESS, E.G. THE VALUES
             OF X, Y[1 : N] AND  DATA[3 : 6]. POUT CAN ALSO BE USED TO
             UPDATE DATA.
 
1SECTION : 5.2.1.1.1.1.B      (FEBRUARY 1979)                     PAGE 3
 
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     CIRCA  5 * N MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD UPON WHICH THE PROCEDUDRE IS BASED, IS A MEMBER OF A
     CLASS OF FIFTH ORDER  RUNGE KUTTA  FORMULAS  PRESENTED IN REFERENCE
     [1]. AUTOMATIC STEPSIZE CONTROL IS IMPLEMENTED IN A WAY AS PROPOSED
     IN REFERENCE [2]. FOR TESTRESULTS AND FURTHER INFORMATION
     SEE  REFERENCE [3].
 
 
 REFERENCES:
 
     [1]. R. ENGLAND.
             ERROR ESTIMATES FOR RUNGE KUTTA TYPE SOLUTIONS TO  SYSTEMS
             OF ORDINARY DIFFERENTIAL EQUATIONS.
             THE COMPUTER JOURNAL , VOLUME 12, P 166 - 169, 1969.
 
     [2]. J.A. ZONNEVELD.
             AUTOMATIC NUMERICAL INTEGRATION.
             MATH. CENTRE TRACT 8(1970).
 
     [3]. P.A. BEENTJES.
             SOME  SPECIAL FORMULAS OF THE ENGLAND CLASS OF FIFTH ORDER
             RUNGE - KUTTA SCHEMES.
             MATH. CENTRE REPORT NW 24/74.
 
1SECTION : 5.2.1.1.1.1.B      (DECEMBER 1975)                     PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     THE SOLUTION AT T = 1 AND T = -1 OF THE SYSTEM
 
     DX / DT = Y - Z,
     DY / DT = X * X + 2 * Y + 4 * T,
     DZ / DT = X * X + 5 * X + Z * Z + 4 * T,
 
     WITH  X = Y = 0  AND  Z = 2  AT  T = 0,
 
     CAN BE OBTAINED BY THE FOLLOWING PROGRAM:
 
 
     "BEGIN" "REAL" T, TE; "ARRAY" Y[1 : 3], DATA[1 : 6];
 
 
        "PROCEDURE" RHS(T, Y); "VALUE" T; "REAL" T; "ARRAY" Y;
        "BEGIN" "REAL" XX, YY, ZZ;
           XX:= Y[1]; YY:= Y[2]; ZZ:= Y[3];
           Y[1]:= YY - ZZ;
           Y[2]:= XX * XX + 2 * YY + 4 * T;
           Y[3]:= XX * (XX + 5) + 2 * ZZ + 4 * T
        "END" RHS;
 
        "PROCEDURE" INFO;
        "IF" T = TE "THEN"
        "BEGIN" "REAL" ET, T2, AEX, AEY, AEZ, REX, REY, REZ;
           ET:= EXP(T); T2:= 2 * T;
           REX:= -ET * SIN(T2); AEX:= REX - Y[1]; REX:= ABS(AEX / REX);
           REY:= ET * ET * (8 + 2 * T2 - SIN(2 * T2)) / 8 - T2 - 1;
           REZ:= ET * (SIN(T2) + 2 * COS(T2)) + REY;
           AEY:= REY - Y[2]; REY:= ABS(AEY / REY); AEZ:= REZ - Y[3];
           REZ:= ABS(AEZ / REZ);
           OUTPUT(61, "(""(" T = ")", +D, //,
           "(" RELATIVE AND ABSOLUTE ERRORS IN X, Y AND Z :")", //,
           "("   RE(X)   RE(Y)   RE(Z)   AE(X)   AE(Y)   AE(Z)")", //,
           6(B,-.2D"+D), //,
           "(" NUMBER OF INTEGRATION STEPS PERFORMED :")",4ZD,/,
           "(" NUMBER OF INTEGRATION STEPS SKIPPED   :")",4ZD,/,
           "(" NUMBER OF INTEGRATION STEPS REJECTED  :")",4ZD,///")",
           T, REX, REY, REZ, ABS(AEX), ABS(AEY), ABS(AEZ),
           DATA[4], DATA[6], DATA[5])
        "END" INFO;
 
        TE:= 1;
     LEFT:
        Y[1]:= Y[2]:= 0; Y[3]:= 2; T:=0;
        DATA[1]:= DATA[2]:= "-5;
        RKE(T, TE, 3, Y, RHS, DATA, "TRUE", INFO);
        "IF" TE = 1 "THEN" "BEGIN" TE:= -1; "GOTO" LEFT "END"
     "END"
1SECTION : 5.2.1.1.1.1.B      (DECEMBER 1975)                     PAGE 5
 
 
 
 
     THIS PROGRAM DELIVERS:
 
 
     T = +1
 
     RELATIVE AND ABSOLUTE ERRORS IN X, Y AND Z :
 
       RE(X)   RE(Y)   RE(Z)   AE(X)   AE(Y)   AE(Z)
 
      .37"-6  .15"-5  .13"-5  .91"-6  .13"-4  .11"-4
 
     NUMBER OF INTEGRATION STEPS PERFORMED :    9
     NUMBER OF INTEGRATION STEPS SKIPPED   :    0
     NUMBER OF INTEGRATION STEPS REJECTED  :    5
 
 
     T = -1
 
     RELATIVE AND ABSOLUTE ERRORS IN X, Y AND Z :
 
       RE(X)   RE(Y)   RE(Z)   AE(X)   AE(Y)   AE(Z)
 
      .22"-6  .52"-7  .19"-6  .75"-7  .55"-7  .77"-7
 
     NUMBER OF INTEGRATION STEPS PERFORMED :   10
     NUMBER OF INTEGRATION STEPS SKIPPED   :    0
     NUMBER OF INTEGRATION STEPS REJECTED  :    7
 
 
 SOURCE TEXT(S):
0"CODE" 33033;
    "PROCEDURE" RKE (X, XE, N, Y, DER, DATA, FI, OUT);
    "VALUE"  FI, N; "INTEGER" N; "REAL" X, XE;
    "BOOLEAN" FI; "ARRAY" Y, DATA;
    "PROCEDURE" DER, OUT;
    "BEGIN" "INTEGER" J;
       "REAL" XT, H, HMIN, INT, HL, HT, ABSH, FHM, DISCR, TOL, MU,
       MU1, FH, E1, E2;
       "BOOLEAN" LAST, FIRST, REJECT;
       "ARRAY" K0, K1, K2, K3, K4[1:N];
       "IF" FI "THEN"
       "BEGIN" DATA[3]:= XE - X; DATA[4]:= DATA[5]:= DATA[6]:= 0 "END";
       ABSH:= H:= ABS(DATA[3]);
       "IF" XE < X "THEN" H:= - H; INT:= ABS(XE - X);
       HMIN:= INT * DATA[1] + DATA[2];
       E1:= 12 * DATA[1] / INT; E2:= 12 * DATA[2] / INT;
       FIRST:= "TRUE"; REJECT:= "FALSE"; "IF" FI "THEN"
       "BEGIN" LAST:= "TRUE"; "GOTO" STEP "END";
    TEST: ABSH:= ABS(H); "IF" ABSH < HMIN "THEN"
       "BEGIN" H:= SIGN (XE - X) * HMIN; ABSH:= HMIN "END";
       "IF" H >= XE - X "EQV" H >= 0 "THEN"
       "BEGIN" LAST:= "TRUE"; H:= XE - X; ABSH:= ABS(H) "END"
       "ELSE" LAST:= "FALSE";
                                                               "COMMENT"
1SECTION : 5.2.1.1.1.1.B      (DECEMBER 1975)                     PAGE 6
                                                                  ;
 
 
    STEP: "IF" ^ REJECT "THEN"
       "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K0[J]:= Y[J];
           DER(X, K0)
       "END";
       HT:= .184262134833347 * H; XT:= X + HT;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K1[J]:= K0[J] * HT + Y[J];
       DER(XT, K1);
       HT:= .690983005625053"-1 * H; XT:= 4 * HT + X;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K2[J]:=
       (3 * K1[J] + K0[J]) * HT + Y[J];
       DER(XT, K2);
       XT:= .5 * H + X; HT:= .1875 * H;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K3[J]:=((1.74535599249993
       * K2[J] - K1[J]) * 2.23606797749979 + K0[J]) * HT + Y[J];
       DER(XT, K3);
       XT:= .723606797749979 * H + X; HT:= .4 * H;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K4[J]:= (((.517595468166681
       * K0[J] - K1[J]) * .927050983124840 + K2[J]) * 1.46352549156242
       + K3[J]) * HT + Y[J];
       DER(XT, K4);
       XT:= "IF" LAST "THEN" XE "ELSE" X + H; HT:= 2 * H;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" K1[J]:= ((((2 * K4[J] +
       K2[J]) * .412022659166595 + K1[J]) * 2.23606797749979 -
       K0[J]) * .375 - K3[J]) * HT + Y[J];
       DER(XT, K1);
       REJECT:= "FALSE"; FHM:= 0;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" DISCR:= ABS((1.6 * K3[J] - K2[J] - K4[J]) * 5 +
           K0[J] + K1[J]);
          TOL:= ABS(K0[J]) * E1 + E2;
          REJECT:= DISCR > TOL "OR" REJECT;
          FH:= DISCR / TOL; "IF" FH > FHM "THEN" FHM:= FH
       "END";
       MU:= 1 / (1 + FHM) + .45; "IF" REJECT "THEN"
       "BEGIN" DATA[5]:= DATA[5] + 1; "IF" ABSH <= HMIN "THEN"
          "BEGIN" DATA[6]:= DATA[6] + 1; HL:= H; REJECT:= "FALSE";
             FIRST:= "TRUE"; "GOTO" NEXT
          "END";
          H:= MU * H; "GOTO" TEST
       "END";
       "IF" FIRST "THEN"
       "BEGIN" FIRST:= "FALSE"; HL:= H; H:= MU * H; "GOTO" ACC
       "END";
       FH:= MU * H / HL + MU - MU1; HL:= H; H:= FH * H;
    ACC: MU1:= MU; HT:= HL / 12;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" Y[J]:=
       ((K2[J] + K4[J]) * 5 + K0[J] + K1[J]) * HT + Y[J];
    NEXT: DATA[3]:= HL; DATA[4]:= DATA[4] + 1; X:= XT; OUT;
       "IF" X ^= XE "THEN" "GOTO" TEST
    "END" RKE;
         "EOP"
1SECTION : 5.2.1.1.1.1.C      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : RK4A.
 
 
 AUTHOR:J.A.ZONNEVELD.
 
 
 CONTRIBUTORS:M.BAKKER AND I.BRINK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE,
 
 
 RECEIVED: 730715.
 
 
 BRIEF DESCRIPTION:
 
     RK4A SOLVES AN INITIAL VALUE PROBLEM FOR A SINGLE FIRST ORDER
     ORDINARY DIFFERENTIAL EQUATION   DY / DX = F(X,Y), WHERE F(X,Y)
     MAY BECOME LARGE, E.G. IN THE NEIGHBOURHOOD OF A SINGULARITY.
     RK4A INTERCHANGES THE DEPENDENT AND INDEPENDENT VARIABLE.
     THE EQUATION IS UPPOSED TO BE NON-STIFF.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM,
     SINGLE FIRST ORDER ORDINARY DIFFERENTIAL EQUATION
     LARGE DERIVATIVE VALUES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" RK4A(X,XA,B,Y,YA,FXY,E,D,FI,XDIR,POS);
     "VALUE" FI,XDIR,POS;
     "BOOLEAN" FI,XDIR,POS;
     "REAL" X,XA,B,Y,YA,FXY;
     "ARRAY" E,D;
     "CODE" 33016;
 
 
1SECTION : 5.2.1.1.1.1.C      (FEBRUARY 1979)                     PAGE 2
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     X:    <VARIABLE>;
           THE INDEPENDENT VARIABLE ;
           UPON COMPLETION OF A CALL X IS EQUAL TO THE MOST RECENT
           VALUE OF THE INDEPENDENT VARIABLE;
     XA:   <ARITHMETIC EXPRESSION>;
           ENTRY: THE INITIAL VALUE OF X;
     B:    <ARITHMETIC EXPRESSION>;
           B DEPENDS ON X AND Y.
           THE EQUATION B=0 FULFILLED WITHIN THE TOLERANCES E[4] AND
           E[5]  SPECIFIES THE END OF THE INTEGRATION INTERVAL.
           AT THE END OF EACH INTEGRATION STEP B IS EVALUATED AND IS
           TESTED FOR CHANGE OF SIGN;
     Y:    <VARIABLE>;
           THE DEPENDENT VARIABLE;
     YA:   <ARITHMETIC EXPRESSION>;
           ENTRY: THE VALUE OF Y AT X=XA;
     FXY:  <ARITHMETIC EXPRESSION>;
           FXY GIVES THE VALUE OF DY/DX;
           FXY USES X AND Y AS JENSEN PARAMETERS.
     E:    <ARRAY IDENTIFIER>;
           "ARRAY" E[0:5];
           ENTRY:
           E[0], E[2] : RELATIVE TOLERANCES, FOR X AND Y RESPECTIVELY;
           E[1], E[3] : ABSOLUTE TOLERANCES, FOR X AND Y RESPECTIVELY;
           E[4], E[5] : TOLERANCES USED IN THE DETERMINATION OF
           THE ZERO OF B;
     D:    <ARRAY IDENTIFIER>;
           "ARRAY" D[0:4];
           AFTER COMPLETION OF EACH STEP WE HAVE :
           IF D[0]>0 THEN X IS THE INTEGRATION VARIABLE;
           IF D[0]<0 THEN Y IS THE INTEGRATION VARIABLE;
           D[1] IS THE NUMBER OF STEPS SKIPPED;
           D[2] IS THE STEPSIZE;
           D[3] IS EQUAL TO THE LAST VALUE OF X;
           D[4] IS EQUAL TO THE LAST VALUE OF Y;
     FI:   <BOOLEAN EXPRESSION>;
           IF FI="TRUE" THEN THE INTEGRATION IS STARTED WITH INITIAL
           VALUES X=XA,Y=YA.
           IF FI="FALSE" THEN THE INTEGRATION IS STARTED WITH X=D[3],
           Y=D[4];
     XDIR, POS : <BOOLEAN EXPRESSION>;
           IF FI="TRUE" THEN THE INTEGRATION STARTS IN SUCH A WAY THAT
           IF POS="TRUE" AND XDIR="TRUE" THEN X INCREASES,
           IF POS="TRUE" AND XDIR="FALSE" THEN Y INCREASES,
           IF POS="FALSE" AND XDIR="TRUE" THEN X DECREASES,
           IF POS="FALSE" AND XDIR="FALSE" THEN Y DECREASES.
 
 
1SECTION : 5.2.1.1.1.1.C      (FEBRUARY 1979)                     PAGE 3
 
 
 
 PROCEDURES USED : ZEROIN = CP34150.
 
 
 METHOD AND PERFORMANCE:
 
     RK4A IS BASED ON AN EXPLICIT, 5-TH ORDER RUNGE-KUTTA METHOD AND
     INTERCHANGES THE DEPENDENT AND INDEPENDENT INTEGRATION VARIABLE.
     IF  ABS(F(X,Y)) < 1, X IS USED AS INTEGRATION VARIABLE,OTHERWISE Y.
     THE PROCEDURE IS PROVIDED WITH STEP SIZE AND ERROR CONTROL.
     FOR DETAILS,E.G. HOW TO USE ARRAY E AND HOW TO SPECIFY THE ENDPOINT
     SEE [1] ( RK4A IS A SLIGHTLY ADAPTED VERSION OF RK4).
 
 
 REFERENCES:
     [1]J.A.ZONNEVELD,
        AUTOMATIC NUMERICAL INTEGRATION.
        MATHEMATICAL CENTRE TRACT 8(1970).
 
 
 EXAMPLE OF USE:
 
     THE SOLUTION OF THE DIFFERENTIAL EQUATION
     DY/DX=1-2*(X**2+Y), X>=0,
     Y=0               , X =0,
     IS REPRESENTED BY THE PARABOLA Y=X*(1-X);
     WE WOULD LIKE TO FIND THE VALUE OF X FOR WHICH THE CURVE
     OF THE SOLUTION INTERSECTS THE LINE Y+X=0.
     THE SOLUTION CAN BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "COMMENT" INTEGRATION OF DY/DX=1-2*(Y+X**2), X>=0,
         Y(0)=0,UNTIL THE CONDITION Y+X=0 IS SATISFIED;
         "REAL" X,Y;"ARRAY" D[0:4],E[0:5];
         E[0]:=E[1]:=E[2]:=E[3]:=E[4]:=E[5]:="-6;
         RK4A(X,0.0,X+Y,Y,0.0,1-2*(X*X+Y),E,D,"TRUE","TRUE","TRUE");
         OUTPUT(61,"("10B"("X=")"+D.9D,10B"("EXACTLY:")"2B+D.9D/,
         10B"("Y=")"+D.9D/,10B"("Y-X*(1-X)=")"+.10D")",X,2,
         Y,Y-X*(1-X))
     "END"
 
     THE PROGRAM PRINTS THE FOLLOWING RESULTS:
 
     X=1.9999998554     EXACTLY: 2.0000000000
 
     Y=-1.9999995347427
 
     Y-X*(1-X)=0.0000000313
1SECTION : 5.2.1.1.1.1.C      (AUGUST 1974)                       PAGE 4
 
 
 
 SOURCE TEXT(S):
0"CODE" 33016 ;
    "PROCEDURE" RK4A(X, XA, B, Y, YA, FXY, E, D, FI, XDIR,
    POS); "VALUE" FI, XDIR, POS; "BOOLEAN" FI, XDIR, POS;
    "REAL" X, XA, B, Y, YA, FXY; "ARRAY" E, D;
    "BEGIN" "INTEGER" I;
       "BOOLEAN" IV, FIRST, FIR, REJ;
       "REAL" K0, K1, K2, K3, K4, K5, FHM, ABSH, DISCR, S, XL,
       COND0, S1, COND1, YL, HMIN, H, ZL, TOL, HL, MU, MU1;
       "ARRAY" E1[1:2];
 
       "PROCEDURE" RKSTEP(X, XL, H, Y, YL, ZL, FXY, D);
       "VALUE" XL, YL, ZL, H; "REAL" X, XL, H, Y, YL, ZL, FXY;
       "INTEGER" D;
       "BEGIN" "IF" D = 2 "THEN" "GOTO" INTEGRATE; "IF" D = 3 "THEN"
          "BEGIN" X:= XL; Y:= YL; K0:= FXY * H "END"
          "ELSE" "IF" D = 1 "THEN" K0:= ZL * H "ELSE" K0:= K0 * MU;
          X:= XL + H / 4.5; Y:= YL + K0 / 4.5; K1:= FXY * H;
          X:= XL + H / 3; Y:= YL + (K0 + K1 * 3) / 12;
          K2:= FXY * H; X:= XL + H * .5;
          Y:= YL + (K0 + K2 * 3) / 8; K3:= H * FXY;
          X:= XL + H * .8;
          Y:= YL + (K0 * 53 - K1 * 135 + K2 * 126 + K3 *
          56) / 125; K4:= FXY * H; "IF" D <= 1 "THEN"
          "BEGIN" X:= XL + H;
             Y:= YL + (K0 * 133 - K1 * 378 + K2 * 276 + K3
             * 112 + K4 * 25) / 168; K5:= FXY * H;
             DISCR:= ABS(K0 * 21 - K2 * 162 + K3 * 224 - K4
             * 125 + K5 * 42) / 14; "GOTO" END
          "END";
       INTEGRATE: X:= XL + H;
          Y:= YL + ( - K0 * 63 + K1 * 189 - K2 * 36 - K3 *
          112 + K4 * 50) / 28; K5:= FXY * H;
          Y:= YL + (K0 * 35 + K2 * 162 + K4 * 125 + K5 *
          14) / 336;
       END:
       "END" RKSTEP;                                           "COMMENT"
1SECTION : 5.2.1.1.1.1.C      (AUGUST 1974)                       PAGE 5
                                                                  ;
 
 
       "REAL" "PROCEDURE" FZERO;
       "BEGIN" "IF" IV "THEN"
          "BEGIN" "IF" S = XL "THEN" FZERO:= COND0 "ELSE" "IF" S = S1
             "THEN" FZERO:= COND1 "ELSE"
             "BEGIN" RKSTEP(X, XL, S - XL, Y, YL, ZL, FXY, 3);
                FZERO:= B
             "END"
          "END"
          "ELSE"
          "BEGIN" "IF" S = YL "THEN" FZERO:= COND0 "ELSE" "IF" S = S1
             "THEN" FZERO:= COND1 "ELSE"
             "BEGIN" RKSTEP(Y, YL, S - YL, X, XL, ZL, 1 /
                FXY, 3); FZERO:= B
             "END"
          "END"
       "END" FZERO;
 
       "IF" FI "THEN"
       "BEGIN" D[3]:= XA; D[4]:= YA; D[0]:= 1 "END";
       D[1]:= 0; X:= XL:= D[3]; Y:= YL:= D[4]; IV:= D[0] > 0;
       FIRST:= FIR:= "TRUE"; HMIN:= E[0] + E[1];
       H:= E[2] + E[3]; "IF" H < HMIN "THEN" HMIN:= H;
    CHANGE: ZL:= FXY; "IF" ABS(ZL) <= 1 "THEN"
       "BEGIN" "IF" "NOT"IV "THEN"
          "BEGIN" D[2]:= H:= H / ZL; D[0]:= 1;
             IV:= FIRST:= "TRUE"
          "END";
          "IF" FIR "THEN" "GOTO" A; I:= 1; "GOTO" AGAIN
       "END"
       "ELSE"
       "BEGIN" "IF" IV "THEN"
          "BEGIN" "IF" "NOT"FIR "THEN" D[2]:= H:= H * ZL; D[0]:= - 1;
             IV:= "FALSE"; FIRST:= "TRUE"
          "END";
          "IF" FIR "THEN"
          "BEGIN" H:= E[0] + E[1];
          A: "IF" ("IF" FI "THEN" ("IF" IV "EQV" XDIR "THEN" H "ELSE"
             H * ZL) < 0 "EQV" POS "ELSE" H * D[2] < 0) "THEN" H:= - H
          "END";
          I:= 1
       "END";                                                  "COMMENT"
1SECTION : 5.2.1.1.1.1.C      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
    AGAIN: ABSH:= ABS(H); "IF" ABSH < HMIN "THEN"
       "BEGIN" H:= SIGN(H) * HMIN; ABSH:= HMIN "END";
       "IF" IV "THEN"
       "BEGIN" RKSTEP(X, XL, H, Y, YL, ZL, FXY, I);
          TOL:= E[2] * ABS(K0) + E[3] * ABSH
       "END"
       "ELSE"
       "BEGIN" RKSTEP(Y, YL, H, X, XL, 1 / ZL, 1 / FXY, I);
          TOL:= E[0] * ABS(K0) + E[1] * ABSH
       "END";
       REJ:= DISCR > TOL; MU:= TOL / (TOL + DISCR) + .45;
       "IF" REJ "THEN"
       "BEGIN" "IF" ABSH <= HMIN "THEN"
          "BEGIN" "IF" IV "THEN"
             "BEGIN" X:= XL + H; Y:= YL + K0 "END"
             "ELSE"
             "BEGIN" X:= XL + K0; Y:= YL + H "END";
             D[1]:= D[1] + 1; FIRST:= "TRUE"; "GOTO" NEXT
          "END";
          H:= H * MU; I:= 0; "GOTO" AGAIN
       "END" REJ;
       "IF" FIRST "THEN"
       "BEGIN" FIRST:= FIR; HL:= H; H:= MU * H; "GOTO" ACCEPT
       "END";
       FHM:= MU * H / HL + MU - MU1; HL:= H; H:= FHM * H;
    ACCEPT: "IF" IV "THEN" RKSTEP(X, XL, HL, Y, YL, ZL, FXY,
       2) "ELSE" RKSTEP(Y, YL, HL, X, XL, ZL, 1 / FXY, 2);
       MU1:= MU;
    NEXT: "IF" FIR "THEN"
       "BEGIN" FIR:= "FALSE"; COND0:= B;
          "IF" "NOT"(FI "OR" REJ) "THEN" H:= D[2]
       "END"
       "ELSE"
       "BEGIN" D[2]:= H; COND1:= B;
          "IF" COND0 * COND1 <= 0 "THEN" "GOTO" ZERO;
          COND0:= COND1
       "END";
       D[3]:= XL:= X; D[4]:= YL:= Y; "GOTO" CHANGE;
    ZERO: E1[1]:= E[4]; E1[2]:= E[5];
       S1:= "IF" IV "THEN" X "ELSE" Y;
       S:= "IF" IV "THEN" XL "ELSE" YL ;
       ZEROIN(S,S1,FZERO,ABS(E1[1]*S)+ABS(E1[2])) ;
       S1:= "IF" IV "THEN" X "ELSE" Y ;
       "IF" IV "THEN" RKSTEP(X, XL, S - XL, Y, YL, ZL, FXY, 3)
       "ELSE" RKSTEP(Y, YL, S - YL, X, XL, ZL, 1 / FXY,
       3); D[3]:= X; D[4]:= Y
    "END" RK4A;
         "EOP"
1SECTION : 5.2.1.1.1.1.D      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : RK4NA.
 
 
 AUTHOR:J.A.ZONNEVELD.
 
 
 CONTRIBUTORS:M.BAKKER AND I.BRINK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730715.
 
 
 BRIEF DESCRIPTION:
 
     RK4NA SOLVES AN INITIAL VALUE PROBLEM FOR A SYSTEM OF FIRST
     ORDER ORDINARY DIFFERENTIAL EQUATIONS  DY / DX = F(X,Y), OF WHICH
     THE DERIVATIVE COMPONENTS ARE SUPPOSED TO BECOME LARGE, E.G. IN
     THE NEIGHBOURHOOD OF SINGULARITIES. RK4NA INTERCHANGES THE
     INDEPENDENT VARIABLE AND ONE DEPENDENT VARIABLE. THE SYSTEM
     IS SUPPOSED TO BE NON-STIFF.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM,
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS,
     LARGE DERIVATIVE COMPONENTS.
 
 
1SECTION : 5.2.1.1.1.1.D      (FEBRUARY 1979)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" RK4NA(X,XA,B,FXJ,J,E,D,FI,N,L,POS);
     "VALUE" FI,N,L,POS;
     "INTEGER" J,N,L;
     "BOOLEAN" FI,POS;
     "REAL" B,FXJ;
     "ARRAY" X,XA,E,D;
     "CODE" 33017;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     X:    <ARRAY IDENTIFIER>;
           "ARRAY" X[0:N];
           X[0] IS THE INDEPENDENT VARIABLE,
           X[1],...,X[N] ARE THE DEPENDENT VARIABLES;
           EXIT:THE SOLUTION AT B=0;
     XA:   <ARRAY IDENTIFIER>;
           "ARRAY" XA[0:N];
           ENTRY: THE INITIAL VALUES OF X[0],...,X[N];
     B:    <ARITHMETIC EXPRESSION>;
           B DEPENDS ON X[0],...,X[N];
           IF THE EQUATION B=0 IS SATISFIED WITHIN A
           CERTAIN TOLERANCE,THE INTEGRATION IS TERMINATED;
           B IS EVALUATED AND TESTED FOR CHANGE OF SIGN AT THE
           END OF EACH STEP;
           FOR THE TOLERANCE SEE PARAMETER E.
     FXJ:  <ARITHMETIC EXPRESSION>;
           FXJ DEPENDS ON X[0],...,X[N] AND J, DEFINING THE RIGHT
           HAND SIDE OF THE DIFFERENTIAL EQUATION;
           AT EACH CALL IT DELIVERS :DX[J]/DX[0];
     J:    <VARIABLE>;
           J IS USED AS A JENSEN PARAMETER FOR FXJ;
     E:    <ARRAY IDENTIFIER>;
           "ARRAY" E[0:2*N+3];
           ENTRY: E[2*J] AND E[2*J+1] , 0<=J<=N ,
           ARE THE RELATIVE AND THE ABSOLUTE TOLERANCE ,
           RESPECTIVELY, ASSOCIATED WITH X[J];
           E[2*N+2] AND E[2*N+3] ARE THE RELATIVE AND ABSOLUTE
           TOLERANCE  USED IN THE DETERMINATION OF THE ZERO OF B;
     D:    <ARRAY IDENTIFIER>;
           "ARRAY" D[0:N+3];
           AFTER COMPLETION OF EACH STEP WE HAVE :
           ENTIER(D[0]+.5) IS THE NUMBER OF STEPS SKIPPED;
           D[2] IS THE STEP LENGTH;
           D[J+3] IS THE LAST VALUE OF X[J], J=0,...,J=N;
1SECTION : 5.2.1.1.1.1.D      (DECEMBER 1975)                     PAGE 3
 
 
 
     FI:   <BOOLEAN EXPRESSION>
           IF FI="TRUE" THEN THE INTEGRATION IS STARTED WITH INITIAL
           CONDITIONS X[J]=XA[J];IF FI="FALSE" THEN THE INTEGRATION IS
           CONTINUED WITH X[J]=D[J+3];
     N:    <ARITHMETIC EXPRESSION>;
           THE NUMBER OF EQUATIONS;
     L:    <ARITHMETIC EXPRESSION>;
           AN INTEGER TO BE SUPPLIED BY THE USER, 0<=L<=N (SEE POS);
     POS:  <BOOLEAN EXPRESSION>
           IF FI="TRUE" THEN THE INTEGRATION STARTS IN SUCH A WAY
           THAT X[L] INCREASES IF POS="TRUE" AND X[L] DECREASES IF
           POS="FALSE";
           IF FI="FALSE" THEN POS IS OF NO SIGNIFICANCE.
 
 
 PROCEDURES USED : ZEROIN = CP34150.
 
 
 REQUIRED CENTRAL MEMORY : CIRCA 9*N MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE :
     RK4NA IS BASED ON AN EXPLICIT, 5-TH ORDER RUNGE-KUTTA METHOD
     AND INTERCHANGES VARIABLES. THE PROCEDURE IS PROVIDED WITH STEPSIZE
     AND ERROR CONTROL. FOR DETAILS, E.G. HOW TO USE ARRAY E, HOW TO
     SPECIFY THE ENDPOINT, HOW TO USE L AND POS, SEE [1] ( RK4NA IS A
     SLIGHTLY ADAPTED VERSION OF RK4N ).
 
 
 REFERENCES:
 
     [1].J.A.ZONNEVELD.
         AUTOMATIC NUMERICAL INTEGRATION.
         MATHEMATICAL CENTRE TRACT 8 (1970).
 
 
1SECTION : 5.2.1.1.1.1.D      (FEBRUARY 1979)                     PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     THE PERIOD OF THE SOLUTION OF THE VAN DER POL EQUATION
     DX[1]/DT = X[2]
     DX[2]/DT = 10*(1-X[1]**2)*X[2]-X[1], T>=0,
     CAN BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "COMMENT" VAN DER POL;
         "REAL" X0;
 
         "PROCEDURE" PRINT(X);"ARRAY" X;
         OUTPUT(61,"("/,4(+ZD.10D3B)")",X[0],X[1],X[2],X0);
 
         "INTEGER" J,K;"BOOLEAN" FIRST;
         "ARRAY" E[0:7],XA,X[0:2],D[0:5];
         "FOR" K:=0,1,2,3,4,5 "DO" E[K]:=.1"-6; E[6]:=E[7]:="-8 ;
         OUTPUT(61,"(""("VAN DER POL")",/BB"("EPS=")"D.10D,/BB
         "("THE VALUES OF X[0],X[1],X[2],P,RESPECTIVELY")"")",E[0]);
         X0:=XA[0]:=XA[2]:=0;XA[1]:=2;J:=0;PRINT(XA);
         FIRST:="TRUE";
         "FOR" J:=1,2,3,4 "DO"
         "BEGIN" RK4NA(X,XA,X[2],"IF" K=1 "THEN" X[2] "ELSE"
             10*(1-X[1]**2)*X[2]-X[1],K,E,D,FIRST,2,0,"TRUE");
             X0:=X[0]-X0;PRINT(X);FIRST:="FALSE"; X0:=X[0]
         "END"
     "END"
 
 
     THE PROGRAM PRINTS THE FOLLOWING RESULTS:
 
     VAN DER POL
 
     EPS=0.0000001000
 
     THE VALUES OF X[0],X[1],X[2],P,RESPECTIVELY:
 
     +0.00000000  +2.00000000  +0.00000000  +0.00000000
 
     +9.32386570  -2.01428560  +0.00000000  +9.32386570
 
     +18.86305411 +2.01428557  +0.00000000  +9.53918840
 
     +28.40224194  -2.01428858  -0.00000000  +9.53918783
 
     +37.94143003  +2.01428558  +0.00000000  +9.53918809
1SECTION : 5.2.1.1.1.1.D      (AUGUST 1974)                       PAGE 5
 
 
 
 SOURCE TEXT(S):
0"CODE" 33017 ;
    "PROCEDURE" RK4NA(X, XA, B, FXJ, J, E, D, FI, N, L, POS);
    "VALUE" FI, N, L, POS; "INTEGER" J, N, L; "BOOLEAN" FI, POS;
    "REAL" B, FXJ; "ARRAY" X, XA, E, D;
    "BEGIN" "INTEGER" I, IV, IV0;
       "BOOLEAN" FIR, FIRST, REJ;
       "REAL" H, COND0, COND1, FHM, ABSH, TOL, FH, MAX, X0,
       X1, S, HMIN, HL, MU, MU1;
       "ARRAY" XL, DISCR, Y[0:N], K[0:5,0:N], E1[1:2];
 
       "PROCEDURE" RKSTEP(H, D); "VALUE" H, D; "INTEGER" D; "REAL" H;
       "BEGIN" "INTEGER" I;
 
 
          "PROCEDURE" F(T); "VALUE" T; "INTEGER" T;
          "BEGIN" "INTEGER" I;
             "REAL" P;
             "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" Y[J]:= FXJ;
             P:= H / Y[IV];
             "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" I ^= IV "THEN" K[T,I]:= Y[I] * P "END"
          "END" F;
 
          "IF" D = 2 "THEN" "GOTO" INTEGRATE; "IF" D = 3 "THEN"
          "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I];
             F(0)
          "END"
          "ELSE" "IF" D = 1 "THEN"
          "BEGIN" "REAL" P;
             P:= H / Y[IV];
             "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" I ^= IV "THEN" K[0,I]:= P * Y[I] "END"
          "END"
          "ELSE"
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
          "BEGIN" "IF" I ^= IV "THEN" K[0,I]:= K[0,I] * MU "END";
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + ("IF" I
          = IV "THEN" H "ELSE" K[0,I]) / 4.5; F(1);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + ("IF" I
          = IV "THEN" H * 4 "ELSE" (K[0,I] + K[1,I] * 3)) / 12;
          F(2);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + ("IF" I
          = IV "THEN" H * .5 "ELSE" (K[0,I] + K[2,I] * 3) / 8);
          F(3);                                                "COMMENT"
1SECTION : 5.2.1.1.1.1.D      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + ("IF" I
          = IV "THEN" H * .8 "ELSE" (K[0,I] * 53 - K[1,I] * 135
          + K[2,I] * 126 + K[3,I] * 56) / 125); F(4);
          "IF" D <= 1 "THEN"
          "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] +
             ("IF" I = IV "THEN" H "ELSE" (K[0,I] * 133 -
             K[1,I] * 378 + K[2,I] * 276 + K[3,I] * 112 +
             K[4,I] * 25) / 168); F(5);
             "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" I ^= IV "THEN" DISCR[I]:= ABS(K[0,I] * 21
                - K[2,I] * 162 + K[3,I] * 224 - K[4,I] *
                125 + K[5,I] * 42) / 14
             "END";
             "GOTO" END
          "END";
       INTEGRATE: "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I]
          + ("IF" I = IV "THEN" H "ELSE" ( - K[0,I] * 63 + K[1,I]
          * 189 - K[2,I] * 36 - K[3,I] * 112 + K[4,I] * 50)
          / 28); F(5);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
          "BEGIN" "IF" I ^= IV "THEN" X[I]:= XL[I] + (K[0,I] * 35
             + K[2,I] * 162 + K[4,I] * 125 + K[5,I] * 14) / 336
          "END" ;
          END ..
          "END" RKSTEP ;
 
 
       "REAL" "PROCEDURE" FZERO;
       "BEGIN" "IF" S = X0 "THEN" FZERO:= COND0 "ELSE" "IF" S = X1
          "THEN" FZERO:= COND1 "ELSE"
          "BEGIN" RKSTEP(S - XL[IV], 3); FZERO:= B "END"
       "END" FZERO;
 
       "IF" FI "THEN"
       "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= XA[I];
          D[0]:= D[2]:= 0
       "END";
       D[1]:= 0;
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I]:= D[I + 3];
       IV:= D[0]; H:= D[2]; FIRST:= FIR:= "TRUE"; Y[0]:= 1;
       "GOTO" CHANGE;
    AGAIN: ABSH:= ABS(H); "IF" ABSH < HMIN "THEN"
       "BEGIN" H:= "IF" H > 0 "THEN" HMIN "ELSE" - HMIN;
          ABSH:= ABS(H)
       "END";
       RKSTEP(H, I); REJ:= "FALSE"; FHM:= 0;
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" "IF" I ^= IV "THEN"
          "BEGIN" TOL:= E[2 * I] * ABS(K[0,I]) + E[2 * I + 1]
             * ABSH; REJ:= TOL < DISCR[I] "OR" REJ;
             FH:= DISCR[I] / TOL; "IF" FH > FHM "THEN" FHM:= FH
          "END"
       "END";                                                  "COMMENT"
1SECTION : 5.2.1.1.1.1.D      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
       MU:= 1 / (1 + FHM) + .45; "IF" REJ "THEN"
       "BEGIN" "IF" ABSH <= HMIN "THEN"
          "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" "IF" I ^= IV "THEN" X[I]:= XL[I] + K[0,I]
                "ELSE" X[I]:= XL[I] + H
             "END";
             D[1]:= D[1] + 1; FIRST:= "TRUE"; "GOTO" NEXT
          "END";
          H:= H * MU; I:= 0; "GOTO" AGAIN
       "END";
       "IF" FIRST "THEN"
       "BEGIN" FIRST:= FIR; HL:= H; H:= MU * H; "GOTO" ACCEPT
       "END";
       FH:= MU * H / HL + MU - MU1; HL:= H; H:= FH * H;
    ACCEPT: RKSTEP(HL, 2); MU1:= MU;
    NEXT: "IF" FIR "THEN"
       "BEGIN" FIR:= "FALSE"; COND0:= B;
          "IF" "NOT"(FI "OR" REJ) "THEN" H:= D[2]
       "END"
       "ELSE"
       "BEGIN" D[2]:= H; COND1:= B;
          "IF" COND0 * COND1 <= 0 "THEN" "GOTO" ZERO;
          COND0:= COND1
       "END";
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= XL[I]:= X[I];
    CHANGE: IV0:= IV;
       "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" Y[J]:= FXJ;
       MAX:= ABS(Y[IV]);
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" "IF" ABS(Y[I]) > MAX "THEN"
          "BEGIN" MAX:= ABS(Y[I]); IV:= I "END"
       "END";
       "IF" IV0 ^= IV "THEN"
       "BEGIN" FIRST:= "TRUE"; D[0]:= IV;
          D[2]:= H:= Y[IV] / Y[IV0] * H
       "END";
       X0:= XL[IV]; "IF" FIR "THEN"
       "BEGIN" HMIN:= E[0] + E[1];
          "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
          "BEGIN" H:= E[2 * I] + E[2 * I + 1];
             "IF" H < HMIN "THEN" HMIN:= H
          "END";
          H:= E[2 * IV] + E[2 * IV + 1];
             "IF" (FI "AND" (Y[L]/Y[IV]*H<0 "EQV" POS)) "OR"
             ("NOT" FI "AND" D[2]*H<0) "THEN" H:= -H
       "END";
       I:= 1; "GOTO" AGAIN;
    ZERO: E1[1]:= E[2 * N + 2]; E1[2]:= E[2 * N + 3];
       X1:=X[IV] ; S:=X0 ;
       ZEROIN(S,X1,FZERO,ABS(E1[1]*S) + ABS(E1[2])) ; X0:=S ; X1:=X[IV];
       RKSTEP(X0 - XL[IV], 3);
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= X[I]
    "END" RK4NA;
         "EOP"
1SECTION : 5.2.1.1.1.1.E      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : RK5NA.
 
 
 AUTHOR: J.A.ZONNEVELD.
 
 
 CONTRIBUTORS: M.BAKKER AND I.BRINK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730715.
 
 
 BRIEF DESCRIPTION:
 
     RK5NA SOLVES AN INITIAL VALUE PROBLEM FOR A SYSTEM OF FIRST ORDER
     ORDINARY DIFFERENTIAL EQUATIONS  DY / DX = F(X,Y), OF WHICH THE
     DERIVATIVE COMPONENTS ARE SUPPOSED TO BECOME LARGE, E.G. IN THE
     NEIGHBOURHOOD OF SINGULARITIES. RK5NA INTRODUCES THE ARC LENGTH
     AS INTEGRATION VARIABLE. THE SYSTEM IS SUPPOSED TO BE NON-STIFF.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM.
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS.
     LARGE DERIVATIVE COMPONENTS.
 
 
1SECTION : 5.2.1.1.1.1.E      (FEBRUARY 1979)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" RK5NA(X, XA, B, FXJ, J, E, D, FI, N, L, POS);
     "VALUE" FI, N, L, POS; "INTEGER" J, N, L; "BOOLEAN" FI, POS;
     "REAL" B, FXJ; "ARRAY" X, XA, E, D;
     "CODE" 33018;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[0 : N];
         THE DEPENDENT VARIABLES;
         X[0], ..., X[N] CAN BE USED AS JENSEN PARAMETERS;
     XA:  <ARRAY IDENTIFIER>;
         "ARRAY" XA[0 : N];
         ENTRY: THE INITIAL VALUES OF X[J], J = 0, ..., N;
     B:  <ARITHMETIC EXPRESSION>;
         B DEPENDS ON X[0], ..., X[N];
         IF,WITHIN SOME TOLERANCE,B = 0 THEN THE INTEGRATION IS TER-
         MINATED; SEE ALSO THE EXPLANATION OF THE PARAMETER E;
     FXJ:  <ARITHMETIC EXPRESSION>;
         THE RIGHT HAND SIDE OF THE DIFFERENTIAL EQUATION;
         FXJ DEPENDS ON X[0], ..., X[N], J, GIVING THE VALUE OF
         DX[J] / DX[0];
     J:  <VARIABLE>;
         J IS USED AS A JENSEN PARAMETER TO DENOTE,IN THE ACTUAL
         PARAMETER CORRESPONDING TO FXJ,THE NUMBER OF THE FUNCTION
         REQUIRED;
     E:  <ARRAY IDENTIFIER>;
         "ARRAY" E[0 : 2 * N + 3];
         ENTRY:
         E[2 * J] AND E[2 * J + 1] ARE THE RELATIVE AND THE ABSOLUTE
         TOLERANCE,RESPECTIVELY,ASSOCIATED WITH X[J],J = 0,..., N, WHILE
         E[2 * N + 2] AND E[2 * N + 3] ARE THE ONES ASSOCIATED WITH B;
     D:  <ARRAY IDENTIFIER>;
         "ARRAY" D[1 : N + 3];
         AFTER COMPLETION OF EACH STEP WE HAVE:
 
             ABS(D[1])                   THE ARC LENGTH,
                 D[2]                    THE STEP LENGTH,
                 D[I + 3]                THE LATEST VALUE OF X[I],
                                         I = 0, ..., N;
 
     FI:  <BOOLEAN EXPRESSION>;
         IF FI = "TRUE" THEN THE INTEGRATION IS STARTED WITH INITIAL
         CONDITIONS X[I] = XA[I], I = 0, ..., N;
         IF FI = "FALSE" THEN THE INTEGRATION IS CONTINUED WITH
         X[I] = D[I + 3];
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF EQUATIONS;
1SECTION : 5.2.1.1.1.1.E      (FEBRUARY 1979)                     PAGE 3
 
 
 
     L:  <ARITHMETIC EXPRESSION>;
         1 <= L <= N; SEE THE EXPLANATION OF POS;
     POS:  <BOOLEAN EXPRESSION>;
         IF FI = "TRUE" THEN THE INTEGRATION STARTS IN SUCH A WAY THAT
         X[L] INCREASES IF POS = "TRUE" AND DECREASES IF POS = "FALSE".
         IF FI = "FALSE" THEN POS IS IGNORED.
 
 
 PROCEDURES USED : ZEROIN = CP34150.
 
 
 REQUIRED CENTRAL MEMORY : CIRCA 9 * N  MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE :
     RK5NA IS BASED ON A 5-TH ORDER RUNGE-KUTTA  METHOD AND INTEGRATES
     THE SYSTEM  DX[J] / DX[0] = F(J,X[0],..,X[N]) / F(0,X[0],..,X[N]).
     THE ARC LENGTH IS INTRODUCED AS INTEGRATION VARIABLE.
     THE INTEGRATION PROCESS IS TERMINATED IF SOME CONDITION ON
     X[0], .. ,X[N], TO BE SUPPLIED BY THE USER, IS SATISFIED.
     RK5NA USES STEPLENGTH AND ERROR CONTROL. DETAILS ABOUT THE
     PROCEDURE AND THE UNDERLYING THEORY ARE GIVEN IN [1] ( RK5NA IS
     A SLIGHTLY  ADAPTED VERSION OF RK5N).
 
 
 REFERENCES:
 
     [1]. J.A.ZONNEVELD,
          AUTOMATIC NUMERICAL INTEGRATION,
          MATH.CENTRE TRACT 8 (1970) .
 
 
1SECTION : 5.2.1.1.1.1.E      (AUGUST 1974)                       PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     THE VAN DER POL EQUATION IN THE PHASE PLANE
 
         DX[1] / DX[0] = (10*(1-X[0]**2)*X[1]-X[0])/X[1]
 
     CAN BE INTEGRATED BY THE PROCEDURE RK5NA; THE STARTING VALUES ARE
     X[0] = 2, X[1] = 0. THE INTEGRATION PROCEEDS UNTIL THE NEXT ZERO OF
     X[1],THEN IT CONTINUES UNTIL THE NEXT ZERO AND SO ON UNTIL THE
     FOURTH ZERO IS ENCOUNTERED.IN THE EXAMPLE THE OUTPUT IS GIVEN FOR
     THE TOLERANCES E[0]=E[1]=E[2]=E[3]= "-6, E[4]=E[5]= "-10.
     THE PROGRAM READS AS FOLLOWS:
 
     "BEGIN" "COMMENT" VAN DER POL IN THE PHASE PLANE;
         "INTEGER" J,K; "BOOLEAN" FIRST;
         "ARRAY" E[0:5],XA,X[0:1],D[1:4];
         "PROCEDURE" PRINT(X); "ARRAY" X;
         "BEGIN" OUTPUT(61,"("/B"("X[0]=")"+D.10D,
             10B"("X[1]=")"+D.10D,10B"("S=")"3D.10D")",X[0],
             X[1],ABS(D[1]))
         "END";
         "FOR" K:=0,1,2,3 "DO" E[K]:="-6 ; E[4]:=E[5]:="-10 ;  D[1]:=0;
         XA[0]:=2; XA[1]:=0; J:=0; PRINT(XA); AA:
         FIRST:=J=0;
         RK5NA(X,XA,X[1],"IF" K=0 "THEN" X[1] "ELSE"
         10*(1-X[0]**2)*X[1]-X[0],K,E,D,FIRST,1,1,"FALSE");;J:=J+1;
         PRINT(X); "IF" J<4 "THEN" "GO TO" AA
     "END"
 
     RESULTS:
 
     X[0]=+2.0000000000    X[1]=+0.0000000000    S=000.0000000000
 
     X[0]=-2.0142853657    X[1]=-0.0000000012    S=029.3873834087
 
     X[0]=+2.0142853659    X[1]=+0.0000000001    S=058.7884331939
 
     X[0]=-2.0142853659    X[1]=-0.0000000000    S=088.1894829781
 
     X[0]=+2.0142853659    X[1]=+0.0000000000    S=117.5905327623
1SECTION : 5.2.1.1.1.1.E      (AUGUST 1974)                       PAGE 5
 
 
 
 SOURCE TEXT(S):
 "CODE" 33018 ;
    "PROCEDURE" RK5NA(X, XA, B, FXJ, J, E, D, FI, N, L, POS);
    "VALUE" FI, N, L, POS; "INTEGER" J, N, L; "BOOLEAN" FI, POS;
    "REAL" B, FXJ; "ARRAY" X, XA, E, D;
    "BEGIN" "INTEGER" I;
       "BOOLEAN" FIRST, FIR, REJ;
       "REAL" FHM, S, S0, COND0, S1, COND1, H, ABSH, TOL, FH,
       HL, MU, MU1;
       "ARRAY" Y, XL, DISCR[0:N], K[0:5,0:N], E1[1:2];
       "REAL" "PROCEDURE" SUM(J,A,B,XJ) ; "INTEGER" J,A,B ; "REAL" XJ ;
       "BEGIN" "REAL" S ; S:= 0 ;
          "FOR" J:=A "STEP" 1 "UNTIL" B "DO" S:=S+XJ ; SUM:= S
       "END" SUM ;
       "PROCEDURE" RKSTEP(H, D); "VALUE" H, D; "INTEGER" D; "REAL" H;
       "BEGIN" "INTEGER" I;
          "PROCEDURE" F(T); "VALUE" T; "INTEGER" T;
          "BEGIN" "INTEGER" I;
             "REAL" P;
             "FOR" J:= 0 "STEP" 1 "UNTIL" N "DO" Y[J]:= FXJ;
             P:= H / SQRT(SUM(I, 0, N, Y[I] ** 2));
             "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" K[T,I]:= Y[I] * P
          "END" F;
          "IF" D = 2 "THEN" "GOTO" INTEGRATE; "IF" D = 1 "THEN"
          "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" K[0,I]:= K[0,I]
             * MU; "GOTO" A
          "END";
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I]; F(0);
       A: "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] +
          K[0,I] / 4.5; F(1);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + (K[0,I]
          + K[1,I] * 3) / 12; F(2);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + (K[0,I]
          + K[2,I] * 3) / 8; F(3);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + (K[0,I]
          * 53 - K[1,I] * 135 + K[2,I] * 126 + K[3,I] * 56)
          / 125; F(4); "IF" D <= 1 "THEN"
          "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] +
             (K[0,I] * 133 - K[1,I] * 378 + K[2,I] * 276 +
             K[3,I] * 112 + K[4,I] * 25) / 168; F(5);
             "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" DISCR[I]:=
             ABS(K[0,I] * 21 - K[2,I] * 162 + K[3,I] * 224
             - K[4,I] * 125 + K[5,I] * 42) / 14; "GOTO" END
          "END";
       INTEGRATE: "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I]
          + ( - K[0,I] * 63 + K[1,I] * 189 - K[2,I] * 36 -
          K[3,I] * 112 + K[4,I] * 50) / 28; F(5);
          "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I] + (K[0,I]
          * 35 + K[2,I] * 162 + K[4,I] * 125 + K[5,I] * 14)
          / 336;
       END:
       "END" RKSTEP;                                           "COMMENT"
1SECTION : 5.2.1.1.1.1.E      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
       "REAL" "PROCEDURE" FZERO;
       "BEGIN" "IF" S = S0 "THEN" FZERO:= COND0 "ELSE" "IF" S = S1
          "THEN" FZERO:= COND1 "ELSE"
          "BEGIN" RKSTEP(S - S0, 3); FZERO:= B "END"
       "END" FZERO;
 
       "IF" FI "THEN"
       "BEGIN" "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= XA[I];
          D[1]:= D[2]:= 0
       "END";
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" X[I]:= XL[I]:= D[I + 3];
       S:= D[1]; FIRST:= FIR:= "TRUE"; H:= E[0] + E[1];
       "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" ABSH:= E[2 * I] + E[2 * I + 1];
          "IF" H > ABSH "THEN" H:= ABSH
       "END";
       "IF" FI "THEN"
       "BEGIN" J:= L; "IF" FXJ * H < 0 "EQV" POS "THEN" H:= - H "END"
       "ELSE" "IF" D[2] * H < 0 "THEN" H:= - H; I:= 0;
    AGAIN: RKSTEP(H, I); REJ:= "FALSE"; FHM:= 0;
       ABSH:= ABS(H);
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" TOL:= E[2 * I] * ABS(K[0,I]) + E[2 * I + 1] *
          ABSH; REJ:= TOL < DISCR[I] "OR" REJ;
          FH:= DISCR[I] / TOL; "IF" FH > FHM "THEN" FHM:= FH
       "END";
       MU:= 1 / (1 + FHM) + .45; "IF" REJ "THEN"
       "BEGIN" H:= H * MU; I:= 1; "GOTO" AGAIN "END";
       "IF" FIRST "THEN"
       "BEGIN" FIRST:= FIR; HL:= H; H:= MU * H "END"
       "ELSE"
       "BEGIN" FH:= MU * H / HL + MU - MU1; HL:= H; H:= FH * H
       "END";
    ACCEPT: RKSTEP(HL, 2); MU1:= MU; S:= S + HL;
       "IF" FIR "THEN"
       "BEGIN" COND0:= B; FIR:= "FALSE"; "IF" "NOT"FI "THEN" H:= D[2]
       "END"
       "ELSE"
       "BEGIN" D[2]:= H; COND1:= B;
          "IF" COND0 * COND1 <= 0 "THEN" "GOTO" ZERO;
          COND0:= COND1
       "END";
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= XL[I]:= X[I];
       D[1]:= S0:= S; I:= 0; "GOTO" AGAIN;
    ZERO: E1[1]:= E[2 * N + 2]; E1[2]:= E[2 * N + 3];
       S1:=S ; S:=S0 ;
       ZEROIN(S,S1,FZERO,ABS(E1[1]*S)+ABS(E1[2])) ;
       RKSTEP(S - S0, 3);
       "FOR" I:= 0 "STEP" 1 "UNTIL" N "DO" D[I + 3]:= X[I]; D[1]:= S
    "END" RK5NA;
         "EOP"
1SECTION : 5.2.1.1.1.1.F      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : MULTISTEP.
 
 
 AUTHOR: P.W.HEMKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730515.
 
 
 BRIEF DESCRIPTION:
 
     MULTISTEP  SOLVES  AN INITIAL VALUE  PROBLEM, FOR A SYSTEM OF
     FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS  DY = F(Y).
     IN PARTICULAR THIS PROCEDURE IS SUITABLE FOR THE INTEGRATION OF
     STIFF DIFFERENTIAL EQUATIONS. IT CAN ALSO BE USED FOR
     NON-STIFF PROBLEMS.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM,
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS.
     STIFF EQUATIONS,
 
 
1SECTION : 5.2.1.1.1.1.F      (FEBRUARY 1979)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "BOOLEAN" "PROCEDURE" MULTISTEP(X,XEND,Y,HMIN,HMAX,YMAX,EPS,
                       FIRST,SAVE,DERIV,AVAILABLE,JACOBIAN,STIFF,N,OUT);
     "VALUE" HMIN,HMAX,EPS,XEND,N,STIFF;
     "BOOLEAN" FIRST,AVAILABLE,STIFF;
     "INTEGER" N;
     "REAL" X,XEND,HMIN,HMAX,EPS;
     "ARRAY" Y,YMAX,SAVE,JACOBIAN;
     "PROCEDURE" DERIV,OUT;
     "CODE" 33080;
 
     MULTISTEP  DELIVERS THE FOLLOWING BOOLEAN VALUE:
             IF DIFFICULTIES  ARE  ENCOUNTERED  DURING  THE  INTEGRATION
             (I.E. SAVE[-1] ^= 0 "OR" SAVE[-2] ^= 0 )  MULTISTEP IS  SET
             TO "FALSE", OTHERWISE MULTISTEP IS SET "TRUE".
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X.
             CAN BE USED IN DERIV, AVAILABLE ETC.;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE FINAL VALUE 'XEND';
     XEND:   <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X ( XEND >= X );
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1:6*N];
             THE DEPENDENT VARIABLE;
             ENTRY  Y[1:N] : THE INITIAL VALUES OF THE SOLUTION OF THE
                    SYSTEM OF DIFFERENTIAL EQUATIONS AT X = X0;
             EXIT Y[1:N] : THE FINAL VALUES OF THE SOLUTION AT X = XEND;
     HMIN,HMAX: <ARITHMETIC EXPRESSION>;
             ENTRY : MINIMAL  RESP. MAXIMAL STEPLENGTH  ALLOWED;
     YMAX:   <ARRAY IDENTIFIER>;
             "ARRAY" YMAX[1:N];
             ENTRY: THE  ABSOLUTE  LOCAL  ERROR  BOUND  DIVIDED  BY  EPS
             EXIT : YMAX[1]  GIVES THE  MAXIMAL VALUE OF THE ENTRY VALUE
                    OF  YMAX[I]  AND  THE  VALUES  OF  ABS(Y[I])  DURING
                    INTEGRATION;
     EPS:    <ARITHMETIC EXPRESSION>;
             THE RELATIVE LOCAL ERROR BOUND;
     FIRST:  <IDENTIFIER>;
             IF FIRST = "TRUE" THEN THE PROCEDURE STARTS THE INTEGRATION
             WITH  A  FIRST  ORDER  ADAMS METHOD AND A STEPLENGTH  EQUAL
             TO HMIN. UPON COMPLETION OF A CALL FIRST:= "FALSE";
             IF   FIRST  =  "FALSE"   THEN   THE   PROCEDURE   CONTINUES
             INTEGRATION;
1SECTION : 5.2.1.1.1.1.F      (DECEMBER 1979)                     PAGE 3
 
 
 
     SAVE:   <ARRAY IDENTIFIER>;
             "ARRAY" SAVE[-38:6*N];
             IN THIS ARRAY THE PROCEDURE STORES INFORMATION WHICH CAN BE
             USED IN A CONTINUING CALL WITH FIRST="FALSE";
             BESIDES THE FOLLOWING MESSAGES ARE DELIVERED:
             SAVE[ 0]=0 : AN ADAMS METHOD HAS BEEN USED;
                      1 : THE PROCEDURE SWITCHED TO GEARS METHOD;
             SAVE[-1]=0 : NO ERROR MESSAGE;
                      1 : WITH  THE HMIN SPECIFIED  THE PROCEDURE CANNOT
                          HANDLE  THE  NONLINEARITY  (DECREASE HMIN!  );
             SAVE[-2]  NUMBER OF TIMES  THAT THE  REQUESTED  LOCAL ERROR
                       BOUND WAS EXCEEDED;
             SAVE[-3]  IF SAVE[-2] IS NONZERO THEN SAVE[-3] GIVES AN
                       ESTIMATE OF THE MAXIMAL LOCAL ERROR BOUND,
                       OTHERWISE SAVE[-3]=0;
     DERIV:  <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIV(DF); "ARRAY" DF;
             THIS PROCEDURE SHOULD DELIVER DY[I]/DX IN DF[I];
     AVAILABLE: <BOOLEAN EXPRESSION>;
             IF AN  ANALYTICAL EXPRESSION  OF THE JACOBIAN MATRIX IS NOT
             AVAILABLE THIS EXPRESSION IS SET TO "FALSE";
             OTHERWISE THIS EXPRESSION IS SET TO "TRUE" AND THE
             EVALUATION  OF  THIS  BOOLEAN  EXPRESSION  MUST  EFFECT THE
             FOLLOWING SIDE-EFFECT:
             THE ENTRIES OF THE JACOBIAN MATRIX   D(DY[I]/DX)/DY[J]  ARE
             DELIVERED IN THE ARRAY ELEMENTS  JACOBIAN[I,J];
     JACOBIAN: <ARRAY IDENTIFIER>;
             "ARRAY" JACOBIAN[1:N,1:N];
             AT EACH EVALUATION OF THE BOOLEAN EXPRESSION AVAILABLE WITH
             THE RESULT AVAILABLE:="TRUE", THE JACOBIAN MATRIX HAS TO BE
             ASSIGNED TO THIS ARRAY (SEE THE  EXAMPLE OF USE);
     STIFF:  <BOOLEAN EXPRESSION>;
             IF STIFF = "TRUE"  THE PROCEDURE  SKIPS AN ATTEMPT TO SOLVE
             THE PROBLEM WITH ADAMS-BASHFORTH- OR ADAMS-MOULTON
             METHODS, DIRECTLY USING GEARS METHOD;
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     OUT:    <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" OUT(H,K);  "VALUE" H,K;  "REAL" H; "INTEGER" K;
             AT THE END OF EACH ACCEPTED STEP OF THE INTEGRATION PROCESS
             THIS PROCEDURE IS CALLED. THE LAST STEPLENGTH USED (H)  AND
             THE ORDER OF THE METHOD (K) ARE DELIVERED.
             AT EACH CALL OF THE  PROCEDURE OUT, THE  CURRENT VALUES  OF
             THE INDEPENDENT VARIABLE (X) AND OF THE SOLUTION (Y[I](X) )
             ARE AVAILABLE  FOR USE. MOREOVER, IN THE  NEIGHBOURHOOD  OF
             THE CURRENT VALUE OF X, ANY VALUE OF  Y[I](X SPECIFIED) CAN
             BE COMPUTED BY MEANS OF THE FOLLOWING INTERPOLATION FORMULA
             Y[I](X SPECIFIED) =
                  SUM(J,0,K, Y[I+J*N] * ((X SPECIFIED - X)/H) ** J ).
 
 
1SECTION : 5.2.1.1.1.1.F      (DECEMBER 1979)                     PAGE 4
 
 
 
 PROCEDURES USED:
 
     MATVEC = CP34011 ,
     DEC    = CP34300 ,
     SOL    = CP34051 .
 
 
 REQUIRED CENTRAL MEMORY: CIRCA  N * ( 2 * N + 5 )  MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE :
     MULTISTEP IS BASED ON TWO LINEAR MULTISTEP METHODS. FOR STIFF
     PROBLEMS IT USES THE BACKWARD DIFFERENTIATION METHODS, FOR
     FOR NON-STIFF PROBLEMS THE ADAMS-BASHFORTH-MOULTON METHODS.
     MULTISTEP IS PROVIDED WITH ORDER, STEPSIZE AND ERROR CONTROL.
 
 
 REFERENCES:
 
     [1].P.W.HEMKER.
         AN ALGOL 60 PROCEDURE  FOR THE SOLUTION  OF STIFF  DIFFERENTIAL
         EQUATIONS.
         MATH. CENTRE, AMSTERDAM. REPORT MR 128/71;
 
 
 EXAMPLE OF USE:
 
     THE SOLUTION AT X=1 AND AT X=10 OF THE DIFFERENTIAL EQUATIONS:
     DY[1]/DX = 0.04 * (1-Y[1]-Y[2]) - Y[1] * ("4*Y[2] + 3"7*Y[1])
     DY[2]/DX = 3"7 Y[1]**2
     WITH THE INITIAL CONDITIONS AT  X = 0 :
     Y[1] = 0  AND Y[2] = 0
     MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
1SECTION : 5.2.1.1.1.1.F      (AUGUST 1974)                       PAGE 5
 
 
 
 
  "BEGIN"
 
         "BOOLEAN" FIRST;
         "INTEGER" I,J,CF,CJ,CA;
         "REAL" X,XEND,HMIN,EPS,R;
         "ARRAY" Y[1:12],YMAX[1:2],D[-40:12],JAC[1:2,1:2];
 
         "PROCEDURE" DER (F);"ARRAY" F;
         "BEGIN" "REAL" R; CF:=CF+1;
              F[2]:= R:= 3"7*Y[1]*Y[1];
              F[1]:= 0.04*(1-Y[1]-Y[2]) - "4*Y[1]*Y[2] - R;
         "END" F;
 
         "BOOLEAN" "PROCEDURE" AVAIL;
         "BEGIN" "REAL" R; CJ:= CJ+1;
             AVAIL:= "TRUE";
             JAC[2,1]:= R:= 6"7*Y[1];
             JAC[1,1]:= -0.04 - "4*Y[2] - R;
             JAC[1,2]:= -0.04 - "4*Y[1];
             JAC[2,2]:= 0
         "END" JAC AVAIL;
 
         "PROCEDURE" OUT(H,K);
         "VALUE" H, K; "REAL" H; "INTEGER" K; CA:= CA+1;
 
         LABEL:
         OUTPUT(61,"("/,"("HMIN,EPS?")",/")");
         INREAL(70,HMIN); INREAL(70,EPS);
         "IF" HMIN<0 "THEN" "GOTO" ESCAPE;
 
         FIRST:= "TRUE"; CA:=CF:=CJ:=0;
         X:=0; Y[1]:= Y[2]:= 0;
         YMAX[1]:= 0.0001; YMAX[2]:= 1;
 
         "FOR" XEND:= 1, 10 "DO"
         "BEGIN"
             MULTISTEP(X,XEND,Y,HMIN,5,YMAX,EPS,FIRST,D,DER,AVAIL,
                                                JAC,"TRUE",2,OUT);
             OUTPUT(61,"("3(5ZD,2B),2(+.13D"+2D,2B),/")",
                                              CA,CF,CJ,Y[1],Y[2]);
         "END";
 
         "GOTO" LABEL;
         ESCAPE:
     "END"
 
     IT DELIVERS WITH  HMIN = "-10  AND  EPS = "-9:
     240   648   2   +.3074626[602000]"-04   +.3350951[493111]"-01
     315   902   3   +.16233909[62091]"-04   +.15861383[92015]"+00
     (NON-SIGNIFICANT DIGITS ARE PLACED BETWEEN [ ] ).
1SECTION : 5.2.1.1.1.1.F      (DECEMBER 1979)                     PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE"  33080;
  "BOOLEAN" "PROCEDURE" MULTISTEP(X,XEND,Y,HMIN,HMAX,YMAX,EPS,
             FIRST,SAVE,DERIV,AVAILABLE,JACOBIAN,STIFF,N,OUT);
  "VALUE" HMIN,HMAX,EPS,XEND,N,STIFF;
  "BOOLEAN" FIRST,AVAILABLE,STIFF;
  "INTEGER" N;
  "REAL" X,XEND,HMIN,HMAX,EPS;
  "ARRAY" Y,YMAX,SAVE,JACOBIAN;
  "PROCEDURE" DERIV,OUT;
  "BEGIN" "OWN" "BOOLEAN" ADAMS,WITH JACOBIAN;
         "OWN" "INTEGER" M,SAME,KOLD;
         "OWN" "REAL" XOLD,HOLD,A0,TOLUP,TOL,TOLDWN,TOLCONV;
         "BOOLEAN" EVALUATE,EVALUATED,DECOMPOSE,DECOMPOSED,CONV;
         "INTEGER" I,J,L,K,KNEW,FAILS;
         "REAL" H, CH, CHNEW,ERROR,DFI,C;
         "ARRAY" A[0:5],DELTA,LAST DELTA,DF[1:N],JAC[1:N, 1:N],AUX[1:3];
         "INTEGER" "ARRAY" P[1:N];
 
         "REAL" "PROCEDURE" NORM2(AI); "REAL" AI;
         "BEGIN" "REAL" S,A; S:= 1.0"-100;
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" A:= AI/YMAX[I]; S:= S + A * A "END";
                 NORM2:= S
         "END" NORM2;
 
         "PROCEDURE" RESET;
         "BEGIN" "IF" CH < HMIN/HOLD "THEN" CH:= HMIN/HOLD "ELSE"
                 "IF" CH > HMAX/HOLD "THEN" CH:= HMAX/HOLD;
                 X:= XOLD; H:= HOLD * CH; C:= 1;
                 "FOR" J:= 0 "STEP" M "UNTIL" K*M "DO"
                 "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                         Y[J+I]:= SAVE[J+I] * C;
                         C:= C * CH
                 "END";
                 DECOMPOSED:= "FALSE"
         "END" RESET;                                          "COMMENT"
 
1SECTION : 5.2.1.1.1.1.F      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
         "PROCEDURE" METHOD;
         "BEGIN" I:= -39;
                 "IF" ADAMS "THEN"
                 "BEGIN" "FOR" C:= 1,1,144,4,0,.5,1,.5,576,144,1,5/12,1,
                               .75,1/6,1436,576,4,.375,1,11/12,1/3,1/24,
                                2844,1436,1,251/720,1,25/24,35/72,
                                5/48,1/120,0,2844,0.1
                         "DO" "BEGIN" I:= I+ 1; SAVE[I]:= C "END"
                 "END" "ELSE"
 
                 "BEGIN" "FOR" C:= 1,1,9,4,0,2/3,1,1/3,36,20.25,1,6/11,
                        1,6/11,1/11,84.028,53.778,0.25,.48,1,.7,.2,.02,
                         156.25, 108.51, .027778, 120/274, 1, 225/274,
                         85/274, 15/274, 1/274, 0, 187.69, .0047361
                         "DO" "BEGIN" I:= I + 1; SAVE[I]:= C "END"
                 "END"
         "END" METHOD;
 
         "PROCEDURE" ORDER;
         "BEGIN" C:= EPS * EPS; J:= (K-1) * (K + 8)/2 - 38;
                 "FOR" I:= 0 "STEP" 1 "UNTIL" K "DO" A[I]:= SAVE[I+J];
                 TOLUP  := C * SAVE[J + K + 1];
                 TOL    := C * SAVE[J + K + 2];
                 TOLDWN := C * SAVE[J + K + 3];
                 TOLCONV:= EPS/(2 * N * (K + 2));
                 A0:= A[0];  DECOMPOSE:= "TRUE";
         "END" ORDER;
 
         "PROCEDURE" EVALUATE JACOBIAN;
         "BEGIN" EVALUATE:= "FALSE";
                 DECOMPOSE:= EVALUATED:= "TRUE";
                 "IF" AVAILABLE "THEN" "ELSE"
                 "BEGIN" "REAL" D; "ARRAY" FIXY,FIXDY,DY[1:N];
                         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                         FIXY[I]:= Y[I];
                         DERIV(FIXDY);
                         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
                         "BEGIN" D:= "IF" EPS > ABS(FIXY[J])
                                 "THEN" EPS * EPS
                                 "ELSE" EPS * ABS(FIXY[J]);
                                 Y[J]:= Y[J] + D; DERIV(DY);
                                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                                 JACOBIAN[I,J]:= (DY[I]-FIXDY[I])/D;
                                 Y[J]:= FIXY[J]
                         "END"
                 "END"
         "END" EVALUATE JACOBIAN;                              "COMMENT"
 
1SECTION : 5.2.1.1.1.1.F      (DECEMBER 1979)                     PAGE 8
                                                                  ;
 
 
         "PROCEDURE" DECOMPOSE JACOBIAN;
         "BEGIN" DECOMPOSE:= "FALSE";
                 DECOMPOSED:= "TRUE"; C:= -A0 * H;
                 "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                         JAC[I,J]:= JACOBIAN[I,J] * C;
                         JAC[J,J]:= JAC[J,J] + 1
                 "END";
                 AUX[2]:=1.0"-12;
                 DEC(JAC,N,AUX,P)
         "END" DECOMPOSE JACOBIAN;
 
         "PROCEDURE" CALCULATE STEP AND ORDER;
         "BEGIN" "REAL" A1,A2,A3;
                 A1:= "IF" K <= 1 "THEN" 0 "ELSE"
                      0.75 * (TOLDWN/NORM2(Y[K*M+I])) ** (0.5/K);
                 A2:= 0.80 * (TOL/ERROR) ** (0.5/(K + 1));
                 A3:= "IF" K >= 5 "OR" FAILS ^= 0
                      "THEN" 0 "ELSE"
                      0.70 * (TOLUP/NORM2(DELTA[I] - LAST DELTA[I])) **
                      (0.5/(K+2));
 
                 "IF" A1 > A2 "AND" A1 > A3 "THEN"
                 "BEGIN" KNEW:= K-1; CHNEW:= A1 "END" "ELSE"
                 "IF" A2 > A3 "THEN"
                 "BEGIN" KNEW:= K  ; CHNEW:= A2 "END" "ELSE"
                 "BEGIN" KNEW:= K+1; CHNEW:= A3 "END"
         "END" CALCULATE STEP AND ORDER;
 
         "IF" FIRST "THEN"
         "BEGIN" FIRST:= "FALSE"; M:= N;
                 "FOR" I:= -1,-2,-3 "DO" SAVE[I]:= 0;
                 OUT(0,0);
                 ADAMS:= "NOT" STIFF; WITH JACOBIAN:= "NOT" ADAMS;
                 "IF" WITH JACOBIAN "THEN" EVALUATE JACOBIAN;
                 METHOD;
         NEW START: K:= 1; SAME:= 2; ORDER; DERIV(DF);
                 H:= "IF" "NOT" WITH JACOBIAN "THEN" HMIN "ELSE"
                 SQRT(2 * EPS/SQRT(NORM2 (MATVEC(1,N,I,JACOBIAN,DF))));
                 "IF" H > HMAX "THEN" H:= HMAX "ELSE"
                 "IF" H < HMIN "THEN" H:= HMIN;
                 XOLD:= X; HOLD:= H; KOLD:= K; CH:= 1;
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" SAVE[I]:= Y[I]; SAVE[M+I]:= Y[M+I]:= DF[I] * H
                 "END";
                 OUT(0,0)
         "END" "ELSE"
         "BEGIN" WITH JACOBIAN:= "NOT" ADAMS; CH:= 1;
                 K:=KOLD; RESET; ORDER;
                 DECOMPOSE:= WITH JACOBIAN
         "END";
         FAILS:= 0;                                            "COMMENT"
 
1SECTION : 5.2.1.1.1.1.F      (AUGUST 1974)                       PAGE 9
                                                                  ;
 
 
         "FOR" L:= 0 "WHILE" X < XEND "DO"
         "BEGIN" "IF" X + H <= XEND "THEN" X:= X + H "ELSE"
                 "BEGIN" H:= XEND-X; X:= XEND; CH:= H/HOLD; C:= 1;
                         "FOR" J:= M "STEP" M "UNTIL" K*M "DO"
                         "BEGIN" C:= C* CH;
                                 "FOR" I:= J+1 "STEP" 1 "UNTIL" J+N "DO"
                                 Y[I]:= Y[I] * C
                         "END";
                         SAME:= "IF" SAME<3 "THEN" 3 "ELSE" SAME+1;
                 "END";
 
                 "COMMENT" PREDICTION;
                 "FOR" L:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" "FOR" I:= L "STEP" M "UNTIL" (K-1)*M+L "DO"
                         "FOR" J:= (K-1)*M+L "STEP" -M "UNTIL" I "DO"
                         Y[J]:= Y[J] + Y[J+M];
                         DELTA[L]:= 0
                 "END";  EVALUATED:= "FALSE";
 
         "COMMENT" CORRECTION AND ESTIMATION LOCAL ERROR;
         "FOR" L:= 1,2,3 "DO"
         "BEGIN" DERIV(DF);
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 DF[I]:= DF[I] * H - Y[M+I];
                 "IF" WITH JACOBIAN "THEN"
                 "BEGIN" "IF" EVALUATE "THEN" EVALUATE JACOBIAN;
                         "IF" DECOMPOSE "THEN" DECOMPOSE JACOBIAN;
                         SOL(JAC,N,P,DF)
                 "END";
 
                 CONV:= "TRUE";
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" DFI:= DF[I];
                         Y[  I]:= Y[  I] + A0 * DFI;
                         Y[M+I]:= Y[M+I] +      DFI;
                         DELTA[I]:= DELTA[I] +  DFI;
                         CONV:= CONV "AND" ABS(DFI) < TOLCONV * YMAX[I]
                 "END";
                 "IF" CONV "THEN"
                 "BEGIN" ERROR:= NORM2(DELTA[I]);
                         "GOTO" CONVERGENCE
                 "END"
         "END";                                                "COMMENT"
 
1SECTION : 5.2.1.1.1.1.F      (DECEMBER 1979)                    PAGE 10
                                                                  ;
 
 
         "COMMENT" ACCEPTANCE OR REJECTION;
         "IF" "NOT" CONV "THEN"
         "BEGIN" "IF" "NOT" WITH JACOBIAN "THEN"
                 "BEGIN" EVALUATE:= WITH JACOBIAN:= SAME >= K
                            "OR" H<1.1 * HMIN;
                         "IF" "NOT" WITH JACOBIAN "THEN" CH:= CH/4;
                 "END" "ELSE"
                 "IF" "NOT" DECOMPOSED "THEN" DECOMPOSE:= "TRUE" "ELSE"
                 "IF" "NOT" EVALUATED  "THEN" EVALUATE := "TRUE" "ELSE"
                 "IF" H > 1.1 * HMIN   "THEN" CH:= CH/4 "ELSE"
                 "IF" ADAMS            "THEN" "GOTO" TRY CURTISS "ELSE"
                 "BEGIN" SAVE[-1]:= 1; "GOTO" RETURN "END";
 
                 RESET
         "END" "ELSE" CONVERGENCE:
 
         "IF" ERROR > TOL "THEN"
         "BEGIN" FAILS:= FAILS + 1;
                 "IF" H > 1.1 * HMIN "THEN"
                 "BEGIN" "IF" FAILS > 2 "THEN"
                         "BEGIN" "IF" ADAMS "THEN"
                                 "BEGIN" ADAMS:= "FALSE"; METHOD "END";
                                 KOLD:= 0; RESET; "GOTO" NEW START
                         "END" "ELSE"
                         "BEGIN" CALCULATE STEP AND ORDER;
                                 "IF" KNEW ^= K "THEN"
                                 "BEGIN" K:= KNEW; ORDER "END";
                                 CH:= CH * CHNEW; RESET
                         "END"
                 "END" "ELSE"
                 "BEGIN" "IF" ADAMS "THEN" TRY CURTISS:
                         "BEGIN" ADAMS:= "FALSE"; METHOD
                         "END" "ELSE"
                         "IF" K = 1 "THEN"
                         "BEGIN" "COMMENT" VIOLATE EPS CRITERION;
                                 C:= EPS * SQRT(ERROR/TOL);
                                 "IF" C > SAVE[-3] "THEN" SAVE[-3]:= C;
                                 SAVE[-2]:= SAVE[-2] + 1;
                                 SAME:= 4; "GOTO" ERROR TEST OK
                         "END";
                         K:= KOLD:= 1; RESET; ORDER; SAME:= 2
                 "END"
         "END" "ELSE" ERROR TEST OK:
         "BEGIN"                                               "COMMENT"
1SECTION : 5.2.1.1.1.1.F      (AUGUST 1974)                      PAGE 11
                                                                  ;
 
 
                 FAILS:= 0;
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" C:= DELTA[I];
                         "FOR" L:= 2 "STEP" 1 "UNTIL" K "DO"
                         Y[L*M+I]:= Y[L*M+I] + A[L] * C;
                         "IF" ABS(Y[I]) > YMAX[I] "THEN"
                              YMAX[I]:=  ABS(Y[I])
                 "END";
 
                 SAME:= SAME-1;
                 "IF" SAME= 1 "THEN"
                 "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                         LAST DELTA[I]:= DELTA[I]
                 "END" "ELSE"
                 "IF" SAME= 0 "THEN"
                 "BEGIN" CALCULATE STEP AND ORDER;
                         "IF" CHNEW > 1.1 "THEN"
                         "BEGIN" DECOMPOSED:= "FALSE";
                                 "IF" K ^= KNEW "THEN"
                                 "BEGIN" "IF" KNEW > K "THEN"
                                         "BEGIN" "FOR" I:= 1 "STEP" 1
                                              "UNTIL" N "DO" Y[KNEW*M+I]
                                                 := DELTA[I] * A[K]/KNEW
                                         "END";
                                         K:= KNEW; ORDER
                                 "END";
                                 SAME:= K+1;
                                 "IF" CHNEW * H > HMAX
                                     "THEN" CHNEW:= HMAX/H;
                                 H:= H * CHNEW; C:= 1;
                                 "FOR" J:= M "STEP" M "UNTIL" K*M "DO"
                                 "BEGIN" C:= C * CHNEW;
                                         "FOR" I:= J+1 "STEP" 1 "UNTIL"
                                         J+N "DO" Y[I]:= Y[I] * C
                                 "END"
                         "END"
                         "ELSE" SAME:= 10
                 "END";
                 "IF" X ^= XEND "THEN"
                 "BEGIN" XOLD:= X; HOLD:= H; KOLD:= K; CH:= 1;
                         "FOR" I:= K * M + N "STEP" -1 "UNTIL" 1 "DO"
                         SAVE[I]:= Y[I];
                         OUT(H,K)
                 "END"
         "END" CORRECTION AND ESTIMATION LOCAL ERROR;
         "END" STEP;
 
         RETURN: SAVE[0]:= "IF" ADAMS "THEN" 0 "ELSE" 1;
         MULTISTEP:= SAVE[-1]= 0 "AND" SAVE[-2]=0
  "END" MULTISTEP;
         "EOP"
1SECTION : 5.2.1.1.1.1.G      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : DIFFSYS.
 
 
 AUTHORS   : R.BULIRSCH AND J.STOER.
 
 
 CONTRIBUTOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731231.
 
 
 BRIEF DESCRIPTION:
 
     DIFFSYS SOLVES AN INITIAL VALUE PROBLEM ,FOR A SYSTEM OF FIRST
     ORDER ORDINARY DIFFERENTIAL EQUATIONS DY / DX = F(X,Y).
     THE METHOD IS RECOMMENDED IF HIGH ACCURACY IS DESIRED.
     DIFFSYS IS NOT SUITED FOR STIFF EQUATIONS.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEMS,
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS.
 
 
1SECTION : 5.2.1.1.1.1.G      (FEBRUARY 1979)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE DIFFSYS READS:
     "PROCEDURE" DIFFSYS(X,XE,N,Y,DERIVATIVE,AETA,RETA,S,H0,OUTPUT);
     "VALUE" N;
     "INTEGER" N;
     "REAL" X,XE,AETA,RETA,H0;
     "ARRAY" Y,S;
     "PROCEDURE" DERIVATIVE,OUTPUT;
     "CODE" 33180;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE  ;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE FINAL VALUE XE;
     XE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X (XE>=X);
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     Y:      <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" Y[1:N];
             THE DEPENDENT VARIABLE;
             ENTRY: THE  INITIAL  VALUES  OF  THE SYSTEM OF DIFFERENTIAL
                    EQUATIONS AT X=X0;
             EXIT : THE FINAL VALUES OF THE SOLUTION AT X=XE;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(X,Y,DY); "REAL" X; "ARRAY" Y,DY;
             THIS  PROCEDURE  SHOULD  DELIVER  THE  RIGHT  HAND  SIDE OF
             THE I-TH DIFFERENTIAL EQUATION AT THE POINT (X,Y) AS DY[I],
             I=1,...,N;
     AETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  ABSOLUTE  PRECISION  IN THE  INTEGRATION PROCESS;
     RETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  RELATIVE  PRECISION  IN THE  INTEGRATION PROCESS;
     S:      <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" S[1:N];
             THE ARRAY S IS USED TO CONTROL THE ACCURACY OF THE COMPUTED
             VALUES OF Y;
             ENTRY: IT IS ADVISABLE TO SET S[I]=0, I=1,...,N;
             EXIT : THE MAXIMUM VALUE  OF ABS(Y[I]), ENCOUNTERED  DURING
                    INTEGRATION, IF THIS VALUE EXCEEDS THE VALUE OF S[I]
                    ON ENTRY;
     H0:     <VARIABLE>;
             THE INITIAL STEP TO BE TAKEN;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS;
             "PROCEDURE" OUTPUT;
             THIS  PROCEDURE  IS  CALLED  AT THE END OF EACH INTEGRATION
             STEP ; THE USER CAN ASK FOR OUTPUT OF SOME PARAMETERS , FOR
             EXAMPLE X, Y, S.
 
 
1SECTION : 5.2.1.1.1.1.G      (FEBRUARY 1979)                     PAGE 3
 
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY : CIRCA 28* N  MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE  DIFFSYS  IS  A SLIGHT  MODIFICATION OF THE ALGORITHM
     PUBLISHED BY BULIRSCH AND STOER (SEE REF[1]) . BY THIS MODIFICATION
     INTEGRATION  FROM X0  UNTIL XE  CAN BE  PERFORMED  BY  ONE  CALL OF
     DIFFSYS. A NUMBER OF INTEGRATION STEPS ARE TAKEN, STARTING WITH THE
     INITIAL STEP H0. IN EACH INTEGRATION STEP A NUMBER OF SOLUTIONS ARE
     COMPUTED BY MEANS OF THE MODIFIED MIDPOINT RULE . EXTRAPOLATION  IS
     USED TO IMPROVE THESE SOLUTIONS,UNTIL THE REQUIRED ACCURACY IS MET.
     AN INTEGRATION STEP  IS REJECTED, IF THE ACCURACY REQUIREMENTS  ARE
     NOT FULFILLED  AFTER NINE EXTRAPOLATION STEPS . IN THESE CASES  THE
     INTEGRATION STEP IS REJECTED , AND INTEGRATION IS TRIED  AGAIN WITH
     THE INTEGRATION STEP HALVED.
     THE ALGORITHM IS FOR EACH STEP A VARIABLE ORDER METHOD (THE HIGHEST
     ORDER IS 14 ), AND USES A VARIABLE NUMBER OF  FUNCTION EVALUATIONS,
     DEPENDING ON THE ORDER (MINIMUM IS 3, MAXIMUM IS 217).
     THE ALGORITHM IS LESS SENSITIVE TO TOO SMALL VALUES  OF THE INITIAL
     STEPSIZE THAN THE ORIGINAL ALGORITHM ( SEE REF [2] );  HOWEVER  BAD
     GUESSES REQUIRE STILL SOME MORE COMPUTATIONS.
 
 REFERENCES:
 
     [1]. R.BULIRSCH AND J.STOER.
          NUMERICAL  TREATMENT  OF  ORDINARY  DIFFERENTIAL  EQUATIONS BY
          EXTRAPOLATION METHODS.
          NUMERISCHE MATHEMATIK, VOLUME 8, PAGE 1-13, 1965.
 
     [2]. PHYLLIS FOX.
          A  COMPARATIVE  STUDY  OF  COMPUTER  PROGRAMS  FOR INTEGRATING
          DIFFERENTIAL EQUATIONS.
          COMMUNICATIONS OF THE A.C.M., VOLUME 15, PAGE 941-948, 1972.
 
     [3]. T.E.HULL, W.H.ENRIGHT, B.M.FELLEN AND A.E.SEDGWICK.
          COMPARING   NUMERICAL   METHODS  FOR   ORDINARY   DIFFERENTIAL
          EQUATIONS.
          SIAM JOURNAL ON NUMERICAL ANALYSIS,VOLUME 9,PAGE 603-635,1972.
 
1SECTION : 5.2.1.1.1.1.G      (AUGUST 1974)                       PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING  PROGRAM  ILLUSTRATES  THE COSTS  AND  THE ACCURACIES
     WHICH ARE OBTAINED WHEN SOLVING A SYSTEM OF DIFFERENTIAL  EQUATIONS
     ARISING FROM THE RESTRICTED PROBLEM OF THREE BODIES ( SEE REF[1] ).
     THE SOLUTION IS A CLOSED ORBIT WITH PERIOD T=6.192169331396.
 
     "BEGIN"
         "INTEGER" PASSES,K;
         "REAL" X,XE,TIME,TOL,H0;
         "REAL" "ARRAY" Y,S[1:4];
 
         "PROCEDURE" DER(X,Y,DY); "REAL" X; "ARRAY" Y,DY;
         "BEGIN" "REAL" MU,MU1,Y1,Y2,Y3,Y4,S1,S2;
             MU:=1/82.45; MU1:=1-MU;
             PASSES:=PASSES+1;
             Y1:=Y[1]; Y2:=DY[1]:=Y[2]; Y3:=Y[3]; Y4:=DY[3]:=Y[4];
             S1:=(Y1+MU)**2+Y3**2; S2:=(Y1-MU1)**2+Y3**2;
             S1:=S1*SQRT(S1); S2:=S2*SQRT(S2);
             DY[2]:=Y1+2*Y4-MU1*(Y1+MU)/S1-MU*(Y1-MU1)/S2;
             DY[4]:=Y3-2*Y2-MU1*Y3/S1-MU*Y3/S2
         "END";
 
         "PROCEDURE" OUT;
         "BEGIN" K:=K+1;
             "IF" X>=XE "THEN"
             OUTPUT(61,"("2(-5ZD),2(4B+Z.3DB3DB3DB3D),-5ZD.3D,/")",K,
             PASSES,Y[1],Y[3],CLOCK-TIME)
         "END";
 
         OUTPUT(61,"(""("    THIS LINE AND THE FOLLOWING TEXT IS ")"
         "("PRINTED BY THIS PROGRAM")",//,
         "("    THE RESULTS WITH DIFFSYS - H0=.2 - ARE: ")",/,
         "("     K   DER.EV.         Y[1]                 Y[3]      ")",
         "("       TIME")",/")");
         "FOR" TOL:="-4,"-6,"-8,"-10,"-12 "DO"
         "BEGIN" PASSES:=K:=0; X:=0; XE:=6.192169331396;
             Y[1]:=1.2; Y[2]:=Y[3]:=0; Y[4]:=-1.04935750983;
             S[1]:=S[2]:=S[3]:=S[4]:=0; H0:=.2; TIME:=CLOCK;
             DIFFSYS(X,XE,4,Y,DER,TOL,TOL,S,H0,OUT);
         "END"
     "END"
 
     THIS LINE AND THE FOLLOWING TEXT IS PRINTED BY THIS PROGRAM:
 
     THE RESULTS WITH DIFFSYS - H0=.2 - ARE:
      K   DER.EV.         Y[1]                  Y[3]             TIME
      30   2591    +1.320 357 347 741     -.032 645 454 836      5.686
      33   3414    +1.200 078 037 878     -.000 053 906 067      7.455
      37   4213    +1.200 003 282 801     -.000 002 363 741      9.267
      44   4618    +1.199 999 999 711     -.000 000 000 095     10.242
      56   6299    +1.200 000 000 003     -.000 000 000 090     13.827
1SECTION : 5.2.1.1.1.1.G      (AUGUST 1974)                       PAGE 5
 
 
 
 SOURCE TEXT:
0"CODE" 33180;
 "PROCEDURE" DIFFSYS(X,XE,N,Y,DERIVATIVE,AETA,RETA,S,H0,OUTPUT);
 "VALUE" N;
 "INTEGER" N;
 "REAL" X,XE,AETA,RETA,H0;
 "ARRAY" Y,S;
 "PROCEDURE" DERIVATIVE,OUTPUT;
 "BEGIN" "REAL" A,B,B1,C,G,H,U,V,TA,FC; "INTEGER" I,J,K,KK,JJ,L,M,R,SR;
     "ARRAY" YA,YL,YM,DY,DZ[1:N],DT[1:N,0:6],D[0:6],YG,YH[0:7,1:N];
     "BOOLEAN" KONV,B0,BH,LAST;
     LAST:="FALSE"; H:=H0;
 NEXT: "IF" H*1.1>=XE-X "THEN"
     "BEGIN" LAST:="TRUE"; H0:=H; H:=XE-X+"-13 "END";
     DERIVATIVE(X,Y,DZ); BH:="FALSE";
     "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" YA[I]:=Y[I];
 ANF: A:=H+X; FC:=1.5; B0:="FALSE"; M:=1; R:=2; SR:=3; JJ:=-1;
     "FOR" J:=0 "STEP" 1 "UNTIL" 9 "DO"
     "BEGIN" "IF" B0 "THEN"
         "BEGIN" D[1]:=16/9; D[3]:=64/9; D[5]:=256/9 "END"
         "ELSE" "BEGIN" D[1]:=9/4; D[3]:=9; D[5]:=36 "END";
         KONV:="TRUE";
         "IF" J>6 "THEN" "BEGIN" L:=6; D[6]:=64; FC:=.6*FC "END"
         "ELSE" "BEGIN" L:=J; D[L]:=M*M "END";
         M:=M*2; G:=H/M; B:=G*2;
         "IF" BH "AND" J<8 "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" YM[I]:=YH[J,I]; YL[I]:=YG[J,I] "END"
         "END"
         "ELSE"
         "BEGIN"                                               "COMMENT"
1SECTION : 5.2.1.1.1.1.G      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
                 KK:=(M-2)/2; M:=M-1;
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" YL[I]:=YA[I]; YM[I]:=YA[I]+G*DZ[I] "END";
             "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" DERIVATIVE(X+K*G,YM,DY);
                 "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" U:=YL[I]+B*DY[I]; YL[I]:=YM[I]; YM[I]:=U;
                     U:=ABS(U); "IF" U>S[I] "THEN" S[I]:=U
                 "END";
                 "IF" K=KK "AND" K^=2 "THEN"
                 "BEGIN" JJ:=JJ+1; "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
                     "BEGIN" YH[JJ,I]:=YM[I]; YG[JJ,I]:=YL[I] "END"
                 "END"
             "END"
         "END";
         DERIVATIVE(A,YM,DY);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" V:=DT[I,0]; TA:=C:=DT[I,0]:=(YM[I]+YL[I]+G*DY[I])/2;
             "FOR" K:=1 "STEP" 1 "UNTIL" L "DO"
             "BEGIN" B1:=D[K]*V; B:=B1-C; U:=V;
                 "IF" B^=0 "THEN"
                 "BEGIN" B:=(C-V)/B; U:=C*B; C:=B1*B "END";
                 V:=DT[I,K]; DT[I,K]:=U; TA:=U+TA
             "END";
             "IF" ABS(Y[I]-TA)>RETA*S[I]+AETA "THEN" KONV:="FALSE";
             Y[I]:=TA
         "END";
         "IF" KONV "THEN" "GOTO" END;
         D[2]:=4; D[4]:=16; B0:=^B0; M:=R; R:=SR; SR:=M*2
     "END";
     BH:=^BH; LAST:="FALSE"; H:=H/2; "GOTO" ANF;
 END: H:=FC*H; X:=A; OUTPUT; "IF" "NOT" LAST "THEN" "GOTO" NEXT;
 "END" DIFFSYS;
         "EOP"
1SECTION : 5.2.1.1.1.1.H      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE : ARK.
 
 
 AUTHOR:  P.A. BEENTJES.
 
 
 INSTITUTE:  MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740510.
 
 
 BRIEF DESCRIPTION:
 
     ARK SOLVES AN INITIAL VALUE PROBLEM, FOR A SYSTEM  OF FIRST ORDER
     ORDINARY DIFFERENTIAL EQUATIONS . ARK IS RECOMMENDED FOR THE
     INTEGRATION OF SEMI-DISCRETE PARABOLIC AND HYPERBOLIC
     INITIAL-BOUNDARY PROBLEMS.
 
 
 KEYWORDS:
     INITIAL VALUE PROBLEM,
     SEMI-DISCRETE PARABOLIC AND HYPERBOLIC PROBLEM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" ARK (T, TE, M0, M, U, DERIVATIVE, DATA, OUT);
     "INTEGER" M0, M; "REAL" T, TE; "ARRAY" U, DATA;
     "PROCEDURE" DERIVATIVE, OUT;
     "CODE" 33061;
 
     ARK :   INTEGRATES THE SYSTEM OF ORDINARY DIFFERENTIAL  EQUATIONS
             DU / DT = H(T, U),  U = U0   AT   T = T0.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     T:      <VARIABLE>;
             THE  INDEPENDENT  VARIABLE  T;
             ENTRY: THE INITIAL VALUE T0;
             EXIT : THE FINAL VALUE TE;
     TE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF T (TE >= T);
     M0,M:   <ARITHMETIC EXPRESSION>;
             INDICES  OF  THE  FIRST  AND  LAST EQUATION OF THE SYSTEM;
     U:      <ARRAY IDENTIFIER>;
             "ARRAY" U[M0 : M];
             ENTRY: THE INITIAL VALUES OF THE SOLUTION OF THE SYSTEM OF
                    DIFFERENTIAL EQUATIONS AT T = T0;
             EXIT : THE VALUES OF THE SOLUTION AT T = TE;
1SECTION : 5.2.1.1.1.1.H      (FEBRUARY 1979)                     PAGE 2
 
 
 
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(T, V); "REAL" T; "ARRAY" V;
             THIS PROCEDURE  PERFORMS  AN  EVALUATION OF THE RIGHT HAND
             SIDE  OF THE SYSTEM WITH DEPENDENT VARIABLES V[M0 : M] AND
             INDEPENDENT VARIABLE T; UPON COMPLETION OF DERIVATIVE, THE
             RIGHT HAND SIDE   SHOULD  BE   OVERWRITTEN  ON  V[M0 : M];
     DATA:   <ARRAY IDENTIFIER>;
             "ARRAY" DATA[1 : 10 + DATA[1]];
             IN ARRAY DATA ONE SHOULD GIVE:
             DATA[1]: THE   NUMBER   OF   EVALUATIONS  OF   H(T, U) PER
                      INTEGRATION STEP(DATA[1] >= DATA[2]);
             DATA[2]: THE ORDER OF ACCURACY OF THE METHOD (DATA[2]<=3);
             DATA[3]: STABILITY BOUND(SEE REFERENCE [3]);
             DATA[4]: THE SPECTRAL RADIUS  OF THE JACOBIAN MATRIX  WITH
                      RESPECT TO  THOSE EIGENVALUES, WHICH ARE  LOCATED
                      IN THE NON-POSITIVE HALF PLANE;
             DATA[5]: THE MINIMAL STEPSIZE;
             DATA[6]: THE ABSOLUTE TOLERANCE;
             DATA[7]: THE RELATIVE TOLERANCE;
                      IF  BOTH  DATA[6]  AND  DATA[7] ARE NEGATIVE, THE
                      INTEGRATION  IS  PERFORMED  WITH  A CONSTANT STEP
                      DATA[5];
             DATA[8]: DATA[8]  SHOULD  BE  0  IF  ARK  IS  CALLED   FOR
                      A FIRST TIME;  FOR  CONTINUED  INTEGRATION
                      DATA[8] SHOULD NOT BE CHANGED;
             DATA[11], ..., DATA[10 + DATA[1]]: POLYNOMIAL COEFFICIENTS
                      (SEE REFERENCE [3]);
             AFTER  EACH  STEP THE FOLLOWING BY-PRODUCTS ARE DELIVERED:
             DATA[8]: THE   NUMBER  OF   INTEGRATION  STEPS  PERFORMED;
             DATA[9]: AN  ESTIMATION  OF THE  LOCAL  ERROR  LAST  MADE;
             DATA[10]: INFORMATIVE MESSAGES:
                      DATA[10] = 0: NO DIFFICULTIES;
                      DATA[10] = 1: MINIMAL  STEPLENGTH   EXCEEDS   THE
                              STEPLENGTH   PRESCRIBED   BY    STABILITY
                              THEORY, I.E. DATA[5] > DATA[3] / DATA[4];
                              (TERMINATION OF ARK);
                              DECREASE  MINIMAL  STEPLENGTH;
             IF NECESSARY, DATA[I],I = 4(1)7, CAN BE UPDATED(AFTER EACH
             STEP) BY MEANS OF PROCEDURE OUT;
     OUT:    <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" OUT;
             AFTER  EACH  INTEGRATION STEP PERFORMED INFORMATION CAN BE
             OBTAINED  OR UPDATED BY THIS PROCEDURE, E.G. THE VALUES OF
             T, U[M0 : M] AND DATA[I], I = 4(1)10.
1SECTION : 5.2.1.1.1.1.H      (FEBRUARY 1979)                     PAGE 3
 
 
 
 DATA AND RESULTS:
 
     FOR THE INDICES  M0  AND  M  THE  FOLLOWING  REMARKS  CAN BE MADE:
     WHEN THE METHOD OF LINES  IS  APPLIED  TO  HYPERBOLIC DIFFERENTIAL
     EQUATIONS THE NUMBER OF RELEVANT ORDINARY  DIFFERENTIAL  EQUATIONS
     DECREASES  DURING  THE  INTEGRATION  PROCESS;  IN   PROCEDURE  ARK
     THIS   MAY   BE   REALIZED   BY INTEGERS  M0  AND  M,  WHICH   ARE
     DEFINED AS FUNCTIONS OF THE NUMBER OF RIGHT HAND SIDE EVALUATIONS.
     A SELECTION OF POSSIBLE ENTRIES FOR ARRAY DATA (DEPENDENT ON THE
     KIND OF INITIAL VALUE PROBLEM) IS GIVEN IN REFERENCE [4],SECTION 8.
 
 
 PROCEDURES USED:
 
     INIVEC = CP31010,
     MULVEC = CP31020,
     DUPVEC = CP31030,
     VECVEC = CP34010,
     ELMVEC = CP34020,
     DECSOL = CP34301.
 
 
 REQUIRED CENTRAL MEMORY : CIRCA 75 + 2 * (M - M0) MEMORY PLACES.
 
 
 METHOD AND PERFORMANCE:
 
     ARK IS  AN  IMPLEMENTATION  OF  LOW  ORDER  STABILIZED RUNGE KUTTA
     METHODS (SEE REFERENCE [1]);
     AUTOMATIC STEPSIZE CONTROL IS PROVIDED BUT STEP-REJECTION HAS BEEN
     EXCLUDED IN ORDER TO SAVE STORAGE;
     BECAUSE OF ITS LIMITED STORAGE REQUIREMENTS AND ADAPTIVE STABILITY
     FACILITIES THE METHOD IS WELL SUITED FOR THE SOLUTION  OF  INITIAL
     BOUNDARY  VALUE  PROBLEMS   FOR  PARTIAL  DIFFERENTIAL  EQUATIONS;
     NUMERICAL   RESULTS,   OBTAINED   WITH   A    SLIGHTLY   DIFFERENT
     IMPLEMENTATION CAN BE FOUND IN REFERENCE [2].
 
 
 REFERENCES:
 
     [1]. P.J. VAN DER HOUWEN.
             STABILIZED RUNGE KUTTA METHOD WITH LIMITED
             STORAGE REQUIREMENTS.
             MATH. CENTR. REPORT  TW 124/71;
 
     [2]. P.A. BEENTJES.
             AN ALGOL 60 VERSION OF STABILIZED RUNGE KUTTA
             METHODS (DUTCH).
             MATH. CENTR. REPORT NR 23/72;
1SECTION : 5.2.1.1.1.1.H      (DECEMBER 1975)                     PAGE 4
 
 
 
     [3]. P.J. VAN DER HOUWEN, J. KOK.
             NUMERICAL SOLUTION OF A MINIMAX PROBLEM.
             MATH. CENTR. REPORT TW 123/71;
 
     [4]. P.J. VAN DER HOUWEN ET AL.
             ONE STEP METHODS FOR LINEAR INITIAL VALUE PROBLEMS, I.I.I.
             NUMERICAL EXAMPLES,
             MATH. CENTR. REPORT TW 130/71.
 
 
 EXAMPLE OF USE:
 
     THE VALUES OF
 
     1. Y(1) AND Y(2) OF THE INITIAL VALUE PROBLEM
        DY / DX = Y - 2 * X / Y,    Y(0) = 1
 
      AND
 
     2. U(.6, 0) OF THE CAUCHY PROBLEM (SEE REFERENCE [2]):
        DU / DT = .5 * DU / DX,  U(0, X) = EXP(-X * X)
 
     MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
 
 "BEGIN" "INTEGER" M0, M, I; "REAL" T, TE, DAT;
     "ARRAY" Y[1 : 1], U[-150 : 150], DATA[1 : 14];
 
     "PROCEDURE" DER1(T, V); "REAL" T; "ARRAY" V;
     V[1]:= V[1] - 2 * T / V[1];
 
     "PROCEDURE" DER2(T, V); "REAL" T; "ARRAY" V;
     "BEGIN" "INTEGER" J; "REAL" V1, V2, V3;
        V2:= V[M0]; M0:= M0 + 1; M:= M - 1; V3:= V[M0];
        "FOR" J:= M0 "STEP" 1 "UNTIL" M "DO"
        "BEGIN" V1:= V2; V2:= V3; V3:= V[J + 1];
            V[J]:= 250 * (V3 - V1) / 3
        "END"
     "END" DER2;
1SECTION : 5.2.1.1.1.1.H      (DECEMBER 1975)                     PAGE 5
 
 
 
     "PROCEDURE" OUT1;
     "IF" T = TE "THEN"
     "BEGIN" "IF" T = 1 "THEN" OUTPUT(61, "("/, "(" PROBLEM 1")", //,
         "(" X  NUMBER OF INTEGRATION STEPS Y(COMPUTED)  Y(EXACT)")",
         //")");
         OUTPUT(61, "("ZD, 13ZD,12B,2(-3ZD.7D),"("...")", /")",
         T, DATA[8], Y[1], SQRT(2 * T + 1));
         TE:= 2
     "END" OUT1;
 
     "PROCEDURE" OUT2;
     "IF" T = .6 "THEN"
     OUTPUT(61, "("//, "(" PROBLEM 2")", //,
        "(" NUMBER OF DERIVATIVE CALLS")",
        "("  U(.6, 0)COMPUTED   U(.6, 0)EXACT")", //, 13ZD,
        2(-10Z.7D), "("...")"")", DATA[1] * DATA[8], U[0], EXP(-.09));
 
     I:= 1;
     "FOR" DAT:= 3, 3, 1, 1, "-3, "-6, "-6, 0, 0, 0, 1, .5, 1 / 6 "DO"
     "BEGIN" DATA[I]:= DAT; I:= I + 1 "END";
     T:= 0; Y[1]:= 1; TE:= 1;
     ARK(T, TE, 1, 1, Y, DER1, DATA, OUT1);
     I:= 1;
     "FOR" DAT:= 4, 3, SQRT(8), 500 / 3, DATA[3] / DATA[4], -1, -1,
        0, 0, 0, 1, .5, 1 / 6, 1 / 24 "DO"
     "BEGIN" DATA[I]:= DAT; I:= I + 1 "END";
     M0:= -150; M:= 150; T:= 0; U[0]:= 1;
     "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
     U[I]:= U[-I]:= EXP(-(.003 * I) ** 2);
     ARK(T, .6, M0, M, U, DER2, DATA, OUT2)
 "END"
 
     THIS PROGRAM DELIVERS:
 
 
  PROBLEM 1
 
  X  NUMBER OF INTEGRATION STEPS Y(COMPUTED)  Y(EXACT)
 
  1            38                1.7320535    1.7320508...
  2            56                2.2360928    2.2360680...
 
 
  PROBLEM 2
 
  NUMBER OF DERIVATIVE CALLS  U(.6, 0)COMPUTED   U(.6, 0)EXACT
 
            144               .9139326           .9139312...
1SECTION : 5.2.1.1.1.1.H      (FEBRUARY 1979)                     PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE" 33061;
 "PROCEDURE" ARK (T, TE, M0, M, U, DERIVATIVE, DATA, OUT);
 "INTEGER" M0, M;
 "REAL" T, TE;
 "ARRAY" U, DATA;
 "PROCEDURE" DERIVATIVE, OUT;
 
 "BEGIN" "INTEGER" P, N, Q;
     "OWN" "REAL" EC0, EC1, EC2, TAU0, TAU1, TAU2, TAUS, T2;
     "REAL" THETANM1, TAU, BETAN, QINV, ETA;
     "ARRAY" MU, LAMBDA[1:DATA[1]], THETHA[0:DATA[1]], RO, R[M0:M];
     "BOOLEAN" START, STEP1, LAST;
 
     "PROCEDURE" INITIALIZE;
     "BEGIN" "INTEGER" I, J, K, L, N1; "REAL" S, THETA0;
         "ARRAY" ALFA[1:8, 1:DATA[1]+1], TH[1:8], AUX[1:3];
 
         "REAL" "PROCEDURE" LABDA(I, J); "VALUE" I, J; "INTEGER" I, J;
         LABDA:= "IF" P < 3 "THEN" ("IF" J =I-1 "THEN" MUI(I) "ELSE" 0)
                 "ELSE" "IF" P =3 "THEN" ("IF" I =N "THEN" ("IF" J=0
                 "THEN" .25 "ELSE" "IF" J =N - 1 "THEN" .75
                 "ELSE" 0) "ELSE" "IF" J =0 "THEN" ("IF" I =1
                 "THEN" MUI(1) "ELSE" .25) "ELSE" "IF" J =I - 1
                 "THEN" LAMBDA[I] "ELSE" 0) "ELSE" 0;
 
         "REAL" "PROCEDURE" MUI(I); "VALUE" I; "INTEGER" I;
         MUI:= "IF" I =N "THEN" 1 "ELSE"
               "IF" I < 1 ! I > N "THEN" 0 "ELSE"
               "IF" P < 3 "THEN" LAMBDA[I] "ELSE"
               "IF" P =3 "THEN" LAMBDA[I] + .25 "ELSE" 0;
 
         "REAL" "PROCEDURE" SUM(I, A, B, X);
         "VALUE" B; "INTEGER" I, A, B; "REAL" X;
         "BEGIN" "REAL" S; S:= 0;
             "FOR" I:= A "STEP" 1 "UNTIL" B "DO" S:= S + X;
             SUM:= S
         "END" SUM;
                                                               "COMMENT"
1SECTION : 5.2.1.1.1.1.H      (DECEMBER 1979)                     PAGE 7
                                                                  ;
 
 
         N:= DATA[1]; P:= DATA[2]; EC1:= EC2 := 0;
         BETAN:= DATA[3];
         THETANM1:= "IF" P=3 "THEN" .75 "ELSE" 1;
         THETA0:= 1 - THETANM1; S:= 1;
         "FOR" J:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" S:= - S * THETA0 + DATA[N + 10 - J];
             MU[J]:= DATA[N + 11 - J] / S;
             LAMBDA[J]:= MU[J] - THETA0
         "END";
         "FOR" I:= 1 "STEP" 1 "UNTIL" 8 "DO"
         "FOR" J:= 0 "STEP" 1 "UNTIL" N "DO"
         ALFA[I, J + 1]:= "IF" I = 1 "THEN" 1 "ELSE"
           "IF" J = 0 "THEN" 0 "ELSE" "IF" I = 2 ! I = 4 ! I = 8 "THEN"
           MUI(J) ** ENTIER((I + 2) / 3) "ELSE"
           "IF" (I = 3 ! I = 6) & J > 1 "THEN" SUM(L, 1, J-1,
           LABDA(J, L) * MUI(L) ** ENTIER(I / 3)) "ELSE"
           "IF" I = 5 & J > 2 "THEN" SUM(L, 2, J - 1, LABDA(J, L) *
           SUM(K, 1, L - 1, LABDA(L, K) * MUI(K))) "ELSE"
           "IF" I = 7 & J > 1 "THEN" SUM(L, 1, J - 1, LABDA(J, L) *
           MUI(L)) * MUI(J) "ELSE" 0;
         N1:="IF" N < 4 "THEN" N + 1 "ELSE" "IF" N < 7 "THEN" 4
           "ELSE" 8;
         I:= 1;
         "FOR" S:= 1, .5, 1 / 6, 1 / 3, 1 / 24, 1 / 12, .125, .25 "DO"
         "BEGIN" TH[I]:= S; I:= I + 1 "END";
         "IF" P = 3 & N < 7 "THEN" TH[1]:= TH[2]:= 0;
         AUX[2]:= " - 14; DECSOL(ALFA, N1, AUX, TH);
         INIVEC(0, N, THETHA, 0);
         DUPVEC(0, N1 - 1, 1, THETHA, TH);
         "IF" ^ (P = 3 & N < 7) "THEN"
         "BEGIN" THETHA[0]:= THETHA[0] - THETA0;
             THETHA[N - 1]:= THETHA[N - 1] - THETANM1; Q:= P + 1
         "END" "ELSE" Q:= 3;
         QINV:= 1 / Q;
         START:= DATA[8] = 0; DATA[10]:= 0; LAST:= "FALSE";
         DUPVEC(M0, M, 0, R, U); DERIVATIVE(T, R)
     "END" INITIALIZE
 
1SECTION : 5.2.1.1.1.1.H      (DECEMBER 1975)                     PAGE 8
                                                                  ;
 
 
     "PROCEDURE" LOCAL ERROR CONSTRUCTION(I); "VALUE" I; "INTEGER" I;
     "BEGIN" "IF" THETHA[I] ^= 0 "THEN"
         ELMVEC(M0, M, 0, RO, R, THETHA[I]);
         "IF" I = N "THEN"
         "BEGIN" DATA[9]:= SQRT(VECVEC(M0, M, 0, RO, RO))* TAU;
             EC0:= EC1; EC1:= EC2; EC2:= DATA[9] / TAU ** Q
         "END"
     "END" LEC;
 
     "PROCEDURE" STEPSIZE;
     "BEGIN" "REAL" TAUACC, TAUSTAB, AA, BB, CC, EC;
         ETA:= SQRT(VECVEC(M0, M, 0, U, U)) * DATA[7] + DATA[6];
         "IF" ETA > 0 "THEN"
         "BEGIN" "IF" START "THEN"
             "BEGIN" "IF" DATA[8] = 0 "THEN"
                 "BEGIN" TAUACC:= DATA[5];
                     STEP1:= "TRUE"
                 "END" "ELSE" "IF" STEP1 "THEN"
                 "BEGIN" TAUACC:= (ETA / EC2) ** QINV;
                     "IF" TAUACC > 10 * TAU2 "THEN"
                     TAUACC:= 10 * TAU2 "ELSE" STEP1:= "FALSE"
                 "END" "ELSE"
                 "BEGIN" BB:= (EC2 - EC1) / TAU1; CC:= - BB * T2 + EC2;
                     EC:= BB * T + CC;
                     TAUACC:= "IF" EC < 0 "THEN" TAU2 "ELSE"
                     (ETA / EC) ** QINV;
                     START:= "FALSE"
                 "END"
             "END" "ELSE"
             "BEGIN" AA:= ((EC0 - EC1) / TAU0 + (EC2 - EC1) / TAU1)
                         / (TAU1 + TAU0);
                 BB:= (EC2 - EC1) / TAU1 - (2 * T2 - TAU1) * AA;
                 CC:= - (AA * T2 + BB) * T2 + EC2;
                 EC:= (AA * T + BB) * T + CC;
                 TAUACC:= "IF" EC < 0 "THEN"
                          TAUS "ELSE" (ETA / EC) ** QINV;
                 "IF" TAUACC > 2 * TAUS "THEN" TAUACC:= 2 * TAUS;
                 "IF" TAUACC < TAUS / 2 "THEN" TAUACC:= TAUS / 2
             "END"
         "END" "ELSE" TAUACC:= DATA[5];
          "IF" TAUACC < DATA[5] "THEN" TAUACC:= DATA[5];
         TAUSTAB:= BETAN / DATA[4]; "IF" TAUSTAB < DATA[5] "THEN"
         "BEGIN" DATA[10]:= 1; "GOTO" ENDARK "END";
         TAU:= "IF" TAUACC > TAUSTAB "THEN" TAUSTAB "ELSE" TAUACC;
         TAUS:= TAU; "IF" TAU >= TE - T "THEN"
         "BEGIN" TAU:= TE - T; LAST:= "TRUE" "END";
         TAU0:= TAU1; TAU1:= TAU2; TAU2:= TAU
     "END" STEPSIZE
 
1SECTION : 5.2.1.1.1.1.H      (DECEMBER 1975)                     PAGE 9
                                                                  ;
 
 
     "PROCEDURE" DIFFERENCE SCHEME;
     "BEGIN" "INTEGER" I, J;
         "REAL" MT, LT;
         MULVEC(M0, M, 0, RO, R, THETHA[0]);
         "IF" P = 3 "THEN" ELMVEC(M0, M, 0, U, R, .25 * TAU);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N - 1 "DO"
         "BEGIN" MT:= MU[I] * TAU; LT:= LAMBDA[I] * TAU;
             "FOR" J:= M0 "STEP" 1 "UNTIL" M "DO"
             R[J]:= LT * R[J] + U[J];
             DERIVATIVE(T + MT, R); LOCAL ERROR CONSTRUCTION(I)
         "END";
         ELMVEC(M0, M, 0, U, R, THETANM1 * TAU);
         DUPVEC(M0, M, 0, R, U); DERIVATIVE(T + TAU, R);
         LOCAL ERROR CONSTRUCTION(N); T2:= T;
         "IF" LAST "THEN"
         "BEGIN" LAST:= "FALSE"; T:= TE "END" "ELSE" T:= T + TAU;
         DATA[8]:= DATA[8]+1
     "END" DIFSCH;
 
     INITIALIZE;
 
   NEXT STEP:
     STEPSIZE; DIFFERENCE SCHEME; OUT;
     "IF" T ^= TE "THEN" "GOTO" NEXT STEP;
 
   ENDARK:
 "END" ARK;
         "EOP"
1SECTION : 5.2.1.1.1.1.I      (FEBRUARY 1979)                     PAGE 1
 
 
 
 PROCEDURE  : EFRK.
 
 
 AUTHOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740710.
 
 
 BRIEF DESCRIPTION:
 
     EFRK  SOLVES  AN INITIAL VALUE PROBLEM  FOR A SYSTEM OF FIRST
     ORDER ORDINARY DIFFERENTIAL EQUATIONS   DU / DT = H(T,U) .
     EFRK IS A SPECIAL PURPOSE PROCEDURE FOR STIFF EQUATIONS WITH A
     KNOWN, CLUSTERED EIGENVALUE SPECTRUM.
 
 
 KEYWORDS:
 
     INITIAL VALUE PROBLEM,
     SYSTEM OF FIRST ORDER ORDINARY DIFFERENTIAL EQUATIONS,
     STIFF EQUATION.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE EFRK READS:
     "PROCEDURE" EFRK ( T,TE, M0,M, U, SIGMA, PHI, DIAMETER, DERIVATIVE,
                        K, STEP, R, L, BETA,  THIRDORDER, TOL, OUTPUT );
     "VALUE" R,L;
     "INTEGER" M0,M,K,R,L;
     "REAL" T,TE,SIGMA,PHI,DIAMETER,STEP,TOL;
     "ARRAY" U,BETA;
     "BOOLEAN" THIRDORDER;
     "PROCEDURE" DERIVATIVE,OUTPUT;
     "CODE" 33070;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     T:      <VARIABLE>;
             THE INDEPENDENT VARIABLE T;
             ENTRY: THE INITIAL VALUE T0;
             EXIT : THE FINAL VALUE TE;
     TE:     <ARITHMETIC ETPRESSION>;
             THE FINAL VALUE OF T (TE>=T);
     M0:     <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE FIRST EQUATION;
     M:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE LAST EQUATION;
1SECTION : 5.2.1.1.1.1.I      (FEBRUARY 1979)                     PAGE 2
 
 
 
     U:      <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" U[M0:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE INITIAL VALUES OF THE SOLUTION OF THE  SYSTEM OF
                    DIFFERENTIAL EQUATIONS AT T = T0;
             EXIT : THE VALUES OF THE SOLUTION AT T = TE;
     SIGMA:  <ARITHMETIC EXPRESSION>;
             THE  MODULUS  OF  THE POINT AT WHICH EXPONENTIAL FITTING IS
             DESIRED , FOR EXAMPLE AN APPROXIMATION OF THE CENTRE OF THE
             LEFT HAND CLUSTER;
     PHI:    <ARITHMETIC EXPRESSION>;
             THE ARGUMENT OF THE CENTRE OF THE LEFT HAND CLUSTER; IN THE
             CASE OF  TWO COMPLEX CONJUGATED CLUSTERS , THE  ARGUMENT OF
             THE CENTRE IN THE SECOND QUADRANT SHOULD BE TAKEN;
     DIAMETER: <ARITHMETIC EXPRESSION>;
             THE DIAMETER OF THE LEFT HAND CLUSTER OF EIGENVALUES OF THE
             JACOBIAN MATRIX  OF THE SYSTEM  OF DIFFERENTIAL  EQUATIONS;
             IN CASE OF NON-LINEAR EQUATIONS DIAMETER SHOULD HAVE SUCH A
             VALUE THAT THE VARIATION OF THE EIGENVALUES IN THIS CLUSTER
             IN THE PERIOD ( T ,T+STEP ) IS LESS THAN HALF THE DIAMETER;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(T,U); "REAL" T; "ARRAY" U;
             THIS PROCEDURE SHOULD DELIVER THE VALUE OF H(T,U) IN THE
             POINT (T,U) IN THE ARRAY U;
     K:      <VARIABLE>;
             COUNTS THE NUMBER OF INTEGRATION STEPS TAKEN;
             FOR EXAMPLE, K MAY BE USED IN THE EXPRESSION FOR TE;
             ENTRY: AN (ARBIRARY) CHOSEN VALUE K0, E.G. K0=0;
             EXIT : K0 + THE NUMBER OF INTEGRATION STEPS PERFORMED;
     STEP:   <ARITHMETIC EXPRESSION>;
             THE  STEPSIZE  CHOSEN  WILL  BE  AT  MOST  EQUAL TO  STEP ;
             THIS  STEPSIZE  MAY BE  REDUCED  BY  STABILITY CONSTRAINTS,
             IMPOSED BY  A  POSITIVE DIAMETER , OR  BY CONSIDERATIONS OF
             INTERNAL STABILITY (SEE REF[1], PAGE 11);
     R:      <ARITHMETIC EXPRESSION>;
             R + L: THE NUMBER OF  EVALUATIONS OF  H(T, U)  ON WHICH THE
             RUNGE-KUTTA SCHEME IS BASED;
             FOR R=1,2,>=3 FIRST, SECOND AND THIRD ORDER ACCURACY MAY BE
             OBTAINED  BY  AN  APPROPRIATE  CHOICE  OF THE  ARRAY  BETA;
     L:      <ARITHMETIC EXPRESSION>;
             ENTRY:
             IF PHI = 4*ARCTAN(1): THE ORDER OF THE EXPONENTIAL FITTING,
             ELSE TWICE THE ORDER OF THE EXPONENTIAL FITTING;
             NOTE THAT L SHOULD BE EVEN IN THE LATTER CASE;
     BETA:   <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" BETA[0:R+L];
             ENTRY: THE ELEMENTS  BETA[I] , I=0, ... ,R  SHOULD HAVE THE
                    VALUE OF THE R+1 FIRST COEFFICIENTS OF THE STABILITY
                    POLYNOMIAL;
1SECTION : 5.2.1.1.1.1.I      (FEBRUARY 1979)                     PAGE 3
 
 
 
     THIRDORDER: <BOOLEAN EXPRESSION>;
             IF THIRD ORDER ACCURACY IS DESIRED , THIRDORDER SHOULD HAVE
             THE VALUE "TRUE" , IN COMBINATION WITH  APPROPRIATE CHOICES
             OF R (R>=3) AND THE ARRAY BETA ( BETA[I]=1/I!, I=0,1,2,3 );
             IN ALL OTHER CASES THIRDORDER MUST  HAVE THE VALUE "FALSE";
     TOL:    <ARITHMETIC EXPRESSION>;
             AN UPPERBOUND FOR  THE ROUNDING ERRORS  IN THE COMPUTATIONS
             IN ONE RUNGE-KUTTA STEP ; IN SOME CASES ( E.G. LARGE VALUES
             OF SIGMA AND R ) TOL WILL CAUSE A DECREASE OF THE STEPSIZE;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS;
             "PROCEDURE" OUTPUT;
             THIS  PROCEDURE  IS  CALLED  AT THE END OF EACH INTEGRATION
             STEP ; THE USER CAN ASK FOR OUTPUT OF SOME PARAMETERS , FOR
             EXAMPLE T, K, U, AND COMPUTE NEW VALUES FOR SIGMA, PHI, AND
             DIAMETER.
 
 
 PROCEDURES USED:
 
     INIVEC= CP31010,
     ELMVEC= CP34020,
     DEC   = CP34300,
     SOL   = CP34051.
 
 
 REQUIRED CENTRAL MEMORY : CIRCA 30 + (M - M0) + L * (5 + L).
 
 
 METHOD AND PERFORMANCE:
     EFRK IS BASED ON EXPLICIT RUNGE-KUTTA METHODS OF ORDER 1, 2 AND 3,
     WHICH MAKE USE OF EXPONENTIAL FITTING. AUTOMATIC ERROR CONTROL
     IS NOT PROVIDED.
     A DETAILED DESCRIPTION  OF THE METHOD  AND  SOME NUMERICAL EXAMPLES
     ARE GIVEN IN REF[1]. REF [3], PAGE 170 REPRESENTS A BRIEF SURVEY. A
     COMPARATIVE TEST  OVER A LARGE CLASS  OF  DIFFERENTIAL EQUATIONS IS
     GIVEN IN REF [4].
     FROM THESE RESULTS IT APPEARS  THAT CALLS WITH  THIRDORDER = "TRUE"
     ARE LESS ADVISABLE.
 
 
1SECTION : 5.2.1.1.1.1.I      (FEBRUARY 1979)                     PAGE 4
 
 
 
 REFERENCES:
 
     [1]. K. DEKKER.
          AN  ALGOL 60  VERSION  OF  EXPONENTIALLY  FITTED   RUNGE-KUTTA
          METHODS (DUTCH).
          NR 25 (1972), MATHEMATICAL CENTRE.
 
     [2]. T. J. DEKKER, P. W. HEMKER AND P. J. VAN DER HOUWEN.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 1 (DUTCH).
          MC SYLLABUS 15.1, (1972) MATHEMATICAL CENTRE.
 
     [3]. P. A. BEENTJES, K. DEKKER, H. C. HEMKER, S.P.N. VAN KAMPEN AND
          G. M. WILLEMS.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 2 (DUTCH).
          MC SYLLABUS 15.2, (1973) MATHEMATICAL CENTRE.
 
     [4]. P. A. BEENTJES, K. DEKKER, H. C. HEMKER AND M. V. VELDHUIZEN.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 3 (DUTCH).
          MC SYLLABUS 15.3, (1974) MATHEMATICAL CENTRE.
 
 
 EXAMPLE OF USE:
 
     CONSIDER THE SYSTEM OF DIFFERENTIAL EQUATIONS:
     DY[1]/DX = -Y[1] + Y[1] * Y[2] + .99 * Y[2]
     DY[2]/DX = -1000 * ( -Y[1] + Y[1] * Y[2] + Y[2] )
     WITH THE INITIAL CONDITIONS AT X = 0:
     Y[1] = 1 AND Y[2] = 0. (SEE REF[2], PAGE 11).
     THE SOLUTION AT X = 50 IS APPROXIMATELY:
     Y[1] = .765 878 320 487  AND  Y[2] = .433 710 353  5768.
     THE FOLLOWING PROGRAM  SHOWS SOME DIFFERENT CALLS  OF THE PROCEDURE
     EFRK:
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                       PAGE 5
 
 
 
     "BEGIN"
 
         "INTEGER" K,R,L,PASSES;
         "REAL" X,SIGMA,PHI,TIME,STEP,DIAMETER;
         "REAL" "ARRAY" Y[1:2],BETA[0:6];
 
         "PROCEDURE" DER(X,Y); "REAL" X; "ARRAY" Y;
         "BEGIN" "REAL" Y1,Y2; Y1:=Y[1]; Y2:=Y[2];
             Y[1]:=(Y1+.99)*(Y2-1)+.99;
             Y[2]:=1000*((1+Y1)*(1-Y2)-1);
             PASSES:=PASSES+1
         "END";
 
         "PROCEDURE" OUT;
         "BEGIN" "REAL" S;
             S:=(-1000*Y[1]-1001+Y[2])/2;
             SIGMA:=ABS(S-SQRT(S*S+10*(Y[2]-1)));
             DIAMETER:=2*STEP*ABS(1000*(1.99*Y[2]-2*Y[1]*(1-Y[2])));
             "IF" X=50 "THEN"
             OUTPUT(61,"("4BD,2BD,2(-5ZD),2(4B+.3DB3DB3D),-5ZD.3D,/")",
             R,L,K,PASSES,Y[1],Y[2],CLOCK-TIME)
         "END";
 
         OUTPUT(61,"(""("    THIS LINE AND THE FOLLOWING TEXT IS ")"
         "("PRINTED BY THIS PROGRAM")",//,
         "("    THE RESULTS WITH EFRK ARE:")",/,
         "("    R  L     K   DER.EV.        Y[1]             Y[2]")"
         "("         TIME")",/")");
         PHI:=4*ARCTAN(1); BETA[0]:=BETA[1]:=1;
         "FOR" R:=1,2,3 "DO" "FOR" L:=1,2,3 "DO"
         "BEGIN" "FOR" K:=2 "STEP" 1 "UNTIL" R "DO"
             BETA[K]:=BETA[K-1]/K;
             "FOR" STEP:=1,.1 "DO"
             "BEGIN" PASSES:=K:=0; X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
                 OUT;
            EFRK(X,50.0,1,2,Y,SIGMA,PHI,DIAMETER,DER,K,STEP,R,L,BETA,
                 R>=3,"-4,OUT);
             "END"; OUTPUT(61,"("/")");
         "END";
     "END"
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                       PAGE 6
 
 
 
     THIS LINE AND THE FOLLOWING TEXT IS PRINTED BY THIS PROGRAM:
 
     THE RESULTS WITH EFRK ARE:
     R  L     K   DER.EV.         Y[1]             Y[2]         TIME
     1  1    237    474     +.765 812 555    +.433 689 306      1.395
     1  1    501   1002     +.765 847 870    +.433 700 619      3.381
 
     1  2     52    156     +.765 570 874    +.433 615 119      0.465
     1  2    501   1503     +.765 848 220    +.433 700 709      4.200
 
     1  3     52    208     +.765 571 278    +.433 615 202      0.531
     1  3    500   2000     +.765 848 512    +.433 700 827      4.879
 
     2  1   3317   9951     +.765 878 320    +.433 710 353     21.808
     2  1   1050   3150     +.765 878 321    +.433 710 330      7.153
 
     2  2    174    696     +.765 878 335    +.433 710 335      1.385
     2  2    501   2004     +.765 878 323    +.433 709 211      4.915
 
     2  3     57    285     +.765 881 339    +.433 817 185      0.642
     2  3    501   2505     +.765 878 323    +.433 709 725      5.756
 
     3  1   7010  28040     +.765 878 320    +.433 710 354     55.298
     3  1   3255  13020     +.765 878 320    +.433 710 374     25.772
 
     3  2    949   4745     +.765 878 319    +.433 711 893      8.499
     3  2   1384   6920     +.765 862 498    +.449 724 830     13.452
 
     3  3    917   5502     +.765 878 018    +.434 105 184      9.143
     3  3   1166   6996     +.765 861 696    +.433 705 641     15.512
 
 
 SOURCE TEXT(S):
0"CODE" 33070;
 "PROCEDURE" EFRK(T,TE,M0,M,U,SIGMA,PHI,DIAMETER,DERIVATIVE,K,STEP,R,L,
         BETA,THIRDORDER,TOL,OUTPUT);
 "VALUE" R,L;
 "INTEGER" M0,M,K,R,L;
 "REAL" T,TE,SIGMA,PHI,DIAMETER,STEP,TOL;
 "ARRAY" U,BETA;
 "BOOLEAN" THIRDORDER;
 "PROCEDURE" DERIVATIVE,OUTPUT;
 "BEGIN" "INTEGER" N;
     "REAL" THETA0,THETANM1,H,B,B0,PHI0,PHIL,PI,COSPHI,SINPHI,EPS,BETAR;
     "BOOLEAN" FIRST,LAST,COMPLEX,CHANGE;
     "INTEGER" "ARRAY" P[1:L];
     "REAL" "ARRAY" MU,LABDA[0:R+L-1],PT[0:R],FAC,BETAC[0:L-1],RL[M0:M],
                    A[1:L,1:L],AUX[0:3];
                                                               "COMMENT"
 
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
     "PROCEDURE" FORM CONSTANTS;
     "BEGIN" "INTEGER" I;
         FIRST:="FALSE";
         FAC[0]:=1;
         "FOR" I:=1 "STEP" 1 "UNTIL" L-1 "DO" FAC[I]:=I*FAC[I-1];
         PT[R]:=L*FAC[L-1];
         "FOR" I:=1 "STEP" 1 "UNTIL" R "DO"
         PT[R-I]:=PT[R-I+1]*(L+I)/I
     "END" FORM CONSTANTS;
 
     "PROCEDURE" FORM BETA;
     "BEGIN" "INTEGER" I,J; "REAL" BB,C,D;
         "IF" FIRST "THEN" FORM CONSTANTS;
         "IF" L=1 "THEN"
         "BEGIN" C:=1-EXP(-B);
             "FOR" J:=1 "STEP" 1 "UNTIL" R "DO" C:=BETA[J]-C/B;
             BETA[R+1]:=C/B
         "END" "ELSE"
         "IF" B>40 "THEN"
         "BEGIN" "FOR" I:=R+1 "STEP" 1 "UNTIL" R+L "DO"
             "BEGIN" C:=0;
                 "FOR" J:=0 "STEP" 1 "UNTIL" R "DO"
                 C:=BETA[J]*PT[J]/(I-J)-C/B;
                 BETA[I]:=C/B/FAC[L+R-I]/FAC[I-R-1]
             "END";
         "END" "ELSE"
         "BEGIN" D:=C:=EXP(-B); BETAC[L-1]:=D/FAC[L-1];
             "FOR" I:=1 "STEP" 1 "UNTIL" L-1 "DO"
             "BEGIN" C:=B*C/I; D:=D+C; BETAC[L-1-I]:=D/FAC[L-1-I] "END";
             BB:=1;
             "FOR" I:=R+1 "STEP" 1 "UNTIL" R+L "DO"
             "BEGIN" C:=0;
                 "FOR" J:=0 "STEP" 1 "UNTIL" R "DO"
                 C:=(BETA[J]-("IF" J<L "THEN" BETAC[J] "ELSE" 0))*
                    PT[J]/(I-J)-C/B;
                 BETA[I]:=C/B/FAC[L+R-I]/FAC[I-R-1]+
                          ("IF" I<L "THEN" BB*BETAC[I] "ELSE" 0);
                 BB:=BB*B
             "END"
         "END"
     "END" FORM BETA;
 
     "PROCEDURE" SOLUTION OF COMPLEX EQUATIONS;
     "BEGIN" "INTEGER" I,J,C1,C3;
         "REAL" C2,E,B1,ZI,COSIPHI,SINIPHI,COSPHIL;
         "REAL" "ARRAY" D[1:L];                                "COMMENT"
 
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                       PAGE 8
                                                                  ;
 
 
         "PROCEDURE" ELEMENTS OF MATRIX;
         "BEGIN" PHIL:=PHI0;
             COSPHI:=COS(PHIL); SINPHI:=SIN(PHIL);
             COSIPHI:=1; SINIPHI:=0;
             "FOR" I:=0 "STEP" 1 "UNTIL" L-1 "DO"
             "BEGIN" C1:=R+1+I; C2:=1;
                 "FOR" J:=L-1 "STEP" -2 "UNTIL" 1 "DO"
                 "BEGIN" A[J,L-I]:=C2*COSIPHI;
                     A[J+1,L-I]:=C2*SINIPHI;
                     C2:=C1*C2; C1:=C1-1
                 "END";
                 COSPHIL:=COSIPHI*COSPHI-SINIPHI*SINPHI;
                 SINIPHI:=COSIPHI*SINPHI+SINIPHI*COSPHI;
                 COSIPHI:=COSPHIL
             "END";
             AUX[2]:=0; DEC(A,L,AUX,P)
         "END" EL OF MAT;
 
         "PROCEDURE" RIGHTHANDSIDE;
         "BEGIN" E:=EXP(B*COSPHI);
             B1:=B*SINPHI-(R+1)*PHIL;
             COSIPHI:=E*COS(B1); SINIPHI:=E*SIN(B1);
             B1:=1/B; ZI:=B1**R;
             "FOR" J:=L "STEP" -2 "UNTIL" 2 "DO"
             "BEGIN" D[J]:=ZI*SINIPHI;
                 D[J-1]:=ZI*COSIPHI;
                 COSPHIL :=COSIPHI*COSPHI-SINIPHI*SINPHI;
                 SINIPHI:=COSIPHI*SINPHI+SINIPHI*COSPHI;
                 COSIPHI:=COSPHIL;
                 ZI:=ZI*B
             "END";
             COSIPHI:=ZI:=1; SINIPHI:=0;
             "FOR" I:=R "STEP" -1 "UNTIL" 0 "DO"
             "BEGIN" C1:=I; C2:=BETA[I];
                 C3:="IF" 2*I>L-2 "THEN" 2 "ELSE" L-2*I;
                 COSPHIL :=COSIPHI*COSPHI-SINIPHI*SINPHI;
                 SINIPHI:=COSIPHI*SINPHI+SINIPHI*COSPHI;
                 COSIPHI:=COSPHIL;
                 "FOR" J:=L "STEP" -2 "UNTIL" C3 "DO"
                 "BEGIN" D[J]:=D[J]+ZI*C2*SINIPHI;
                     D[J-1]:=D[J-1]-ZI*C2*COSIPHI;
                     C2:=C2*C1; C1:=C1-1
                 "END";
                 ZI:=ZI*B1
             "END"
         "END" RIGHT HAND SIDE;
 
         "IF" PHI0^=PHIL "THEN" ELEMENTS OF MATRIX;
         RIGHTHANDSIDE;
         SOL(A,L,P,D);
         "FOR" I:=1 "STEP" 1 "UNTIL" L "DO" BETA[R+I]:=D[L+1-I]*B1
     "END" SOLOFCOMEQ;                                         "COMMENT"
 
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                       PAGE 9
                                                                  ;
 
 
     "PROCEDURE" COEFFICIENT;
     "BEGIN" "INTEGER" J,K; "REAL" C;
         B0:=B; PHI0:=PHI;
         "IF" B>=1 "THEN"
         "BEGIN" "IF" COMPLEX "THEN" SOLUTION OF COMPLEX EQUATIONS
             "ELSE" FORM BETA
         "END";
         LABDA[0]:=MU[0]:=0;
         "IF" THIRDORDER "THEN"
         "BEGIN" THETA0:=.25; THETANM1:=.75;
             "IF" B<1 "THEN"
             "BEGIN" C:=MU[N-1]:=2/3; LABDA[N-1]:=5/12;
                 "FOR" J:=N-2 "STEP" -1 "UNTIL" 1 "DO"
                 "BEGIN" C:=MU[J]:=C/(C-.25)/(N-J+1);
                     LABDA[J]:=C-.25
                 "END"
             "END" "ELSE"
             "BEGIN" C:=MU[N-1]:=BETA[2]*4/3; LABDA[N-1]:=C-.25;
                 "FOR" J:=N-2 "STEP" -1 "UNTIL" 1 "DO"
                 "BEGIN" C:=MU[J]:=C/(C-.25)*BETA[N-J+1]/BETA[N-J]/
                            ("IF" J<L "THEN" B "ELSE" 1);
                     LABDA[J]:=C-.25
                 "END"
             "END"
         "END" "ELSE"
         "BEGIN" THETA0:=0; THETANM1:=1;
             "IF" B<1 "THEN"
             "BEGIN" "FOR" J:=N-1 "STEP" -1 "UNTIL" 1 "DO"
                 MU[J]:=LABDA[J]:=1/(N-J+1)
             "END" "ELSE"
             "BEGIN" LABDA[N-1]:=MU[N-1]:=BETA[2];
                 "FOR" J:=N-2 "STEP" -1 "UNTIL" 1 "DO"
                 MU[J]:=LABDA[J]:=BETA[N-J+1]/BETA[N-J]/
                        ("IF" J<L "THEN" B "ELSE" 1)
             "END"
         "END"
     "END" COEFFICIENT;                                        "COMMENT"
 
1SECTION : 5.2.1.1.1.1.I      (AUGUST 1974)                      PAGE 10
                                                                 ;
 
 
     "PROCEDURE" STEPSIZE;
     "BEGIN" "REAL" D,HSTAB,HSTABINT;
         H:=STEP;
         D:=ABS(SIGMA*SIN(PHI));
         COMPLEX:=L//2*2=L "AND" 2*D>DIAMETER;
         "IF" DIAMETER>0 "THEN"
         HSTAB:=(SIGMA**2/(DIAMETER*(DIAMETER*.25+D)))**(L*.5/R)/
                BETAR/SIGMA
         "ELSE" HSTAB:=H;
         D:= "IF" THIRDORDER "THEN" (2*TOL/EPS/BETA[R])**(1/(N-1))*
             4**((L-1)/(N-1)) "ELSE" (TOL/EPS)**(1/R)/BETAR;
         HSTABINT:= ABS(D/SIGMA);
         "IF" H>HSTAB "THEN" H:=HSTAB;
         "IF" H>HSTABINT "THEN" H:=HSTABINT;
         "IF" T+H>TE*(1-K*EPS) "THEN"
         "BEGIN" LAST:="TRUE"; H:=TE-T "END";
         B:=H*SIGMA; D:=DIAMETER*.1*H; D:=D*D;
         "IF" H<T*EPS  "THEN" "GOTO" ENDOFEFRK;
         CHANGE:=B0=-1 "OR" ((B-B0)*(B-B0)+B*B0*(PHI-PHI0)*(PHI-PHI0)>D)
     "END" STEPSIZE;
 
     "PROCEDURE" DIFFERENCESCHEME ;
     "BEGIN" "INTEGER" I,J; "REAL" MT,LT,THT;
         I:=-1;
         NEXTTERM:
         I:=I+1; MT:=MU[I]*H; LT:=LABDA[I]*H;
         "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO" RL[J]:=U[J]+LT*RL[J];
         DERIVATIVE(T+MT,RL);
         "IF" I=0 "OR" I=N-1 "THEN"
         "BEGIN" THT:="IF" I=0 "THEN" THETA0*H "ELSE" THETANM1*H;
             ELMVEC(M0,M,0,U,RL,THT)
         "END";
         "IF" I<N-1 "THEN" "GOTO" NEXTTERM;
         T:=T+H
     "END" DIFFERENCE SCHEME;
 
     N:=R+L; FIRST:="TRUE"; B0:=-1; BETAR:=BETA[R]**(1/R);
     LAST:="FALSE"; EPS:=2.0**(-48); PI:=PHI0:=PHIL:=4*ARCTAN(1);
     INIVEC(M0, M, RL, 0);
 NEXTLEVEL:
     STEPSIZE;
     "IF" CHANGE "THEN" COEFFICIENT;
     K:=K+1;
     DIFFERENCE SCHEME;
     OUTPUT;
     "IF" "NOT" LAST "THEN" "GOTO" NEXTLEVEL;
 ENDOFEFRK:
 "END" EXPONENTIALLY FITTED RUNGE KUTTA;
         "EOP"
1SECTION : 5.2.1.1.1.2        (NOVEMBER 1976)                     PAGE 1
 
 
 
 SECTION 5.2.1.1.1.2 CONTAINS SIX ALTERNATIVE PROCEDURES FOR SOLVING
 FIRST-ORDER INITIAL VALUE PROBLEMS WITH THE JACOBIAN MATRIX AVAILABLE.
 
 A.  EFSIRK SOLVES AN INITIAL VALUE PROBLEM, GIVEN AS AN AUTONOMOUS
     SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS DY/DX = F(Y), BY
     MEANS OF AN EXPONENTIALLY FITTED, SEMI-IMPLICIT RUNGE-KUTTA
     METHOD; IN PARTICULAR THIS PROCEDURE IS SUITABLE FOR THE
     INTEGRATION OF STIFF EQUATIONS.
 
 B.  EFERK SOLVES INITIAL VALUE PROBLEMS, GIVEN AS AN AUTONOMOUS SYSTEM
     OF FIRST ORDER DIFFERENTIAL EQUATIONS, BY MEANS OF AN EXPONENTIALLY
     FITTED, EXPLICIT RUNGE KUTTA METHOD OF THIRD ORDER, WHICH INVOLVES
     THE USE OF THE JACOBIAN MATRIX. AUTOMATIC STEP CONTROL IS PROVIDED.
     IN PARTICULAR  THIS METHOD IS SUITABLE FOR THE INTEGRATION OF STIFF
     DIFFERENTIAL EQUATIONS.
 
 C.  LINIGER1VS SOLVES INITIAL VALUE PROBLEMS, GIVEN AS AN AUTONOMOUS
     SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS, BY MEANS OF AN
     IMPLICIT, FIRST ORDER ACCURATE, EXPONENTIALLY FITTED ONESTEP
     METHOD.
     AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
 
 D.  LINIGER2 SOLVES INITIAL VALUE PROBLEMS, GIVEN AS AN AUTONOMOUS
     SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS, BY MEANS OF AN
     EXPONENTIALLY FITTED ONESTEP METHOD.
     NO AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
 
 E.  GMS SOLVES AN INITIAL VALUE PROBLEM, GIVEN AS AN AUTONOMOUS SYSTEM
     OF FIRST ORDER DIFFERENTIAL EQUATIONS DY / DX = F(Y), BY MEANS OF A
     THIRD ORDER GENERALIZED LINEAR MULTISTEP METHOD.
 
 F.  IMPEX SOLVES AN INITIAL VALUE PROBLEM,GIVEN AS AN AUTONOMOUS SYSTEM
     OF FIRST ORDER DIFFERENTIAL EQUATIONS, BY MEANS OF THE IMPLICIT
     MID-POINT RULE WITH SMOOTHING AND EXTRAPOLATION.
     AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
 
 
 IN PARTICULAR ALL THESE METHODS ARE SUITABLE FOR THE INTEGRATION OF
 STIFF DIFFERENTIAL EQUATIONS.
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 1
 
 
 
 AUTHOR: S.P.N. VAN KAMPEN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730529.
 
 
 BRIEF DESCRIPTION:
 
     EFSIRK SOLVES AN INITIAL VALUE PROBLEM, GIVEN AS AN AUTONOMOUS
     SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS DY/DX = F(Y), BY
     MEANS OF AN EXPONENTIALLY FITTED, SEMI-IMPLICIT RUNGE-KUTTA
     METHOD; IN PARTICULAR THIS PROCEDURE IS SUITABLE FOR THE
     INTEGRATION OF STIFF EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEM,
     AUTONOMOUS SYSTEM,
     STIFF EQUATIONS,
     SEMI-IMPLICIT RUNGE-KUTTA METHOD,
     EXPONENTIAL FITTING.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" EFSIRK(X, XE, M, Y, DELTA, DERIVATIVE, JACOBIAN, J,
                        N, AETA, RETA, HMIN, HMAX, LINEAR, OUTPUT);
     "VALUE" M; "INTEGER" M, N;
     "REAL" X, XE, DELTA, AETA, RETA, HMIN, HMAX;
     "PROCEDURE" DERIVATIVE, JACOBIAN, OUTPUT;
     "ARRAY" Y, J;
     "BOOLEAN" LINEAR;
     "CODE" 33160;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE END VALUE XE;
     XE:     <ARITHMETIC EXPRESSION>;
             THE END VALUE OF X;
     M:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF DIFFERENTIAL EQUATIONS;
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1 : M];
             THE DEPENDENT VARIABLE;
             DURING THE INTEGRATION PROCESS THE COMPUTED SOLUTION
             AT THE POINT X IS ASSIGNED TO THE ARRAY Y;
             ENTRY: THE INITIAL VALUES OF THE SOLUTION OF THE SYSTEM;
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 2
 
 
 
     DELTA:  <ARITHMETIC EXPRESSION>;
             DELTA DENOTES THE REAL PART OF THE POINT AT WHICH
             EXPONENTIAL FITTING IS DESIRED;
             ALTERNATIVES:
             DELTA = (AN ESTIMATE OF) THE REAL PART OF THE, IN  ABSOLUTE
             VALUE, LARGEST EIGENVALUE OF THE JACOBIAN MATRIX OF THE
             SYSTEM;
             DELTA < -10**14, IN ORDER TO OBTAIN ASYMPTOTIC
             STABILITY;
             DELTA = 0, IN ORDER TO OBTAIN A HIGHER ORDER OF ACCURACY IN
             CASE OF LINEAR OR ALMOST LINEAR EQUATIONS;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             "PROCEDURE" DERIVATIVE(A); "ARRAY" A;
             WHEN IN EFSIRK DERIVATIVE IS CALLED, A[I] CONTAINS THE
             VALUES OF Y[I];
             UPON COMPLETION OF A CALL OF DERIVATIVE, THE ARRAY A
             SHOULD CONTAIN THE VALUES OF F(Y);
             NOTE THAT THE VARIABLE X SHOULD NOT BE USED IN DERIVATIVE,
             BECAUSE THE DIFFERENTIAL EQUATION IS SUPPOSED TO BE
             AUTONOMOUS;
     JACOBIAN: <PROCEDURE IDENTIFIER>;
             "PROCEDURE" JACOBIAN(J, Y); "ARRAY" J, Y;
             WHEN IN EFSIRK JACOBIAN IS CALLED THE ARRAY Y CONTAINS
             THE VALUES OF THE DEPENDENT VARIABLE;
             UPON COMPLETION OF A CALL OF JACOBIAN THE ARRAY J SHOULD
             CONTAIN THE VALUES OF THE JACOBIAN MATRIX OF F(Y);
     J:      <ARRAY IDENTIFIER>;
             J[1 : M, 1 : M];
             J IS AN AUXILLIARY ARRAY WHICH IS USED IN THE PROCEDURE
             JACOBIAN;
     N:      <VARIABLE>;
             AN INTEGER WHICH COUNTS THE INTEGRATION STEPS;
     AETA, RETA:
             <ARITHMETIC EXPRESSION>;
             REQUIRED ABSOLUTE AND RELATIVE LOCAL ACCURACY;
     HMIN, HMAX:
             <ARITHMETIC EXPRESSION>;
             MINIMAL  AND MAXIMAL  STEPSIZE BY WHICH  THE INTEGRATION IS
             PERFORMED;
     LINEAR: <BOOLEAN EXPRESSION>;
             IF LINEAR = "TRUE" THE PROCEDURE JACOBIAN WILL ONLY BE
             CALLED IF N = 1; THE INTEGRATION WILL THEN BE PERFORMED
             WITH A STEPSIZE HMAX; THE CORRESPONDING REDUCTION
             OF COMPUTING TIME CAN BE EXPLOITED IN CASE OF LINEAR OR
             ALMOST LINEAR EQUATIONS;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             "PROCEDURE" OUTPUT;
             IN OUTPUT ONE MAY PRINT THE VALUES OF E.G. X,
             Y[I], J[K, L] AND N.
 
 
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 3
 
 
 
 DATA AND RESULTS: SEE REF[2] AND [3].
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     MATVEC = CP34011,
     MATMAT = CP34013,
     GSSELM = CP34231,
     SOLELM = CP34061.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA M * M + 5 * M.
 
 
 RUNNING TIME:
 
     DEPENDS  STRONGLY  ON  THE  DIFFERENTIAL  EQUATION  TO  BE   SOLVED
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE EFSIRK IS AN EXPONENTIALLY FITTED, A-STABLE,
     SEMI-IMPLICIT RUNGE-KUTTA METHOD OF THIRD ORDER (SEE REF[1]
     AND [2]). THE ALGORITHM USES FOR EACH STEP TWO FUNCTION EVALUATIONS
     AND IF LINEAR = "FALSE" ONE EVALUATION OF THE JACOBIAN MATRIX.
     THE STEPSIZE IS NOT DETERMINED BY THE ACCURACY OF THE NUMERICAL
     SOLUTION, BUT BY THE AMOUNT BY WHICH THE GIVEN DIFFERENTIAL
     EQUATION DIFFERS FROM A LINEAR EQUATION (SEE REF[2]).
     THE PROCEDURE DOES NOT REJECT INTEGRATION STEPS.
 
 
 REFERENCES:
 
     [1].P.J. VAN DER HOUWEN.
         ONE-STEP METHODS WITH ADAPTIVE STABILITY FUCNTIONS
         FOR THE INTEGRATION OF DIFFERENTIAL EQUATIONS.
         LECTURE NOTES OF THE CONFERENCE ON
         NUMERISCHE, INSBESONDERE APPROXIMATIONSTHEORETISCHE
         BEHANDLUNG VON FUNKTIONALGLEICHUNGEN.
         OBERWOLFACH, DECEMBER, 3 - 12, 1972.
 
     [2].SYLLABUS COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 2 (DUTCH).
         MATH.CENTR. SYLLABUS 15.2/73.
 
     [3].SYLLABUS COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 3 (DUTCH).
         MATH.CENTR. SYLLABUS 15.3/73.
         TO APPEAR IN 1973.
 
 
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     WE CONSIDER THE DIFFERENTIAL EQUATION
     DY / DX = -EXP(X) * (Y - LN(X)) + 1 / X,
     ON THE INTERVAL  [0.01, 8], WITH  INITIAL VALUE  Y(0.01) = LN(0.01)
     AND ANALYTICAL SOLUTION Y(X) = LN(X);
     FOR THE FIT POINT WE USE THE  EIGENVALUE  OF THE JACOBIAN MATRIX,
     I.E. DELTA = -EXP(X);
 
     "BEGIN"
         "PROCEDURE" DER(Y); "ARRAY" Y;
         "BEGIN" "REAL" Y2; Y2:= Y[2];
             DELTA:= -EXP(Y2); LNX:= LN(Y2);
             Y[1]:= (Y[1] - LNX) * DELTA + 1 / Y2;
             Y[2]:= 1
         "END" DER;
         "PROCEDURE" JAC(J, Y); "ARRAY" J, Y;
         "BEGIN" "REAL" Y2; Y2:= Y[2];
             J[1, 1]:= DELTA;
             J[1, 2]:= (Y[1] - LNX - 1 / Y2) * DELTA - 1 / (Y2 * Y2);
             J[2, 1]:= J[2, 2]:= 0
         "END" JAC;
         "PROCEDURE" OUTP;
         "IF" X = XE "THEN"
         "BEGIN" "REAL" Y1; Y1:= Y[1]; LNX:= LN(X);
             OUTPUT(61, "(""("N = ")", 2ZD,
                        "("   X = ")", +D.D,
                        "("  Y(X) = ")", +D.5D,
                        "("  DELTA = ")", +3ZD.2D, /,
                        "("ABS. ERR. = ")", .2D"+2D,
                        "("  REL. ERR. = ")", .2D"+2D, //")",
                        N, X, Y1, DELTA,
                        ABS(Y1 - LNX), ABS((Y1 - LNX) / LNX));
             "IF" X = 0.4 "THEN" XE:= 8
         "END" OUTP;
         "INTEGER" N;
         "REAL" X, XE, DELTA, LNX;
         "ARRAY" Y[1 : 2], J[1 : 2, 1 : 2];
 
         XE:= 0.4; X:= 0.01; Y[1]:= LN(0.01); Y[2]:= X;
         EFSIRK(X, XE, 2, Y, DELTA, DER, JAC, J,
                N, "-2, "-2, 0.005, 1.5, "FALSE", OUTP)
     "END"
 
     THIS PROGRAM DELIVERS:
 
         N =  10   X = +0.4  Y(X) = -0.91099  DELTA =    -1.44
         ABS. ERR. = .53"-02  REL. ERR. = .58"-02
 
         N = 98    X = +8.0  Y(X) = +2.07911  DELTA = -2980.02
         ABS. ERR. = .33"-03  REL. ERR. = .16"-03
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 5
 
 
 
 SOURCE TEXT(S):
0"CODE" 33160;
     "PROCEDURE" EFSIRK(X, XE, M, Y, DELTA, DERIVATIVE, JACOBIAN, J,
                        N, AETA, RETA, HMIN, HMAX, LINEAR, OUTPUT);
     "VALUE" M; "INTEGER" M, N;
     "REAL" X, XE, DELTA, AETA, RETA, HMIN, HMAX;
     "PROCEDURE" DERIVATIVE, JACOBIAN, OUTPUT;
     "BOOLEAN" LINEAR;
     "ARRAY" Y, J;
 
     "BEGIN" "INTEGER" K, L;
         "REAL" STEP, H, MU0, MU1, MU2, THETA0, THETA1, NU1, NU2,
         NU3, YK, FK, C1, C2, D;
         "ARRAY" F, K0, LABDA[1 : M], J1[1 : M,1 : M], AUX[1 : 7];
         "INTEGER" "ARRAY" RI, CI[1 : M];
         "BOOLEAN" LIN;
         "REAL" "PROCEDURE" STEPSIZE;
         "BEGIN" "REAL" DISCR, ETA, S;
             "IF" LINEAR "THEN" S:= H:= HMAX "ELSE"
             "IF" N = 1 "OR" HMIN = HMAX "THEN" S:= H:= HMIN "ELSE"
             "BEGIN" ETA:= AETA + RETA * SQRT(VECVEC(1, M, 0, Y, Y));
                 C1:= NU3 * STEP; "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
                 LABDA[K]:= LABDA[K] + C1 * F[K] - Y[K];
                 DISCR:= SQRT(VECVEC(1, M, 0, LABDA, LABDA));
                 S:= H:= (ETA / (0.75 * (ETA + DISCR)) + 0.33) * H;
                 "IF" H < HMIN "THEN" S:= H:= HMIN "ELSE"
                 "IF" H > HMAX "THEN" S:= H:= HMAX
             "END";
             "IF" X + S > XE "THEN" S:= XE - X;
             LIN:= STEP = S "AND" LINEAR; STEPSIZE:= S
         "END" STEPSIZE;
 
         "PROCEDURE" COEFFICIENT;
         "BEGIN" "REAL" Z1, E, ALPHA1, A, B;
             "OWN" "REAL" Z2;
             Z1:= STEP * DELTA; "IF" N = 1 "THEN" Z2:= Z1 + Z1;
             "IF" ABS(Z2 - Z1) > " - 6 * ABS(Z1) "OR" Z2 > - 1 "THEN"
             "BEGIN" A:= Z1 * Z1 + 12; B:= 6 * Z1;
                 "IF" ABS(Z1) < 0.1 "THEN"
                 ALPHA1:= (Z1 * Z1 / 140 - 1) * Z1 / 30 "ELSE"
                 "IF" Z1 < - "14 "THEN" ALPHA1:= 1 / 3 "ELSE"
                 "IF" Z1 < - 33 "THEN"
                 ALPHA1:= (A + B) / (3 * Z1 * (2 + Z1)) "ELSE"
                 "BEGIN" E:= "IF" Z1 < 230 "THEN" EXP(Z1) "ELSE" "100;
                     ALPHA1:= ((A - B) * E - A - B) /
                              (((2 - Z1) * E - 2 - Z1) * 3 * Z1)
                 "END";                                        "COMMENT"
1SECTION : 5.2.1.1.1.2.A      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
                 MU2:= (1 / 3 + ALPHA1) * 0.25;
                 MU1:= - (1 + ALPHA1) * 0.5;
                 MU0:= (6 * MU1 + 2) / 9; THETA0:= 0.25;
                 THETA1:= 0.75; A:= 3 * ALPHA1;
                 NU3:= (1 + A) / (5 - A) * 0.5; A:= NU3 + NU3;
                 NU1:= 0.5 - A; NU2:= (1 + A) * 0.75;
                 Z2:= Z1
             "END"
         "END" COEFFICIENT;
 
         "PROCEDURE" DIFFERENCE SCHEME;
         "BEGIN" DERIVATIVE(F); STEP:= STEPSIZE;
             "IF" "NOT" LINEAR "OR" N = 1 "THEN" JACOBIAN(J, Y);
             "IF" "NOT" LIN "THEN"
             "BEGIN" COEFFICIENT;
                 C1:= STEP * MU1; D:= STEP * STEP * MU2;
                 "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
                 "BEGIN" "FOR" L:= 1 "STEP" 1 "UNTIL" M "DO"
                     J1[K,L]:= D * MATMAT(1, M, K, L, J, J) +
                               C1 * J[K,L];
                     J1[K,K]:= J1[K,K] + 1
                 "END";
                 GSSELM(J1, M, AUX, RI, CI)
             "END";
             C1:= STEP * STEP * MU0; D:= STEP * 2 / 3;
             "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" K0[K]:= FK:= F[K];
                 LABDA[K]:= D * FK + C1 * MATVEC(1, M, K, J, F)
             "END";
             SOLELM(J1, M, RI, CI, LABDA);
             "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO" F[K]:= Y[K] + LABDA[K];
             DERIVATIVE(F);
             C1:= THETA0 * STEP; C2:= THETA1 * STEP; D:= NU1 * STEP;
             "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" YK:= Y[K]; FK:= F[K];
                 LABDA[K]:= YK + D * FK + NU2 * LABDA[K];
                 Y[K]:= F[K]:= YK + C1 * K0[K] + C2 * FK
             "END"
         "END" DIFFERENCE SCHEME;
 
         AUX[2]:= "-14; AUX[4]:= 8;
         "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO" F[K]:= Y[K];
         N:= 0; OUTPUT; STEP:= 0;
     NEXT STEP: N:= N + 1;
         DIFFERENCE SCHEME; X:= X + STEP; OUTPUT;
         "IF" X < XE "THEN" "GOTO" NEXT STEP
     "END" EFSIRK;
         "EOP"
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 1
 
 
 
 AUTHOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 1973/07/31.
 
 
 BRIEF DESCRIPTION:
 
     EFERK SOLVES INITIAL VALUE PROBLEMS , GIVEN AS AN AUTONOMOUS SYSTEM
     OF FIRST ORDER DIFFERENTIAL EQUATIONS, BY MEANS OF AN EXPONENTIALLY
     FITTED, EXPLICIT RUNGE KUTTA METHOD OF THIRD ORDER, WHICH INVOLVES
     THE USE OF THE JACOBIAN MATRIX. AUTOMATIC STEP CONTROL IS PROVIDED.
     IN PARTICULAR  THIS METHOD IS SUITABLE FOR THE INTEGRATION OF STIFF
     DIFFERENTIAL EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEMS,
     STIFF EQUATIONS,
     EXPONENTIAL FITTING,
     EXPLICIT RUNGE KUTTA METHODS.
 
 
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE EFERK READS:
     "PROCEDURE" EFERK(X,XE,M,Y,SIGMA,PHI,DERIVATIVE,J,JACOBIAN,
                   K,L,AUT,AETA,RETA,HMIN,HMAX,LINEAR,OUTPUT);
     "VALUE" L;
     "INTEGER" M,K,L;
     "REAL" X,XE,SIGMA,PHI,AETA,RETA,HMIN,HMAX;
     "ARRAY" Y,J;
     "BOOLEAN" AUT,LINEAR;
     "PROCEDURE" DERIVATIVE,JACOBIAN,OUTPUT;
     "CODE" 33120;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X;
             CAN BE USED IN DERIVATIVE, JACOBIAN, OUTPUT, ETC.;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE FINAL VALUE XE;
     XE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X (XE>=X);
     M:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     Y:      <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" Y[1:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE  INITIAL  VALUES  OF  THE SYSTEM OF DIFFERENTIAL
                    EQUATIONS: Y[I] AT X=X0;
             EXIT : THE FINAL VALUES OF THE SOLUTION: Y[I] AT X=XE;
     SIGMA:  <ARITHMETIC EXPRESSION>;
             THE  MODULUS  OF  THE POINT AT WHICH EXPONENTIAL FITTING IS
             DESIRED, FOR EXAMPLE THE LARGEST NEGATIVE EIGENVALUE OF THE
             JACOBIAN MATRIX OF THE SYSTEM OF DIFFERENTIAL EQUATIONS;
     PHI:    <ARITHMETIC EXPRESSION>;
             THE  ARGUMENT  OF THE  COMPLEX POINT  AT WHICH  EXPONENTIAL
             FITTING IS DESIRED;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(Y); "ARRAY" Y;
             THIS  PROCEDURE  SHOULD  DELIVER THE RIGHT HAND SIDE OF THE
             I-TH DIFFERENTIAL EQUATION AT THE POINT (Y) AS Y[I];
     J:      <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" J[1:M,1:M];
             THE JACOBIAN MATRIX OF THE SYSTEM;
             THE ARRAY J SHOULD BE UPDATED IN THE PROCEDURE JACOBIAN;
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 3
 
 
 
     JACOBIAN: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
             IN THIS PROCEDURE  THE JACOBIAN AT THE POINT (Y)  HAS TO BE
             ASSIGNED TO THE ARRAY J;
     K:      <VARIABLE>;
             COUNTS THE NUMBER OF INTEGRATION STEPS TAKEN;
             FOR EXAMPLE, MAY BE USED IN THE EXPRESSION FOR XE;
     L:      <ARITHMETIC EXPRESSION>;
             ENTRY:
             IF PHI = 4*ARCTAN(1): THE ORDER OF THE EXPONENTIAL FITTING,
             ELSE TWICE THE ORDER OF THE EXPONENTIAL FITTING;
     AUT:    <BOOLEAN EXPRESSION>;
             IF THE SYSTEM HAS BEEN WRITTEN IN AUTONOMOUS FORM BY ADDING
             THE EQUATION DY[M]/DX = 1 TO THE SYSTEM , THEN AUT MAY HAVE
             THE VALUE "FALSE", ELSE AUT SHOULD HAVE THE VALUE "TRUE";
     AETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  ABSOLUTE  PRECISION  IN THE  INTEGRATION PROCESS;
             AETA HAS TO BE POSITIVE;
     RETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  RELATIVE  PRECISION  IN THE  INTEGRATION PROCESS;
             RETA HAS TO BE POSITIVE;
     HMIN:   <ARITHMETIC EXPRESSION>;
             THE STEPLENGTH CHOSEN WILL BE AT LEAST EQUAL TO HMIN;
     HMAX:   <ARITHMETIC EXPRESSION>;
             THE STEPLENGTH CHOSEN WILL BE AT MOST EQUAL TO HMAX;
     LINEAR: <ARITHMETIC EXPRESSION>;
             THE PROCEDURE JACOBIAN IS CALLED  ONLY IF LINEAR="FALSE" OR
             K=0; SO IF THE SYSTEM IS LINEAR , LINEAR MAY HAVE THE VALUE
             "TRUE";
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS;
             "PROCEDURE" OUTPUT;
             THIS  PROCEDURE  IS  CALLED  AT THE END OF EACH INTEGRATION
             STEP ; THE USER CAN ASK FOR OUTPUT OF SOME PARAMETERS , FOR
             EXAMPLE X, K, Y.
 
 
 DATA AND RESULTS: SEE EXAMPLE OF USE, AND REF[4].
 
 
 PROCEDURES USED:
 
     VECVEC= CP34010,
     MATVEC= CP34011,
     DEC   = CP34300,
     SOL   = CP34051.
 
 
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 4
 
 
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: CIRCA 30 + 4 * M + L * (5+L).
 
 
 RUNNING TIME: DEPENDS  STRONGLY  ON THE DIFFERENTIAL EQUATION TO SOLVE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
    THE PROCEDURE EFERK IS AN EXPONENTIALLY FITTED, SEMI-EXPLICIT RUNGE
    KUTTA METHOD OF THIRD ORDER ( SEE REF [1] AND [3] ) . THE ALGORITHM
    USES FOR EACH STEP TWO FUNCTION EVALUATIONS AND IF LINEAR = "FALSE"
    ONE EVALUATION OF THE JACOBIAN MATRIX.THE STEPSIZE IS DETERMINED BY
    AN ESTIMATION  OF THE LOCAL TRUNCATION ERROR  BASED ON THE RESIDUAL
    FUNCTION (SEE REF[3]). INTEGRATION STEPS ARE NOT REJECTED.
 
 
 REFERENCES:
 
    [1]. P.J.VAN DER HOUWEN.
         ONE-STEP  METHODS  WITH ADAPTIVE  STABILITY FUNCTIONS  FOR THE
         INTEGRATION OF DIFFERENTIAL EQUATIONS.
         LECTURES NOTES OF THE CONFERENCE ON NUMERISCHE, INSBESONDERE
         APPROXIMATIONSTHEORETISCHE BEHANDLUNG VON FUNKTIONAL-
         GLEICHUNGEN.
         OBERWOLFACH, DECEMBER, 3 -12, 1972.
 
    [2]. T.J.DEKKER, P.W.HEMKER AND P.J.VAN DER HOUWEN.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 1 (DUTCH).
          MC SYLLABUS 15.1, (1972) MATHEMATICAL CENTRE.
 
     [3]. P.A.BEENTJES, K.DEKKER, H.C.HEMKER, S.P.N.VAN KAMPEN
          AND G.M.WILLEMS.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 2 (DUTCH).
          MC SYLLABUS 15.2, (1973) MATHEMATICAL CENTRE.
 
    [4]. (TO APPEAR).
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 3 (DUTCH).
          MC SYLLABUS 15.3, (1973) MATHEMATICAL CENTRE.
 
 EXAMPLE OF USE:
 
     CONSIDER THE SYSTEM OF DIFFERENTIAL EQUATIONS:
     DY[1]/DX = -Y[1] + Y[1] * Y[2] + .99 * Y[2]
     DY[2]/DX = -1000 * ( -Y[1] + Y[1] * Y[2] + Y[2] )
     WITH THE INITIAL CONDITIONS AT X = 0:
     Y[1] = 1 AND Y[2] = 0. (SEE REF[2], PAGE 11).
     THE SOLUTION AT X = 50 IS APPROXIMATELY:
     Y[1] = .765 878 320 487  AND  Y[2] = .433 710 353  5768.
     THE FOLLOWING PROGRAM  SHOWS SOME DIFFERENT CALLS  OF THE PROCEDURE
     EFERK,AND ILLUSTRATES THE ACCURACIES WHICH MAY BE OBTAINED BY THEM:
 
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 5
 
 
 
     "BEGIN"
 
         "INTEGER" K,PASSES,PASJAC;
         "REAL" X,SIGMA,PHI,TIME,TOL;
         "REAL" "ARRAY" Y[1:2],J[1:2,1:2];
 
         "PROCEDURE" DER(Y); "ARRAY" Y;
         "BEGIN" "REAL" Y1,Y2; Y1:=Y[1]; Y2:=Y[2];
             Y[1]:=(Y1+.99)*(Y2-1)+.99;
             Y[2]:=1000*((1+Y1)*(1-Y2)-1);
             PASSES:=PASSES+1
        "END";
 
         "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
         "BEGIN" J[1,1]:=Y[2]-1; J[1,2]:=.99+Y[1];
             J[2,1]:=1000*(1-Y[2]); J[2,2]:=-1000*(1+Y[1]);
             SIGMA:=ABS(J[2,2]+J[1,1]-SQRT((J[2,2]-J[1,1])**2+
                    4*J[2,1]*J[1,2]))/2;
             PASJAC:=PASJAC+1
         "END" JACOBIAN;
 
         "PROCEDURE" OUT;
         "IF" X=50 "THEN"
        OUTPUT(61,"("3(-5ZD),2(4B+.3DB3DB3D),-5ZD.3D,/")",K,PASSES,
         PASJAC,Y[1],Y[2],CLOCK-TIME);
 
         OUTPUT(61,"(""("    THIS LINE AND THE FOLLOWING TEXT IS ")"
         "("PRINTED BY THIS PROGRAM")",//,
         "("    THE RESULTS WITH EFERK -FIRST ORDER FIT- ARE:")",/,
         "("     K   DER.EV. JAC.EV.       Y[1]             Y[2]")"
         "("         TIME")",/")");
         PHI:=4*ARCTAN(1);
         "FOR" TOL:=1,"-1,"-2,"-3 "DO"
         "BEGIN" PASSES:=PASJAC:=0; X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
           EFERK(X,50.0,2,Y,SIGMA,PHI,DER,J,JACOBIAN,K,1,"TRUE",TOL,
                                          TOL,"-6,50.0,"FALSE",OUT);
         "END";
     "END"
 
     THIS LINE AND THE FOLLOWING TEXT IS PRINTED BY THIS PROGRAM:
 
     THE RESULTS WITH EFERK -FIRST ORDER FIT- ARE:
      K   DER.EV. JAC.EV.       Y[1]             Y[2]         TIME
     93    186     93    +.765 883 211    +.428 752 781      1.170
    105    210    105    +.765 878 445    +.433 569 561      1.296
    147    294    147    +.765 878 317    +.433 708 489      1.834
    266    532    266    +.765 878 320    +.433 710 229      3.297
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE" 33120;
 "PROCEDURE" EFERK(X,XE,M,Y,SIGMA,PHI,DERIVATIVE,J,JACOBIAN,
               K,L,AUT,AETA,RETA,HMIN,HMAX,LINEAR,OUTPUT);
 "VALUE" L; "INTEGER" M,K,L;
 "REAL" X,XE,SIGMA,PHI,AETA,RETA,HMIN,HMAX; "ARRAY" Y,J;
 "BOOLEAN" AUT,LINEAR; "PROCEDURE" DERIVATIVE,JACOBIAN,OUTPUT;
 "BEGIN" "INTEGER" M1,I;
     "REAL" H,B,B0,PHI0,COSPHI,SINPHI,ETA,DISCR,FAC,PI;
     "BOOLEAN" CHANGE,LAST;
     "INTEGER" "ARRAY" P[1:L];
     "REAL" "ARRAY" BETA,BETHA[0:L],BETAC[0:L+3],K0,D,D1,D2[1:M],
         A[1:L,1:L],AUX[1:3];
     "REAL" "PROCEDURE" SUM(I,L,U,T); "VALUE" L,U; "INTEGER" I,L,U;
     "REAL" T;
     "BEGIN" "REAL" S; S:=0;
         "FOR" I:=L "STEP" 1 "UNTIL" U "DO" S:=S+T;
         SUM:=S
     "END";
     "PROCEDURE" FORMBETA;
     "IF" L=1 "THEN"
     "BEGIN" BETHA[1]:=(.5-(1-(1-EXP(-B))/B)/B)/B;
         BETA[1]:=(1/6-BETHA[1])/B
     "END" "ELSE"
     "IF" L=2 "THEN"
     "BEGIN" "REAL" E,EMIN1; E:=EXP(-B); EMIN1:=E-1;
         BETHA[1]:=(1-(3+E+4*EMIN1/B)/B)/B;
         BETHA[2]:=(.5-(2+E+3*EMIN1/B)/B)/B/B;
         BETA[2]:=(1/6-BETHA[1])/B/B;
         BETA[1]:=(1/3-(1.5-(4+E+5*EMIN1/B)/B)/B)/B
     "END" "ELSE"
     "BEGIN" "REAL" B0,B1,B2,A0,A1,A2,A3,C,D;
         BETAC[L-1]:=C:=D:=EXP(-B)/FAC;
         "FOR" I:=L-1 "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" C:=I*B*C/(L-I); BETAC[I-1]:=D:=D*I+C "END";
         B2:=.5-BETAC[2];
         B1:=(1-BETAC[1])*(L+1)/B;
         B0:=(1-BETAC[0])*(L+2)*(L+1)*.5/B/B;
         A3:=1/6-BETAC[3];
         A2:=B2*(L+1)/B;
         A1:=B1*(L+2)*.5/B;
         A0:=B0*(L+3)/3/B;
         D:=L/B;
         "FOR" I:=1 "STEP" 1 "UNTIL" L "DO"
         "BEGIN"BETA[I]:=(A3/I-A2/(I+1)+A1/(I+2)-A0/(I+3))*D+BETAC[I+3];
             BETHA[I]:=(B2/I-B1/(I+1)+B0/(I+2))*D+BETAC[I+2];
             D:=D*(L-I)/I/B;
         "END"
     "END" FORMBETA;                                           "COMMENT"
 
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
     "PROCEDURE" SOLUTIONOFCOMPLEXEQUATIONS;
     "IF" L=2 "THEN"
     "BEGIN" "REAL" COS2PHI,COSA,SINA,E,ZI;
         PHI0:=PHI; COSPHI:=COS(PHI0); SINPHI:=SIN(PHI0);
         E:=EXP(B*COSPHI); ZI:=B*SINPHI-3*PHI0;
         SINA:=("IF" ABS(SINPHI)<"-6 "THEN" -E*(B+3)
               "ELSE" E*SIN(ZI)/SINPHI);
         COS2PHI:=2*COSPHI*COSPHI-1;
         BETHA[2]:=(.5+(2*COSPHI+(1+2*COS2PHI+SINA)/B)/B)/B/B;
         SINA:=("IF" ABS(SINPHI)<"-6 "THEN" E*(B+4)
               "ELSE" SINA*COSPHI-E*COS(ZI));
         BETHA[1]:=-(COSPHI+(1+2*COS2PHI+(4*COSPHI*COS2PHI+SINA)
                   /B)/B)/B;
         BETA[1]:=BETHA[2]+2*COSPHI*(BETHA[1]-1/6)/B;
         BETA[2]:=(1/6-BETHA[1])/B/B
     "END" "ELSE"
 
     "BEGIN" "INTEGER" J,C1;
         "REAL" C2,E,ZI,COSIPHI,SINIPHI,COSPHIL;
         "REAL" "ARRAY" D[1:L];
         "PROCEDURE" ELEMENTS OF MATRIX;
         "BEGIN" PHI0:=PHI;
             COSPHI:=COS(PHI0); SINPHI:=SIN(PHI0);
             COSIPHI:=1; SINIPHI:=0;
             "FOR" I:=0 "STEP" 1 "UNTIL" L-1 "DO"
             "BEGIN" C1:=4+I; C2:=1;
                 "FOR" J:=L-1 "STEP" -2 "UNTIL" 1 "DO"
                 "BEGIN"  A[J,L-I]:=C2*COSIPHI;
                     A[J+1,L-I]:=C2*SINIPHI;
                     C2:=C2*C1; C1:=C1-1
                 "END";
                 COSPHIL:=COSIPHI*COSPHI-SINIPHI*SINPHI;
                 SINIPHI:=COSIPHI*SINPHI+SINIPHI*COSPHI;
                 COSIPHI:=COSPHIL
             "END";
             AUX[2]:=0; DEC(A,L,AUX,P)
         "END" EL OF MAT;
         "PROCEDURE" RIGHT HAND SIDE;
         "BEGIN" E:=EXP(B*COSPHI);
             ZI:=B*SINPHI-4*PHI0;
             COSIPHI:=E*COS(ZI); SINIPHI:=E*SIN(ZI);
             ZI:=1/B/B/B;
             "FOR" J:=L "STEP" -2 "UNTIL" 2 "DO"
             "BEGIN" D[J]:=ZI*SINIPHI;
                 D[J-1]:=ZI*COSIPHI;
                 COSPHIL:=COSIPHI*COSPHI-SINIPHI*SINPHI;
                 SINIPHI:=COSIPHI*SINPHI+SINIPHI*COSPHI;
                 COSIPHI:=COSPHIL; ZI:=ZI*B
             "END";                                            "COMMENT"
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 8
                                                                  ;
 
 
             SINIPHI:=2*SINPHI*COSPHI;
             COSIPHI:=2*COSPHI*COSPHI-1;
             COSPHIL:=COSPHI*(2*COSIPHI-1);
             D[L]:=D[L]+SINPHI*(1/6+(COSPHI+(1+2*COSIPHI*(1+2*COSPHI/B))
                         /B)/B);
             D[L-1]:=D[L-1]-COSPHI/6-(.5*COSIPHI+(COSPHIL+(2*COSIPHI*
                         COSIPHI-1)/B)/B)/B;
             D[L-2]:=D[L-2]+SINPHI*(.5+(2*COSPHI+(2*COSIPHI+1)/B)/B);
             D[L-3]:=D[L-3]-.5*COSPHI-(COSIPHI+COSPHIL/B)/B;
             "IF" L<5 "THEN" "GOTO" END;
             D[L-4]:=D[L-4]+SINPHI+SINIPHI/B;
             D[L-5]:=D[L-5]-COSPHI-COSIPHI/B;
             "IF" L<7 "THEN" "GOTO" END;
             D[L-6]:=D[L-6]+SINPHI;
             D[L-7]:=D[L-7]-COSPHI;
         END:
         "END" RHS;
         "IF" PHI0^=PHI "THEN" ELEMENTS OF MATRIX;
         RIGHT HAND SIDE;
         SOL(A,L,P,D);
         ZI:=1/B;
         "FOR" I:=1 "STEP" 1 "UNTIL" L "DO"
         "BEGIN" BETA[I]:=D[L+1-I]*ZI;
             BETHA[I]:=(I+3)*BETA[I];
             ZI:=ZI/B
         "END"
     "END" SOLOFEQCOM;
 
     "PROCEDURE" COEFFICIENT;
     "BEGIN" B0:=B:=ABS(H*SIGMA);
         "IF" B>=.1 "THEN"
         "BEGIN" "IF" PHI^=PI "AND" L=2 "OR" ABS(PHI-PI)>.01 "THEN"
             SOLUTION OF COMPLEX EQUATIONS "ELSE" FORMBETA
         "END" "ELSE"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" L "DO"
             "BEGIN" BETHA[I]:=BETA[I-1];
                 BETA[I]:=BETA[I-1]/(I+3);
             "END"
         "END"
     "END" COEFFICIENT;
 
     "PROCEDURE" LOCAL ERROR BOUND;
     ETA:=AETA+RETA*SQRT(VECVEC(1,M1,0,Y,Y));
 
     "PROCEDURE" STEPSIZE;
     "BEGIN" LOCAL ERROR BOUND;
         "IF" K=0 "THEN"
         "BEGIN" DISCR:=SQRT(VECVEC(1,M1,0,D,D)); H:=ETA/DISCR
         "END" "ELSE"
         "BEGIN" DISCR:=H*SQRT(SUM(I,1,M1,(D[I]-D2[I])**2))/ETA;
             H:=H*("IF" LINEAR "THEN" 4/(4+DISCR)+.5
                               "ELSE" 4/(3+DISCR)+1/3)
         "END";                                                "COMMENT"
1SECTION : 5.2.1.1.1.2.B      (AUGUST 1974)                       PAGE 9
                                                                  ;
 
 
         "IF" H<HMIN "THEN" H:=HMIN;
         "IF" H>HMAX "THEN" H:=HMAX;
         B:=ABS(H*SIGMA);
         CHANGE:=ABS(1-B/B0)>.05 "OR" PHI^=PHI0;
         "IF" 1.1*H>=XE-X "THEN"
         "BEGIN" CHANGE:=LAST:="TRUE"; H:=XE-X "END";
         "IF" "NOT" CHANGE "THEN" H:=H*B0/B
     "END" STEPSIZE;
 
     "PROCEDURE" DIFFERENCE SCHEME;
     "BEGIN" "INTEGER" K;
         "REAL" BETAI,BETHAI;
         "IF" M1<M "THEN"
         "BEGIN" D2[M]:=1; K0[M]:=Y[M]+2*H/3; Y[M]:=Y[M]+.25*H "END";
         "FOR" K:=1 "STEP" 1 "UNTIL" M1 "DO"
         "BEGIN" K0[K]:=Y[K]+2*H/3*D[K];
             Y[K]:=Y[K]+.25*H*D[K];
             D1[K]:=H*MATVEC(1,M,K,J,D);
             D2[K]:=D1[K]+D[K]
         "END";
         "FOR" I:=0 "STEP" 1 "UNTIL" L "DO"
         "BEGIN" BETAI:=4*BETA[I]/3; BETHAI:=BETHA[I];
             "FOR" K:=1 "STEP" 1 "UNTIL" M1 "DO" D[K]:=H*D1[K];
             "FOR" K:=1 "STEP" 1 "UNTIL" M1 "DO"
             "BEGIN" K0[K]:=K0[K]+BETAI*D[K];
                 D1[K]:=MATVEC(1,M1,K,J,D);
                 D2[K]:=D2[K]+BETHAI*D1[K]
             "END"
         "END";
         DERIVATIVE(K0);
         "FOR" K:=1 "STEP" 1 "UNTIL" M "DO" Y[K]:=Y[K]+.75*H*K0[K]
     "END" DIFF SCHEME;
 
     B0:=PHI0:=-1; PI:=4*ARCTAN(1);
     BETAC[L]:=BETAC[L+1]:=BETAC[L+2]:=BETAC[L+3]:=0;
     BETA[0]:=1/6; BETHA[0]:=.5;
     FAC:=1; "FOR" I:=2 "STEP" 1 "UNTIL" L-1 "DO" FAC:=I*FAC;
     M1:= "IF" AUT "THEN" M "ELSE" M-1;
     K:=0; LAST:="FALSE";
  NEXT LEVEL:
     "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" D[I]:=Y[I];
     DERIVATIVE(D);
     "IF" "NOT" LINEAR "OR" K=0 "THEN" JACOBIAN(J,Y);
     STEPSIZE;
     "IF" CHANGE "THEN" COEFFICIENT;
     OUTPUT;
     DIFFERENCE SCHEME;
     K:=K+1;
     X:=X+H;
     "IF" "NOT" LAST "THEN" "GOTO" NEXT LEVEL;
 END OF EFERK: OUTPUT;
 "END" EFERK;
         "EOP"
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 1973/09/01.
 
 
 BRIEF DESCRIPTION:
 
     LINIGER1VS SOLVES  INITIAL VALUE PROBLEMS , GIVEN AS AN  AUTONOMOUS
     SYSTEM  OF  FIRST  ORDER  DIFFERENTIAL  EQUATIONS , BY MEANS OF  AN
     IMPLICIT,FIRST ORDER ACCURATE, EXPONENTIALLY FITTED ONESTEP METHOD.
     AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF  STIFF
     DIFFERENTIAL EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEMS,
     STIFF EQUATIONS,
     EXPONENTIAL FITTING,
     IMPLICIT ONESTEP METHODS.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE LINIGER1VS READS:
     "PROCEDURE" LINIGER1VS (X,XE,M,Y,SIGMA,DERIVATIVE,J,JACOBIAN,
                           ITMAX,HMIN,HMAX,AETA,RETA,INFO,OUTPUT);
     "VALUE" M;
     "INTEGER" M,ITMAX;
     "REAL" X,XE,SIGMA,HMIN,HMAX,AETA,RETA;
     "ARRAY" Y,J,INFO;
     "PROCEDURE" DERIVATIVE,JACOBIAN,OUTPUT;
    "CODE" 33132;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE FINAL VALUE XE;
     XE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X (XE>=X);
     M:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE  INITIAL  VALUES  OF  THE SYSTEM OF DIFFERENTIAL
                    EQUATIONS: Y[I] AT X=X0;
             EXIT : THE FINAL VALUES OF THE SOLUTION: Y[I] AT X=XE;
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 2
 
 
 
     SIGMA:  <ARITHMETIC EXPRESSION>;
             THE  MODULUS  OF  THE POINT AT WHICH EXPONENTIAL FITTING IS
             DESIRED, FOR EXAMPLE THE LARGEST NEGATIVE EIGENVALUE OF THE
             JACOBIAN OF THE SYSTEM OF DIFFERENTIAL EQUATIONS;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(Y); "ARRAY" Y;
             THIS  PROCEDURE  SHOULD  DELIVER THE RIGHT HAND SIDE OF THE
             I-TH DIFFERENTIAL EQUATION AT THE POINT (Y) AS Y[I];
      J:     <ARRAY IDENTIFIER>;
             "ARRAY" J[1:M,1:M];
             THE JACOBIAN MATRIX OF THE SYSTEM;
             THE ARRAY J SHOULD BE UPDATED IN THE PROCEDURE JACOBIAN;
     JACOBIAN: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
             IN THIS PROCEDURE (AN APPROXIMATION OF) THE JACOBIAN HAS TO
             BE ASSIGNED TO THE ARRAY J;
     ITMAX:  <ARITHMETIC EXPRESSION>;
             AN  UPPERBOUND  FOR  THE  NUMBER  OF ITERATIONS IN NEWTON'S
             PROCESS, USED TO SOLVE THE IMPLICIT EQUATIONS;
     HMIN:   <ARITHMETIC EXPRESSION>;
             MINIMAL  STEPSIZE  BY WHICH  THE INTEGRATION  IS PERFORMED;
     HMAX:   <ARITHMETIC EXPRESSION>;
             MAXIMAL  STEPSIZE  BY WHICH  THE INTEGRATION  IS PERFORMED;
     AETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  ABSOLUTE  PRECISION  IN THE INTEGRATION  PROCESS;
     RETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED  RELATIVE  PRECISION  IN THE INTEGRATION  PROCESS;
             IF BOTH AETA  AND RETA  HAVE  NEGATIVE VALUES , INTEGRATION
             WILL BE PERFORMED WITH A STEPSIZE EQUAL TO HMAX , WHICH MAY
             BE  VARIATED BY USER ; IN THIS CASE  THE ABSOLUTE VALUES OF
             AETA AND RETA WILL CONTROL THE NEWTON ITERATION;
     INFO:   <ARRAY IDENTIFIER>;
             "ARRAY" INFO[1:9];
             DURING INTEGRATION  AND UPON EXIT  THIS ARRAY CONTAINS  THE
             FOLLOWING INFORMATION:
             INFO[1]: NUMBER OF INTEGRATION STEPS TAKEN;
             INFO[2]: NUMBER OF DERIVATIVE EVALUATIONS USED;
             INFO[3]: NUMBER OF JACOBIAN EVALUATIONS USED;
             INFO[4]: NUMBER OF INTEGRATION STEPS  EQUAL TO HMIN TAKEN ;
             INFO[5]: NUMBER OF INTEGRATION STEPS  EQUAL TO HMAX TAKEN ;
             INFO[6]: MAXIMAL NUMBER OF  ITERATIONS TAKEN  IN THE NEWTON
                      PROCESS;
             INFO[7]: LOCAL ERROR TOLERANCE;
             INFO[8]: ESTIMATED LOCAL ERROR;
             INFO[9]: MAXIMUM VALUE OF THE ESTIMATED LOCAL ERROR;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS;
             "PROCEDURE" OUTPUT;
             THIS  PROCEDURE  IS  CALLED  AT THE END OF EACH INTEGRATION
             STEP ; THE USER CAN ASK FOR OUTPUT  OF THE PARAMETERS , FOR
             EXAMPLE X, Y, INFO.
 
 
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 3
 
 
 
 DATA AND RESULTS: SEE EXAMPLE OF USE, AND REF[2].
 
 
 PROCEDURES USED:
 
     INIVEC= CP31010,
     MULVEC= CP31020,
     MULROW= CP31021,
     DUPVEC= CP31030,
     MATVEC= CP34011,
     ELMVEC= CP34020,
     VECVEC= CP34010,
     DEC   = CP34300,
     SOL   = CP34051.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH : CIRCA 20 + M * (5 + M).
 
 
 RUNNING TIME: DEPENDS  STRONGLY  ON THE DIFFERENTIAL EQUATION TO SOLVE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     LINIGER1VS: INTEGRATES THE SYSTEM OF DIFFERENTIAL EQUATIONS FROM X0
                 UNTIL XE, BY MEANS OF A FIRST ORDER FORMULA.
 
     THE INTEGRATION METHOD  IS BASED ON THE F(1) FORMULA  DESCRIBED  BY
     LINIGER AND WILLOUGHBY (SEE REF[1]). ERROR ESTIMATES AND A STEPSIZE
     STRATEGY FOR THIS METHOD ARE DESCRIBED IN [2] , AND A VARIABLE STEP
     METHOD IS CONSTRUCTED FOR THE CONVENIENCE OF THE USER. HOWEVER, THE
     STEPSIZE STRATEGY  REQUIRES  MANY EXTRA  ARRAY OPERATIONS. THE USER
     MAY AVOID THIS EXTRA WORK  BY GIVING AETA AND RETA A NEGATIVE VALUE
     AND PRESCRIBING A STEPSIZE (HMAX) HIMSELF.
 
 
 REFERENCES:
 
     [1]. W.LINIGER AND R.A.WILLOUGHBY.
          EFFICIENT  INTEGRATION  METHODS  FOR STIFF SYSTEMS OF ORDINARY
          DIFFERENTIAL EQUATIONS.
          SIAM J. NUM. ANAL. 7 (1970) PAGE 47.
 
     [2]. K.DEKKER.
          ERROR ESTIMATES AND STEPSIZE STRATEGIES FOR THE LINIGER-
          WILLOUGHBY FORMULAE.
          (TO APPEAR IN 1974).
 
 
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     CONSIDER THE SYSTEM OF DIFFERENTIAL EQUATIONS:
     DY[1]/DX = -Y[1] + Y[1] * Y[2] + .99 * Y[2]
     DY[2]/DX = -1000 * ( -Y[1] + Y[1] * Y[2] + Y[2] )
     WITH THE INITIAL CONDITIONS AT X = 0:
     Y[1] = 1 AND Y[2] = 0.
     THE SOLUTION AT X = 50 IS APPROXIMATELY:
     Y[1] = .765 878 320 2487  AND  Y[2] = .433 710 353  5768.
     THE FOLLOWING  PROGRAM  SHOWS  INTEGRATION  OF  THIS  PROBLEM  WITH
     VARIABLE AND CONSTANT STEPSIZES:
 
 "BEGIN" "COMMENT" TEST LINIGER1VS;
     "INTEGER" ITMAX;
     "REAL" X,SIGMA,RETA,TIME;
     "REAL" "ARRAY" Y[1:2],J[1:2,1:2],INFO[1:9];
     "PROCEDURE" F(A); "ARRAY" A;
     "BEGIN" "REAL" A1,A2; A1:=A[1]; A2:=A[2];
         A[1]:=(A1+.99)*(A2-1)+.99;
         A[2]:=1000*((1+A1)*(1-A2)-1);
     "END";
     "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
     "BEGIN" J[1,1]:=Y[2]-1; J[1,2]:=.99+Y[1];
         J[2,1]:=1000*(1-Y[2]); J[2,2]:=-1000*(1+Y[1]);
         SIGMA:=ABS(J[2,2]+J[1,1]-SQRT((J[2,2]-J[1,1])**2+
               4*J[2,1]*J[1,2]))/2;
     "END" JACOBIAN;
     "PROCEDURE" OUT;
     "IF" X=50 "THEN"
     OUTPUT(61,"("6(3ZDB),2BD"-ZD,2(2B+.3DB3D),-3ZD.3D,/")",
     INFO[1],INFO[2],INFO[3],INFO[4],INFO[5],INFO[6],INFO[9],Y[1],
     Y[2],CLOCK-TIME);
     "FOR" RETA:="-2,"-4,"-6 "DO"
     "BEGIN" X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
         LINIGER1VS(X,50.0,2,Y,SIGMA,F,J,JACOBIAN,10,.1,50.0,RETA,
             RETA,INFO,OUT);
     "END";  OUTPUT(61,"("//")");
     "FOR" RETA:=-"-2,-"-4,-"-6 "DO"
     "BEGIN" X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
         LINIGER1VS(X,50.0,2,Y,SIGMA,F,J,JACOBIAN,10,.1,1.0,RETA,
             RETA,INFO,OUT);
     "END";
 "END"
   17   21    8    2    0    2   2" -2  +.772 017  +.435 672    0.525
   13   25   23    2    0    2   2" -2  +.767 414  +.434 202    0.717
  105  210  105    2    0    2   2" -2  +.766 027  +.433 758    4.741
 
 
   50   52    1    0   50    2   0"  0  +.766 670  +.433 081    0.549
   50  104    3    0   50    3   0"  0  +.766 183  +.433 811    1.158
   50  152   12    0   50    4   0"  0  +.766 185  +.433 809    1.653
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 5
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 33132;
 "PROCEDURE" LINIGER1VS(X,XE,M,Y,SIGMA,DERIVATIVE,J,
    JACOBIAN,ITMAX,HMIN,HMAX,AETA,RETA,INFO,OUTPUT);
 "VALUE" M;
 "INTEGER" M,ITMAX;
 "REAL" X,XE,SIGMA,AETA,RETA,HMIN,HMAX;
 "ARRAY" Y,J,INFO;
 "PROCEDURE" DERIVATIVE,JACOBIAN,OUTPUT;
 
 "BEGIN" "INTEGER" I,ST,LASTJAC;
     "REAL" H,HNEW,MU,MU1,BETA,P,E,E1,ETA,ETA1,DISCR;
     "BOOLEAN" LAST,FIRST,EVALJAC,EVALCOEF;
     "INTEGER" "ARRAY" PI[1:M];
     "REAL" "ARRAY" DY,YL,YR,F[1:M],A[1:M,1:M],AUX[1:3];
 
     "REAL" "PROCEDURE" NORM(A); "ARRAY" A;
     NORM:=SQRT(VECVEC(1,M,0,A,A));
 
     "PROCEDURE" COEFFICIENT;
     "BEGIN" "REAL" B,E; B:=ABS(H*SIGMA);
         "IF" B>40 "THEN"
         "BEGIN" MU:=1/B; BETA:=1; P:=2+2/(B-2)
         "END" "ELSE"
         "IF" B<.04 "THEN"
         "BEGIN" E:=B*B/30; P:=3-E;
             MU:=.5-B/12*(1-E/2);
             BETA:=.5+B/6*(1-E)
         "END" "ELSE"
         "BEGIN" E:=EXP(B)-1;
             MU:=1/B-1/E;
             BETA:=(1-B/E)*(1+1/E);
             P:=(BETA-MU)/(.5-MU)
         "END";
         MU1:=H*(1-MU);
         LUDECOMP
     "END" COEFFICIENT;                                        "COMMENT"
 
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 6
                                                                  ;
 
 
     "PROCEDURE" LUDECOMP;
     "BEGIN" "INTEGER" I;
         "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" MULROW(1,M,I,I,A,J,-MU1);
             A[I,I]:=A[I,I]+1
         "END";
         AUX[2]:=0; DEC(A,M,AUX,PI)
     "END" LUDECOMP;
 
     "PROCEDURE" STEPSIZE;
     "IF" ETA<0 "THEN"
     "BEGIN" "REAL" HL; HL:=H;
         H:=HNEW:=HMAX; INFO[5]:=INFO[5]+1;
         "IF" 1.1*HNEW>XE-X "THEN"
         "BEGIN" LAST:="TRUE"; H:=HNEW:=XE-X
         "END";
         EVALCOEF:=H^=HL;
     "END" "ELSE"
     "IF" FIRST "THEN"
     "BEGIN" H:=HNEW:=HMIN; FIRST:="FALSE"; INFO[4]:=INFO[4]+1
     "END" "ELSE"
     "BEGIN" "REAL" B,HL;
         B:=DISCR/ETA; HL:=H; "IF" B<.01 "THEN" B:=.01;
         HNEW:= "IF" B>0 "THEN" H*B**(-1/P) "ELSE" HMAX;
         "IF" HNEW<HMIN "THEN"
         "BEGIN" HNEW:=HMIN; INFO[4]:=INFO[4]+1
         "END" "ELSE"
         "IF" HNEW>HMAX "THEN"
         "BEGIN" HNEW:=HMAX; INFO[5]:=INFO[5]+1 "END";
         "IF" 1.1*HNEW>=XE-X "THEN"
         "BEGIN" LAST:="TRUE"; H:=HNEW:=XE-X
         "END" "ELSE"
         "IF" ABS(H/HNEW-1)>.1 "THEN" H:=HNEW;
         EVALCOEF:=H^=HL
     "END" STEPSIZE;
 
     "PROCEDURE" LINEARITY(ERROR); "REAL" ERROR;
     "BEGIN" "INTEGER" K;
         "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
         DY[K]:=Y[K]-MU1*F[K];
         SOL(A,M,PI,DY);
         ELMVEC(1,M,0,DY,Y,-1);
         ERROR:=NORM(DY)
     "END" LINEARITY;                                          "COMMENT"
 
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 7
                                                                  ;
 
 
     "PROCEDURE" ITERATION(I); "INTEGER" I;
     "IF" RETA<0 "THEN"
     "BEGIN" "INTEGER" K;
         "IF" I=1 "THEN"
         "BEGIN" MULVEC(1,M,0,DY,F,H);
             "FOR" K:=1 "STEP" 1 "UNTIL" M "DO" YL[K]:=Y[K]+MU*DY[K];
             SOL(A,M,PI,DY); E:=1;
         "END" "ELSE"
         "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
             DY[K]:=YL[K]-Y[K]+MU1*F[K];
             "IF" E*NORM(Y)>E1*E1 "THEN"
             "BEGIN" EVALJAC:=I>=3;
                 "IF" I>3 "THEN"
                 "BEGIN" INFO[3]:=INFO[3]+1; JACOBIAN(J,Y);
                     LUDECOMP
                 "END";
             "END";
             SOL(A,M,PI,DY)
         "END";
         E1:=E; E:=NORM(DY);
         ELMVEC(1,M,0,Y,DY,1);
         ETA:=NORM(Y)*RETA+AETA;
         DISCR:=0;
         DUPVEC(1,M,0,F,Y);
         DERIVATIVE(F);
         INFO[2]:=INFO[2]+1;
     "END" "ELSE"
     "BEGIN" "INTEGER" K;
         "IF" I=1 "THEN"
         "BEGIN" LINEARITY(E);
             "IF" E*(ST-LASTJAC)>ETA "THEN"
             "BEGIN" JACOBIAN(J,Y); LASTJAC:=ST;
                 INFO[3]:=INFO[3]+1;
                 H:=HNEW; COEFFICIENT;
                 LINEARITY(E)
             "END";
             EVALJAC:= E*(ST+1-LASTJAC)>ETA;
             MULVEC(1,M,0,DY,F,H);
             "FOR" K:=1 "STEP" 1 "UNTIL" M "DO" YL[K]:=Y[K]+MU*DY[K];
             SOL(A,M,PI,DY);
             "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
             YR[K]:=H*BETA*MATVEC(1,M,K,J,DY);
             SOL(A,M,PI,YR);
             ELMVEC(1,M,0,YR,DY,1);                            "COMMENT"
1SECTION : 5.2.1.1.1.2.C      (OCTOBER 1974)                      PAGE 8
                                                                  ;
 
 
         "END" "ELSE"
         "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
             DY[K]:=YL[K]-Y[K]+MU1*F[K];
             "IF" E>ETA1 "AND" DISCR>ETA1 "THEN"
             "BEGIN" INFO[3]:=INFO[3]+1; JACOBIAN(J,Y);
                 LUDECOMP
             "END";
             SOL(A,M,PI,DY);
             E:=NORM(DY)
         "END";
         ELMVEC(1,M,0,Y,DY,1);
         ETA:=NORM(Y)*RETA+AETA;
         ETA1:=ETA/SQRT(RETA);
         DUPVEC(1,M,0,F,Y);
         DERIVATIVE(F);
         INFO[2]:=INFO[2]+1;
         "FOR" K:=1 "STEP" 1 "UNTIL" M "DO" DY[K]:=YR[K]-H*F[K];
         DISCR:=NORM(DY)/2
     "END" ITERATION;
 
     FIRST:=EVALJAC:="TRUE"; LAST:=EVALCOEF:="FALSE";
     INIVEC(1,9,INFO,0);
     ETA:=RETA*NORM(Y)+AETA;
     ETA1:=ETA/SQRT(ABS(RETA));
     DUPVEC(1,M,0,F,Y);
     DERIVATIVE(F);
     INFO[2]:=1;
     "FOR" ST:=1,ST+1 "WHILE" ^LAST "DO"
     "BEGIN" STEPSIZE; INFO[1]:=INFO[1]+1;
         "IF" EVALJAC "THEN"
         "BEGIN" JACOBIAN(J,Y);
             INFO[3]:=INFO[3]+1;
             H:=HNEW;
             COEFFICIENT;
             EVALJAC:="FALSE"; LASTJAC:=ST
         "END" "ELSE"
         "IF" EVALCOEF "THEN" COEFFICIENT;
         "FOR" I:=1,I+1 "WHILE" E>ABS(ETA) "AND" DISCR>1.3*ETA
         "AND" I<=ITMAX "DO"
         "BEGIN" ITERATION(I); "IF" I>INFO[6] "THEN" INFO[6]:=I;
         "END"; INFO[7]:=ETA; INFO[8]:=DISCR;
         X:=X+H;
         "IF" DISCR>INFO[9] "THEN" INFO[9]:=DISCR;
         OUTPUT;
     "END";
 "END" LINIGER1VS;
         "EOP"
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 1
 
 
 
 AUTHOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 1973/07/16.
 
 
 BRIEF DESCRIPTION:
 
     LINIGER2  SOLVES  INITIAL VALUE  PROBLEMS , GIVEN AS  AN AUTONOMOUS
     SYSTEM  OF  FIRST  ORDER  DIFFERENTIAL  EQUATIONS , BY MEANS  OF AN
     EXPONENTIALLY FITTED ONESTEP METHOD.
     NO AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION  OF STIFF
     DIFFERENTIAL EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEMS,
     STIFF EQUATIONS,
     EXPONENTIAL FITTING,
     IMPLICIT ONESTEP METHODS.
 
 
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 2
 
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE LINIGER2 READS:
     "PROCEDURE" LINIGER2(X,XE,M,Y,SIGMA1,SIGMA2,F,EVALUATE,J,
                    JACOBIAN,K,ITMAX,STEP,AETA,RETA,OUTPUT);
     "INTEGER" M,K,ITMAX;
     "REAL" X,XE,SIGMA1,SIGMA2,STEP,AETA,RETA;
     "ARRAY" Y,J;
     "BOOLEAN" "PROCEDURE" EVALUATE;
     "REAL" "PROCEDURE" F;
     "PROCEDURE" JACOBIAN,OUTPUT;
     "CODE" 33131;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X;
             CAN BE USED IN F, JACOBIAN, OUTPUT, ETC.;
             ENTRY: THE INITIAL VALUE X0;
             EXIT : THE FINAL VALUE XE;
     XE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF X (XE>=X);
     M:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE  INITIAL  VALUES  OF  THE SYSTEM OF DIFFERENTIAL
                    EQUATIONS: Y[I] AT X=X0;
             EXIT : THE FINAL VALUES OF THE SOLUTION: Y[I] AT X=XE;
     SIGMA1: <ARITHMETIC EXPRESSION>;
             THE  MODULUS  OF  THE POINT AT WHICH EXPONENTIAL FITTING IS
             DESIRED;  THIS  POINT  MAY BE COMPLEX OR REAL AND NEGATIVE;
     SIGMA2: <ARITHMETIC EXPRESSION>;
             SIGMA2  MAY DEFINE  THREE  DIFFERENT TYPES  OF  EXPONENTIAL
             FITTING: FITTING IN TWO COMPLEX CONJUGATED POINTS , FITTING
             IN  TWO  REAL  NEGATIVE  POINTS , OR  FITTING  IN ONE POINT
             COMBINED WITH THIRD ORDER ACCURACY;
             IF THIRD ORDER ACCURACY IS DESIRED , SIGMA2 SHOULD HAVE THE
             VALUE 0;
             IF FITTING  IN A SECOND NEGATIVE POINT  IS DESIRED , SIGMA2
             SHOULD HAVE THE VALUE OF THE MODULUS OF THIS POINT;
             IF FITTING IN  TWO COMPLEX CONJUGATED  POINTS  IS DESIRED ,
             THEN  SIGMA2 SHOULD BE  MINUS THE VALUE  OF THE ARGUMENT OF
             THE POINT IN THE SECOND QUADRANT (THUS A VALUE BETWEEN - PI
             AND - PI/2);
     F:      <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "REAL" "PROCEDURE" F(I); "INTEGER" I;
             THIS  PROCEDURE  SHOULD  DELIVER THE RIGHT HAND SIDE OF THE
             I-TH DIFFERENTIAL EQUATION AS F;
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 3
 
 
 
     EVALUATE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "BOOLEAN" "PROCEDURE" EVALUATE(ITNUM); "INTEGER" ITNUM;
             EVALUATE  SHOULD  HAVE  THE  VALUE "TRUE", IF IT IS DESIRED
             THAT  THE JACOBIAN OF THE SYSTEM IS UPDATED IN THE ITNUM-TH
             ITERATION STEP OF THE NEWTON PROCESS;
      J:     <ARRAY IDENTIFIER>;
             "ARRAY" J[1:M,1:M];
             THE JACOBIAN MATRIX OF THE SYSTEM;
             THE ARRAY J SHOULD BE UPDATED IN THE PROCEDURE JACOBIAN;
     JACOBIAN: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
             IN THIS PROCEDURE  THE JACOBIAN  HAS TO BE ASSIGNED  TO THE
             THE ARRAY J , OR AN APPROXIMATION OF THE JACOBIAN , IF ONLY
             SECOND ORDER ACCURACY IS REQUIRED;
     K:      <VARIABLE>;
             COUNTS THE NUMBER OF INTEGRATION STEPS TAKEN;
             FOR EXAMPLE, CAN BE USED IN EVALUATE;
     ITMAX:  <ARITHMETIC EXPRESSION>;
             AN  UPPERBOUND  FOR  THE NUMBER  OF ITERATIONS  IN NEWTON'S
             PROCESS, USED TO SOLVE THE IMPLICIT EQUATIONS;
     STEP:   <ARITHMETIC EXPRESSION>;
             THE LENGTH OF THE INTEGRATION STEP, TO BE PRESCRIBED BY THE
             THE USER;
     AETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED ABSOLUTE PRECISION  IN THE NEWTON PROCESS, USED TO
             SOLVE THE IMPLICIT EQUATIONS;
     RETA:   <ARITHMETIC EXPRESSION>;
             REQUIRED RELATIVE PRECISION  IN THE NEWTON PROCESS, USED TO
             SOLVE THE IMPLICIT EQUATIONS;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS;
             "PROCEDURE" OUTPUT;
             THIS  PROCEDURE  IS  CALLED  AT THE END OF EACH INTEGRATION
             STEP ; THE USER CAN ASK FOR OUTPUT  OF THE PARAMETERS , FOR
             EXAMPLE X, K, Y.
 
 
 DATA AND RESULTS: SEE EXAMPLE OF USE, AND REF[3].
 
 
 PROCEDURES USED:
 
     VECVEC= CP34010,
     MATVEC= CP34011,
     MATMAT= CP34013,
     DEC   = CP34300,
     SOL   = CP34051.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA 20 + M * (4+M).
 
 
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 4
 
 
 
 RUNNING TIME: DEPENDS  STRONGLY  ON THE DIFFERENTIAL EQUATION TO SOLVE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     LINIGER2: INTEGRATES  THE  SYSTEM OF DIFFERENTIAL EQUATIONS FROM X0
               UNTIL XE, BY MEANS OF A SECOND ORDER FORMULA (IF SIGMA2=0
               AND EVALUATE="TRUE" EVEN THIRD ORDER).
     SEE ALSO REF[1] AND REF[2].
 
 REFERENCES:
 
     [1]. W.LINIGER AND R.A.WILLOUGHBY.
          EFFICIENT  INTEGRATION  METHODS  FOR STIFF SYSTEMS OF ORDINARY
          DIFFERENTIAL EQUATIONS.
          SIAM J. NUM. ANAL. 7 (1970) PAGE 47.
 
     [2]. T.J.DEKKER, P.W.HEMKER AND P.W.VAN DER HOUWEN.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 1 (DUTCH).
          MC SYLLABUS 15.1, (1972) MATHEMATICAL CENTRE.
 
     [3]. P.A.BEENTJES, K.DEKKER, H.C.HEMKER, S.P.N.VAN KAMPEN AND
          G.M.WILLEMS.
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 2 (DUTCH).
          MC SYLLABUS 15.2, (1973) MATHEMATICAL CENTRE.
 
 
 EXAMPLE OF USE:
 
     CONSIDER THE SYSTEM OF DIFFERENTIAL EQUATIONS:
     DY[1]/DX = -Y[1] + Y[1] * Y[2] + .99 * Y[2]
     DY[2]/DX = -1000 * ( -Y[1] + Y[1] * Y[2] + Y[2] )
     WITH THE INITIAL CONDITIONS AT X = 0:
     Y[1] = 1 AND Y[2] = 0. (SEE REF[2], PAGE 11).
     THE SOLUTION AT X = 50 IS APPROXIMATELY:
     Y[1] = .765 878 320 2487  AND  Y[2] = .433 710 353  5768.
     THE FOLLOWING PROGRAM  SHOWS SOME DIFFERENT CALLS OF  THE PROCEDURE
     LINIGER2, AND ILLUSTRATES THE ACCURACY WHICH MAY BE OBTAINED BY IT:
 
     "BEGIN"
 
         "INTEGER" K,ITMAX,PASSES,PASJAC;
         "REAL" X,SIGMA,STEP,TIME;
         "REAL" "ARRAY" Y[1:2],J[1:2,1:2];
 
         "REAL" "PROCEDURE" F(I); "INTEGER" I;
         "IF" I=1 "THEN" F:=(Y[1]+.99)*(Y[2]-1)+.99 "ELSE"
         "BEGIN" PASSES:=PASSES+1; F:=1000*((1+Y[1])*(1-Y[2])-1) "END";
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 5
 
 
 
         "PROCEDURE" JACOBIAN(J,Y); "ARRAY" J,Y;
         "BEGIN" J[1,1]:=Y[2]-1; J[1,2]:=.99+Y[1];
             J[2,1]:=1000*(1-Y[2]); J[2,2]:=-1000*(1+Y[1]);
             SIGMA:=ABS(J[2,2]+J[1,1]-SQRT((J[2,2]-J[1,1])**2+
                    4*J[2,1]*J[1,2]))/2;
             PASJAC:=PASJAC+1
         "END" JACOBIAN;
         "BOOLEAN" "PROCEDURE" EVALUATE1(I); "INTEGER" I;
         EVALUATE1:= I=1;
         "BOOLEAN" "PROCEDURE" EVALUATE2(I); "INTEGER" I;
         EVALUATE2:= "TRUE";
         "PROCEDURE" OUT;
         "IF" X=50 "THEN"
         OUTPUT(61,"("3(-4ZDB),2(4B+.3DB3DB3D),-5ZD.3D,/")",K,PASSES,
         PASJAC,Y[1],Y[2],CLOCK-TIME);
         OUTPUT(61,"(""("    THIS LINE AND THE FOLLOWING TEXT IS ")"
         "("PRINTED BY THIS PROGRAM")",//,
         "("    THE RESULTS WITH LINIGER2 -SECOND ORDER- ARE:")",/,
         "("     K   DER.EV. JAC.EV.       Y[1]             Y[2]")"
         "("         TIME")",/")");
         "FOR" STEP:=10,1 "DO"
         "FOR" ITMAX:=1,3 "DO"
         "BEGIN" PASSES:=PASJAC:=0; X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
         LINIGER2(X,50.0,2,Y,SIGMA,0.0,F,EVALUATE1,J,JACOBIAN,K,ITMAX,
                                                    STEP,"-4,"-4,OUT);
         "END";
         OUTPUT(61,"("//,
         "("    THE RESULTS WITH LINIGER2 -THIRD ORDER- ARE:")",/,
         "("     K   DER.EV. JAC.EV.       Y[1]             Y[2]")"
         "("         TIME")",/")");
         "FOR" STEP:=10,1 "DO"
         "FOR" ITMAX:=1,3 "DO"
         "BEGIN" PASSES:=PASJAC:=0; X:=Y[2]:=0; Y[1]:=1; TIME:=CLOCK;
         LINIGER2(X,50.0,2,Y,SIGMA,0.0,F,EVALUATE2,J,JACOBIAN,K,ITMAX,
                                                    STEP,"-4,"-4,OUT);
         "END";
     "END"
 
     THIS LINE AND THE FOLLOWING TEXT IS PRINTED BY THIS PROGRAM:
 
     THE RESULTS WITH LINIGER2 -SECOND ORDER- ARE:
      K   DER.EV. JAC.EV.       Y[1]             Y[2]         TIME
      5      5      5     +.766 392 210    +.434 218 863      0.092
      5     15      5     +.765 755 853    +.433 671 223      0.175
     50     50     50     +.765 884 310    +.433 715 687      0.949
     50    101     50     +.765 877 388    +.433 710 059      1.494
 
 
     THE RESULTS WITH LINIGER2 -THIRD ORDER- ARE:
      K   DER.EV. JAC.EV.       Y[1]             Y[2]         TIME
      5      5      5     +.766 392 210    +.434 218 863      0.092
      5     15     15     +.765 882 250    +.433 711 614      0.300
     50     50     50     +.765 884 310    +.433 715 687      0.949
     50    101    101     +.765 878 873    +.433 710 531      2.080
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 6
 
 
 
 SOURCE TEXT(S):
 
0"CODE" 33131;
 "PROCEDURE" LINIGER2(X,XE,M,Y,SIGMA1,SIGMA2,F,EVALUATE,J,
                JACOBIAN,K,ITMAX,STEP,AETA,RETA,OUTPUT);
 "INTEGER" M,K,ITMAX;
 "REAL" X,XE,SIGMA1,SIGMA2,STEP,AETA,RETA;
 "ARRAY" Y,J;
 "BOOLEAN" "PROCEDURE" EVALUATE;
 "REAL" "PROCEDURE" F;
 "PROCEDURE" JACOBIAN,OUTPUT;
 
 "BEGIN" "INTEGER" I;
     "REAL" H,HL,B1,B2,P,Q,C0,C1,C2,C3,C4;
     "BOOLEAN" LAST;
     "INTEGER" "ARRAY" PI[1:M];
     "REAL" "ARRAY" DY,YL,FL[1:M],A[1:M,1:M],AUX[1:3];
 
     "PROCEDURE" STEPSIZE;
     "BEGIN" H:=STEP;
         "IF" 1.1*H>=XE-X "THEN"
         "BEGIN" LAST:="TRUE"; H:=XE-X; X:=XE
         "END" "ELSE" X:=X+H
     "END" STEPSIZE;
 
     "PROCEDURE" COEFFICIENT;
     "BEGIN" "REAL" R1,R2,EX,ZETA,ETA,SINL,COSL,SINH,COSH,D;
         "REAL" "PROCEDURE" R(X); "VALUE" X; "REAL" X;
         "IF" X>40 "THEN" R:=X/(X-2) "ELSE"
         "BEGIN" EX:=EXP(-X); R:=X*(1-EX)/(X-2+(X+2)*EX) "END";
 
         B1:=H*SIGMA1;
         B2:=H*SIGMA2;
         "IF" B1<.1 "THEN" "BEGIN" P:=0; Q:=1/3; "GOTO" OUT "END";
         "IF" B2<0 "THEN" "GOTO" COMPLEX;
         "IF" B1<1 "OR" B2<.1 "THEN" "GOTO" THIRDORDER;
         "IF" ABS(B1-B2)<B1*B1*"-6 "THEN" "GOTO" DOUBLEFIT;
 
         R1:=R(B1)*B1; R2:=R(B2)*B2;
         D:=B2*R1-B1*R2;
         P:=2*(R2-R1)/D;
         Q:=2*(B2-B1)/D;
         "GOTO" OUT;                                           "COMMENT"
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
 THIRDORDER: Q:=1/3;
         P:=R(B1)/3-2/B1;
         "GOTO" OUT;
 DOUBLEFIT: B1:=.5*(B1+B2);
         R1:=R(B1);
         "IF" B1>40 "THEN" EX:=0;
         R2:=B1/(1-EX); R2:=1-EX*R2*R2;
         Q:=1/(R1*R1*R2);
         P:=R1*Q-2/B1;
         "GOTO" OUT;
 COMPLEX: ETA:=ABS(B1*SIN(SIGMA2));
         ZETA:=ABS(B1*COS(SIGMA2));
         "IF" ETA<B1*B1*"-6 "THEN"
         "BEGIN" B1:=B2:=ZETA; "GOTO" DOUBLEFIT "END";
         "IF" ZETA>40 "THEN"
         "BEGIN" P:=1-4*ZETA/B1/B1; Q:=4*(1-ZETA)/B1/B1+1 "END" "ELSE"
         "BEGIN" EX:=EXP(ZETA);
             SINL:=SIN(ETA); COSL:=COS(ETA);
             SINH:=.5*(EX-1/EX); COSH:=.5*(EX+1/EX);
             D:=ETA*(COSH-COSL)-.5*B1*B1*SINL;
             P:=(ZETA*SINL+ETA*SINH-4*ZETA*ETA/B1/B1*(COSH-COSL))/D;
             Q:=ETA*((COSH-COSL-ZETA*SINH-ETA*SINL)*4/B1/B1+COSH+COSL)/D
         "END";
 OUT:    C0:=.25*H*H*(P+Q);
         C1:=.5*H*(1+P);
         C2:=H-C1;
         C3:=.25*H*H*(Q-P);
         C4:=.5*H*P;
         ELEMENTS OF MATRIX
     "END" COEFFICIENT;
 
     "PROCEDURE" ELEMENTS OF MATRIX;
     "BEGIN" "INTEGER" K;
         "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
             A[I,K]:=C0*MATMAT(1,M,I,K,J,J)-C1*J[I,K];
             A[I,I]:=A[I,I]+1
         "END";
         AUX[2]:=0; DEC(A,M,AUX,PI)
     "END" ELOFMAT;                                            "COMMENT"
1SECTION : 5.2.1.1.1.2.D      (AUGUST 1974)                       PAGE 8
                                                                  ;
 
 
     "PROCEDURE" NEWTON ITERATION;
     "BEGIN" "INTEGER" ITNUM; "REAL" JFL,ETA,DISCR;
         ITNUM:=0;
 NEXT:   ITNUM:=ITNUM+1;
         "IF" EVALUATE(ITNUM) "THEN"
         "BEGIN" JACOBIAN(J,Y); COEFFICIENT "END"
         "ELSE" "IF" ITNUM=1 "AND" H^=HL "THEN" COEFFICIENT;
         "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" FL[I]:=F(I);
         "IF" ITNUM=1 "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" JFL:=MATVEC(1,M,I,J,FL);
                 DY[I]:=H*(FL[I]-C4*JFL);
                 YL[I]:=Y[I]+C2*FL[I]+C3*JFL
             "END"
         "END" "ELSE"
         "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
         DY[I]:=YL[I]-Y[I]+C1*FL[I]-C0*MATVEC(1,M,I,J,FL);
         SOL(A,M,PI,DY);
         "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" Y[I]:=Y[I]+DY[I];
         "IF" ITNUM<ITMAX "THEN"
         "BEGIN" ETA:=SQRT(VECVEC(1,M,0,Y,Y))*RETA+AETA;
             DISCR:=SQRT(VECVEC(1,M,0,DY,DY));
             "IF" ETA<DISCR "THEN" "GOTO" NEXT
         "END"
     "END" NEWTON;
 
     LAST:="FALSE"; K:=0; HL:=0;
 NEXT LEVEL:
     K:=K+1;
     STEPSIZE;
     NEWTON ITERATION;
     HL:=H;
     OUTPUT;
     "IF" "NOT" LAST "THEN" "GOTO" NEXT LEVEL
 "END" LINIGER2;
         "EOP"
1SECTION : 5.2.1.1.1.2.E      (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR: J.G. VERWER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740809.
 
 
 BRIEF DESCRIPTION:
 
     GMS SOLVES AN INITIAL VALUE PROBLEM, GIVEN AS AN AUTONOMOUS
     SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS DY/DX = F(Y), BY
     MEANS OF A THIRD ORDER GENERALIZED LINEAR MULTISTEP METHOD;
     IN PARTICULAR THIS PROCEDURE IS SUITABLE FOR THE INTEGRATION
     OF STIFF EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEM,
     AUTONOMOUS SYSTEM,
     STIFF EQUATIONS,
     GENERALIZED LINEAR MULTISTEP METHOD.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" GMS(X, XE, R, Y, H, HMIN, HMAX, DELTA, DERIVATIVE,
                     JACOBIAN, AETA, RETA, N, JEV, LU, NSJEV,
                     LINEAR, OUT);
     "VALUE" R;
     "REAL" X, XE, H, HMIN, HMAX, DELTA, AETA, RETA;
     "INTEGER" R, N, JEV, NSJEV, LU;
     "BOOLEAN" LINEAR;
     "ARRAY" Y;
     "PROCEDURE" DERIVATIVE, JACOBIAN, OUT;
     "CODE" 33191;
 
     GMS INTEGRATES THE SYSTEM OF DIFFERENTIAL EQUATIONS DY/DX = F(Y)
     FROM X = X0 TO X = XE;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X:      <VARIABLE>;
             THE INDEPENDENT VARIABLE X;
             ENTRY: THE INITIAL VALUE OF X;
             EXIT : THE END VALUE OF X;
     XE:     <ARITHMETIC EXPRESSION>;
             ENTRY: THE END VALUE OF X;
     R:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE NUMBER OF DIFFERENTIAL EQUATIONS;
1SECTION : 5.2.1.1.1.2.E      (MARCH 1977)                        PAGE 2
 
 
 
     Y:      <ARRAY IDENTIFIER>;
             "ARRAY" Y[1:R];
             THE DEPENDENT VARIABLE;
             ENTRY: THE INITIAL VALUE OF Y;
             EXIT : THE SOLUTION Y AT THE POINT X AFTER EACH
                    INTEGRATION STEP;
     H:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE STEPLENGTH WHEN THE INTEGRATION HAS TO BE
                    PERFORMED WITHOUT THE STEPSIZE MECHANISM, OTHER-
                    WISE THE INITIAL STEPLENGTH (SEE THE PARAMETERS
                    HMIN AND HMAX);
     HMIN, HMAX: <ARITHMETIC EXPRESSION>;
             ENTRY: MINIMAL AND MAXIMAL STEPLENGTH BY WHICH THE INTE-
                    GRATION IS ALLOWED TO BE PERFORMED;
             BY PUTTING HMIN = HMAX THE STEPSIZE MECHANISM IS
             ELIMINATED; IN THIS CASE THE GIVEN VALUES FOR HMIN AND
             HMAX ARE IRRELEVANT, WHILE THE INTEGRATION IS PERFORMED
             WITH THE STEPLENGTH GIVEN BY H;
     DELTA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE REAL PART OF THE POINT AT WHICH EXPONENTIAL
                    FITTING IS DESIRED;
                    (SEE METHOD AND PERFORMANCE);
             ALTERNATIVES:
             DELTA = (AN ESTIMATE OF) THE REAL PART OF THE LARGEST
             EIGENVALUE IN MODULUS OF THE JACOBIAN MATRIX OF THE
             SYSTEM;
             DELTA <= -10**15, IN ORDER TO OBTAIN ASYMPTOTIC STABILITY;
             DELTA = 0, IN ORDER TO OBTAIN A HIGHER ORDER OF ACCURACY
             IN CASE OF LINEAR EQUATIONS;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             "PROCEDURE" DERIVATIVE(Y); "ARRAY" Y;
             <REPLACEMENT OF THE I-TH COMPONENT OF THE SOLUTION Y BY
             THE I-TH COMPONENT OF THE DERIVATIVE F(Y), I = 1,..., R>;
     JACOBIAN: <PROCEDURE IDENTIFIER>;
             "PROCEDURE" JACOBIAN(J, Y); "ARRAY" J, Y;
             WHEN IN GMS JACOBIAN IS CALLED THE ARRAY Y CONTAINS
             THE VALUES OF THE DEPENDENT VARIABLE;
             UPON COMPLETION OF A CALL OF JACOBIAN THE ARRAY J SHOULD
             CONTAIN THE VALUES OF THE JACOBIAN MATRIX OF F(Y);
     AETA, RETA: <ARITHMETIC EXPRESSION>;
             ENTRY: MEASURE OF THE ABSOLUTE AND RELATIVE LOCAL
                    ACCURACY REQUIRED;
             THESE VALUES ARE IRRELEVANT WHEN THE INTEGRATION IS PER-
             FORMED WITHOUT THE STEPSIZE MECHANISM;
     N:      <VARIABLE>;
             EXIT : THE NUMBER OF INTEGRATION STEPS;
     JEV:    <VARIABLE>;
             EXIT: THE NUMBER OF JACOBIAN EVALUATIONS;
     LU:     <VARIABLE>;
             EXIT: THE NUMBER OF LU-DECOMPOSITIONS;
1SECTION : 5.2.1.1.1.2.E      (OCTOBER 1974)                      PAGE 3
 
 
 
     NSJEV:  <VARIABLE>;
             ENTRY: NUMBER OF INTEGRATION STEPS PER
                    JACOBIAN EVALUATION;
             THE VALUE OF NSJEV IS RELEVANT ONLY WHEN THE INTEGRATION
             IS PERFORMED WITHOUT THE STEPSIZE MECHANISM AND THE
             SYSTEM TO BE SOLVED IS NON-LINEAR;
     LINEAR: <BOOLEAN EXPRESSION>;
             ENTRY: TRUE WHEN THE SYSTEM TO BE INTEGRATED IS LINEAR,
                    OTHERWISE FALSE;
             IF LINEAR IS TRUE THE STEPSIZE MECHANISM IS AUTOMATICALLY
             ELIMINATED;
     OUT:    <PROCEDURE IDENTIFIER>;
             "PROCEDURE" OUT;
             <BY MEANS OF OUT ONE MAY PRINT THE VALUES OF THE RELEVANT
             PARAMETERS OCCURRING IN THE PARAMETERLIST; OUT IS CALLED
             AFTER EACH INTEGRATION STEP>;
 
 
 DATA AND RESULTS: SEE REF[2].
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     MATVEC = CP34011,
     MATMAT = CP34013,
     ELMROW = CP34024,
     ELMVEC = CP34020,
     DUPVEC = CP31030,
     GSSELM = CP34231,
     SOLELM = CP34061,
     COLCST = CP31131,
     MULVEC = CP31020.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: 8 * R + 3 * R * R;
 
 
 RUNNING TIME:
 
     DEPENDS STRONGLY ON THE DIFFERENTIAL EQUATION TO BE SOLVED.
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 5.2.1.1.1.2.E      (MARCH 1977)                        PAGE 4
 
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE GMS DESCRIBES AN IMPLEMENTATION OF A THIRD ORDER
     THREE-STEP GENERALIZED LINEAR MULTISTEP METHOD WITH QUASI-ZERO
     PARASITIC ROOTS AND QUASI-ADAPTIVE STABILITY FUNCTION. IN PARTI-
     CULAR THE ALGORITHM IS DEVELOPED FOR THE INTEGRATION OF STIFF
     SYSTEMS OF ORDINARY DIFFERENTIAL EQUATIONS. THE PROCEDURE SUPPLIES
     THE ADDITIONAL STARTING VALUES AND PERFORMS A STEPSIZE CONTROL
     WHICH IS BASED ON THE NON-LINEARITY OF THE DIFFERENTIAL EQUATION.
     BY THIS CONTROL THE JACOBIAN MATRIX IS INCIDENTALLY EVALUATED. IT
     IS POSSIBLE TO ELIMINATE THE STEPSIZE CONTROL. THEN, ONE HAS
     TO GIVE THE NUMBER OF INTEGRATION STEPS PER JACOBIAN EVALUATION.
     FOR LINEAR EQUATIONS THE STEPSIZE CONTROL IS AUTOMATICALLY ELIMIN-
     ATED, WHILE THE PROCEDURE PERFORMS ONE EVALUATION OF THE JACOBIAN.
     MOREOVER, IN THIS CASE THE THREE-STEP SCHEME IS REDUCED TO A ONE-
     STEP SCHEME. THE PROCEDURE USES ONE FUNCTION EVALUATION PER INTE-
     GRATION STEP AND IT DOES NOT REJECT INTEGRATION STEPS. EACH CHANGE
     IN THE STEPLENGTH OR EACH REEVALUATION OF THE JACOBIAN COSTS ONE
     LU-DECOMPOSITION. IT IS POSSIBLE TO FIT EXPONENTIALLY, THIS FIT-
     TING IS EQUIVALENT TO FITTING IN THE SENSE OF LINIGER AND
     WILLOUGHBY, ONLY WHEN THE JACOBIAN MATRIX IS EVALUATED AT EACH IN-
     TEGRATION STEP. WHEN THE SYSTEM TO BE INTEGRATED IS NON-LINEAR
     AND THE JACOBIAN MATRIX IS NOT EVALUATED AT EACH INTEGRATION STEP,
     IT IS RECOMMENDED TO FIT AT INFINITY (DELTA <= -10**15).
     DETAILS ARE GIVEN IN REFERENCE 2.
 
 
 REFERENCES:
 
     [1] HOUWEN, P. J. VAN DER AND VERWER, J. G.,
         GENERALIZED LINEAR MULTISTEP METHODS 1, DEVELOPMENT OF ALGO-
         RITHMS WITH ZERO-PARASITIC ROOTS,
         REPORT NW 10/74, MATHEMATISCH CENTRUM, AMSTERDAM 1974.
     [2] VERWER, J. G.,
         GENERALIZED LINEAR MULTISTEP METHODS 2, NUMERICAL
         APPLICATIONS, REPORT NW 12/74, MATHEMATISCH CENTRUM,
         AMSTERDAM, 1974.
 
 
 EXAMPLE OF USE:
 
     WE CONSIDER THE DIFFERENTIAL EQUATION
 
     DY1/DX = -1000 * Y1 * (Y1 + Y2 -1.999987),
     DY2/DX = -2500 * Y2 * (Y1 + Y2 - 2),
 
     ON THE INTERVAL [0,50], WITH  INITIAL VALUE  Y1(0) = Y2(0) = 1.
     THE REFERENCE SOLUTION AT X = 50 IS GIVEN BY:
     Y1(50) = .5976546988,
     Y2(50) = 1.4023434075.
 
1SECTION : 5.2.1.1.1.2.E      (MARCH 1977)                        PAGE 5
 
 
 
     "BEGIN"
         "PROCEDURE" DER(Y); "ARRAY" Y;
         "BEGIN" "REAL" Y1, Y2;
             Y1:= Y[1]; Y2:= Y[2];
             Y[1]:= -1000 * Y1 * (Y1 + Y2 - 1.999987);
             Y[2]:= -2500 * Y2 * (Y1 + Y2 - 2)
         "END" DER;
 
         "PROCEDURE" JAC(J, Y); "ARRAY" J, Y;
         "BEGIN" "REAL" Y1, Y2; Y1:= Y[1]; Y2:= Y[2];
             J[1,1]:= 1999.987 - 1000 * (2 * Y1 + Y2);
             J[1,2]:= -1000 * Y1;
             J[2,1]:= -2500 * Y2;
             J[2,2]:= 2500 * (2 - Y1 - 2 * Y2)
         "END" JAC;
 
         "PROCEDURE" OUTP;
         "IF" X = 50 "THEN"
         "BEGIN"  "REAL"  YE1, YE2;
             YE1:= .5976546988; YE2:= 1.4023434075;
             OUTPUT(61, "("
             "("X = ")", 2D2B,
             "("N = ")", 3ZD2B,
             "("JEV = ")", 3ZD2B,
             "("LU = ")", 3ZD, 2/,
             "("Y1 = ")", +.13D"+2D2B,
             "("REL. ERR. = ")", .2D"+2D, /,
             "("Y2 = ")", +.13D"+2D2B,
             "("REL. ERR. = ")", .2D"+2D")",
             X, N, JEV, LU, Y[1], ABS((Y[1] - YE1) / YE1),
             Y[2], ABS((Y[2] - YE2) / YE2))
         "END" OUTP;
 
         "INTEGER" N, JEV, LU; "REAL" X;
         "ARRAY" Y[1:2]; X:= 0.0; Y[1]:= Y[2]:= 1.0;
         GMS(X, 50.0, 2, Y, .01, .001, .5, -"15,
             DER, JAC, "-5, "-5, N, JEV,
             LU, 0, "FALSE", OUTP)
     "END"
 
     THIS PROGRAM DELIVERS:
 
     X = 50  N =  109  JEV =    3  LU =   12
 
     Y1 = +.5976547958004"+00  REL. ERR. = .16"-06
     Y2 = +.1402343310813"+01  REL. ERR. = .69"-07
1SECTION : 5.2.1.1.1.2.E      (MARCH 1977)                        PAGE 6
 
 
 
 SOURCE TEXT:
 
 "CODE" 33191;
    "PROCEDURE" GMS(X, XE, R, Y, H, HMIN, HMAX, DELTA, DERIVATIVE,
                    JACOBIAN, AETA, RETA, N, JEV, LU, NSJEV,
                    LINEAR, OUT);
    "VALUE" R;
    "REAL" X, XE, H, HMIN, HMAX, DELTA, AETA, RETA;
    "INTEGER" R, N, JEV, NSJEV, LU;
    "BOOLEAN" LINEAR;
    "ARRAY" Y;
    "PROCEDURE" DERIVATIVE, JACOBIAN, OUT;
    "BEGIN"
        "INTEGER" I, J, K, L, NSJEV1, COUNT, COUNT1, KCHANGE;
        "REAL" A, A1, ALFA, E, S1, S2, Z1, X0, XL0, XL1,
        XL2, ETA, H0, H1, Q, Q1, Q2, Q12, Q22, Q1Q2, DISCR;
        "BOOLEAN" UPDATE, CHANGE, REEVAL, STRATEGY;
        "INTEGER" "ARRAY" RI, CI[1:R];
        "ARRAY" AUX[1:9], BD1, BD2[1:3,1:3], Y1,
        Y0[1:R], HJAC, H2JAC2, RQZ[1:R,1:R], YL, FL[1:3 * R];
 
        "PROCEDURE" INITIALIZATION;
        "BEGIN" LU:= JEV:= N:= NSJEV1:= KCHANGE:= 0; X0:= X; DISCR:= 0;
            K:=1; H1:= H0:= H; COUNT:= -2; AUX[2]:= "-14; AUX[4]:= 8;
            DUPVEC(1, R, 0, YL, Y); REEVAL:= CHANGE:= "TRUE";
            STRATEGY:= HMIN ^= HMAX "AND" ^LINEAR; Q1:= -1; Q2:= -2;
            COUNT1:= 0; XL0:= XL1:= XL2:= 0
        "END" INITIALIZATION;                                  "COMMENT"
 
1SECTION : 5.2.1.1.1.2.E      (OCTOBER 1974)                      PAGE 7
                                                                  ;
 
 
        "PROCEDURE" COEFFICIENT;
        "BEGIN" XL2:= XL1; XL1:= XL0; XL0:= X0;
            "IF" CHANGE "THEN"
            "BEGIN" "IF" N > 2 "THEN"
                "BEGIN" Q1:= (XL1 - XL0) / H1;
                    Q2:= (XL2 - XL0) / H1
                "END";
                Q12:= Q1 * Q1; Q22:= Q2 * Q2; Q1Q2:= Q1 * Q2;
                A:= -(3 * ALFA + 1) / 12;
                BD1[1,3]:= 1 + (1 / 3 - (Q1 + Q2) * .5) / Q1Q2;
                BD1[2,3]:= (1 / 3 - Q2 * .5) / (Q12 - Q1Q2);
                BD1[3,3]:= (1 / 3 - Q1 * .5) / (Q22 - Q1Q2);
                BD2[1,3]:= -ALFA * .5 + A * (1 - Q1 - Q2) / Q1Q2;
                BD2[2,3]:= A * (1 - Q2) / (Q12 - Q1Q2);
                BD2[3,3]:= A * (1 - Q1) / (Q22 - Q1Q2);
                "IF" STRATEGY "OR" N <= 2 "THEN"
                "BEGIN" BD1[2,2]:= 1 / (2 * Q1);
                    BD1[1,2]:= 1 - BD1[2,2];
                    BD2[2,2]:= -(3 * ALFA + 1) / (12 * Q1);
                    BD2[1,2]:= -BD2[2,2] - ALFA * .5
                "END"
            "END"
        "END" COEFFICIENT;
 
        "PROCEDURE" OPERATOR CONSTRUCTION;
        "BEGIN" "IF" REEVAL "THEN"
            "BEGIN" JACOBIAN(HJAC, Y);
                JEV:= JEV + 1; NSJEV1:= 0;
                "IF" DELTA <= -"15 "THEN" ALFA:= 1 / 3 "ELSE"
                "BEGIN" Z1:= H1 * DELTA;
                    A:= Z1 * Z1 + 12; A1:= 6 * Z1;
                    "IF" ABS(Z1) < .1 "THEN"
                    ALFA:= (Z1 * Z1 / 140 - 1) * Z1 / 30 "ELSE"
                    "IF" Z1 < -33 "THEN"
                    ALFA:= (A + A1) / (3 * Z1 * (2 + Z1)) "ELSE"
                    "BEGIN" E:= EXP(Z1); ALFA:= ((A - A1) *
                        E - A - A1) / (((2 - Z1) * E - 2 - Z1) *
                        Z1 * 3)
                    "END"
                "END";
                S1:= -(1 + ALFA) * .5; S2:= (ALFA * 3 + 1) / 12
            "END";                                             "COMMENT"
1SECTION : 5.2.1.1.1.2.E      (OCTOBER 1974)                      PAGE 8
                                                                  ;
 
 
            A:= H1 / H0; A1:= A * A;
            "IF" REEVAL "THEN" A:= H1;
            "IF" A ^= 1 "THEN"
            "FOR" J:= 1 "STEP" 1 "UNTIL" R "DO"
            COLCST(1, R, J, HJAC, A);
            "FOR" I:= 1 "STEP" 1 "UNTIL" R "DO"
            "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" R "DO"
                "BEGIN" Q:= H2JAC2[I,J]:= "IF" REEVAL "THEN"
                    MATMAT(1, R, I, J, HJAC, HJAC)
                    "ELSE" H2JAC2[I,J] * A1;
                    RQZ[I,J]:= S2 * Q
                "END";
                RQZ[I,I]:= RQZ[I,I] + 1;
                ELMROW(1, R, I, I, RQZ, HJAC, S1)
            "END";
            GSSELM(RQZ, R, AUX, RI, CI); LU:= LU + 1;
            REEVAL:= UPDATE:= "FALSE"
        "END" OPERATOR CONSTRUCTION;
 
        "PROCEDURE" DIFFERENCE SCHEME;
        "BEGIN" "IF" COUNT ^= 1 "THEN"
            "BEGIN" DUPVEC(1, R, 0, FL, YL);
                DERIVATIVE(FL); N:= N + 1; NSJEV1:= NSJEV1 + 1
            "END";
            MULVEC(1, R, 0, Y0, YL, (1 - ALFA) / 2 - BD1[1,K]);
            "FOR" L:= 2 "STEP" 1 "UNTIL" K "DO"
            ELMVEC(1, R, R * (L - 1), Y0, YL, -BD1[L,K]);
            "FOR" L:= 1 "STEP" 1 "UNTIL" K "DO"
            ELMVEC(1, R, R * (L - 1), Y0, FL, H1 * BD2[L,K]);
            "FOR" I:= 1 "STEP" 1 "UNTIL" R "DO"
            Y[I]:= MATVEC(1, R, I, HJAC, Y0);
            MULVEC(1, R, 0, Y0, YL, (1 - 3 * ALFA) / 12 - BD2[1,K]);
            "FOR" L:= 2 "STEP" 1 "UNTIL" K "DO"
            ELMVEC(1, R, R * (L - 1), Y0, YL, -BD2[L,K]);
            "FOR" I:= 1 "STEP" 1 "UNTIL" R "DO"
            Y[I]:= Y[I] + MATVEC(1, R, I, H2JAC2, Y0);
            DUPVEC(1, R, 0, Y0, YL);
            "FOR" L:= 1 "STEP" 1 "UNTIL" K "DO"
            ELMVEC(1, R, R * (L - 1), Y0, FL, H1 * BD1[L,K]);
            ELMVEC(1, R, 0, Y, Y0, 1); SOLELM(RQZ, R, RI, CI, Y)
        "END" DIFFERENCE SCHEME;
 
        "PROCEDURE" NEXT INTEGRATION STEP;
        "BEGIN" "FOR" L:= 2, 1 "DO"
            "BEGIN" DUPVEC(L * R + 1, (L + 1) * R, -R, YL, YL);
                DUPVEC(L * R + 1, (L + 1) * R, -R, FL, FL)
            "END";
            DUPVEC(1, R, 0, YL, Y)
        "END" NEXT INTEGRATION STEP;                           "COMMENT"
 
1SECTION : 5.2.1.1.1.2.E      (OCTOBER 1974)                      PAGE 9
                                                                  ;
 
 
        "PROCEDURE" TEST ACCURACY;
        "BEGIN" K:= 2;
            DUPVEC(1, R, 0, Y1, Y); DIFFERENCE SCHEME; K:= 3;
            ETA:= AETA + RETA * SQRT(VECVEC(1, R, 0, Y1, Y1));
            ELMVEC(1, R, 0, Y, Y1, -1);
            DISCR:= SQRT(VECVEC(1, R, 0, Y, Y));
            DUPVEC(1, R, 0, Y, Y1)
        "END" TEST ACCURACY;
 
        "PROCEDURE" STEPSIZE;
        "BEGIN" X0:= X; H0:= H1;
            "IF" N <= 2 "AND" ^LINEAR "THEN" K:= K + 1;
            "IF" COUNT = 1 "THEN"
            "BEGIN" A:= ETA / (.75 * (ETA + DISCR)) + .33;
                H1:= "IF" A <= .9 "OR" A >= 1.1 "THEN" A * H0
                "ELSE" H0; COUNT:= 0;
                REEVAL:= A <= .9 "AND" NSJEV1 ^= 1;
                COUNT1:= "IF" A >= 1 "OR" REEVAL "THEN" 0 "ELSE"
                COUNT1 + 1; "IF" COUNT1 = 10 "THEN"
                "BEGIN" COUNT1:= 0; REEVAL:= "TRUE";
                    H1:= A * H0
                "END"
            "END" "ELSE"
            "BEGIN" H1:= H; REEVAL:= NSJEV = NSJEV1 "AND"
                ^STRATEGY "AND" ^LINEAR
            "END";
            "IF" STRATEGY "THEN" H1:= "IF" H1 > HMAX
            "THEN" HMAX "ELSE" "IF" H1 < HMIN "THEN" HMIN "ELSE" H1;
            X:= X + H1; "IF" X >= XE "THEN"
            "BEGIN" H1:= XE - X0; X:= XE "END";
            "IF" N <= 2 "AND" ^LINEAR "THEN" REEVAL:= "TRUE";
            "IF" H1 ^= H0 "THEN"
            "BEGIN" UPDATE:= "TRUE"; KCHANGE:= 3 "END";
            "IF" REEVAL "THEN" UPDATE:= "TRUE";
            CHANGE:= KCHANGE > 0 "AND" ^LINEAR;
            KCHANGE:= KCHANGE - 1
        "END" STEPSIZE;
 
 
        INITIALIZATION; OUT; X:= X + H1;
        OPERATOR CONSTRUCTION;
        BD1[1,1]:= 1; BD2[1,1]:= -ALFA * .5;
        "IF" ^LINEAR "THEN" COEFFICIENT;
     NEXT STEP: DIFFERENCE SCHEME;
        "IF" STRATEGY "THEN" COUNT:= COUNT + 1;
        "IF" COUNT = 1 "THEN" TEST ACCURACY;
        OUT; "IF" X >= XE "THEN" "GOTO" END;
        STEPSIZE; "IF" UPDATE "THEN" OPERATOR CONSTRUCTION;
        "IF" ^LINEAR "THEN" COEFFICIENT;
        NEXT INTEGRATION STEP; "GOTO" NEXT STEP;
     END:
    "END" GMS;
         "EOP"
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHOR: B.LINDBERG.
 
 
 CONTRIBUTOR: K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 741101.
 
 
 BRIEF DESCRIPTION:
 
     IMPEX SOLVES AN INITIAL VALUE PROBLEM,GIVEN AS AN AUTONOMOUS SYSTEM
     OF FIRST ORDER  DIFFERENTIAL  EQUATIONS , BY MEANS OF  THE IMPLICIT
     MIDPOINT RULE WITH SMOOTHING AND EXTRAPOLATION.
     AUTOMATIC STEPSIZE CONTROL IS PROVIDED.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF  STIFF
     DIFFERENTIAL EQUATIONS.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEMS,
     STIFF EQUATIONS,
     IMPLICIT MIDPOINT RULE,
     SMOOTHING,
     EXTRAPOLATION.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IMPEX READS:
     "PROCEDURE" IMPEX (N, T0, TEND, Y0, DERIV, AVAILABLE, H0, HMAX,
                       PRESCH, EPS, WEIGHTS, UPDATE, FAIL, CONTROL);
     "VALUE" N;
     "INTEGER" N;
     "REAL" T0,TEND,H0,HMAX,EPS;
     "BOOLEAN" PRESCH,FAIL;
     "ARRAY" Y0,WEIGHTS;
     "BOOLEAN" "PROCEDURE" AVAILABLE;
     "PROCEDURE" DERIV,UPDATE,CONTROL;
     "CODE" 33135;
 
     IMPEX:   INTEGRATES THE SYSTEM OF DIFFERENTIAL EQUATIONS , GIVEN AS
              DY/DT=F(T,Y), FROM T0 UNTIL TEND.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF EQUATIONS;
     T0:     <ARITHMETIC EXPRESSION>;
             THE INITIAL VALUE OF THE INDEPENDENT VARIABLE;
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 2
 
 
 
     TEND:   <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF THE INDEPENDENT VARIABLE;
     Y0:     <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" Y0[1:N];
             ENTRY: THE  INITIAL  VALUES  OF  THE SYSTEM OF DIFFERENTIAL
                    EQUATIONS: Y0[I] AT T=T0;
     DERIV:  <PROCEDURE" IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIV(T,Y,F,N);
             "INTEGER" N; "REAL" T; "ARRAY" Y,F;
             THIS PROCEDURE  SHOULD DELIVER  THE VALUE OF F(T,Y)  IN THE
             ARRAY F[1:N];
     AVAILABLE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "BOOLEAN" "PROCEDURE" AVAILABLE(T,Y,A,N);
             "INTEGER" N; "REAL" T; "ARRAY" Y,A;
             IF AN  ANALYTIC  EXPRESSION OF  THE JACOBIAN MATRIX  AT THE
             POINT (T,Y) IS NOT AVAILABLE, THIS PROCEDURE SHOULD DELIVER
             THE VALUE "FALSE";
             OTHERWISE THE  PROCEDURE  SHOULD  DELIVER THE VALUE "TRUE",
             AND THE  JACOBIAN  MATRIX  SHOULD BE ASSIGNED TO THE  ARRAY
             A[1:N,1:N];
     H0:     <ARITHMETIC EXPRESSION>;
             THE INITIAL STEPSIZE;
     HMAX:   <ARITHMETIC EXPRESSION>;
             MAXIMAL  STEPSIZE  BY WHICH  THE INTEGRATION  IS PERFORMED;
     PRESCH: <BOOLEAN EXPRESSION>;
             INDICATOR FOR CHOICE OF STEPSIZE;
             THE STEPSIZE IS AUTOMATICALLY CONTROLLED IF PRESCH="FALSE";
             OTHERWISE  THE STEPSIZE  HAS TO BE PRESCRIBED , EITHER ONLY
             INITIALLY OR ALSO BY THE PROCEDURE CONTROL;
     EPS:    <ARITHMETIC EXPRESSION>;
             BOUND FOR THE ESTIMATE OF THE LOCAL ERROR;
     WEIGHTS: <ARRAY IDENTIFIER>;
             "REAL" "ARRAY" WEIGHTS[1:N];
             WEIGHTS FOR THE COMPUTATION  OF THE WEIGHTED EUCLIDEAN NORM
             OF THE ERRORS;
             ENTRY: INITIAL WEIGHTS;
             NOTE THAT THE CHOICE  WEIGHTS[I] = 1 IMPLIES  AN ESTIMATION
             OF THE ABSOLUTE ERROR , WHEREAS WEIGTHS[I] = Y[I] DEFINES A
             RELATIVE ERROR;
     UPDATE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" UPDATE(WEIGHTS,Y2,N);
             "INTEGER" N; "ARRAY" WEIGHTS,Y2;
             THIS PROCEDURE  MAY CHANGE THE ARRAY WEIGHTS , ACCORDING TO
             THE VALUE OF AN APPROXIMATION FOR Y(T) , GIVEN IN THE ARRAY
             Y2[1:N];
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 3
 
 
 
     FAIL:   <BOOLEAN EXPRESSION>;
             EXIT :
             IF  THE PROCEDURE  FAILS TO SOLVE  THE SYSTEM OF EQUATIONS,
             FAIL WILL HAVE THE VALUE "TRUE" UPON EXIT;
             THIS MAY OCCUR  UPON DIVERGENCE  OF THE ITERATION  PROCESS,
             USED IN THE MIDPOINT RULE , WHILE INTEGRATION  IS PERFORMED
             WITH A USER DEFINED PRESCRIBED STEPSIZE;
     CONTROL: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" CONTROL(TPRINT,T,H,HNEW,Y,ERROR,N);
             "INTEGER" N; "REAL" TPRINT,T,H,HNEW; "ARRAY" Y,ERROR;
             CONTROL IS CALLED ON ENTRY OF IMPEX, AND FURTHER AS SOON AS
             THE INEQUALITY  TPRINT <= T  HOLDS;
             DURING A CALL OF CONTROL  PRINTING OF RESULTS AND
             CHANGE OF STEPSIZE (IF PRESCH = "TRUE")  IS THEN  POSSIBLE;
             THE MEANING OF THE FORMAL PARAMETERS IS:
             TPRINT: <VARIABLE>;
                     ENTRY: THE  VALUE  OF THE  INDEPENDENT  VARIABLE AT
                            WHICH A CALL OF CONTROL WAS DESIRED;
                     EXIT:  A NEW VALUE  (TPRINT>T)  AT WHICH  A CALL OF
                            CONTROL IS DESIRED;
             T:      <VARIABLE>;
                     THE ACTUAL VALUE OF THE INDEPENDENT VARIABLE, UP TO
                     WHICH INTEGRATION HAS BEEN PERFORMED;
             H:      <VARIABLE>;
                     HALVE THE ACTUAL STEPSIZE;
             HNEW:   <VARIABLE>;
                     THE NEW STEPSIZE;
                     IF PRESCH="TRUE", THEN THE USER MAY PRESCRIBE A NEW
                     STEPSIZE BY CHANGING HNEW;
             Y:      <ARRAY IDENTIFIER>;
                     "REAL" "ARRAY" Y[1:5,1:N];
                     THE VALUE  OF THE DEPENDENT VARIABLE  AND ITS FIRST
                     FOUR DIVIDED DIFFERENCES  AT THE POINT T  ARE GIVEN
                     IN THIS ARRAY;
            ERROR:   <ARRAY IDENTIFIER>;
                     "REAL" "ARRAY" ERROR[1:3];
                     THE ELEMENTS  OF THIS ARRAY  CONTAIN  THE FOLLOWING
                     ERRORS:
                     ERROR[1]: THE LOCAL ERROR;
                     ERROR[2]: THE GLOBAL ERROR OF SECOND ORDER IN H;
                     ERROR[3]: THE GLOBAL ERROR OF FOURTH ORDER IN H;
            N:       <VARIABLE>;
                     THE NUMBER OF EQUATIONS;
            EXAMPLE OF USE: SEE EXAMPLE OF USE OF THE PROCEDURE IMPEX;
 
 
 DATA AND RESULTS:
     FOR DATA, SEE REF[1].
     THE RESULTS OF THE INTEGRATION ARE ATTAINABLE THROUGH THE PROCEDURE
     CONTROL , WHICH IS CALLED AT SPECIFIED, USER DEFINED, VALUES OF THE
     INDEPENDENT  VARIABLE . IN PARTICULAR , THE VALUES OF THE DEPENDENT
     VARIABLE  AT THE ENDPOINT OF INTEGRATION  ARE OBTAINED BY A CALL OF
     CONTROL WITH TPRINT=TEND.
 
 
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 4
 
 
 
 PROCEDURES USED:
 
     INIVEC   = CP31010,
     INIMAT   = CP31011,
     MULVEC   = CP31020,
     MULROW   = CP31021,
     DUPVEC   = CP31030,
     DUPROWVEC= CP31032,
     DUPMAT   = CP31035,
     VECVEC   = CP34010,
     MATVEC   = CP34011,
     MATMAT   = CP34013,
     ELMVEC   = CP34020,
     ELMROW   = CP34024,
     DEC      = CP34300,
     SOL      = CP34051.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA  N * ( 23 + 2 * N ) (DECIMAL).
 
 
 RUNNING TIME: DEPENDS  STRONGLY  ON THE DIFFERENTIAL EQUATION TO SOLVE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE INTEGRATION METHOD (REF[1]) IS BASED ON  THE COMPUTATION OF TWO
     INDEPENDENT SOLUTIONS Y(T,H) AND Y(T,H/2)  BY THE IMPLICIT MIDPOINT
     RULE. PASSIVE SMOOTHING  AND PASSIVE EXTRAPOLATION  IS PERFORMED TO
     OBTAIN STABILITY  AND HIGH ACCURACY . THE ALGORITHM  USES  FOR EACH
     STEP AT LEAST THREE FUNCTION EVALUATIONS, AND ON CHANGE OF STEPSIZE
     OR AT SLOW CONVERGENCE IN THE ITERATION PROCESS AN APPROXIMATION OF
     THE JACOBIAN MATRIX (COMPUTED BY DIVIDED DIFFERENCES  OR EXPLICITLY
     SPECIFIED  BY THE USER) . IF THE COMPUTED LOCAL ERROR  EXCEEDS  THE
     TOLERANCE , THE LAST STEP IS REJECTED. MOREOVER , TWO GLOBAL ERRORS
     ARE COMPUTED.
 
 
 REFERENCES:
 
     [1]. B.LINDBERG.
          IMPEX 2 , A PROCEDURE  FOR THE SOLUTION  OF  SYSTEMS OF  STIFF
          DIFFERENTIAL EQUATIONS.
          ROYAL INSTITUTE OF TECHNOLOGY,STOCKHOLM. TRITA-NA-7303 (1973).
 
     [2]. (TO APPEAR)
          COLLOQUIUM STIFF DIFFERENTIAL EQUATIONS 3 (DUTCH).
          M.C. SYLLABUS 15.3 (1974), MATHEMATICAL CENTRE.
 
 
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 5
 
 
 
 EXAMPLE OF USE:
     CONSIDER THE AUTONOMOUS SYSTEM OF DIFFERENTIAL EQUATIONS:
     DY[1]/DX = .2 * ( Y[2] - Y[1] ),
     DY[2]/DX = 10 * Y[1] - ( 60 - Y[3]/8 ) * Y[2] + Y[3]/8,
     DY[3]/DX = 1,
     WITH  INITIAL  CONDITIONS  AT  X=0 : Y[1]=Y[2]=Y[3]=0 (SEE REF[2]).
     THE SOLUTION  AT SEVERAL POINTS  IN THE INTERVAL  [0, 400]  MAY  BE
     OBTAINED BY THE FOLLOWING PROGRAM:
     (THE  SOLUTION  AT  X=400  IS: Y[1]=22.24222011,  Y[2]=27.11071335)
 
 "BEGIN" "INTEGER" N,NFE,NJE,POINT;
     "REAL" T,TEND,EPS,HMAX,L,H2,TIME;
     "ARRAY" Y,SW[1:3],PRINT[1:5];
     "BOOLEAN" FAIL;
 
     "PROCEDURE" LIPEST(L,Y,EPS,T,F,N);
     "REAL" T,L,EPS; "ARRAY" Y; "INTEGER" N; "PROCEDURE" F;
     "BEGIN" "REAL" N1,N2; "INTEGER" I,IT; "ARRAY" F1,F2,Z,X[1:N];
         "REAL" "PROCEDURE" NORM(Y); "ARRAY" Y;
         NORM:=SQRT(VECVEC(1,N,0,Y,Y));
         DUPVEC(1,N,0,Z,Y);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         X[I]:="IF" Y[I]=0 "THEN" EPS "ELSE" (1+EPS)*Y[I];
         N1:=NORM(X)*EPS; F(T,X,F1,N);
         "FOR" IT:=1 "STEP" 1 "UNTIL" 5 "DO"
         "BEGIN" F(T,Z,F2,N);
             ELMVEC(1,N,0,F2,F1,-1);
             N2:=N1/NORM(F2);
             DUPVEC(1,N,0,Z,X); ELMVEC(1,N,0,Z,F2,N2)
         "END";
         F(T,Z,F2,N);
         ELMVEC(1,N,0,F2,F1,-1);
         L:=NORM(F2)/N1
     "END" LIPEST;
 
     "PROCEDURE" F(T,Y,F1,N); "VALUE" T; "REAL" T; "ARRAY" Y,F1;
     "INTEGER" N;
     "BEGIN" NFE:=NFE+1;
         F1[1]:=0.2*(Y[2]-Y[1]);
         F1[2]:=10*Y[1]-(60-.125*Y[3])*Y[2]+.125*Y[3];
         F1[3]:=1
     "END";
 
     "BOOLEAN" "PROCEDURE" AVAILABLE(T,Y,A,N);
     "INTEGER" N; "REAL" T; "ARRAY" Y,A;
     "BEGIN" NJE:=NJE+1; AVAILABLE:="TRUE";
         A[1,1]:=-.2; A[1,2]:=.2; A[1,3]:=A[3,1]:=A[3,2]:=A[3,3]:=0;
         A[2,1]:=10; A[2,2]:=.125*Y[3]-60; A[2,3]:=.125*(1+Y[2])
     "END"
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 6
 
 
 
     "PROCEDURE" UPDATE(SW,R1,N); "INTEGER" N; "ARRAY" SW,R1;
     "BEGIN" "REAL" S1,S2; "INTEGER" I;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" S1:=1/SW[I]; S2:=ABS(R1[I]);
             "IF" S1<S2 "THEN" SW[I]:=1/S2
         "END"
     "END";
 
     "PROCEDURE" CONTROL(TP,T,H,HNEW,Y,ERR,N);
     "REAL" TP,T,H,HNEW; "ARRAY" Y,ERR; "INTEGER" N;
     "BEGIN" "INTEGER" I;
         "ARRAY" C[3:5],X[1:N];
         "REAL" S,S2,S3,S4,C1;
   NEXT: S:=(T-TP)/H;
         S2:=S*S; S3:=S2*S; S4:=S3*S;
         C[3]:=(S2-S)/2;
         C[4]:=-S3/6+S2/2-S/3;
         C[5]:=S4/24-S3/4+11*S2/24-S/4;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         X[I]:=Y[1,I]-S*Y[2,I]+C[3]*Y[3,I]+C[4]*Y[4,I]+C[5]*Y[5,I];
         OUTPUT(61,"("3ZD.2D2B,D.D"-D2B,2(+D.8D"-D2B),2(4ZD),3ZD.2D,
                /")",TP,ERR[3],X[1],X[2],NFE,NJE,CLOCK-TIME);
         "IF" TP<TEND "THEN"
         "BEGIN" POINT:=POINT+1; TP:=PRINT[POINT];
                 "IF" TP<=T "THEN" "GOTO" NEXT
         "END"
     "END" CONTROL;
 
     N:=3; NJE:=NFE:=0; T:=0; TEND:=400; EPS:="-5; HMAX:=400;
     Y[1]:=Y[2]:=Y[3]:=0; SW[1]:=SW[2]:=SW[3]:=1;
     PRINT[1]:=.1; PRINT[2]:=1; PRINT[3]:=10; PRINT[4]:=100;
     PRINT[5]:=400; POINT:= 0;
     LIPEST(L,Y,"-5,T,F,N);
     H2:=(EPS*320)**(1/5)/(4*L);
     OUTPUT(61,"(""("EPS=")",D.2D"-D,/,"("INTERVAL OF INTEGRATION=(")",
     3ZD,"(",")",3ZD,"(")")",/,"("MAXIMALLY ALLOWED STEPSIZE=")",
     D.2D"-D,//")",EPS,T,TEND,HMAX);
     OUTPUT(61,"(""("LIPSCHCONST=")",BD.3D"+D,/,"("STARTING STEPSIZE")"
     "("=")",BD.2D"+D,/,"("FUNCTIONAL EVAL=")",4ZD,//")",L,H2,NFE);
     TIME:=CLOCK;
     OUTPUT(61,"(""("    X     ERROR       Y[1]            Y[2]")"
     "("         NFE  NJE   TIME")",/")");
     IMPEX(N,T,TEND,Y,F,AVAILABLE,H2,HMAX,"FALSE",EPS,SW,UPDATE,FAIL,
     CONTROL);
     OUTPUT(61,"("/"("NO OF FUNCTIONAL EVALUATIONS= ")",3ZD,/,
     "("NO OF JACOBEAN EVALUATIONS= ")",3ZD,/")",NFE,NJE)
 "END"
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 7
 
 
 
 THIS PROGRAM DELIVERS:
 
 EPS=1.00"-5
 INTERVAL OF INTEGRATION=(   0, 400)
 MAXIMALLY ALLOWED STEPSIZE=4.00" 2
 
 LIPSCHCONST= 6.003"+1
 STARTING STEPSIZE= 1.32"-3
 FUNCTIONAL EVAL=    7
 
     X     ERROR       Y[1]            Y[2]         NFE  NJE   TIME
    0.00  0.0" 0  +0.00000000" 0  +0.00000000" 0      7    0   0.01
    0.10  6.3"-7  +1.49614151"-6  +1.74013792"-4     46    4   0.72
    1.00  1.5"-6  +1.91041887"-4  +2.08361269"-3     85    8   1.48
   10.00  8.7"-7  +1.30147663"-2  +2.34487800"-2    119    9   1.99
  100.00  1.3"-5  +3.06302487"-1  +3.27552180"-1    225   13   3.47
  400.00  1.4"-5  +2.22406546" 1  +2.71090507" 1    556   30   7.51
 
 NO OF FUNCTIONAL EVALUATIONS=  556
 NO OF JACOBEAN EVALUATIONS=   30
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 8
 
 
 
 SOURCE TEXT(S):
0"CODE" 33135;
 "PROCEDURE" IMPEX (N, T0, TEND, Y0, DERIV, AVAILABLE, H0, HMAX,
                   PRESCH, EPS, WEIGHTS, UPDATE, FAIL, CONTROL);
 "VALUE" N;
 "INTEGER" N;
 "REAL" T0,TEND,H0,HMAX,EPS;
 "BOOLEAN" PRESCH,FAIL;
 "ARRAY" Y0,WEIGHTS;
 "BOOLEAN" "PROCEDURE" AVAILABLE;
 "PROCEDURE" DERIV,UPDATE,CONTROL;
 "BEGIN" "INTEGER" I,K,ECI;
     "REAL" T,T1,T2,T3,TP,H,H2,HNEW,ALF,LQ;
     "ARRAY" Y,Z,S1,S2,S3,U1,U3,W1,W2,W3,EHR[1:N],R,RF[1:5,1:N],
             ERR[1:3],A1,A2[1:N,1:N];
     "INTEGER" "ARRAY" PS1,PS2[1:N];
     "BOOLEAN" START,TWO,HALV;
 
     "PROCEDURE" DFDY(T,Y,A); "REAL" T; "ARRAY" Y,A;
     "BEGIN" "INTEGER" I,J; "REAL" SL; "ARRAY" F1,F2[1:N];
         DERIV(T,Y,F1,N);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN"
             SL:="-6*Y[I]; "IF" ABS(SL)<"-6 "THEN" SL:="-6;
             Y[I]:=Y[I]+SL; DERIV(T,Y,F2,N);
             "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
             A[J,I]:=(F2[J]-F1[J])/SL;
             Y[I]:=Y[I]-SL;
         "END"
     "END" DFDY;
 
     "PROCEDURE" STARTV(Y,T); "VALUE" T; "REAL" T; "ARRAY" Y;
     "BEGIN" "REAL" A,B,C;
         A:=(T-T1)/(T1-T2); B:=(T-T2)/(T1-T3);
         C:=(T-T1)/(T2-T3)*B; B:=A*B;
         A:=1+A+B; B:=A+C-1;
         MULVEC(1,N,0,Y,S1,A); ELMVEC(1,N,0,Y,S2,-B);
         ELMVEC(1,N,0,Y,S3,C)
     "END" STARTV
 
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                      PAGE 9
                                                                  ;
 
 
     "PROCEDURE" ITERATE(Z,Y,A,H,T,WEIGHTS,FAIL,PS);
     "ARRAY" Z,Y,A,WEIGHTS; "REAL" H,T; "LABEL" FAIL;
     "INTEGER" "ARRAY" PS;
     "BEGIN" "INTEGER" IT,LIT; "REAL" MAX,MAX1,CONV; "ARRAY" DZ,F1[1:N];
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" Z[I]:=(Z[I]+Y[I])/2;
         IT:=LIT:=1; CONV:=1;
     ATER: DERIV(T,Z,F1,N);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         F1[I]:=DZ[I]:=Z[I]-H*F1[I]/2-Y[I];
         SOL(A,N,PS,DZ);
         ELMVEC(1,N,0,Z,DZ,-1);
         MAX:=0;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         MAX:=MAX+(WEIGHTS[I]*DZ[I])**2;
         MAX:=SQRT(MAX);
         "IF" MAX*CONV<EPS/10 "THEN" "GOTO" OUT;
         IT:=IT+1; "IF" IT=2 "THEN" "GOTO" ASS;
         CONV:=MAX/MAX1;
         "IF" CONV>.2 "THEN"
         "BEGIN" "IF" LIT=0 "THEN" "GOTO" FAIL;
             LIT:=0; CONV:=1; IT:=1;
             RECOMP(A,H,T,Z,FAIL,PS);
         "END";
     ASS: MAX1:=MAX;
         "GOTO" ATER;
     OUT: "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" Z[I]:=2*Z[I]-Y[I];
     "END" ITERATE;
 
     "PROCEDURE" RECOMP(A,H,T,Y,FAIL,PS);
     "REAL" H,T; "ARRAY" A,Y; "LABEL" FAIL; "INTEGER" "ARRAY" PS;
     "BEGIN" "REAL" SL; "ARRAY" AUX[1:3];
         SL:=H/2;
         "IF" "NOT" AVAILABLE(T,Y,A,N) "THEN" DFDY(T,Y,A);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" MULROW(1,N,I,I,A,A,-SL); A[I,I]:=1+A[I,I]
         "END";
         AUX[2]:="-14;
         DEC(A,N,AUX,PS);
         "IF" AUX[3]<N "THEN" "GOTO" FAIL
     "END" RECOMP;
 
     "PROCEDURE" INITIALIZATION;
     "BEGIN" H2:=HNEW; H:=H2/2;
         DUPVEC(1,N,0,S1,Y0); DUPVEC(1,N,0,S2,Y0); DUPVEC(1,N,0,S3,Y0);
         DUPVEC(1,N,0,W1,Y0); DUPROWVEC(1,N,1,R,Y0);
         INIVEC(1,N,U1,0); INIVEC(1,N,W2,0);
         INIMAT(2,5,1,N,R,0); INIMAT(1,5,1,N,RF,0);
         T:=T1:=T0; T2:=T0-2*H-"6; T3:=2*T2+1;
         RECOMP(A1,H,T,S1,MISS,PS1);RECOMP(A2,H2,T,W1,MISS,PS2);
     "END"
 
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                     PAGE 10
                                                                 ;
 
 
     "PROCEDURE" ONE LARGE STEP;
     "BEGIN" STARTV(Z,T+H);
         ITERATE(Z,S1,A1,H,T+H/2,WEIGHTS,MISS,PS1);
         DUPVEC(1,N,0,Y,Z);
         STARTV(Z,T+H2);
         ITERATE(Z,Y,A1,H,T+3*H/2,WEIGHTS,MISS,PS1);
         DUPVEC(1,N,0,U3,U1); DUPVEC(1,N,0,U1,Y);
         DUPVEC(1,N,0,S3,S2); DUPVEC(1,N,0,S2,S1);
         DUPVEC(1,N,0,S1,Z);
         ELMVEC(1,N,0,Z,W1,1); ELMVEC(1,N,0,Z,S2,-1);
         ITERATE(Z,W1,A2,H2,T+H,WEIGHTS,MISS,PS2);
         T3:=T2; T2:=T1; T1:=T+H2;
         DUPVEC(1,N,0,W3,W2); DUPVEC(1,N,0,W2,W1); DUPVEC(1,N,0,W1,Z);
     "END";
 
     "PROCEDURE" CHANGE OF INFORMATION;
     "BEGIN" "REAL" ALF1,C1,C2,C3; "ARRAY" KOF[2:4,2:4],E,D[1:4];
         "INTEGER" I, K;
         C1:=HNEW/H2; C2:=C1*C1; C3:=C2*C1;
         KOF[2,2]:=C1; KOF[2,3]:=(C1-C2)/2; KOF[2,4]:=C3/6-C2/2+C1/3;
         KOF[3,3]:=C2; KOF[3,4]:=C2-C3; KOF[4,4]:=C3;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         U1[I]:=R[2,I]+R[3,I]/2+R[4,I]/3;
         ALF1:=MATVEC(1,N,1,RF,U1)/VECVEC(1,N,0,U1,U1);
         ALF:=(ALF+ALF1)*C1;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN"
             E[1]:=RF[1,I]-ALF1*U1[I];
             E[2]:=RF[2,I]-ALF1*2*R[3,I];
             E[3]:=RF[3,I]-ALF1*4*R[4,I];
             E[4]:=RF[4,I];
             D[1]:=R[1,I]; RF[1,I]:=E[1]:=E[1]*C2;
             "FOR" K:=2 "STEP" 1 "UNTIL" 4 "DO"
             "BEGIN" R[K,I]:=D[K]:=MATMAT(K,4,K,I,KOF,R);
                 RF[K,I]:=E[K]:=C2*MATVEC(K,4,K,KOF,E)
             "END" K;
             S1[I]:=D[1]+E[1];W1[I]:=D[1]+4*E[1];
             S2[I]:=S1[I]-(D[2]+E[2]/2);
             S3[I]:=S2[I]-(D[2]+E[2])+(D[3]+E[3]/2);
         "END" I;
         T3:=T-HNEW; T2:=T-HNEW/2; T1:=T;
         H2:=HNEW; H:=H2/2; ERR[1]:=0;
         "IF" HALV "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" PS2[I]:= PS1[I];
             DUPMAT(1,N,1,N,A2,A1) "END";
         "IF" TWO "THEN"
         "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" PS1[I]:= PS2[I];
             DUPMAT(1,N,1,N,A1,A2)
         "END" "ELSE" RECOMP(A1,HNEW/2,T,S1,MISS,PS1);
         "IF" ^HALV "THEN" RECOMP(A2,HNEW,T,W1,MISS,PS2);
     "END" HNEW^=H2
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                     PAGE 11
                                                                 ;
 
 
 
     "PROCEDURE" BACKWARD DIFFERENCES;
     "FOR"I:=1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" "REAL" B0,B1,B2,B3;
         B1:=(U1[I]+2*S2[I]+U3[I])/4;
         B2:=(W1[I]+2*W2[I]+W3[I])/4;
         B3:=(S3[I]+2*U3[I]+S2[I])/4;
         B2:=(B2-B1)/3; B0:=B1-B2;
         B2:=B2-(S1[I]-2*S2[I]+S3[I])/16;
         B1:=2*B3-(B2+RF[1,I])-(B0+R[1,I])/2;
         B3:=0;
         "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" B1:=B1-B3; B3:=R[K,I]; R[K,I]:=B0; B0:=B0-B1
         "END"; R[5,I]:=B0;
         "FOR" K:=1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" B3:=RF[K,I]; RF[K,I]:=B2; B2:=B2-B3 "END";
         RF[5,I]:=B2;
     "END";
 
     "PROCEDURE" ERROR ESTIMATES;
     "BEGIN" "REAL" C0,C1,C2,C3,B0,B1,B2,B3,W,SL1,SN,LR;
         C0:=C1:=C2:=C3:=0;
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:=WEIGHTS[I]**2;
             B0:=RF[4,I]/36; C0:=C0+B0*B0*W; LR:=ABS(B0);
             B1:=RF[1,I]+ALF*R[2,I]; C1:=C1+B1*B1*W;
             B2:=RF[3,I]; C2:=C2+B2*B2*W;
             SL1:=ABS(RF[1,I]-RF[2,I]);
             SN:="IF" SL1<"-10 "THEN"1"ELSE"ABS(RF[1,I]-R[4,I]/6)/SL1;
             "IF" SN>1 "THEN" SN:=1;
             "IF" START "THEN" "BEGIN" SN:=SN**4; LR:=LR*4 "END";
             EHR[I]:=B3:=SN*EHR[I]+LR; C3:=C3+B3*B3*W;
         "END" I;
         B0:=ERR[1];
         ERR[1]:=B1:=SQRT(C0); ERR[2]:=SQRT(C1);
         ERR[3]:=SQRT(C3)+SQRT(C2)/2;
         LQ:=EPS/("IF" B0<B1 "THEN" B1"ELSE" B0);
         "IF" B0<B1 "AND" LQ>=80 "THEN" LQ:=10;
     "END";
 
     "PROCEDURE" REJECT;
     "IF" START "THEN"
     "BEGIN" HNEW:=LQ**(1/5)*H/2; "GOTO" INIT
     "END" "ELSE"
     "BEGIN" "FOR" K:=1,2,3,4,1,2,3 "DO" ELMROW(1,N,K,K+1,R,R,-1);
         "FOR" K:=1,2,3,4 "DO" ELMROW(1,N,K,K+1,RF,RF,-1);
         T:=T-H2; HALV:="TRUE"; HNEW:=H; "GOTO" MSTP
     "END"
 
1SECTION : 5.2.1.1.1.2.F      (OCTOBER 1975)                     PAGE 12
                                                                 ;
 
 
     "PROCEDURE" STEPSIZE;
     "IF" LQ<2 "THEN"
     "BEGIN" HALV:="TRUE"; HNEW:=H "END" "ELSE"
     "BEGIN" "IF" LQ>80 "THEN"
         HNEW:=("IF" LQ>5120 "THEN" (LQ/5)**(1/5) "ELSE" 2)*H2;
         "IF" HNEW>HMAX "THEN" HNEW:=HMAX;
         "IF" TEND>T "AND" TEND-T<HNEW "THEN" HNEW:=TEND-T;
         TWO:=HNEW=2*H2;
     "END";
 
     "IF" PRESCH "THEN" H:=H0 "ELSE"
     "BEGIN" "IF" H0>HMAX "THEN" H:=HMAX "ELSE" H:=H0;
         "IF" H>(TEND-T0)/4 "THEN" H:=(TEND-T0)/4;
     "END";
     HNEW:=H;
     ALF:=0; T:=TP:=T0;
     INIVEC(1,3,ERR,0); INIVEC(1,N,EHR,0);
     DUPROWVEC(1,N,1,R,Y0); INIMAT(2, 5, 1, N, R, 0.0);
     CONTROL(TP,T,H,HNEW,R,ERR,N);
 INIT: INITIALIZATION; START:="TRUE";
     "FOR" ECI:=0,1,2,3 "DO"
     "BEGIN" ONE LARGE STEP; T:=T+H2;
         "IF" ECI>0 "THEN"
         "BEGIN" BACKWARD DIFFERENCES; UPDATE(WEIGHTS,S2,N) "END"
     "END";
     ECI:=4;
 MSTP: "IF" HNEW^=H2 "THEN"
     "BEGIN" ECI:=1; CHANGE OF INFORMATION;
         ONE LARGE STEP; T:=T+H2; ECI:=2;
     "END";
     ONE LARGE STEP;
     BACKWARD DIFFERENCES;
     UPDATE(WEIGHTS,S2,N);
     ERROR ESTIMATES;
     "IF" ECI<4 "AND" LQ>80 "THEN" LQ:=20;
     HALV:=TWO:="FALSE";
     "IF" PRESCH "THEN" "GOTO" TRYCK;
     "IF" LQ<1 "THEN" REJECT "ELSE" STEPSIZE;
 TRYCK: "IF" TP<=T "THEN" CONTROL(TP,T,H,HNEW,R,ERR,N);
     "IF" START "THEN" START:="FALSE";
     "IF" HNEW=H2 "THEN" T:=T+H2; ECI:=ECI+1;
     "IF" T<TEND+H2 "THEN" "GOTO" MSTP "ELSE" "GOTO" END;
 MISS: FAIL:=PRESCH;
     "IF" ^ FAIL "THEN"
     "BEGIN" "IF" ECI>1 "THEN" T:=T-H2;
         HALV:=TWO:="FALSE"; HNEW:=H2/2;
         "IF" START "THEN" "GOTO" INIT "ELSE" "GOTO" TRYCK
     "END";
 END:
 "END" IMPEX;
         "EOP"
1SECTION : 5.2.1.1.1.3        (AUGUST 1974)                       PAGE 1
 
 
 
 SECTION 5.2.1.1.1.3 CONTAINS TWO  ALTERNATIVE PROCEDURES FOR SOLVING
 FIRST-ORDER INITIAL VALUE PROBLEMS WITH SEVERAL DERIVATIVES AVAILABLE.
 
 A.  MODIFIED TAYLOR SOLVES AN INITIAL ( BOUNDARY ) VALUE PROBLEM, GIVEN
     AS A SYSTEM OF  FIRST ORDER DIFFERENTIAL EQUATIONS , BY MEANS OF A
     ONE-STEP TAYLOR-METHOD.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF LARGE
     SYSTEMS ARISING FROM PARTIAL DIFFERENTIAL EQUATIONS, PROVIDED THAT
     HIGHER ORDER DERIVATIVES CAN BE EASILY OBTAINED.
 
 B.  EXPONENTIALLY FITTED TAYLOR  SOLVES AN INITIAL VALUE PROBLEM, GIVEN
     AS A SYSTEM  OF  FIRST ORDER DIFFERENTIAL EQUATIONS , BY MEANS OF A
     ONE-STEP  TAYLOR-METHOD . AUTOMATIC  STEPSIZE  CONTROL IS PROVIDED.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF  STIFF
     DIFFERENTIAL EQUATIONS , PROVIDED THAT HIGHER ORDER DERIVATIVES CAN
     BE EASILY OBTAINED.
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 1
 
 
 
 AUTHORS: P.J. VAN DER HOUWEN AND P.A.BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730616.
 
 
 BRIEF DESCRIPTION:
 
     MODIFIED TAYLOR SOLVES AN INITIAL ( BOUNDARY ) VALUE PROBLEM, GIVEN
     AS A SYSTEM  OF  FIRST ORDER DIFFERENTIAL EQUATIONS , BY MEANS OF A
     ONE-STEP TAYLOR-METHOD.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF  LARGE
     SYSTEMS ARISING FROM PARTIAL DIFFERENTIAL EQUATIONS , PROVIDED THAT
     HIGHER ORDER DERIVATIVES CAN BE EASILY OBTAINED.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL (BOUNDARY) VALUE PROBLEMS,
     ONE-STEP TAYLOR-METHOD.
 
 
1SECTION : 5.2.1.1.1.3.A      (DECEMBER 1975)                     PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" MODIFIED TAYLOR (T,TE,M0,M,U,SIGMA,TAUMIN,I,DERIVATIVE,
                                K,DATA,ALFA,NORM,AETA,RETA,ETA,RHO,OUT);
     "INTEGER" M0,M,I,K,NORM;
     "REAL" T,TE,SIGMA,TAUMIN,ALFA,AETA,RETA,ETA,RHO;
     "ARRAY" U,DATA;
     "PROCEDURE" DERIVATIVE,OUT;
     "CODE" 33040;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     T:      <VARIABLE>;
             THE INDEPENDENT VARIABLE T;
             MAY BE USED IN DERIVATIVE, SIGMA ETC.;
             ENTRY: THE INITIAL VALUE T0;
             EXIT : THE FINAL VALUE TE;
     TE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF T (TE >= T);
     M0,M:   <ARITHMETIC EXPRESSION>;
             INDICES OF THE FIRST AND LAST EQUATION OF THE SYSTEM TO  BE
             SOLVED;
     U:      <ARRAY IDENTIFIER>;
             "ARRAY" U[M0:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE INITIAL VALUES OF THE SOLUTION OF THE SYSTEM  OF
                    DIFFERENTIAL EQUATIONS AT T = T0;
             EXIT : THE VALUES OF THE SOLUTION AT T = TE;
     SIGMA:  <ARITHMETIC EXPRESSION>;
             THE SPECTRAL RADIUS OF THE JACOBIAN MATRIX WITH RESPECT
             TO THOSE EIGENVALUES WHICH ARE LOCATED IN THE LEFT
             HALFPLANE;
             IF  SIGMA  TENDS  TO  INFINITY , PROCEDURE  MODIFIED TAYLOR
             TERMINATES;
     TAUMIN: <ARITHMETIC EXPRESSION>;
             MINIMAL STEP LENGTH BY WHICH THE INTEGRATION IS  PERFORMED;
             HOWEVER,ACTUAL STEPSIZES WILL ALWAYS BE WITHIN THE INTERVAL
             [MIN(HMIN,HSTAB),HSTAB],WHERE HSTAB(= DATA[0]/SIGMA) IS THE
             STEPLENGTH PRESCRIBED BY STABILITY CONSIDERATIONS;
     I:      <VARIABLE>;
             A JENSEN PARAMETER FOR PROCEDURE DERIVATIVE;
             MAY BE USED IN M0 AND M;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(I,A); "INTEGER" I; "ARRAY" A;
             WHEN THIS PROCEDURE IS CALLED, ARRAY A[M0 : M] CONTAINS THE
             COMPONENTS OF THE (I-1)-ST DERIVATIVE OF U  AT THE POINT T;
             UPON COMPLETION OF DERIVATIVE, ARRAY A SHOULD  CONTAIN  THE
             COMPONENTS  OF THE I-TH  DERIVATIVE  OF U AT  THE POINT  T;
     K:      <VARIABLE>;
             INDICATES  THE  NUMBER  OF  INTEGRATION  STEPS   PERFORMED;
             ENTRY: K = 0;
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 3
 
 
 
     DATA:   <ARRAY IDENTIFIER>;
             "ARRAY" DATA[-2 : DATA[-2]];
             ENTRY:
             DATA[-2]: THE  ORDER OF THE  HIGHEST DERIVATIVE  UPON WHICH
                       THE TAYLOR METHOD IS BASED;
             DATA[-1]: ORDER OF ACCURACY OF THE METHOD;
             DATA[0] : STABILITY PARAMETER;
             DATA[1] , ... , DATA[DATA[-2]] :  POLYNOMIAL  COEFFICIENTS;
             FOR FURTHER EXPLANATION AND POSSIBLE VALUES OF THE ELEMENTS
             OF ARRAY DATA SEE REFERENCES [2] AND [3];
     ALFA:   <ARITHMETIC EXPRESSION>;
             GROWTH FACTOR FOR THE INTEGRATION STEP LENGTH;
     NORM:   <ARITHMETIC EXPRESSION>;
             IF NORM = 1 DISCREPANCY AND TOLERANCE ARE ESTIMATED IN  THE
             MAXIMUM NORM, OTHERWISE IN THE EUCLIDIAN NORM;
     AETA,RETA: <ARITHMETIC EXPRESSION>;
             DESIRED ABSOLUTE AND RELATIVE ACCURACY;
             IF BOTH  AETA AND RETA  ARE NEGATIVE , ACCURACY  CONDITIONS
             WILL BE IGNORED;
     ETA,RHO: <VARIABLE>;
             COMPUTED TOLERANCE AND DISCREPANCY;
     OUT:    <PROCEDURE IDENTIFIER>;
             THE  HEADING  OF  THIS  PROCEDURE  READS : "PROCEDURE" OUT;
             THROUGH  THIS  PROCEDURE  THE VALUES AFTER EACH INTEGRATION
             STEP  OF  FOR INSTANCE  T, U, ETA AND RHO  ARE  ACCESSIBLE.
 
 
 DATA AND RESULTS:
 
     FOR FURTHER EXPLANATION OF THE PARAMETERS AETA, RETA, ETA, RHO, M0,
     M AND THE ARRAY DATA SEE REFERENCES [2] AND [3].
     AS  FOR  THE  INDICES  M0 AND M THE FOLLOWING MAY BE REMARKED: WHEN
     THE METHOD OF LINES IS APPLIED TO HYPERBOLIC DIFFERENTIAL EQUATIONS
     THE NUMBER OF  RELEVANT  ORDINARY DIFFERENTIAL EQUATIONS  DECREASES
     DURING THE INTEGRATION PROCESS.
     IN PROCEDURE MODIFIED TAYLOR , THIS  MAY  BE  REALIZED  BY  INTEGER
     PROCEDURES M0 AND M WHICH  ARE  DEFINED  AS  FUNCTIONS OF I, K  AND
     DATA[-2].
 
 
 PROCEDURES USED: VECVEC = CP34010.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA 75 + M - M0.
 
 
 RUNNING TIME:
 
     DEPENDS  STRONGLY  ON  THE  DIFFERENTIAL  EQUATION  TO  BE  SOLVED.
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 4
 
 
 
 METHOD AND PERFORMANCE: SEE REFERENCES.
 
 REFERENCES:
 
     [1].P.J. VAN DER HOUWEN.
         ONE-STEP METHODS FOR LINEAR INITIAL VALUE PROBLEMS I,
         POLYNOMIAL METHODS,TW REPORT 119,
         MATHEMATICAL CENTRE, AMSTERDAM (1970).
 
     [2].P.J. VAN DER HOUWEN, P.BEENTJES, K.DEKKER AND E.SLAGT
         ONE-STEP METHODS FOR LINEAR INITIAL VALUE PROBLEMS III,
         NUMERICAL EXAMPLES, TW REPORT 130/71,
         MATHEMATICAL CENTRE, AMSTERDAM (1971).
 
     [3].P.J. VAN DER HOUWEN, J.KOK.
         NUMERICAL SOLUTION OF A MINIMAX PROBLEM, TW REPORT 123/71,
         MATHEMATICAL CENTRE, AMSTERDAM (1971).
 
 
 EXAMPLE OF USE:
 
     THE  SOLUTION AT T=EXP(1) AND T=EXP(2) OF THE DIFFERENTIAL EQUATION
     DU/DT=-EXP(T)*(U-LN(T)) + 1/T WITH INITIAL CONDITION U(.01)=LN(.01)
     AND  ANALYTICAL SOLUTION U(T) = LN(T), MAY BE OBTAINED  AS FOLLOWS:
 
     "BEGIN" "INTEGER" I,K;"REAL" T,TE,ETA,RHO,EXPT,LNT,C0,C1,C2,C3;
         "ARRAY" U[0:0],DATA[-2:4];
         "PROCEDURE" OP;"IF" T=TE "THEN"
         OUTPUT(61,"(""("NUMBER OF STEPS:")",3ZD,/,
                      "("SOLUTION:  T= ")",+D.5D,
                      "("    U(T) = ")",+D.7D,//")",K,T,U[0]);
         "PROCEDURE" DER(I,A);"INTEGER" I;"ARRAY" A;
         "BEGIN" "IF" I=1 "THEN"
             "BEGIN" EXPT:=EXP(T);LNT:=LN(T);C0:=A[0];
                 C1:=A[0]:=-EXPT*C0+1/T+EXPT*LNT
             "END";
             "IF" I=2 "THEN" C2:=A[0]:=EXPT*(LNT+1/T-C0-C1)-1/T/T;
             "IF" I=3 "THEN" C3:=A[0]:=
             EXPT*(LNT+2/T-C0-2*C1-C2-1/T/T)+2/T/T/T;
             "IF" I=4 "THEN" A[0]:=C3-2*(1+3/T)/T/T/T+
             EXPT*((1-(2-2/T)/T)/T-C1-C2*2-C3)
         "END";
         I:=-2;"FOR" T:=4,3,6.025,1,.5,1/6,.018455702 "DO"
         "BEGIN" DATA[I]:=T;I:=I+1 "END";
         T:=U[0]:="-2;K:=0;"FOR" TE:=EXP(1),TE*TE "DO"
         MODIFIED TAYLOR(T,TE,0,0,U,EXP(T),"-4,I,DER,K,DATA,1.5,1,"-5,
                        "-4,ETA,RHO,OP)
     "END"
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 5
 
 
 
     THIS PROGRAM DELIVERS:
 
     NUMBER OF STEPS:  46
     SOLUTION:  T= +2.71828    U(T) = +1.0000285
 
     NUMBER OF STEPS: 424
     SOLUTION:  T= +7.38906    U(T) = +1.9999967
 
 
 SOURCE TEXT(S):
0"CODE" 33040;
 "PROCEDURE" MODIFIED TAYLOR(T,TE,M0,M,U,SIGMA,TAUMIN,I,DERIVATIVE,K,
                   DATA,ALFA,NORM,AETA,RETA,ETA,RHO,OUT);
 "INTEGER" M0,M,I,K,NORM;
 "REAL" T,TE,SIGMA,TAUMIN,ALFA,AETA,RETA,ETA,RHO;
 "ARRAY" U,DATA;
 "PROCEDURE" DERIVATIVE,OUT;
 
 "BEGIN" I:=0;
     "BEGIN" "INTEGER" N,P,Q;
         "OWN" "REAL" EC0,EC1,EC2,TAU0,TAU1,TAU2,TAUS,T2;
         "REAL" T0,TAU,TAUI,TAUEC,ECL,BETAN,GAMMA;
         "REAL" "ARRAY" C[M0:M],BETA,BETHA[1:DATA[-2]];
         "BOOLEAN" START,STEP1,LAST;
 
         "PROCEDURE" COEFFICIENT;
         "BEGIN" "INTEGER" J;"REAL" IFAC;
             IFAC:=1; GAMMA:=.5; N:=DATA[-2]; P:=DATA[-1];
             BETAN:=DATA[0]; Q:= "IF" P<N "THEN" P+1 "ELSE" N;
             "FOR" J:=1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" BETA[J]:=DATA[J]; IFAC:=IFAC/J;
                 BETHA[J]:=IFAC-BETA[J]
             "END";
             "IF" P=N "THEN" BETHA[N]:=IFAC
         "END";                                                "COMMENT"
 
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 6
                                                                  ;
 
 
 
         "REAL" "PROCEDURE" NORMFUNCTION(NORM,W);
         "INTEGER" NORM; "ARRAY" W;
         "BEGIN" "INTEGER" J; "REAL" S,X;
             S:=0;
             "IF" NORM=1 "THEN"
             "BEGIN" "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO"
                 "BEGIN"  X:=ABS(W[J]); "IF" X>S "THEN" S:=X "END"
             "END" "ELSE"
             S:=SQRT(VECVEC(M0,M,0,W,W));
             NORMFUNCTION:=S
         "END";
 
         "PROCEDURE" LOCAL ERROR BOUND;
         ETA:=AETA+RETA * NORMFUNCTION(NORM,U);
 
         "PROCEDURE" LOCAL ERROR CONSTRUCTION(I);"INTEGER" I;
         "BEGIN" "IF" I=P "THEN" "BEGIN" ECL:=0;TAUEC:=1 "END";
             "IF" I>P+1 "THEN" TAUEC:=TAUEC*TAU;
             ECL:=ECL+ABS(BETHA[I])*TAUEC*NORMFUNCTION(NORM,C);
             "IF" I=N "THEN"
             "BEGIN" EC0:=EC1;EC1:=EC2;EC2:=ECL;
                 RHO:=ECL*TAU**Q
             "END"
         "END";
 
         "PROCEDURE" STEPSIZE;
         "BEGIN" "REAL" TAUACC,TAUSTAB,AA,BB,CC,EC;
             LOCAL ERROR BOUND;
             "IF" ETA>0 "THEN"
             "BEGIN" "IF" START "THEN"
                 "BEGIN" "IF" K=0 "THEN"
                     "BEGIN" "INTEGER" J;
                         "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO" C[J]:=U[J];
                         I:=1; DERIVATIVE(I,C);
                         TAUACC:=ETA/NORMFUNCTION(NORM,C);
                         STEP1:="TRUE"
                     "END" "ELSE"
                     "IF" STEP1 "THEN"
                     "BEGIN" TAUACC:=(ETA/RHO)**(1/Q)*TAU2;
                         "IF" TAUACC>10*TAU2 "THEN"
                         TAUACC:=10*TAU2 "ELSE" STEP1:="FALSE"
                     "END" "ELSE"
                     "BEGIN" BB:=(EC2-EC1)/TAU1; CC:=EC2-BB*T2;
                         EC:=BB*T+CC;
                         TAUACC:="IF" EC<0 "THEN" TAU2 "ELSE"
                         (ETA/EC)**(1/Q);
                         START:="FALSE"
                     "END"
1SECTION : 5.2.1.1.1.3.A      (AUGUST 1974)                       PAGE 7
 
 
 
                 "END" "ELSE"
                 "BEGIN" AA:=((EC0-EC1)/TAU0+(EC2-EC1)/TAU1)/
                             (TAU1+TAU0);
                     BB:=(EC2-EC1)/TAU1-AA*(2*T2-TAU1);
                     CC:=EC2-T2*(BB+AA*T2); EC:=CC+T*(BB+T*AA);
                     TAUACC:="IF" EC<0 "THEN" TAUS
                             "ELSE" (ETA/EC)**(1/Q);
                     "IF" TAUACC>ALFA*TAUS "THEN" TAUACC:=ALFA*TAUS;
                     "IF" TAUACC<GAMMA*TAUS "THEN" TAUACC:=GAMMA*TAUS;
                 "END"
             "END" "ELSE" TAUACC:=TE-T;
             "IF" TAUACC<TAUMIN "THEN" TAUACC:=TAUMIN;
             TAUSTAB:=BETAN/SIGMA;
             "IF" TAUSTAB<"-12 * (T-T0) "THEN"
             "BEGIN" OUT;"GOTO" END OF MODIFIED TAYLOR "END";
             TAU:="IF" TAUACC>TAUSTAB "THEN" TAUSTAB "ELSE" TAUACC;
             TAUS:=TAU; "IF" TAU>=TE-T "THEN"
             "BEGIN" TAU:=TE-T;LAST:= "TRUE" "END";
             TAU0:=TAU1;TAU1:=TAU2;TAU2:=TAU
         "END";
 
         "PROCEDURE" DIFFERENCE SCHEME;
         "BEGIN" "INTEGER" J; "REAL" B;
             "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO" C[J]:=U[J]; TAUI:=1;
           NEXT TERM:
             I:=I+1; DERIVATIVE(I,C); TAUI:=TAUI*TAU;
             B:=BETA[I]*TAUI;
             "IF" ETA>0 "AND" I>=P "THEN" LOCAL ERROR CONSTRUCTION(I);
             "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO" U[J]:=U[J]+B*C[J];
             "IF" I<N "THEN" "GOTO" NEXT TERM;
             T2:=T; "IF" LAST "THEN"
             "BEGIN" LAST:= "FALSE"; T:= TE "END"
             "ELSE" T:= T + TAU
         "END";
 
         START:= K=0; T0:=T;
         COEFFICIENT; LAST:= "FALSE";
       NEXT LEVEL:
         STEPSIZE; K:=K+1; I:=0; DIFFERENCE SCHEME; OUT;
         "IF" T ^= TE "THEN" "GOTO" NEXT LEVEL
     "END";
     END OF MODIFIED TAYLOR:
 "END" MODIFIED TAYLOR;
         "EOP"
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 1
 
 
 
 AUTHORS: P.J. VAN DER HOUWEN AND K.DEKKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740416.
 
 
 BRIEF DESCRIPTION:
 
     EXPONENTIALLY FITTED TAYLOR  SOLVES AN INITIAL VALUE PROBLEM, GIVEN
     AS A SYSTEM  OF  FIRST ORDER DIFFERENTIAL EQUATIONS , BY MEANS OF A
     ONE-STEP  TAYLOR-METHOD . AUTOMATIC  STEPSIZE  CONTROL IS PROVIDED.
     IN PARTICULAR THIS METHOD IS SUITABLE FOR THE INTEGRATION OF  STIFF
     DIFFERENTIAL EQUATIONS , PROVIDED THAT HIGHER ORDER DERIVATIVES CAN
     BE EASILY OBTAINED.
 
 
 KEYWORDS:
 
     DIFFERENTIAL EQUATIONS,
     INITIAL VALUE PROBLEMS,
     EXPONENTIAL FITTING,
     STIFF EQUATIONS,
     THREE-CLUSTER METHOD,
     ONE-STEP TAYLOR-METHOD.
 
 
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 2
 
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"  EXPONENTIALLY  FITTED  TAYLOR (T, TE, M0, M, U, SIGMA,
                            PHI, DIAMETER, DERIVATIVE, I, K, ALFA, NORM,
                            AETA, RETA, ETA, RHO, HMIN, HSTART, OUTPUT);
     "INTEGER" M0,M,I,K,NORM;
     "REAL"  T,TE,SIGMA,PHI,DIAMETER,ALFA,AETA,RETA,ETA,RHO,HMIN,HSTART;
     "ARRAY" U;
     "PROCEDURE" DERIVATIVE,OUTPUT;
     "CODE" 33050;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     T:      <VARIABLE>;
             THE INDEPENDENT VARIABLE T;
             MAY BE USED IN DERIVATIVE, SIGMA ETC.;
             ENTRY: THE INITIAL VALUE T0;
             EXIT : THE FINAL VALUE TE;
     TE:     <ARITHMETIC EXPRESSION>;
             THE FINAL VALUE OF T (TE >= T);
     M0:     <ARITHMETIC EXPRESSION>;
             INDEX OF THE FIRST EQUATION OF THE SYSTEM TO BE SOLVED;
     M:      <ARITHMETIC EXPRESSION>;
             INDEX OF THE LAST EQUATION OF THE SYSTEM TO BE SOLVED;
     U:      <ARRAY IDENTIFIER>;
             "ARRAY" U[M0:M];
             THE DEPENDENT VARIABLE;
             ENTRY: THE INITIAL VALUES OF THE SOLUTION OF THE SYSTEM  OF
                    DIFFERENTIAL EQUATIONS AT T = T0;
             EXIT : THE VALUES OF THE SOLUTION AT T = TE;
     SIGMA:  <ARITHMETIC EXPRESSION>;
             THE  MODULUS  OF THE (COMPLEX) POINT  AT WHICH  EXPONENTIAL
             FITTING  IS DESIRED , FOR EXAMPLE  AN APPROXIMATION  OF THE
             MODULUS OF THE CENTRE OF THE LEFT HAND CLUSTER;
     PHI:    <ARITHMETIC EXPRESSION>;
             THE ARGUMENT  OF THE (COMPLEX) POINT  AT WHICH  EXPONENTIAL
             FITTING IS DESIRED;
             PHI SHOULD HAVE A VALUE FROM THE RANGE [PI/2,PI];
     DIAMETER: <ARITHMETIC EXPRESSION>;
             THE DIAMETER OF THE LEFT HAND CLUSTER;
     DERIVATIVE: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" DERIVATIVE(I,A); "INTEGER" I; "ARRAY" A;
             I ASSUMES THE VALUES 1,2,3 AND A IS A ONE-DIMENSIONAL ARRAY
             A[M0:M];
             WHEN  THIS  PROCEDURE  IS  CALLED , ARRAY  A  CONTAINS  THE
             COMPONENTS OF THE (I-1)-ST DERIVATIVE OF U  AT THE POINT T;
             UPON COMPLETION OF DERIVATIVE, ARRAY A SHOULD  CONTAIN  THE
             COMPONENTS  OF THE I-TH  DERIVATIVE  OF U AT  THE POINT  T;
     I:      <VARIABLE>;
             A JENSEN PARAMETER FOR PROCEDURE DERIVATIVE;
             MAY BE USED IN M0 AND M;
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 3
 
 
 
     K:      <VARIABLE>;
             INDICATES THE NUMBER OF INTEGRATION STEPS PERFORMED;
             ENTRY: K = 0;
             EXIT : THE NUMBER OF INTEGRATION STEPS PERFORMED;
     ALFA:   <ARITHMETIC EXPRESSION>;
             MAXIMAL GROWTH FACTOR FOR THE INTEGRATION STEP LENGTH;
     NORM:   <ARITHMETIC EXPRESSION>;
             IF NORM = 1 DISCREPANCY AND TOLERANCE ARE ESTIMATED IN  THE
             MAXIMUM NORM, OTHERWISE IN THE EUCLIDIAN NORM;
     AETA:   <ARITHMETIC EXPRESSION>;
             DESIRED  ABSOLUTE LOCAL ACCURACY ; AETA SHOULD BE POSITIVE;
     RETA:   <ARITHMETIC EXPRESSION>;
             DESIRED  RELATIVE LOCAL ACCURACY ; RETA SHOULD BE POSITIVE;
     ETA:    <VARIA2LE>;
             COMPUTED TOLERANCE;
     RHO:    <VARIABLE>;
             COMPUTED DISCREPANCY;
     HMIN:   <ARITHMETIC EXPRESSION>;
             MINIMAL STEPSIZE BY WHICH THE INTEGRATION IS PERFORMED;
             HOWEVER, A SMALLER STEP  WILL BE TAKEN  IF HMIN EXCEEDS THE
             STEPSIZE  HSTAB , PRESCRIBED  BY THE  STABILITY  CONDITIONS
             (SEE REF[2], FORMULA 6.12);
             IF HSTAB TENDS TO ZERO, THE PROCEDURE TERMINATES;
     HSTART: <VARIABLE>;
             ENTRY: THE INTITIAL STEPSIZE ; HOWEVER, IF K = 0  ON ENTRY,
                    THE VALUE OF HSTART IS NOT TAKEN INTO CONSIDERATION;
             EXIT:  A SUGGESTION  FOR THE STEPSIZE , IF  THE INTEGRATION
                    SHOULD BE CONTINUED FOR T>TE;
             HSTART MAY BE USED IN SUCCESSIVE CALLS OF THE PROCEDURE, IN
             ORDER TO OBTAIN THE SOLUTION IN SEVERAL POINTS TE1,TE2,ETC;
     OUTPUT: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" OUTPUT;
             THROUGH  THIS  PROCEDURE  THE VALUES AFTER EACH INTEGRATION
             STEP  OF  FOR INSTANCE  T, U, ETA AND RHO  ARE  ACCESSIBLE;
 
 
 DATA AND RESULTS:
 
     FOR FURTHER EXPLANATION OF THE PARAMETERS  SIGMA,PHI,DIAMETER,AETA,
     RETA,ETA,RHO,M0,M SEE REF[2];
     FOR RESULTS: SEE EXAMPLE OF USE AND REF[2];
 
 
 PROCEDURES USED:
 
     INIVEC = CP 31010;
     DUPVEC = CP 31030;
     VECVEC = CP 34010;
     ELMVEC = CP 34020;
     ZEROIN = CP 34150.
 
 
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 4
 
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: CIRCA 40 + 2 * (M - M0).
 
 
 RUNNING TIME:
 
     DEPENDS  STRONGLY  ON  THE  DIFFERENTIAL  EQUATION  TO  BE  SOLVED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE REFERENCES.
 
 
 REFERENCES:
 
     [1]. P.J. VAN DER HOUWEN.
          ONE-STEP METHODS FOR LINEAR INITIAL VALUE PROBLEMS II,
          POLYNOMIAL METHODS.
          TW REPORT 122, (1970) MATHEMATICAL CENTRE.
 
     [2]. P.J. VAN DER HOUWEN, P.BEENTJES, K.DEKKER AND E.SLAGT.
          ONE-STEP METHODS FOR LINEAR INITIAL VALUE PROBLEMS III,
          NUMERICAL EXAMPLES.
          TW REPORT 130, (1971) MATHEMATICAL CENTRE.
 
 
 EXAMPLE OF USE:
 
     THE  SOLUTION AT T=EXP(1) AND T=EXP(2) OF THE DIFFERENTIAL EQUATION
     DU/DT=-EXP(T)*(U-LN(T)) + 1/T WITH INITIAL CONDITION U(.01)=LN(.01)
     AND  ANALYTICAL SOLUTION U(T) = LN(T), MAY BE OBTAINED  AS FOLLOWS:
 
     "BEGIN" "INTEGER" I,K;
         "REAL" T,TE,TE1,TE2,RETA,ETA,RHO,PI,HS,EXPT,LNT,TIME,U0,U1,U2;
         "REAL" "ARRAY" U[0:0];
 
         "PROCEDURE" DERIVATIVE(I,U); "INTEGER" I; "ARRAY" U;
         "IF" I=1 "THEN" "BEGIN" EXPT:=EXP(T); LNT:=LN(T); U0:=U[0];
                                 U1:=U[0]:=EXPT*(LNT-U0)+1/T
                         "END" "ELSE"
         "IF" I=2 "THEN" U2:=U[0]:=EXPT*(LNT-U0-U1+1/T)-1/T/T
                  "ELSE" U[0]:=EXPT*(LNT-U0-2*U1-U2+2/T-1/T/T)+2/T/T/T;
 
         "PROCEDURE" OUT;
         "IF" T=TE "THEN" OUTPUT(61,"("6ZD,+3ZD.3DB3DB3D")",K,U[0]);
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 5
 
 
 
         "PROCEDURE" OUT1;
         OUTPUT(61,"("4BD"-D,3Z.3D,/")",RETA,CLOCK-TIME);
 
         OUTPUT(61,"(""("    THIS LINE AND THE FOLLOWING TEXT IS ")"
         "("PRINTED BY THIS PROGRAM")",//,
         "("    THE RESULTS WITH EFT ARE -CONFER REF[2]- :")",/,
         "("     K        U(TE1)         K        U(TE2)")"
         "("        RETA   TIME")",/")");
         PI:=4*ARCTAN(1); TE1:=EXP(1); TE2:=EXP(2);
         "FOR" RETA:="-1,"-2,"-3,"-4 "DO"
         "BEGIN" T:=.01; U[0]:=LN(T); K:=0; HS:=0; TIME:=CLOCK;
             "FOR" TE:=TE1,TE2 "DO"
             EXPONENTIALLY FITTED TAYLOR
               (T,TE,0,0,U,EXP(T),PI,2*EXP(2*T/3),DERIVATIVE,I,K,1.5,2,
             RETA/10,RETA,ETA,RHO,"-4,HS,OUT); OUT1
         "END";
 
         OUTPUT(61,"("//,"("    WITH RELAXED ACCURACY CONDITIONS FOR ")"
         "("T>3:")",/,"("     K        U(TE1)         K        U(TE2)")"
         "("        RETA   TIME")",/")");
         "FOR" RETA:="-1,"-2,"-3,"-4 "DO"
         "BEGIN" T:=.01; U[0]:=LN(T); K:=0; HS:=0; TIME:=CLOCK;
             "FOR" TE:=TE1,TE2 "DO"
             EXPONENTIALLY FITTED TAYLOR
               (T,TE,0,0,U,EXP(T),PI,2*EXP(2*T/3),DERIVATIVE,I,K,1.5,2,
                 RETA/10*("IF" T<3 "THEN" 1 "ELSE" EXP(2*(T-3))),
                 RETA*("IF" T<3 "THEN" 1 "ELSE" EXP(2*(T-3))),
                 ETA,RHO,"-4,HS,OUT); OUT1
         "END"
     "END"
 
     THIS LINE AND THE FOLLOWING TEXT IS PRINTED BY THIS PROGRAM
 
     THE RESULTS WITH EFT ARE -CONFER REF[2]- :
      K        U(TE1)         K        U(TE2)        RETA   TIME
      15   +1.003 845 001     42   +2.000 076 417    1"-1   .938
      22   +1.001 211 286     52   +2.000 066 067    1"-2  1.121
      36   +1.000 108 738     92   +2.000 020 495    1"-3  1.872
      56   +1.000 045 271    171   +2.000 000 925    1"-4  3.493
 
 
     WITH RELAXED ACCURACY CONDITIONS FOR T>3:
      K        U(TE1)         K        U(TE2)        RETA   TIME
      15   +1.003 845 001     42   +2.000 076 417    1"-1  1.037
      22   +1.001 211 286     50   +2.000 049 978    1"-2  1.154
      36   +1.000 108 738     68   +2.000 023 330    1"-3  1.419
      56   +1.000 045 271     98   +2.000 065 056    1"-4  2.008
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 6
 
 
 
 SOURCE TEXT(S):
0"CODE" 33050;
 "PROCEDURE" EXPONENTIALLY FITTED TAYLOR(T,TE,M0,M,U,SIGMA,PHI,DIAMETER,
         DERIVATIVE,I,K,ALFA,NORM,AETA,RETA,ETA,RHO,HMIN,HSTART,OUTPUT);
 "INTEGER" M0,M,I,K,NORM;
 "REAL" T,TE,SIGMA,PHI,DIAMETER,ALFA,AETA,RETA,ETA,RHO,HMIN,HSTART;
 "ARRAY" U;
 "PROCEDURE" DERIVATIVE,OUTPUT;
 "BEGIN" "INTEGER" KL;
     "REAL" Q,EC0,EC1,EC2,H,HI,H0,H1,H2,BETAN,T2,SIGMAL,PHIL;
     "REAL" "ARRAY" C,RO[M0:M],BETA,BETHA[1:3];
     "BOOLEAN" LAST,START;
 
     "PROCEDURE" COEFFICIENT;
     "BEGIN" "REAL" B,B1,B2,BB,E,BETA2,BETA3;
         B:=H*SIGMAL; B1:=B*COS(PHIL); BB:=B*B;
         "IF" ABS(B)<"-3 "THEN"
         "BEGIN" BETA2:=.5-BB/24;
             BETA3:=1/6+B1/12;
             BETHA[3]:=.5+B1/3
         "END" "ELSE"
         "IF" B1<-40 "THEN"
         "BEGIN" BETA2:=(-2*B1-4*B1*B1/BB+1)/BB;
             BETA3:=(1+2*B1/BB)/BB;
             BETHA[3]:=1/BB
         "END" "ELSE"
         "BEGIN" E:=EXP(B1)/BB; B2:=B*SIN(PHIL);
             BETA2:=(-2*B1-4*B1*B1/BB+1)/BB;
             BETA3:=(1+2*B1/BB)/BB;
             "IF" ABS(B2/B)<"-5 "THEN"
             "BEGIN" BETA2:=BETA2-E*(B1-3);
                 BETA3:=BETA3+E*(B1-2)/B1;
                 BETHA[3]:=1/BB+E*(B1-1)
             "END" "ELSE"
             "BEGIN" BETA2:=BETA2-E*SIN(B2-3*PHIL)/B2*B;
                 BETA3:=BETA3+E*SIN(B2-2*PHIL)/B2;
                 BETHA[3]:=1/BB+E*SIN(B2-PHIL)/B2*B;
             "END"
         "END";
         BETA[1]:=BETHA[1]:=1;
         BETA[2]:=BETA2; BETA[3]:=BETA3;
         BETHA[2]:=1-BB*BETA3; B:=ABS(B);
         Q:="IF" B<1.5 "THEN" 4-2*B/3 "ELSE" "IF" B<6 "THEN" (30-2*B)/9
         "ELSE" 2;
     "END";                                                    "COMMENT"
 
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 7
                                                                  ;
 
 
     "REAL" "PROCEDURE" NORMFUNCTION(NORM,W);
     "INTEGER" NORM; "ARRAY" W;
     "BEGIN" "INTEGER" J; "REAL" S,X;
         S:=0;
         "IF" NORM=1 "THEN"
         "BEGIN" "FOR" J:=M0 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" X:=ABS(W[J]); "IF" X>S "THEN" S:=X "END"
         "END" "ELSE"
         S:=SQRT(VECVEC(M0,M,0,W,W));
         NORMFUNCTION:=S;
     "END";
 
     "PROCEDURE" LOCAL ERROR BOUND;
     ETA:=AETA+RETA * NORMFUNCTION(NORM,U);
 
     "PROCEDURE" LOCAL ERROR CONSTRUCTION(I); "INTEGER" I;
     "BEGIN" "IF" I=1 "THEN" INIVEC(M0,M,RO,0);
         "IF" I<4 "THEN" ELMVEC(M0,M,0,RO,C,BETHA[I]*HI);
         "IF" I=4 "THEN"
         "BEGIN" ELMVEC(M0,M,0,RO,C,-H);
             RHO:=NORMFUNCTION(NORM,RO);
             EC0:=EC1;EC1:=EC2;EC2:=RHO/H**Q;
         "END"
     "END";
 
     "PROCEDURE" STEPSIZE;
     "BEGIN" "REAL" HACC,HSTAB,HCR,HMAX,A,B,C;
         "IF" "NOT" START "THEN" LOCAL ERROR BOUND;
         "IF" START "THEN"
         "BEGIN" H1:=H2:=HACC:=HSTART;
             EC2:=EC1:=1; KL:=1; START:="FALSE"
         "END" "ELSE"
         "IF" KL<3 "THEN"
         "BEGIN" HACC:=(ETA/RHO)**(1/Q)*H2;
             "IF" HACC>10*H2 "THEN" HACC:=10*H2 "ELSE" KL:=KL+1
         "END" "ELSE"
         "BEGIN" A:=(H0*(EC2-EC1)-H1*(EC1-EC0))/(H2*H0-H1*H1);
             H:=H2*("IF" ETA<RHO "THEN" (ETA/RHO)**(1/Q) "ELSE" ALFA);
             "IF" A>0 "THEN"
             "BEGIN" B:=(EC2-EC1-A*(H2-H1))/H1;
                 C:=EC2-A*H2-B*T2; HACC:=0; HMAX:=H;
                 "IF" ^ZEROIN(HACC,H,HACC**Q*(A*HACC+B*T+C)-ETA,
                 "-3*H2) "THEN" HACC:=HMAX
             "END" "ELSE" HACC:=H;
             "IF" HACC<.5*H2 "THEN" HACC:=.5*H2;
         "END";
         "IF" HACC<HMIN "THEN" HACC:=HMIN; H:=HACC;            "COMMENT"
1SECTION : 5.2.1.1.1.3.B      (AUGUST 1974)                       PAGE 8
                                                                  ;
 
 
         "IF" H*SIGMAL>1 "THEN"
         "BEGIN" A:=ABS(DIAMETER/SIGMAL+"-14)/2; B:=2*ABS(SIN(PHIL));
             BETAN:=("IF" A>B "THEN" 1/A "ELSE" 1/B)/A;
             HSTAB:=ABS(BETAN/SIGMAL);
             "IF" HSTAB<"-14*T "THEN" "GOTO" ENDOFEFT;
             "IF" H>HSTAB "THEN" H:=HSTAB
         "END";
         HCR:=H2*H2/H1;
         "IF" KL>2 "AND" ABS(H-HCR)<"-6*HCR "THEN"
         H:="IF" H<HCR "THEN" HCR*(1-"-7) "ELSE" HCR*(1+"-7);
         "IF" T+H>TE "THEN"
         "BEGIN" LAST:="TRUE"; HSTART:=H; H:=TE-T "END";
         H0:=H1;H1:=H2;H2:=H;
     "END";
 
     "PROCEDURE" DIFFERENCE SCHEME;
     "BEGIN" HI:=1; SIGMAL:=SIGMA; PHIL:=PHI;
         STEPSIZE;
         COEFFICIENT;
         "FOR" I:=1,2,3 "DO"
         "BEGIN" HI:=HI*H;
             "IF" I>1 "THEN" DERIVATIVE(I,C);
             LOCALERRORCONSTRUCTION(I);
             ELMVEC(M0,M,0,U,C,BETA[I]*HI)
         "END";
         T2:=T; K:=K+1;
         "IF" LAST "THEN"
         "BEGIN" LAST:="FALSE"; T:=TE; START:="TRUE"
         "END" "ELSE" T:=T+H;
         DUPVEC(M0,M,0,C,U);
         DERIVATIVE(1,C);
         LOCALERRORCONSTRUCTION(4);
         OUTPUT;
     "END";
 
     START:="TRUE"; LAST:="FALSE";
     DUPVEC(M0,M,0,C,U);
     DERIVATIVE(1,C);
     "IF" K=0 "THEN"
     "BEGIN" LOCAL ERROR BOUND; HSTART:=ETA/NORMFUNCTION(NORM,C)
     "END";
 NEXT LEVEL:
     DIFFERENCE SCHEME;
     "IF" T^=TE "THEN" "GOTO" NEXT LEVEL;
 ENDOFEFT:
  "END" EXPONENTIAL FITTED TAYLOR;
         "EOP"
