1SECTION : 1.1.1              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR:     P.A.BEENTJES.
 
 
 INSTITUTE:  MATHEMATICAL CENTRE.
 
 
 RECEIVED:   730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FIVE PROCEDURES.
     INIVEC  INITIALIZES  A  ( PART  OF  A )  VECTOR  WITH  A  CONSTANT.
     INIMAT  INITIALIZES  A  ( PART  OF  A )  MATRIX  WITH  A  CONSTANT.
     INIMATD INITIALIZES ELEMENTS A[I, I+SHIFT], I= LR(1)UR OF A MATRIX.
     INISYMD INITIALIZES A (PART OF A) CODIAGONAL OF A SYMMETRIC MATRIX,
     WHOSE UPPERTRIANGLE  IS  STORED  COLUMNWISE  IN  A  ONE-DIMENSIONAL
     ARRAY.
     INISYMROW INITIALIZES A (PART OF A) ROW OF A SYMMETRIC MATRIX,WHOSE
     UPPERTRIANGLE  IS STORED  COLUMNWISE  IN A  ONE-DIMENSIONAL  ARRAY.
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     INITIALIZATION.
 
 
 SUBSECTION: INIVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" INIVEC(L, U, A, X); "VALUE" L,U,X;
     "INTEGER" L,U; "REAL" X; "ARRAY" A;
     "CODE" 31010;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER  AND  UPPER  INDEX  OF  THE  VECTOR  A, RESPECTIVELY;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], THE ARRAY TO BE INITIALIZED;
     X:      <ARITHMETIC EXPRESSION>;
             INITIALIZATION CONSTANT.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.1              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: INIMAT.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" INIMAT(LR, UR, LC, UC, A, X); "VALUE" LR,UR,LC,UC,X;
     "INTEGER" LR,UR,LC,UC; "REAL" X; "ARRAY" A;
     "CODE" 31011;
 
     FORMAL PARAMETERS:
     LR,UR,LC,UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER ROW-INDEX, AND LOWER AND UPPER COLUMN-INDEX
             OF THE MATRIX A, RESPECTIVELY;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR : UR, LC : UC], THE ARRAY TO BE INITIALIZED;
     X:      <ARITHMETIC EXPRESSION>;
             INITIALIZATION CONSTANT.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: INIMATD.
 
 
 CALLING SEQUENCE:
     HEADING:
     "PROCEDURE" INIMATD(LR, UR, SHIFT, A, X); "VALUE" LR,UR,SHIFT,X;
     "INTEGER" LR,UR,SHIFT; "REAL" X; "ARRAY" A;
     "CODE" 31012;
 
     FORMAL PARAMETERS:
     LR,UR:  <ARITHMETIC EXPRESSION>;
             LOWER   AND   UPPER  ROW-INDEX  OF  THE  CODIAGONAL  TO  BE
             INITIALIZED;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             DISTANCE BETWEEN DIAGONAL AND CODIAGONAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR : UR, LR + SHIFT : UR + SHIFT],  THE  ARRAY TO
             BE INITIALIZED;
     X:      <ARITHMETIC EXPRESSION>;
             INITIALIZATION CONSTANT.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.1              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: INISYMD.
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" INISYMD(LR, UR, SHIFT, A, X); "VALUE" LR,UR,SHIFT,X;
     "INTEGER" LR,UR,SHIFT; "REAL" X; "ARRAY" A;
     "CODE" 31013;
 
     FORMAL PARAMETERS:
     LR,UR:  <ARITHMETIC EXPRESSION>;
             LOWER  AND  UPPER ROW-INDEX  OF  AN UPPER CODIAGONAL ( OF A
             SYMMETRIC MATRIX OF ORDER N ) TO BE INITIALIZED;
             LR AND UR SHOULD SATISFY : LR >= 1, UR <= N;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             DISTANCE BETWEEN DIAGONAL AND CODIAGONAL, (0 =< SHIFT < N);
     A:      <ARRAY IDENTIFIER>;
             A ONE-DIMENSIONAL ARRAY A[1 : N * (N+1)//2]  CONTAINING THE
             COLUMNWISE  STORED  UPPERTRIANGLE  OF  A  SYMMETRIC MATRIX,
             SUCH  THAT  THE (I,J) - TH  ELEMENT  OF  THE  MATRIX  IS
             A[ (J-1) * J//2 + I ]; J = 1,...,N; I = 1,...,J;
     X:      <ARITHMETIC EXPRESSION>;
             INITIALIZATION CONSTANT.
 
 LANGUAGE:   ALGOL 60.
 
 
 SUBSECTION: INISYMROW.
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" INISYMROW(L, U, I, A, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A;
     "CODE" 31014;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER INDEX OF ROW-ELEMENT TO BE INITIALIZED;
     I:      <ARITHMETIC EXPRESSION>;
             ROW INDEX;
     A:      <ARRAY IDENTIFIER>;
             A ONE-DIMENSIONAL ARRAY A[1 : N * (N+1)//2];
             ARRAY A SHOULD CONTAIN A COLUMNWISE STORED UPPERTRIANGLE OF
             A SYMMETRIC MATRIX OF ORDER N,
             SUCH  THAT  THE (I,J) - TH  ELEMENT  OF  THE  MATRIX  IS
             A[ (J - 1) * J//2 + I ]; J = 1, ... ,N; I = 1, ... ,J.
             FOR FIXED ORDER N, THE PARAMETERS L, U AND I SHOULD
             SATISFY THE CONDITIONS :  1 <=L<= N, 1 <=U<= N, 1 <=I<= N ;
     X:      <ARITHMETIC EXPRESSION>;
             INITIALIZATION CONSTANT.
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION : 1.1.1              (DECEMBER 1979)                     PAGE 4
 
 
 
 SOURCE TEXT(S):
 
 THE PROCEDURES INIVEC,  INIMAT AND INIMATD ARE WRITTEN IN  COMPASS,  AN
 EQUIVALENT ALGOL 60 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
 
 
 "CODE" 31010;
     "PROCEDURE" INIVEC(L, U, A, X); "VALUE" L,U,X;
     "INTEGER" L,U; "REAL" X; "ARRAY" A;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= X;
         "EOP"
 
 "CODE" 31011;
     "PROCEDURE" INIMAT(LR, UR, LC, UC, A, X); "VALUE" LR,UR,LC,UC,X;
     "INTEGER" LR,UR,LC,UC; "REAL" X; "ARRAY" A;
     "BEGIN" "INTEGER" J;
 
         "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
         "FOR" J:= LC "STEP" 1 "UNTIL" UC "DO" A[LR, J]:= X
     "END" INIMAT;
         "EOP"
 
 "CODE" 31012;
     "PROCEDURE" INIMATD(LR, UR, SHIFT, A, X); "VALUE" LR,UR,SHIFT,X;
     "INTEGER" LR,UR,SHIFT; "REAL" X; "ARRAY" A;
     "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO" A[LR, LR + SHIFT]:= X;
         "EOP"
 
 "CODE" 31013;
     "PROCEDURE" INISYMD(LR, UR, SHIFT, A, X); "VALUE" LR,UR,SHIFT,X;
     "INTEGER" LR,UR,SHIFT; "REAL" X; "ARRAY" A;
     "BEGIN" SHIFT:= ABS(SHIFT); UR:= UR + SHIFT + 1; SHIFT:=LR + SHIFT;
         LR := (SHIFT - 3) * SHIFT // 2 + LR;
         "FOR" LR := SHIFT + LR "WHILE" SHIFT < UR "DO"
         "BEGIN" A[LR]:= X; SHIFT:= SHIFT + 1 "END"
     "END" INISYMD;
         "EOP"
 
 "CODE" 31014;
     "PROCEDURE" INISYMROW(L, U, I, A, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A;
     "BEGIN" "INTEGER" K;
         "IF" L <= I "THEN"
         "BEGIN" K:= (I - 1) * I//2; L := K + L;
             K := ("IF" U < I "THEN" U "ELSE" I) + K;
             "FOR" L:= L "STEP" 1 "UNTIL" K "DO" A[L]:= X;
             L := I + 1
         "END";
         "IF" U>I "THEN""FOR" K:=(L-1)*L//2+I, K+L-1 "WHILE" L<= U "DO"
         "BEGIN" A[K]:= X; L:= L + 1 "END"
     "END" INISYMROW;
         "EOP"
1SECTION : 1.1.2              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR:     P.A.BEENTJES.
 
 
 INSTITUTE:  MATHEMATICAL CENTRE.
 
 
 RECEIVED:   730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS SIX PROCEDURES.
     DUPVEC COPIES THE VECTOR GIVEN IN ARRAY B[L+SHIFT : U+SHIFT] TO THE
     VECTOR GIVEN IN ARRAY A[L:U].
     DUPVECROW COPIES THE ROW VECTOR GIVEN IN ARRAY  B[I:I, L:U]  TO THE
     VECTOR GIVEN IN ARRAY A[L:U].
     DUPROWVEC COPIES THE VECTOR GIVEN IN ARRAY B[L:U] TO THE ROW VECTOR
     GIVEN IN ARRAY A[I:I, L:U].
     DUPVECCOL  COPIES THE COLUMN VECTOR GIVEN IN ARRAY  B[L:U, J:J]  TO
     THE VECTOR GIVEN IN ARRAY A[L:U].
     DUPCOLVEC  COPIES THE VECTOR GIVEN IN ARRAY  B[L:U]  TO THE  COLUMN
     VECTOR GIVEN IN ARRAY A[L:U, J:J].
     DUPMAT  COPIES THE MATRIX GIVEN IN ARRAY  B[L:U, I:J] TO THE MATRIX
     GIVEN IN ARRAY A[L:U, I:J].
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     DUPLICATION.
 
 
 SUBSECTION: DUPVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPVEC(L, U, SHIFT, A, B); "VALUE" L,U,SHIFT;
     "INTEGER" L,U,SHIFT; "ARRAY" A,B;
     "CODE" 31030;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER VECTOR-INDEX, RESPECTIVELY;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L + SHIFT : U + SHIFT],   B  IS  COPIED
             INTO A.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.2              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: DUPVECROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPVECROW(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "CODE" 31031;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER   AND   UPPER  VECTOR ( COLUMN )-INDEX, RESPECTIVELY;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[I : I, L : U], B IS COPIED INTO A.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: DUPROWVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPROWVEC(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "CODE" 31032;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER   AND   UPPER  VECTOR ( COLUMN )-INDEX, RESPECTIVELY;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[L : U], B IS COPIED INTO A.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.2              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: DUPVECCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPVECCOL(L, U, J, A, B); "VALUE" L,U,J;
     "INTEGER" L,U,J; "ARRAY" A,B;
     "CODE" 31033;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER   AND   UPPER   VECTOR ( ROW )-INDEX,   RESPECTIVELY;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L : U, I : I], B IS COPIED INTO A.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: DUPCOLVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPCOLVEC(L, U, J, A, B); "VALUE" L,U,J;
     "INTEGER" L,U,J; "ARRAY" A,B;
     "CODE" 31034;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER   AND   UPPER   VECTOR ( ROW )-INDEX,   RESPECTIVELY;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U], B IS COPIED INTO A.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.2              (DECEMBER 1979)                     PAGE 4
 
 
 
 SUBSECTION: DUPMAT.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" DUPMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A,B;
     "CODE" 31035;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER ROW-INDEX, RESPECTIVELY;
     I,J:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER COLUMN-INDEX, RESPECTIVELY;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : J], B[L : U, I : J],  B IS COPIED INTO
             A.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.2              (DECEMBER 1979)                     PAGE 5
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
 
 
 "CODE" 31030;
     "PROCEDURE" DUPVEC(L, U, SHIFT, A, B); "VALUE" L,U,SHIFT;
     "INTEGER" L,U,SHIFT; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= B[L+SHIFT];
         "EOP"
 
 "CODE" 31031;
     "PROCEDURE" DUPVECROW(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= B[I,L];
         "EOP"
 
 "CODE" 31032;
     "PROCEDURE" DUPROWVEC(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= B[L];
         "EOP"
 
 "CODE" 31033;
     "PROCEDURE" DUPVECCOL(L, U, J, A, B); "VALUE" L,U,J;
     "INTEGER" L,U,J; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= B[L,J];
         "EOP"
 
 "CODE" 31034;
     "PROCEDURE" DUPCOLVEC(L, U, J, A, B); "VALUE" L,U,J;
     "INTEGER" L,U,J; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,J]:= B[L];
         "EOP"
 
 "CODE" 31035;
     "PROCEDURE" DUPMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A,B;
     "BEGIN" "INTEGER" K;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "FOR" K:= I "STEP" 1 "UNTIL" J "DO" A[L,K]:= B[L,K]
     "END" DUPMAT;
         "EOP"
1SECTION : 1.1.3              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHORS:    P.A.BEENTJES, C.G. VAN DER LAAN.
 
 
 INSTITUTE:  MATHEMATICAL CENTRE.
 
 
 RECEIVED:   730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FIVE PROCEDURES.
     MULVEC STORES X TIMES THE VECTOR GIVEN IN ARRAY  B[L+SHIFT:U+SHIFT]
     INTO THE VECTOR GIVEN IN ARRAY A[L:U].
     MULROW STORES X TIMES THE ROW VECTOR GIVEN IN ARRAY B[J:J,L:U] INTO
     THE ROW VECTOR GIVEN IN ARRAY A[I:I,L:U].
     MULCOL STORES X TIMES THE COLUMN VECTOR  GIVEN IN ARRAY  B[L:U,J:J]
     INTO THE COLUMN VECTOR GIVEN IN ARRAY A[L:U,I:I].
     COLCST MULTIPLIES THE COLUMN VECTOR GIVEN IN ARRAY A[L:U,J:J] BY X.
     ROWCST MULTIPLIES THE ROW VECTOR GIVEN IN ARRAY A[I:I,L:U] BY X.
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     MULTIPLICATIONS.
 
 
 SUBSECTION: MULVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" MULVEC(L, U, SHIFT, A, B, X); "VALUE" L,U,SHIFT,X;
     "INTEGER" L,U,SHIFT; "REAL" X; "ARRAY" A,B;
     "CODE" 31020;
 
     FORMAL PARAMETERS:
     L,U:    <ARITMETIC EXPRESSION>;
             LOWER AND UPPER VECTOR-INDEX, RESPECTIVELY;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             SUBSCRIPT-SHIFTING PARAMETER;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L + SHIFT : U + SHIFT],  THE PRODUCT OF
             THE CONTENTS OF B ARE STORED IN A.
     X:      <ARITHMETIC EXPRESSION>;
             MULTIPLICATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.3              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: MULROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" MULROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 31021;
 
     FORMAL PARAMETERS:
     L,U:    <ARITMETIC EXPRESSION>;
             LOWER AND UPPER COLUMN-INDEX, RESPECTIVELY;
     I,J:    <ARITHMETIC EXPRESSION>;
             ROW-INDICES OF THE ROW VECTORS A AND B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[J : J, L : U], THE CONTENTS OF B
             MULTIPLIED BY X ARE STORED INTO A.
     X:      <ARITHMETIC EXPRESSION>;
             MULTIPLICATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: MULCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" MULCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 31022;
 
     FORMAL PARAMETERS:
     L,U:    <ARITMETIC EXPRESSION>;
             LOWER AND UPPER ROW-INDEX, RESPECTIVELY;
     I,J:    <ARITHMETIC EXPRESSION>;
             COLUMN-INDICES OF THE COLUMN VECTORS A AND B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U, J : J], THE CONTENTS OF B
             MULTIPLIED BY X ARE STORED INTO A;
     X:      <ARITHMETIC EXPRESSION>;
             MULTIPLICATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.3              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: COLCST.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" COLCST(L, U, J, A, X); "VALUE" L,U,J,X;
     "INTEGER" L,U,J; "REAL" X; "ARRAY" A;
     "CODE" 31131;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER ROW-INDEX, RESPECTIVELY;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, J : J];
     X:      <ARITHMETIC EXPRESSION>;
             MULTIPLICATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ROWCST.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ROWCST(L, U, I, A, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A;
     "CODE" 31132;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER COLUMN-INDEX, RESPECTIVELY;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U];
     X:      <ARITHMETIC EXPRESSION>;
             MULTIPLICATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.3              (DECEMBER 1979)                     PAGE 4
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
 
 
 "CODE" 31020;
     "PROCEDURE" MULVEC(L, U, SHIFT, A, B, X); "VALUE" L,U,SHIFT,X;
     "INTEGER" L,U,SHIFT; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= B[L+SHIFT]*X;
         "EOP"
 
 "CODE" 31021;
     "PROCEDURE" MULROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= B[J,L]*X;
         "EOP"
 
 "CODE" 31022;
     "PROCEDURE" MULCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,I]:= B[L,J]*X;
         "EOP"
 
 "CODE" 31131;
     "PROCEDURE" COLCST(L, U, J, A, X); "VALUE" L,U,J,X;
     "INTEGER" L,U,J; "REAL" X; "ARRAY" A;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,J]:= A[L,J] * X;
         "EOP"
 
 "CODE" 31132;
     "PROCEDURE" ROWCST(L, U, I, A, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= A[I,L] * X;
         "EOP"
1SECTION : 1.1.4.1            (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHORS:        T.J.DEKKER, J.C.P.BUS, J.WOLLESWINKEL.
 
 
 CONTRIBUTORS:   P.A.BEENTJES, J.C.P.BUS.
 
 
 INSTITUTE:      MATHEMATICAL CENTRE.
 
 
 RECEIVED:       741215.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS NINE PROCEDURES.
     VECVEC:= SCALAR PRODUCT OF  THE VECTOR  GIVEN  IN  ARRAY A[L:U] AND
     ARRAY B[SHIFT + L : SHIFT + U].
     MATVEC:= SCALAR PRODUCT OF THE ROW VECTOR GIVEN IN ARRAY A[I:I,L:U]
     AND THE VECTOR GIVEN IN ARRAY B[L:U].
     TAMVEC:= SCALAR  PRODUCT  OF  THE  COLUMN  VECTOR  GIVEN  IN  ARRAY
     A[L:U, I:I] AND THE VECTOR GIVEN IN ARRAY B[L:U].
     MATMAT:= SCALAR PRODUCT OF THE ROW VECTOR GIVEN IN ARRAY A[I:I,L:U]
     AND THE COLUMN VECTOR IN ARRAY B[L:U, J:J].
     TAMMAT:= SCALAR  PRODUCT  OF  THE  COLUMN VECTORS  GIVEN  IN  ARRAY
     A[L:U, I:I] AND ARRAY B[L:U, J:J].
     MATTAM :=  SCALAR  PRODUCT  OF  THE  ROW  VECTORS  GIVEN  IN  ARRAY
     A[I:I,L:U] AND ARRAY B[J:J, L:U].
     SEQVEC :=  SCALAR   PRODUCT   OF   THE   VECTORS   GIVEN  IN  ARRAY
     A[IL : IL + (U+L-1)*(U-L)//2]  AND ARRAY  B[SHIFT + L : SHIFT + U],
     WHERE THE ELEMENTS OF  THE FIRST VECTOR ARE  A[IL+(J+L-1)*(J-L)//2]
     FOR J = L, ..., U.
     SCAPRD1:=  SCALAR   PRODUCT   OF   THE   VECTORS   GIVEN  IN  ARRAY
     A[MIN(LA, LA + (N - 1) * SA) : MAX(LA,LA + (N - 1) * SA)] AND ARRAY
     B[MIN(LB, LB + (N - 1) * SB) : MAX(LB,LB + (N - 1) * SB)] WHERE THE
     ELEMENTS  OF  THE  VECTORS  ARE  A[LA+(J-1)*SA] AND  B[LB+(J-1)*SB]
     FOR J = 1, ..., N.
     SYMMATVEC := THE SCALARPRODUCT OF ( A PART OF ) A VECTOR AND
     ( A PART OF ) A ROW OF A SYMMETRIC MATRIX , WHOSE  UPPERTRIANGLE IS
     GIVEN COLUMNWISE IN AN ONE-DIMENSIONAL ARRAY.
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     SCALAR PRODUCTS.
1SECTION : 1.1.4.1            (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: VECVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" VECVEC(L, U, SHIFT, A, B); "VALUE" L,U,SHIFT;
     "INTEGER" L,U,SHIFT; "ARRAY" A,B;
     "CODE" 34010;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER OF THE VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L + SHIFT : U + SHIFT].
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: MATVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" MATVEC(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "CODE" 34011;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[L : U].
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.4.1            (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: TAMVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" TAMVEC(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "CODE" 34012;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U].
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: MATMAT.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" MATMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A,B;
     "CODE" 34013;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             ROW-INDEX  OF  THE ROW VECTOR  A  AND  COLUMN-INDEX  OF THE
             COLUMN VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[L : U, J : J].
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.4.1            (DECEMBER 1979)                     PAGE 4
 
 
 
 SUBSECTION: TAMMAT.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" TAMMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A,B;
     "CODE" 34014;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             COLUMN-INDICES OF THE COLUMN VECTORS A AND B, RESPECTIVELY;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U, J : J].
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: MATTAM.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" MATTAM(L, U, I, J, A, B); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A,B;
     "CODE" 34015;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             ROW-INDICES  OF  THE  ROW VECTORS  A  AND  B, RESPECTIVELY;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[J : J, L : U].
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.4.1            (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: SEQVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" SEQVEC(L, U, IL, SHIFT, A, B);
     "VALUE" L, U, IL, SHIFT; "INTEGER" L, U, IL, SHIFT; "ARRAY" A, B;
     "CODE" 34016;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     IL:     <ARITHMETIC EXPRESSION>;
             LOWER BOUND OF THE VECTOR A;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER OF THE VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q], B[L + SHIFT, U + SHIFT];
             THE VALUES OF P AND  Q  SHOULD  SATISFY  P <= IL  AND  Q >=
             IL+(U+L-1)*(U-L)//2).
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: SCAPRD1.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "REAL" "PROCEDURE" SCAPRD1(LA, SA, LB, SB, N, A, B);
     "VALUE" LA,SA,LB,SB,N; "INTEGER" LA,SA,LB,SB,N; "ARRAY" A,B;
     "CODE" 34017;
 
     FORMAL PARAMETERS:
     N:      <ARITHMETIC EXPRESSION>;
             UPPER BOUND OF THE RUNNING SUBSCRIPT;
     LA,LB:  <ARITHMETIC EXPRESSION>;
             LOWER   BOUNDS   OF   THE VECTORS  A  AND  B, RESPECTIVELY;
     SA,SB:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING   PARAMETERS   OF   THE  VECTORS  A  AND  B,
             RESPECTIVELY;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q], B[R : S];
             THE SUBSCRIPTS ABOVE AND THE VALUES OF LA( +(J-1)*SA )  AND
             LB( +(J-1)*SB ),J = 1(1)N SHOULD NOT CONTRADICT EACH OTHER.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.4.1            (MARCH 1977)                        PAGE 6
 
 
 
 SUBSECTION: SYMMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" SYMMATVEC(L, U, I, A, B); "VALUE" L,U,I;
     "INTEGER" L,U,I; "ARRAY" A,B;
     "CODE" 34018;
 
 
     SYMMATVEC:= THE VALUE OF THE SCALAR PRODUCT OF THE VECTORS GIVEN
                 IN  ARRAY A[P:Q] AND  ARRAY B[L:U] , WHERE THE ELEMENTS
                 OF THE FIRST VECTOR ARE: IF L<I THEN A[(I-1)*I//2 + J],
                 J=L,..., MIN(U, I-1) AND A[(J-1)*J//2 + I], J=I,..., U,
                 RESPECTIVELY , OTHERWISE A[(J-1)*J//2 + I], J=L,..., U.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE VECTOR B, RESPECTIVELY; L >=1;
     I:      <ARITHMETIC EXPRESSION>;
             ROW INDEX OF THE MATRIX A; I >= 1;
     A:      <ARRAY IDENTIFIER>;
             A  ONE-DIMENSIONAL  ARRAY  A[P : Q]  WITH:  IF  I > L  THEN
             P=(I-1)*I//2 + L ELSE  P=(L-1)*L//2 + I AND IF  I > U  THEN
             Q=(I-1)*I//2 + U ELSE  Q=(U-1)*U//2 + I;
     B:      <ARRAY IDENTIFIER>;
             A ONE-DIMENSIONAL ARRAY B[L:U];
 
 
 PROCEDURES USED:
 
            VECVEC = CP34010,
            SEQVEC = CP34016.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
            SEE REFERENCE [2].
 
 REFERENCES :
 
        [1]  T.J.DEKKER.
             ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA,PART 1,
             MATHEMATICAL CENTRE TRACT 22,AMSTERDAM (1970)
        [2]  J.C.P.BUS.
             MINIMALISERING VAN FUNCTIES VAN MEERDERE VARIABELEN,
             MATHEMATICAL CENTRE, NR 29/72,AMSTERDAM (1972)
1SECTION : 1.1.4.1            (DECEMBER 1979)                     PAGE 7
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES,  EXCEPT FOR SYMMATVEC ARE WRITTEN IN COMPASS,
 AN EQUIVALENT ALGOL 60 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
0"CODE" 34010;
    "REAL" "PROCEDURE" VECVEC(L, U, SHIFT, A, B); "VALUE" L,U,SHIFT;
    "INTEGER" L,U,SHIFT; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[K] * B[SHIFT + K] + S;
        VECVEC:= S
    "END" VECVEC;
        "EOP"
0"CODE" 34011;
    "REAL" "PROCEDURE" MATVEC(L, U, I, A, B); "VALUE" L,U,I;
    "INTEGER" L,U,I; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[I,K] * B[K] + S;
        MATVEC:= S
    "END" MATVEC;
        "EOP"
0"CODE" 34012;
    "REAL" "PROCEDURE" TAMVEC(L, U, I, A, B); "VALUE" L,U,I;
    "INTEGER" L,U,I; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[K,I] * B[K] + S;
        TAMVEC:= S
    "END" TAMVEC;
        "EOP"
0"CODE" 34013;
    "REAL" "PROCEDURE" MATMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
    "INTEGER" L,U,I,J; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[I,K] * B[K,J] + S;
        MATMAT:= S
    "END" MATMAT
1SECTION : 1.1.4.1            (DECEMBER 1975)                     PAGE 8
 
 
 
                                                                   ;
        "EOP"
0"CODE" 34014;
    "REAL" "PROCEDURE" TAMMAT(L, U, I, J, A, B); "VALUE" L,U,I,J;
    "INTEGER" L,U,I,J; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[K,I] * B[K,J] + S;
        TAMMAT:= S
    "END" TAMMAT;
        "EOP"
0"CODE" 34015;
    "REAL" "PROCEDURE" MATTAM(L, U, I, J, A, B); "VALUE" L,U,I,J;
    "INTEGER" L,U,I,J; "ARRAY" A,B;
    "BEGIN" "INTEGER" K; "REAL" S;
        S:= 0;
        "FOR" K:=L "STEP" 1 "UNTIL" U "DO" S:= A[I,K] * B[J,K] + S;
        MATTAM:= S
    "END" MATTAM;
        "EOP"
0"CODE" 34016;
    "REAL" "PROCEDURE" SEQVEC(L, U, IL, SHIFT, A, B);
    "VALUE" L,U,IL,SHIFT; "INTEGER" L,U,IL,SHIFT; "ARRAY" A,B;
    "BEGIN" "REAL" S;
        S:= 0;
        "FOR" L:=L "STEP" 1 "UNTIL" U "DO"
        "BEGIN" S:= A[IL] * B[L + SHIFT] + S; IL:= IL + L "END";
        SEQVEC:= S
    "END" SEQVEC;
        "EOP"
0"CODE" 34017;
    "REAL" "PROCEDURE" SCAPRD1(LA, SA, LB, SB, N, A, B);
    "VALUE" LA,SA,LB,SB,N; "INTEGER" LA,SA,LB,SB,N; "ARRAY" A,B;
    "BEGIN" "REAL" S;"INTEGER" K;
        S:= 0;
        "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
        "BEGIN" S:=A[LA] * B[LB] + S; LA:= LA + SA; LB:= LB + SB "END";
        SCAPRD1:= S
    "END" SCAPRD1;
        "EOP"
0"CODE" 34018;
    "REAL" "PROCEDURE" SYMMATVEC(L, U, I, A, B); "VALUE" L,U,I;
    "INTEGER" L,U,I; "ARRAY" A,B;
    "BEGIN" "INTEGER" K, M;
        M:= "IF" L > I "THEN" L "ELSE" I; K:= M * (M - 1) // 2;
        SYMMATVEC:= VECVEC(L, "IF" I <= U "THEN" I-1 "ELSE" U, K, B, A)
                    + SEQVEC(M, U, K + I, 0, A, B)
    "END" SYMMATVEC;
        "EOP"
1SECTION : 1.1.4.2            (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR : D.WINTER.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED : 741215.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS FIVE PROCEDURES :
     FULMATVEC CALCULATES THE VECTOR A * B, WHERE A IS A GIVEN MATRIX
     AND B IS A VECTOR.
     FULTAMVEC CALCULATES THE VECTOR A' * B, WHERE A' IS THE TRANSPOSED
     OF THE MATRIX A AND B IS A VECTOR.
     FULSYMMATVEC CALCULATES THE VECTOR A * B, WHERE A IS A SYMMETRIC
     MATRIX WHOSE UPPERTRIANGLE IS STORED COLUMNWISE IN A
     ONE-DIMENSIONAL ARRAY AND B IS A VECTOR.
     RESVEC CALCULATES THE RESIDUAL VECTOR A * B + X * C, WHERE A IS A
     GIVEN MATRIX, B AND C ARE VECTORS AND X IS A SCALAR.
     SYMRESVEC CALCULATES THE RESIDUAL VECTOR A * B + X * C, WHERE A IS
     A SYMMETRIC MATRIX WHOSE UPPERTRIANGLE IS STORED IN A
     ONE-DIMENSIONAL ARRAY, B AND C ARE VECTORS AND X IS A SCALAR.
 
 
 KEYWORDS :
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATION.
1SECTION : 1.1.4.2            (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION: FULMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" FULMATVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31500;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B IS DELIVERED IN C.
 
 
 LANGUAGE:   COMPASS 3.
     (FOR THE COMPASS-VERSION, THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 METHOD AND PERFORMANCE: SEE REFERENCE [1].
 
 SUBSECTION: FULTAMVEC.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" FULTAMVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31501;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
            "ARRAY" B[LR:UR]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LC:UC];
             THE RESULT A' * B IS DELIVERED IN C; HERE A' DENOTES THE
             TRANSPOSED OF THE MATRIX A.
 
1SECTION : 1.1.4.2            (DECEMBER 1975)                     PAGE 3
 
 
 
 LANGUAGE:   COMPASS 3.
     (FOR THE COMPASS-VERSION, THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 
 METHOD AND PERFORMANCE: ELEMENTARY.
 
 
 SUBSECTION: FULSYMMATVEC.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" FULSYMMATVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC, B; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31502;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX; LR >= 1;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX; LC >= 1;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U], WHERE:
             L = MIN(LR * (LR - 1) // 2 + LC, LC * (LC - 1) // 2 + LR),
             U = MAX(UR * (UR - 1) // 2 + UC, UC * (UC - 1) // 2 + UR)
             AND FOR I <= J THE (I,J)-TH ELEMENT, OTHERWISE THE
             (J,I)-TH ELEMENT OF THE SYMMETRIC MATRIX SHOULD BE
             GIVEN IN A[J * (J - 1) // 2 + I];
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B IS DELIVERED IN C.
 
 
1SECTION : 1.1.4.2            (DECEMBER 1975)                     PAGE 4
 
 
 
 PROCEDURES USED:
 
     SYMMATVEC = CP34018.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 SUBSECTION: RESVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" RESVEC(LR, UR, LC, UC, A, B, C, X);
     "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" A, B, C;
     "CODE" 31503;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     X:      <ARITHMETIC EXPRESSION>;
             THE VALUE OF THE MULTIPLYING SCALAR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B + X * C IS OVERWRITTEN ON C.
 
 
 LANGUAGE:   COMPASS 3.
     (FOR THE COMPASS-VERSION, THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
1SECTION : 1.1.4.2            (DECEMBER 1975)                     PAGE 5
 
 
 
 SUBSECTION: SYMRESVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" SYMRESVEC(LR, UR, LC, UC, A, B, C, X);
     "VALUE" LR, UR, LC, UC, B, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" A, B, C;
     "CODE" 31504;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX; LR >= 1;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX; LC >= 1;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U], WHERE:
             L = MIN(LR * (LR - 1) // 2 + LC, LC * (LC - 1) // 2 + LR),
             U = MAX(UR * (UR - 1) // 2 + UC, UC * (UC - 1) // 2 + UR)
             AND THE (I,J)-TH ELEMENT OF THE SYMMETRIC MATRIX SHOULD BE
             GIVEN IN A[J * (J - 1) // 2 + I];
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     X:      <ARITHMETIC EXPRESSION>;
             THE VALUE OF THE MULTIPLYING SCALAR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B  + X * C IS DELIVERED IN C.
 
 
 PROCEDURES USED:
 
     SYMMATVEC = CP34018.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 REFERENCES:
 
     [1].T.J.DEKKER.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART1,
         MATHEMATICAL CENTRE TRACT 22, AMSTERDAM (1970).
 
     [2].J.C.P.BUS.
         MINIMALISERING VAN FUNKTIES VAN MEERDERE VARIABELEN,
         MATHEMATICAL CENTRE, NR 29/72, AMSTERDAM (1972).
1SECTION : 1.1.4.2            (DECEMBER 1975)                     PAGE 6
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES, EXCEPT FOR FULSYMMATVEC AND SYMRESVEC ARE
 WRITTEN IN COMPASS 3, AN EQUIVALENT ALGOL TEXT OF THESE COMPASS
 ROUTINES IS GIVEN.
0"CODE" 31500;
    "PROCEDURE" FULMATVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN"
        "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
        C[LR]:= MATVEC(LC, UC, LR, A, B);
    "END" FULMATVEC;
         "EOP"
0"CODE" 31501;
    "PROCEDURE" FULTAMVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN"
        "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
        C[LC]:= TAMVEC(LR, UR, LC, A, B);
    "END" FULTAMVEC;
         "EOP"
0"CODE" 31502;
    "PROCEDURE" FULSYMMATVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC, B; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN"
        "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
        C[LR]:= SYMMATVEC(LC, UC, LR, A, B)
    "END" FULSYMMATVEC;
         "EOP"
0"CODE" 31503;
    "PROCEDURE" RESVEC(LR, UR, LC, UC, A, B, C, X);
    "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
    "REAL" X; "ARRAY" A, B, C;
    "BEGIN"
        "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
        C[LR]:= MATVEC(LC, UC, LR, A, B) + C[LR] * X
    "END" RESVEC;
         "EOP"
0"CODE" 31504;
    "PROCEDURE" SYMRESVEC(LR, UR, LC, UC, A, B, C, X);
    "VALUE" LR, UR, LC, UC, B, X; "INTEGER" LR, UR, LC, UC;
    "REAL" X; "ARRAY" A, B, C;
    "BEGIN"
        "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
       C[LR]:= SYMMATVEC(LC, UC, LR, A, B) + C[LR] * X
    "END" SYMRESVEC;
         "EOP"
1SECTION : 1.1.4.3            (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR: D.T.WINTER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 751208.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS PROCEDURES  THAT MULTIPLY A GIVEN MATRIX BY A
     (GENERALIZED) HOUSEHOLDER MATRIX, I.E. A MATRIX M = I + X * U * U',
     WHERE  I  IS THE UNIT MATRIX,   X  A REAL CONSTANT AND  U  A VECTOR
     (CALLED THE HOUSEHOLDER CONSTANT AND HOUSEHOLDER VECTOR,
     RESPECTIVELY)
 
     HSHVECMAT  PREMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX, THE
                HOUSEHOLDER VECTOR HAS BEEN STORED
                IN A ONE-DIMENSIONAL ARRAY.
     HSHCOLMAT  PREMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX,
                THE HOUSEHOLDER VECTOR HAS BEEN STORED AS A COLUMN
                IN A TWO-DIMENSIONAL ARRAY.
     HSHROWMAT  PREMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX,
                THE HOUSEHOLDER VECTOR HAS BEEN STORED AS A ROW
                IN A TWO-DIMENSIONAL ARRAY.
     HSHVECTAM  POSTMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX,
                THE HOUSEHOLDER VECTOR HAS BEEN STORED
                IN A ONE-DIMENSIONAL ARRAY.
     HSHCOLTAM  POSTMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX,
                THE HOUSEHOLDER VECTOR HAS BEEN STORED
                AS A COLUMN IN A TWO-DIMENSIONAL ARRAY.
     HSHROWTAM  POSTMULTIPLIES  A  MATRIX BY A HOUSEHOLDER MATRIX,
                THE HOUSEHOLDER VECTOR HAS BEEN STORED
                AS A ROW IN A TWO-DIMENSIONAL ARRAY.
 
 KEYWORDS:
 
     HOUSEHOLDER MATRIX
     ORTHOGONAL TRANSFORMATION
 
 
 LANGUAGE: ALGOL 60
 
1SECTION : 1.1.4.3            (JANUARY 1976)                      PAGE 2
 
 
 
 SUBSECTION: HSHVECMAT
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHVECMAT(LR, UR, LC, UC, X, U, A);
     "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31070;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[LR:UR];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE PREMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
 PROCEDURES USED:
     TAMVEC    = CP34012
     ELMCOLVEC = CP34022
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
 SUBSECTION: HSHCOLMAT
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHCOLMAT(LR, UR, LC, UC, I, X, U, A);
     "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31071;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     I:  <ARITHMETIC EXPRESSION>;
         THE COLUMN INDEX OF THE HOUSEHOLDER VECTOR;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[LR:UR,I:I];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE PREMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
 PROCEDURES USED:
     TAMMAT    = CP34014
     ELMCOL    = CP34023
 
1SECTION : 1.1.4.3            (JANUARY 1976)                      PAGE 3
 
 
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
 SUBSECTION: HSHROWMAT
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHROWMAT(LR, UR, LC, UC, I, X, U, A);
     "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31072;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     I:  <ARITHMETIC EXPRESSION>;
         THE ROW INDEX OF THE HOUSEHOLDER VECTOR;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[I:I,LR:UR];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE PREMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
 PROCEDURES USED:
     MATMAT    = CP34013
     ELMCOLROW = CP34027
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
 SUBSECTION: HSHVECTAM
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHVECTAM(LR, UR, LC, UC, X, U, A);
     "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31073;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[LC:UC];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE POSTMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
1SECTION : 1.1.4.3            (JANUARY 1976)                      PAGE 4
 
 
 
 PROCEDURES USED:
     MATVEC    = CP34011
     ELMROWVEC = CP34027
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
 SUBSECTION: HSHCOLTAM
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHCOLTAM(LR, UR, LC, UC, I, X, U, A);
     "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31074;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     I:  <ARITHMETIC EXPRESSION>;
         THE COLUMN INDEX OF THE HOUSEHOLDER VECTOR;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[LC:UC,I:I];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE POSTMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
 PROCEDURES USED:
     MATMAT    = CP34013
     ELMROWCOL = CP34028
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
1SECTION : 1.1.4.3            (JANUARY 1976)                      PAGE 5
 
 
 
 SUBSECTION: HSHROWTAM
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHROWTAM(LR, UR, LC, UC, I, X, U, A);
     "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
     "REAL" X; "ARRAY" U, A;
     "CODE" 31075;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR,UR: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER ROW INDICES;
     LC,UC: <ARITHMETIC EXPRESSIONS>;
         THE LOWER AND UPPER COLUMN INDICES;
     I:  <ARITHMETIC EXPRESSION>;
         THE ROW INDEX OF THE HOUSEHOLDER VECTOR;
     X:  <ARITHMETIC EXPRESSION>;
         THE HOUSEHOLDER CONSTANT;
     U:  <ARRAY IDENTIFIER>; "ARRAY" U[I:I,LC:UC];
         THE HOUSEHOLDER VECTOR;
     A:  <ARRAY IDENTIFIER>; "ARRAY" A[LR:UR,LC:UC];
         THE MATRIX TO BE POSTMULTIPLIED BY THE HOUSEHOLDER MATRIX.
 
 PROCEDURES USED:
     MATTAM    = CP34015
     ELMROW    = CP34024
 
 RUNNING TIME: PROPORTIONAL TO (UC-LC+1)*(UR-LR+1)
 
 SOURCE TEXTS:
 
0"CODE" 31070;
 "PROCEDURE" HSHVECMAT(LR, UR, LC, UC, X, U, A);
 "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
     ELMCOLVEC(LR, UR, LC, A, U, TAMVEC(LR, UR, LC, A, U) * X)
 "END";
         "EOP"
0"CODE" 31071;
 "PROCEDURE" HSHCOLMAT(LR, UR, LC, UC, I, X, U, A);
 "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
     ELMCOL(LR, UR, LC, I, A, U, TAMMAT(LR, UR, LC, I, A, U) * X)
 "END"
1SECTION : 1.1.4.3            (JANUARY 1976)                      PAGE 6
 
 
 
                                                                   ;
         "EOP"
0"CODE" 31072;
 "PROCEDURE" HSHROWMAT(LR, UR, LC, UC, I, X, U, A);
 "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
     ELMCOLROW(LR, UR, LC, I, A, U, MATMAT(LR, UR, I, LC, U, A) * X)
 "END";
         "EOP"
0"CODE" 31073;
 "PROCEDURE" HSHVECTAM(LR, UR, LC, UC, X, U, A);
 "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
     ELMROWVEC(LC, UC, LR, A, U, MATVEC(LC, UC, LR, A, U) * X)
 "END";
         "EOP"
0"CODE" 31074;
 "PROCEDURE" HSHCOLTAM(LR, UR, LC, UC, I, X, U, A);
 "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
     ELMROWCOL(LC, UC, LR, I, A, U, MATMAT(LC, UC, LR, I, A, U) * X)
 "END";
         "EOP"
0"CODE" 31075;
 "PROCEDURE" HSHROWTAM(LR, UR, LC, UC, I, X, U, A);
 "VALUE" LR, UR, LC, UC, I, X; "INTEGER" LR, UR, LC, UC, I;
 "REAL" X; "ARRAY" U, A;
 "BEGIN"
     "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
     ELMROW(LC, UC, LR, I, A, U, MATTAM(LC, UC, LR, I, A, U) * X)
 "END";
         "EOP"
1SECTION : 1.1.5              (APRIL 1974)                        PAGE 1
 
 
 
 AUTHORS:        T.J.DEKKER, C.G. VAN DER LAAN.
 
 
 CONTRIBUTOR:    P.A.BEENTJES.
 
 
 INSTITUTE:      MATHEMATICAL CENTRE.
 
 
 RECEIVED:       730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TEN PROCEDURES.
     ELMVEC ADDS X TIMES THE VECTOR GIVEN IN ARRAY  B[SHIFT+L : SHIFT+U]
     TO THE VECTOR GIVEN IN ARRAY A[L:U].
     ELMCOL ADDS X TIMES THE COLUMN VECTOR GIVEN IN ARRAY B[L:U, J:J] TO
     THE COLUMN VECTOR GIVEN IN ARRAY A[L:U, I:I].
     ELMROW ADDS  X TIMES  THE ROW VECTOR GIVEN IN ARRAY  B[J:J, L:U] TO
     THE ROW VECTOR GIVEN IN ARRAY A[I:I, L:U].
     ELMVECCOL ADDS X TIMES THE COLUMN VECTOR GIVEN IN ARRAY B[L:U, I:I]
     TO THE VECTOR GIVEN IN ARRAY A[L:U].
     ELMCOLVEC  ADDS  X  TIMES  THE VECTOR  GIVEN IN ARRAY B[L:U] TO THE
     COLUMN VECTOR GIVEN IN ARRAY A[L:U, I:I].
     ELMVECROW ADDS X TIMES THE ROW VECTOR GIVEN IN ARRAY B[I:I, L:U] TO
     THE VECTOR GIVEN IN ARRAY A[L:U].
     ELMROWVEC  ADDS  X  TIMES  THE VECTOR  GIVEN IN ARRAY B[L:U] TO THE
     ROW VECTOR GIVEN IN ARRAY A[I:I, L:U].
     ELMCOLROW ADDS X TIMES THE ROW VECTOR GIVEN IN ARRAY B[J:J, L:U] TO
     THE COLUMN VECTOR GIVEN IN ARRAY A[L:U, I:I].
     ELMROWCOL ADDS X TIMES THE COLUMN VECTOR GIVEN IN ARRAY B[L:U, J:J]
     TO THE ROW VECTOR GIVEN IN ARRAY A[I:I, L:U].
     MAXELMROW ADDS X TIMES THE ROW VECTOR GIVEN IN ARRAY B[J:J, L:U] TO
     THE ROW VECTOR GIVEN IN ARRAY A[I:I, L:U].
     MOREOVER, MAXELMROW:= THE  VALUE  OF  THE  SECOND  SUBSCRIPT  OF AN
     ELEMENT  OF  THE  NEW  ROW VECTOR  IN  ARRAY A  WHICH IS OF MAXIMUM
     ABSOLUTE VALUE.
     IF, HOWEVER, L > U, THEN MAXELMROW:= L.
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     ELIMINATION.
 
 
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: ELMVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMVEC(L, U, SHIFT, A, B, X); "VALUE" L,U,SHIFT,X;
     "INTEGER" L,U,SHIFT; "REAL" X; "ARRAY" A,B;
     "CODE" 34020;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER OF THE VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L + SHIFT : U + SHIFT];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ELMCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 34023;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR A;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U, J : J];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: ELMROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 34024;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     J:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[J : J, L : U];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ELMVECCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMVECCOL(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "CODE" 34021;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[L : U, I : I];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 4
 
 
 
 SUBSECTION ELMCOLVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMCOLVEC(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "CODE" 34022;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[L : U];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ELMVECROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMVECROW(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "CODE" 34026;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U], B[I : I, L : U];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: ELMROWVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMROWVEC(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "CODE" 34027;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[L : U];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ELMCOLROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMCOLROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 34029;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR A;
     J:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, I : I], B[J : J, L : U],  WHEN  A = B THEN
             CORRECT  ELIMINATION  IS GUARANTEED  ONLY WHEN  THE ROW AND
             COLUMN ARE DISJUNCT;
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 6
 
 
 
 SUBSECTION: ELMROWCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ELMROWCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 34028;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[L : U, J : J],  WHEN  A = B THEN
             CORRECT  ELIMINATION  IS GUARANTEED  ONLY WHEN  THE ROW AND
             COLUMN ARE DISJUNCT;
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 7
 
 
 
 SUBSECTION: MAXELMROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "INTEGER" "PROCEDURE" MAXELMROW(L, U, I, J, A, B, X);
     "VALUE" L,U,I,J,X; "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "CODE" 34025;
 
     MAXELMROW DELIVERS THE INDEX  OF THE MAXIMAL ELEMENT AFTER ELIMINA-
             TION STEP IN ARRAY A.
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR A;
     J:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR B;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY" A[I : I, L : U], B[I : I, L : U];
     X:      <ARITHMETIC EXPRESSION>;
             ELIMINATION FACTOR.
 
 
 LANGUAGE: COMPASS.
 
 
 REFERENCES:
 
     [1].T.J.DEKKER.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MATHEMATICAL CENTRE TRACT 22, AMSTERDAM (1970).
1SECTION : 1.1.5              (DECEMBER 1979)                     PAGE 8
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
     ELMVEC
     ELMROW
     ELMVECCOL
     ELMCOLVEC
     MAXELMROW
 
 "CODE" 34020;
     "PROCEDURE" ELMVEC(L, U, SHIFT, A, B, X); "VALUE" L,U,SHIFT,X;
     "INTEGER" L,U,SHIFT; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= A[L] + B[L + SHIFT] * X;
         "EOP"
 
 "CODE" 34023;
     "PROCEDURE" ELMCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,I]:= A[L,I] + B[L,J] * X;
         "EOP"
 
 "CODE" 34024;
     "PROCEDURE" ELMROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= A[I,L] + B[J,L] * X;
         "EOP"
 
 "CODE" 34021;
     "PROCEDURE" ELMVECCOL(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= A[L] + B[L,I] * X;
         "EOP"
 
 "CODE" 34022;
     "PROCEDURE" ELMCOLVEC(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,I]:= A[L,I] + B[L] * X;
         "EOP"
 
 "CODE" 34026;
     "PROCEDURE" ELMVECROW(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L]:= A[L] + B[I,L] * X;
                                                         "COMMENT"
 
1SECTION : 1.1.5              (APRIL 1974)                        PAGE 9
 
 
                                                                  ;
         "EOP"
 "CODE" 34027;
     "PROCEDURE" ELMROWVEC(L, U, I, A, B, X); "VALUE" L,U,I,X;
     "INTEGER" L,U,I; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= A[I,L] + B[L] * X;
         "EOP"
 
 "CODE" 34029;
     "PROCEDURE" ELMCOLROW(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[L,I]:= A[L,I] + B[J,L] * X;
         "EOP"
 
 "CODE" 34028;
     "PROCEDURE" ELMROWCOL(L, U, I, J, A, B, X); "VALUE" L,U,I,J,X;
     "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" A[I,L]:= A[I,L] + B[L,J] * X;
         "EOP"
 
 "CODE" 34025;
     "INTEGER" "PROCEDURE" MAXELMROW(L, U, I, J, A, B, X);
     "VALUE" L,U,I,J,X; "INTEGER" L,U,I,J; "REAL" X; "ARRAY" A,B;
     "BEGIN" "INTEGER" K; "REAL" R, S;
         S:= 0;
         "FOR" K:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[I,K]:= A[I,K] + B[J,K] * X;"IF" ABS(R) > S "THEN"
             "BEGIN" S:= ABS(R); L:= K "END"
         "END";
         MAXELMROW:= L
     "END" MAXELMROW;
         "EOP"
1SECTION : 1.1.6              (APRIL 1974)                        PAGE 1
 
 
 
 AUTHOR:         T.J.DEKKER.
 
 
 CONTRIBUTOR:    P.A.BEENTJES.
 
 
 INSTITUTE:      MATHEMATICAL CENTRE.
 
 
 RECEIVED:       730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS SIX PROCEDURES.
     ICHVEC  INTERCHANGES  THE ELEMENTS  OF  THE VECTOR  GIVEN IN  ARRAY
     A[L:U] AND ARRAY A[SHIFT + L : SHIFT + U].
     ICHCOL  INTERCHANGES  THE ELEMENTS  OF THE COLUMN VECTORS  GIVEN IN
     ARRAY A[L:U, I:I] AND ARRAY A[L:U, J:J].
     ICHROW INTERCHANGES THE ELEMENTS OF THE ROW VECTORS GIVEN IN  ARRAY
     A[I:I, L:U] AND ARRAY A[J:J, L:U].
     ICHROWCOL  INTERCHANGES  THE ELEMENTS  OF  THE  ROW VECTOR GIVEN IN
     ARRAY A[I:I, L:U] AND THE COLUMN VECTOR GIVEN IN ARRAY A[L:U, J:J].
     ICHSEQVEC INTERCHANGES THE ELEMENTS OF THE VECTORS  GIVEN IN  ARRAY
     A[IL : IL + (U + L - 1)*(U - L)//2] AND ARRAY A[SHIFT+L : SHIFT+U],
     WHERE THE ELEMENTS OF THE FIRST VECTOR  ARE  A[IL+(J+L-1)*(J-L)//2]
     FOR J = L,..., U.
     ICHSEQ   INTERCHANGES   THE   ELEMENTS   OF   THE   VECTORS   GIVEN
     IN   ARRAY    A[IL : IL + (U + L - 1) * (U - L) // 2]   AND   ARRAY
     A[SHIFT + IL : SHIFT + IL + (U + L - 1) * (U - L) // 2]  WHERE  THE
     ELEMENTS OF THE VECTORS ARE A[IL + (J + L - 1) * (J - L) // 2]  AND
     A[SHIFT + IL + (J + L - 1) * (J - L) // 2]   FOR   J = L ,..., U  .
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     INTERCHANGING.
 
 
1SECTION : 1.1.6              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: ICHVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHVEC(L, U, SHIFT, A); "VALUE" L,U,SHIFT;
     "INTEGER" L,U,SHIFT; "ARRAY" A;
     "CODE" 34030;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q]; P AND Q SHOULD SATISFY:  P <= L,  Q >= U,
             P <= L + SHIFT AND Q >= U + SHIFT.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ICHCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHCOL(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "CODE" 34031;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             COLUMN-INDICES   OF   THE  COLUMN  VECTORS   OF   ARRAY  A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, P : Q]; P AND Q SHOULD SATISFY:  P  <=  I,
             P <= J, Q >= I AND Q >= J.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.6              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: ICHROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHROW(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "CODE" 34032;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             ROW-INDICES OF THE ROW VECTORS OF ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q, L : U]; P AND Q SHOULD SATISFY:  P  <=  I,
             P <= J, Q >= I AND Q >= J.
 
 
 LANGUAGE: COMPASS.
 
 
 SUBSECTION: ICHROWCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHROWCOL(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "CODE" 34033;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE ROW VECTOR OF ARRAY A;
     J:      <ARITHMETIC EXPRESSION>;
             COLUMN-INDEX OF THE COLUMN VECTOR OF ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q, R : S]; P,  Q,  R  AND  S  SHOULD SATISFY:
             P <= I, P <= L, Q >= I, Q >= U, R <= J, R <= L, S >= J  AND
             S >= U,  FURTHERMORE THE ROW AND COLUMN  TO BE INTERCHANGED
             SHOULD BE DISJUNCT.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.6              (DECEMBER 1979)                     PAGE 4
 
 
 
 SUBSECTION: ICHSEQVEC.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHSEQVEC(L, U, IL, SHIFT, A); "VALUE" L,U,IL,SHIFT;
     "INTEGER" L,U,IL,SHIFT; "ARRAY" A;
     "CODE" 34034;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     IL:     <ARITHMETIC EXPRESSION>;
             LOWER BOUND OF THE VECTOR A;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q];
             THE SUBSCRIPTS ABOVE AND THE VALUES OF L(+SHIFT), U(+SHIFT)
             AND IL+(U+L-1)*(U-L)//2 SHOULD NOT CONTRADICT EACH OTHER.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.6              (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: ICHSEQ.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ICHSEQ(L, U, IL, SHIFT, A); "VALUE" L,U,IL,SHIFT;
     "INTEGER" L,U,IL,SHIFT; "ARRAY" A;
     "CODE" 34035;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     IL:     <ARITHMETIC EXPRESSION>;
             LOWER BOUND OF THE VECTOR A;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             INDEX-SHIFTING PARAMETER;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q];
             THE SUBSCRIPTS ABOVE AND THE VALUES OF  IL+(J+L-1)*(J-L)//2
             ( +SHIFT ),J = L(1)U, SHOULD  NOT  CONTRADICT  EACH  OTHER.
 
 
 LANGUAGE: COMPASS.
 
 
 REFERENCES:
 
     [1].T.J.DEKKER.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MATHEMATICAL CENTRE TRACT 22, AMSTERDAM (1970).
1SECTION : 1.1.6              (DECEMBER 1979)                     PAGE 6
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
0"CODE" 34030;
     "PROCEDURE" ICHVEC(L, U, SHIFT, A); "VALUE" L,U,SHIFT;
     "INTEGER" L,U,SHIFT; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[L]; A[L]:= A[L + SHIFT]; A[L + SHIFT]:= R "END"
     "END" ICHVEC;
        "EOP"
 
 "CODE" 34031;
     "PROCEDURE" ICHCOL(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[L,I]; A[L,I]:= A[L,J]; A[L,J]:= R "END"
     "END" ICHCOL;
         "EOP"
 
 "CODE" 34032;
     "PROCEDURE" ICHROW(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[I,L]; A[I,L]:= A[J,L]; A[J,L]:= R "END"
     "END" ICHROW
 
1SECTION : 1.1.6              (APRIL 1974)                        PAGE 7
 
 
                                                                   ;
         "EOP"
 "CODE" 34033;
     "PROCEDURE" ICHROWCOL(L, U, I, J, A); "VALUE" L,U,I,J;
     "INTEGER" L,U,I,J; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[I,L]; A[I,L]:= A[L,J]; A[L,J]:= R "END"
     "END" ICHROWCOL;
         "EOP"
 
 "CODE" 34034;
     "PROCEDURE" ICHSEQVEC(L, U, IL, SHIFT, A); "VALUE" L,U,IL,SHIFT;
     "INTEGER" L,U,IL,SHIFT; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[IL]; A[IL]:= A[L + SHIFT]; A[L + SHIFT]:= R;
             IL:= IL + L
         "END"
     "END" ICHSEQVEC;
         "EOP"
 
 "CODE" 34035;
     "PROCEDURE" ICHSEQ(L, U, IL, SHIFT, A); "VALUE" L,U,IL,SHIFT;
     "INTEGER" L,U,IL,SHIFT; "ARRAY" A;
     "BEGIN" "REAL" R;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" R:= A[IL]; A[IL]:= A[IL + SHIFT]; A[IL + SHIFT]:= R;
             IL:= IL + L
         "END"
     "END" ICHSEQ;
         "EOP"
1SECTION : 1.1.7              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHOR:     P.A.BEENTJES.
 
 
 INSTITUTE:  MATHEMATICAL CENTRE.
 
 
 RECEIVED:   730715.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES.
     ROTCOL REPLACES THE COLUMN VECTOR X GIVEN IN ARRAY  A[L:U, I:I] AND
     THE  COLUMN VECTOR  Y  GIVEN IN ARRAY  A[L:U, J:J]  BY  THE VECTORS
     CX + SY AND CY - SX.
     ROTROW REPLACES THE ROW VECTOR X GIVEN IN ARRAY A[I:I, L:U] AND THE
     ROW VECTOR Y GIVEN IN ARRAY A[J:J, L:U] BY THE VECTORS CX + SY  AND
     CY - SX.
 
 
 KEYWORDS:
 
     ELEMENTARY PROCEDURE,
     VECTOR OPERATIONS,
     ROTATION.
 
 
 SUBSECTION: ROTCOL.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ROTCOL(L, U, I, J, A, C, S); "VALUE" L,U,I,J,C,S;
     "INTEGER" L,U,I,J; "REAL" C,S; "ARRAY" A;
     "CODE" 34040;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             COLUMN-INDICES OF THE COLUMN VECTORS OF ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L : U, P : Q]; P AND Q SHOULD SATISFY:  P  <=  I,
             P <= J, Q >= I AND Q >= J;
     C,S:    <ARITHMETIC EXPRESSION>;
             ROTATION FACTORS.
 
 
 LANGUAGE: COMPASS.
1SECTION : 1.1.7              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: ROTROW.
 
 
 CALLING SEQUENCE:
 
     HEADING:
     "PROCEDURE" ROTROW(L, U, I, J, A, C, S); "VALUE" L,U,I,J,C,S;
     "INTEGER" L,U,I,J; "REAL" C,S; "ARRAY" A;
     "CODE" 34041;
 
     FORMAL PARAMETERS:
     L,U:    <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I,J:    <ARITHMETIC EXPRESSION>;
             ROW-INDICES OF THE ROW-VECTORS OF ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[P : Q, L : U]; P AND Q SHOULD SATISFY:  P  <=  I,
             P <= J, Q >= I AND Q >= J;
     C,S:    <ARITHMETIC EXPRESSION>;
             ROTATION FACTORS.
 
 
 LANGUAGE: COMPASS.
 
 
 REFERENCES:
 
     [1].T.J.DEKKER.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MATHEMATICAL CENTRE TRACT 22, AMSTERDAM (1970).
1SECTION : 1.1.7              (DECEMBER 1979)                     PAGE 3
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
 
 
 
 "CODE" 34040;
     "PROCEDURE" ROTCOL(L, U, I, J, A, C, S); "VALUE" L,U,I,J,C,S;
     "INTEGER" L,U,I,J; "REAL" C,S; "ARRAY" A;
     "BEGIN" "REAL" X, Y;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" X:= A[L,I]; Y:= A[L,J]; A[L,I]:= X * C + Y * S;
             A[L,J]:= Y * C - X * S
         "END"
     "END" ROTCOL;
         "EOP"
 
 "CODE" 34041;
     "PROCEDURE" ROTROW(L, U, I, J, A, C, S); "VALUE" L,U,I,J,C,S;
     "INTEGER" L,U,I,J; "REAL" C,S; "ARRAY" A;
     "BEGIN" "REAL" X, Y;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" X:= A[I,L]; Y:= A[J,L]; A[I,L]:= X * C + Y * S;
             A[J,L]:= Y * C - X * S
         "END"
     "END" ROTROW;
         "EOP"
1SECTION : 1.1.8              (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHORS: C.G. VAN DER LAAN AND J.C.P. BUS.
 
 
 CONTRIBUTOR: J.C.P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740921.
 
 
 BRIEF DESCRIPTION:
 
     INFNRMVEC CALCULATES THE INFINITY-NORM OF A VECTOR;
     INFNRMROW CALCULATES THE INFINITY-NORM OF A ROW VECTOR;
     INFNRMCOL CALCULATES THE INFINITY-NORM OF A COLUMN VECTOR;
     INFNRMMAT CALCULATES THE INFINITY-NORM OF A MATRIX;
     ONENRMVEC CALCULATES THE ONE-NORM OF A VECTOR;
     ONENRMROW CALCULATES THE ONE-NORM OF A ROW VECTOR;
     ONENRMCOL CALCULATES THE ONE-NORM OF A COLUMN VECTOR;
     ONENRMMAT CALCULATES THE ONE-NORM OF A MATRIX;
     ABSMAXMAT CALCULATES FOR A GIVEN MATRIX THE MODULUS OF AN ELEMENT
     WHICH IS OF MAXIMUM ABSOLUTE VALUE;
 
 
 KEYWORDS:
 
     VECTOR NORMS,
     MATRIX NORMS.
 
 
1SECTION : 1.1.8              (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: INFNRMVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" INFNRMVEC(L, U, K, A);
     "VALUE" L, U; "INTEGER" L, U, K; "ARRAY" A;
     "CODE" 31061;
 
     INFNRMVEC := MAX( ABS(A[I]), I= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE INDEX OF THE
                   VECTOR A, RESPECTIVELY;
     K:      <VARIABLE>;
             EXIT:THE FIRST INDEX FOR WHICH ABS(A[I]), I = L, ..., U,
                  IS MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U].
 
 
 PROCEDURES USED: NONE.
 
 
 SUBSECTION: INFNRMROW.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" INFNRMROW(L, U, I, K, A);
     "VALUE" L, U, I; "INTEGER" L, U, I, K; "ARRAY" A;
     "CODE" 31062;
 
     INFNRMROW := MAX( ABS(A[I,J]), J= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE COLUMN INDEX
                   OF THE ROW VECTOR A, RESPECTIVELY;
     I:      <ARITHMETIC EXPRESSION>;
             ENTRY:THE ROW INDEX;
     K:      <VARIABLE>;
             EXIT:THE FIRST INDEX FOR WHICH ABS(A[I,J]), J = L, ..., U,
                  IS MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[I:I,L:U].
 
 
 PROCEDURES USED: NONE.
 
 
1SECTION : 1.1.8              (DECEMBER 1979)                     PAGE 3
 
 
 
 SUBSECTION: INFNRMCOL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" INFNRMCOL(L, U, J, K, A);
     "VALUE" L, U, J; "INTEGER" L, U, J, K; "ARRAY" A;
     "CODE" 31063;
 
     INFNRMCOL := MAX( ABS(A[I,J]), I= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE ROW INDEX OF
                   THE COLUMN VECTOR A, RESPECTIVELY;
     J:      <ARITHMETIC EXPRESSION>;
             ENTRY:THE COLUMN INDEX;
     K:      <VARIABLE>;
             EXIT:THE FIRST INDEX FOR WHICH ABS(A[I,J]), I = L, ..., U,
                  IS MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U,J:J].
 
 
 PROCEDURES USED: NONE.
 
 
 SUBSECTION: INFNRMMAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" INFNRMMAT(LR, UR, LC, UC, KR, A);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, KR; "ARRAY" A;
     "CODE" 31064;
 
     INFNRMMAT := MAX( ONENRMROW(LC, UC, I, A), I=LR, ..., UR );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE ROW INDEX,
                   RESPECTIVELY;
     LC, UC: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE COLUMN INDEX,
                   RESPECTIVELY;
     KR:     <VARIABLE>;
             EXIT:THE FIRST ROW INDEX FOR WHICH THE ONE-NORM IS MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC].
 
 
 PROCEDURES USED: ONENRMROW.
 
 
1SECTION : 1.1.8              (DECEMBER 1979)                     PAGE 4
 
 
 
 SUBSECTION: ONENRMVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" ONENRMVEC(L, U, A);
     "VALUE" L, U; "INTEGER" L, U; "ARRAY" A;
     "CODE" 31065;
 
     ONENRMVEC := SUM( ABS(A[I]), I= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE INDEX OF THE
                   VECTOR A, RESPECTIVELY;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U].
 
 
 PROCEDURES USED: NONE.
 
 
 SUBSECTION: ONENRMROW.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" ONENRMROW(L, U, I, A);
     "VALUE" L, U, I; "INTEGER" L, U, I; "ARRAY" A;
     "CODE" 31066;
 
     ONENRMROW := SUM( ABS(A[I,J]), J= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE COLUMN INDEX
                   OF THE ROW VECTOR A, RESPECTIVELY;
     I:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE ROW INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[I:I,L:U].
 
 
 PROCEDURES USED: NONE.
 
 
1SECTION : 1.1.8              (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: ONENRMCOL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" ONENRMCOL(L, U, J, A);
     "VALUE" L, U, J; "INTEGER" L, U, J; "ARRAY" A;
     "CODE" 31067;
 
     ONENRMCOL := SUM( ABS(A[I,J]), I= L, ..., U );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L, U:   <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE ROW INDEX OF
                   THE COLUMN VECTOR A, RESPECTIVELY;
     J:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE COLUMN INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U,J:J].
 
 
 PROCEDURES USED: NONE.
 
 
 SUBSECTION: ONENRMMAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" ONENRMMAT(LR, UR, LC, UC, KC, A);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, KC; "ARRAY" A;
     "CODE" 31068;
 
     ONENRMMAT := MAX(ONENRMCOL(LR, UR, J, A), J=LC, ..., UC);
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE ROW INDEX,
                   RESPECTIVELY;
     LC, UC: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE COLUMN INDEX,
                   RESPECTIVELY;
     KC:     <VARIABLE>;
             EXIT:THE FIRST COLUMN INDEX FOR WHICH THE ONE-NORM IS
                  MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC].
 
 
 PROCEDURES USED: ONENRMCOL.
 
 
1SECTION : 1.1.8              (OCTOBER 1975)                      PAGE 6
 
 
 
 SUBSECTION: ABSMAXMAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" ABSMAXMAT(LR, UR, LC, UC, KR, KC, A);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, KR, KC;
     "ARRAY" A;
     "CODE" 31069;
 
     ABSMAXMAT := MAX( ABS(A[I,J]), I= LR, ..., UR, J= LC, ..., UC );
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE ROW INDEX,
                   RESPECTIVELY;
     LC, UC: <ARITHMETIC EXPRESSION>;
             ENTRY:THE LOWER BOUND AND UPPER BOUND OF THE COLUMN INDEX,
                   RESPECTIVELY;
     KR, KC: <VARIABLE>;
             EXIT:THE ROW AND COLUMN INDEX OF AN ELEMENT FOR WHICH THE
                  MODULUS IS MAXIMAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC].
 
 
 PROCEDURES USED: INFNRMCOL.
 
 
 LANGUAGE: COMPASS.
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
1SECTION : 1.1.8              (OCTOBER 1975)                      PAGE 7
 
 
 
 SOURCE TEXT(S):
 
 THE FOLLOWING PROCEDURES ARE WRITTEN IN COMPASS, AN EQUIVALENT ALGOL 60
 TEXT OF THESE COMPASS ROUTINES IS GIVEN.
 
 
 
0"CODE" 31061;
  "REAL" "PROCEDURE" INFNRMVEC(L, U, K, A); "VALUE" L, U;
  "INTEGER" L, U, K; "ARRAY" A;
  "BEGIN" "REAL" R, MAX;
     MAX:= 0; K:= L;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     "BEGIN" R:= ABS(A[L]); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; K:= L "END"
     "END";
     INFNRMVEC:= MAX
 "END" INFNRMVEC;
         "EOP"
0"CODE" 31062;
  "REAL" "PROCEDURE" INFNRMROW(L, U, I, K, A); "VALUE" L, U, I;
  "INTEGER" L, U, I, K; "ARRAY" A;
  "BEGIN" "REAL" R, MAX;
     MAX:= 0; K:= L;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     "BEGIN" R:= ABS(A[I,L]); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; K:= L "END"
     "END";
     INFNRMROW:= MAX
 "END" INFNRMROW;
         "EOP"
0"CODE" 31063;
  "REAL" "PROCEDURE" INFNRMCOL(L, U, J, K, A); "VALUE" L, U, J;
  "INTEGER" L, U, J, K; "ARRAY" A;
  "BEGIN" "REAL" R, MAX;
     MAX:= 0; K:= L;
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     "BEGIN" R:= ABS(A[L,J]); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; K:= L "END"
     "END";
     INFNRMCOL:= MAX
 "END" INFNRMCOL
1SECTION : 1.1.8              (OCTOBER 1975)                      PAGE 8
 
 
                                                                   ;
         "EOP"
0"CODE" 31064;
  "REAL" "PROCEDURE" INFNRMMAT(LR, UR, LC, UC, KR, A);
  "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, KR; "ARRAY" A;
  "BEGIN" "REAL" R, MAX;
     MAX:= 0; KR:= LR;
     "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
     "BEGIN" R:= ONENRMROW(LC, UC, LR, A); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; KR:= LR "END"
     "END";
     INFNRMMAT:= MAX
 "END" INFNRMMAT;
         "EOP"
0"CODE" 31065;
  "REAL" "PROCEDURE" ONENRMVEC(L, U, A); "VALUE" L, U;
  "INTEGER" L, U; "ARRAY" A;
  "BEGIN" "REAL" SUM;
     SUM:= 0; "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     SUM:= SUM + ABS(A[L]);
     ONENRMVEC:= SUM
 "END" ONENRMVEC;
         "EOP"
0"CODE" 31066;
  "REAL" "PROCEDURE" ONENRMROW(L, U, I, A); "VALUE" L, U, I;
  "INTEGER" L, U, I; "ARRAY" A;
  "BEGIN" "REAL" SUM;
     SUM:= 0; "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     SUM:= SUM + ABS(A[I,L]);
     ONENRMROW:= SUM
 "END" ONENRMROW
1SECTION : 1.1.8              (OCTOBER 1975)                      PAGE 9
 
 
                                                                   ;
         "EOP"
0"CODE" 31067;
  "REAL" "PROCEDURE" ONENRMCOL(L, U, J, A); "VALUE" L, U, J;
  "INTEGER" L, U, J; "ARRAY" A;
  "BEGIN" "REAL" SUM;
     SUM:= 0; "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
     SUM:= SUM + ABS(A[L,J]);
     ONENRMCOL:= SUM
 "END" ONENRMCOL;
         "EOP"
0"CODE" 31068;
  "REAL" "PROCEDURE" ONENRMMAT(LR, UR, LC, UC, KC, A);
  "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, KC; "ARRAY" A;
  "BEGIN" "REAL" MAX, R;
     MAX:= 0; KC:= LC;
     "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
     "BEGIN" R:= ONENRMCOL(LR, UR, LC, A); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; KC:= LC "END"
     "END";
     ONENRMMAT:= MAX
 "END" ONENRMMAT;
         "EOP"
0"CODE" 31069;
  "REAL" "PROCEDURE" ABSMAXMAT(LR, UR, LC, UC, I, J, A);
  "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC, I, J; "ARRAY" A;
  "BEGIN" "INTEGER" II; "REAL" MAX, R;
     MAX:= 0; I:= LR; J:= LC;
     "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
     "BEGIN" R:= INFNRMCOL(LR, UR, LC, II, A); "IF" R > MAX "THEN"
         "BEGIN" MAX:= R; I:= II; J:= LC "END"
     "END";
     ABSMAXMAT:= MAX
 "END" ABSMAXMAT;
         "EOP"
1SECTION : 1.1.9              (APRIL 1974)                        PAGE 1
 
 
 
 AUTHORS  : T.J. DEKKER, W. HOFFMANN.
 
 
 CONTRIBUTORS: W. HOFFMANN, S.P.N. VAN KAMPEN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731030.
 
 
 BRIEF DESCRIPTION:
 
     THE PROCEDURE REASCL  NORMALIZES THE  (NON-NULL) COLUMNS  OF A TWO-
     DIMENSIONAL ARRAY IN SUCH A WAY THAT, IN EACH COLUMN, AN ELEMENT OF
     MAXIMUM  ABSOLUTE  VALUE  EQUALS  1.  THE  NORMALIZED  VECTORS  ARE
     DELIVERED IN THE CORRESPONDING COLUMNS OF THE ARRAY.
 
 
 KEYWORDS:
 
     NORMALIZATION,
     VECTOR SCALING.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" REASCL(A, N, N1, N2); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A;
     "CODE" 34183;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             A TWO-DIMENSIONAL ARRAY A[1:N,N1:N2];
             ENTRY: THE  N2 - N1 + 1  COLUMN VECTORS MUST BE GIVEN IN A;
             EXIT:  THE NORMALIZED  VECTORS (I.E. IN  EACH VECTOR AN
                    ELEMENT  OF MAXIMUM  ABSOLUTE  VALUE  EQUALS 1)  ARE
                    DELIVERED IN THE CORRESPONDING COLUMNS OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF ROWS OF ARRAY A;
     N1, N2: <ARITHMETIC EXPRESSION>;
             THE LOWER AND UPPER BOUND OF THE COLUMN INDICES OF ARRAY A.
 
1SECTION : 1.1.9              (APRIL 1974)                        PAGE 2
 
 
 
 PROCEDURES USED: NONE.
 
 
 
 
 RUNNING TIME: PROPORTIONAL TO N * (N2 - N1 + 1).
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE REF [1].
 
 
 REFERENCES:
     [1].T.J. DEKKER AND W. HOFFMANN.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
         MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
 
 
 EXAMPLE OF USE:
 
     THE PROCEDURE REASCL IS USED IN REAEIG1, SECTION 3.3.1.2.2.
 
 
0SOURCE TEXT(S) :
 
 "CODE" 34183;
     "COMMENT" MCA 2413;
     "PROCEDURE" REASCL(A, N, N1, N2); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A;
     "BEGIN" "INTEGER" I, J; "REAL" S;
         "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" S:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "IF" ABS(A[I,J]) > ABS(S) "THEN" S:= A[I,J];
             "IF" S ^= 0 "THEN"
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" A[I,J]:= A[I,J] / S
         "END"
     "END" REASCL;
         "EOP"
1SECTION : 1.2.3              (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730928.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES COMCOLCST AND COMROWCST.
     COMCOLCST MULTIPLIES THE COMPLEX COLUMN-VECTOR GIVEN IN ARRAY
     AR,AI[L:U,J:J] BY XR+I*XI.
     COMROWCST MULTIPLIES THE COMPLEX ROW-VECTOR GIVEN IN ARRAY
     AR,AI[I:I,L:U] BY XR+I*XI.
 
 
 KEYWORDS :
 
     COMPLEX VECTOR OPERATIONS,
     MULTIPLICATION.
 
 SUBSECTION: COMCOLCST.
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" COMCOLCST(L,U,J,AR,AI,XR,XI);
     "VALUE" L,U,J,XR,XI;"INTEGER" L,U,J;"REAL" XR,XI;
     "ARRAY" AR,AI;
     "CODE" 34352;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L,U:       <ARITHMETIC EXPRESSION>;
                LOWER AND UPPER BOUND OF THE COLUMN VECTOR;
     J:         <ARITHMETIC EXPRESSION>;
                COLUMN-INDEX OF THE COLUMN VECTOR;
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[L:U,J:J]
                ENTRY:
                AR : REAL PART,
                AI : IMAGINARY PART OF THE COLUMN VECTOR
                EXIT:
                THE TRANSFORMED COMPLEX COLUMN;
     XR,XI:     <ARITHMETIC EXPRESSION>;
                ENTRY:
                XR: REAL PART OF THE MULTIPLICATION FACTOR;
                XI: IMAGINARY PART OF THE MULTIPLICATION FACTOR.
 
 
 PROCEDURES USED: COMMUL = CP34341.
1SECTION : 1.2.3              (DECEMBER 1975)                     PAGE 2
 
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO (U-L+1).
 
 
 LANGUAGE: ALGOL 60.
 
 
 SUBSECTION: COMROWCST.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" COMROWCST(L, U, I, AR, AI, XR, XI);
     "VALUE" L, U, I, XR, XI; "INTEGER" L, U, I; "REAL" XR, XI;
     "ARRAY" AR, AI;
     "CODE" 34353;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L,U:       <ARITHMETIC EXPRESSION>;
                LOWER AND UPPER BOUND OF THE ROW VECTOR;
     I:         <ARITHMETIC EXPRESSION>;
                ROW-INDEX OF THE ROW VECTOR;
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY"AR,AI[I:I,L:U];
                ENTRY:
                AR : REAL PART,
                AI : IMAGINARY PART OF THE ROW VECTOR
                EXIT:
                THE TRANSFORMED COMPLEX ROW;
     XR,XI:     <ARITHMETIC EXPRESSION>;
                XR: REAL PART OF THE MULTIPLICATION FACTOR;
                XI: IMAGINARY PART OF THE MULTIPLICATION FACTOR.
 
 
 PROCEDURES USED: COMMUL = CP34341.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO (U-L).
 
 
 LANGUAGE: ALGOL 60.
1SECTION : 1.2.3              (MAY 1974)                          PAGE 3
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34352;
     "PROCEDURE" COMCOLCST(L,U,J,AR,AI,XR,XI);
     "VALUE" L,U,J,XR,XI;"INTEGER" L,U,J;"REAL" XR,XI;
     "ARRAY" AR,AI;
     "BEGIN"
     "FOR" L:=L "STEP" 1 "UNTIL" U "DO"
     COMMUL(AR[L,J],AI[L,J],XR,XI,AR[L,J],AI[L,J]);
     "END" COMCOLCST;
         "EOP"
0"CODE" 34353;
     "PROCEDURE" COMROWCST(L, U, I, AR, AI, XR, XI);
     "VALUE" L, U, I, XR, XI; "INTEGER" L, U, I; "REAL" XR, XI;
     "ARRAY" AR, AI;
     "BEGIN"
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" COMMUL(AR[I,L], AI[I,L], XR,
     XI, AR[I,L], AI[I,L]);
     "END" COMROWCST;
         "EOP"
1SECTION : 1.2.4              (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED : 731016.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THREE PROCEDURES:
 
     COMMATVEC CALCULATES THE SCALAR PRODUCT OF A COMPLEX ROWVECTOR
     GIVEN IN ARRAY AR,AI[I:I,L:U] AND THE COMPLEX VECTOR GIVEN IN
     ARRAY BR,BI[L:U].
     HSHCOMCOL TRANSFORMS A COMPLEX VECTOR INTO A VECTOR
     PROPORTIONAL TO A UNIT VECTOR;
     HSHCOMPRD PREMULTIPLIES A COMPLEX MATRIX WITH A COMPLEX
     HOUSEHOLDER MATRIX.
     HSHCOMCOL AND HSHCOMPRD ARE AUXILIARY PROCEDURES FOR PREMULTIPLYING
     A COMPLEX MATRIX OR VECTOR WITH A COMPLEX HOUSEHOLDER MATRIX;
 
 
 KEYWORDS:
 
     COMPLEX SCALAR PRODUCTS.
     HOUSEHOLDER TRANSFORMATION
 
 
 SUBSECTION: COMMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" COMMATVEC(L, U, I, AR, AI, BR, BI, RR, RI);
     "VALUE" L, U, I; "INTEGER" L, U, I; "REAL" RR, RI;
     "ARRAY" AR, AI, BR, BI;
     "CODE" 34354;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L,U :   <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE VECTORS;
     I :     <ARITHMETIC EXPRESSION>;
             ROW-INDEX OF THE  ROW VECTORS AR AND AI;
     AR,AI:  <ARRAY IDENTIFIER>;
             "ARRAY" AR,AI[I:I,L:U];
             ENTRY:
             AR: REAL PART AND
             AI: IMAGINARY PART OF THE MATRIX;
1SECTION : 1.2.4              (MAY 1974)                          PAGE 2
 
 
 
     BR,BI : <ARRAY IDENTIFIER>;
             "ARRAY" BR,BI[L:U];
             ENTRY:
             BR: REAL PART AND
             BI: IMAGINARY PART OF THE VECTOR;
     RR,RI:  <VARIABLE>;
             EXIT:
             RR: THE REAL PART AND
             RI: THE IMAGINARY PART OF THE SCALAR PRODUCT.
 
 
 PROCEDURES USED:MATVEC=CP34011.
 
 
 RUNNING TIME: PROPORTIONAL TO U-L.
 
 
 LANGUAGE: ALGOL 60.
 
 
 SUBSECTION: HSHCOMCOL.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "BOOLEAN" "PROCEDURE" HSHCOMCOL(L, U, J, AR, AI, TOL, K, C, S, T);
     "VALUE" L, U, J, TOL; "INTEGER" L, U, J; "REAL" TOL, K, C, S, T;
     "ARRAY" AR, AI;
     "CODE" 34355;
 
     HSHCOMCOL DELIVERS THE FOLLOWING BOOLEAN VALUE:
     IF AR[L+1,J]**2+AI[L+1,J]**2+...+AR[U,J]**2+AI[U,J]**2>TOL THEN
     A TRANSFORMATION IS PERFORMED AND HSHCOMCOL:="TRUE",OTHERWISE
     HSHCOMCOL:="FALSE" AND THE VECTOR TO BE TRANSFORMED IS CONSIDERED
     TO BE PROPORTIONAL TO THE DESIRED UNIT VECTOR AND NO
     TRANSFORMATION IS PERFORMED.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L,U,J:  <ARITHMETIC EXPRESSION>;
             THE COMPLEX VECTOR  TO BE TRANSFORMED, MUST BE GIVEN IN
             THE J-TH COLUMN FROM ROW L UNTIL ROW U OF A COMPLEX
             MATRIX;
     AR,AI:  <ARRAY IDENTIIER>;
             "ARRAY" AR,AI[L:U,J:J];
             ENTRY:
             THE REAL PART AND THE IMAGINARY PART OF THE VECTOR TO BE
             TRANSFORMED MUST BE GIVEN IN THE ARRAYS AR AND AI,
             RESPECTIVELY;
             EXIT:
             THE REAL PART AND THE IMAGINARY PART OF THE VECTOR U,
             OF THE HOUSEHOLDER MATRIX I-UU"/T (WHERE " DENOTES
             CONJUGATING AND TRANSPOSING)ARE DELIVERED IN THE ARRAYS
             AR AND AI,RESPECTIVELY,PROVIDED A TRANSFORMATION IS
             PERFORMED.IF NO TRANSFORMATION IS PERFORMED THE ARRAYS
             AR AND AI ARE UNALTERED;
1SECTION : 1.2.4              (DECEMBER 1979)                     PAGE 3
 
 
 
     TOL:    <ARITHMETIC EXPRESSION>;
             ENTRY: A TOLERANCE;
                (E.G. THE SQUARE OF THE MACHINE PRECISION TIMES A NORM
                 OF THE MATRIX IN CONSIDERATION);
     T:      <ARITHMETIC EXPRESSION>;
             EXIT:
             INFORMATION CONCERNING THE TRANSFORMATION,I.E. THE SCALAR
             T OF THE HOUSEHOLDER MATRIX ,PROVIDED A TRANSFORMATION IS
             PERFORMED.OTHERWISE,T:=-1;
     K,C,S:  <VARIABLE>;
             EXIT:
             THE MODULUS , COSINE AND SINE OF THE ARGUMENT OF THE
             FIRST ELEMENT OF THE TRANSFORMED VECTOR ARE DELIVERED IN
             K,C AND S,RESPECTIVELY,PROVIDED A TRANSFORMATION IS
             PERFORMED.OTHERWISE THE MODULUS,COSINE AND SINE OF THE
             ARGUMENT OF THE COMPLEX NUMBER AR[L,J]+AI[L,J]*I ARE
             DELIVERED.
 
 PROCEDURES USED:
 
     CARPOL=CP34344,
     TAMMAT=CP34014.
 
 
 RUNNING TIME: PROPORTIONAL TO U-L.
 
 
 METHOD AND PERFORMANCE:
 
     SEE WILKINSON(1965,P.49,50).
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 1.2.4              (DECEMBER 1975)                     PAGE 4
 
 
 
 SUBSECTION: HSHCOMPRD.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHCOMPRD(I, II, L, U, J, AR, AI, BR, BI, T);
     "VALUE" I, II, L, U, J, T; "INTEGER" I, II, L, U, J; "REAL" T;
     "ARRAY" AR, AI, BR, BI;
     "CODE" 34356;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     I,II,L,U:   <ARITHMETIC EXPRESSION>;
                 ENTRY:
                 THE COMPLEX MATRIX TO BE PREMULTIPLIED, MUST BE GIVEN
                 IN THE L-TH TO    U-TH COLUMN FROM ROW I TO    ROW II
                 OF A COMPLEX MATRIX;
     J:          <ARITHMETIC EXPRESSION>;
                 ENTRY:
                 THE COMPLEX VECTOR V OF THE HOUSEHOLDER MATRIX
                 I-VV"/T,WHERE " DENOTES TRANSPOSING AND CONJUGATING,
                 MUST BE GIVEN IN THE J-TH COLUMN FROM ROW I TO    ROW
                 II OF A COMPLEX MATRIX GIVEN IN (BR,BI);
     AR,AI:      <ARRAY IDENTIFIER>;
                 "ARRAY" AR,AI[I:II,L:U];
                 ENTRY:
                 THE REAL PART AND THE IMAGINARY PART OF THE MATRIX TO
                 BE PREMULTIPLIED,MUST BE GIVEN IN THE ARRAYS AR AND
                 AI,RESPECTIVELY;
                 EXIT:
                 THE REAL PART AND THE IMAGINARY PART OF THE
                 RESULTING MATRIX ARE DELIVERED IN THE ARRAYS AR AND
                 AI,RESPECTIVELY;
     BR,BI:      <ARRAY IDENTIFIER>;
                 "ARRAY" BR,BI[I:II,J:J];
                 ENTRY:
                 THE REAL PART AND THE IMAGINARY PART OF THE COMPLEX
                 VECTOR V OF THE HOUSEHOLDER MATRIX MUST BE GIVEN IN
                 THE ARRAYS BR AND BI,RESPECTIVELY;
                 (E.G. AS DELIVERED BY HSHCOMCOL);
     T:          <ARITHMETIC EXPRESSION>;
                 ENTRY:
                 THE SCALAR T OF THE HOUSEHOLDER MATRIX;
                 (E.G. AS DELIVERED BY HSHCOMCOL);
 
 
1SECTION : 1.2.4              (MAY 1974)                          PAGE 5
 
 
 
 PROCEDURES USED:
 
     TAMMAT   =CP34014,
     ELMCOMCOL=CP34377.
 
 
 RUNNING TIME: PROPORTIONAL TO (U-L)*(II-I).
 
 
 LANGUAGE: ALGOL 60.
 
 
 REFERENCE:
 
     WILKINSON,J.H(1965):
     THE ALGEBRAIC EIGENVALUE PROBLEM,
     CLARENDON PRESS,OXFORD.
 
 
 EXAMPLE OF USE:
 
    AS A FORMAL TEST OF THE PROCEDURES HSHCOMCOL AND HSHCOMPRD THE
    FOLLOWING MATRIX:
      3   4*I
      4*I 5
    IS TRANSFORMED INTO UPPER TRIANGULAR FORM.
 
 "BEGIN""INTEGER"I;"REAL"K,C,S,T;
    "ARRAY"AR,AI[1:2,1:2];
    AR[1,1]:=3;AR[1,2]:=AR[2,1]:=0;AR[2,2]:=5;
    AI[1,1]:=0;AI[1,2]:=AI[2,1]:=4;AI[2,2]:=0;
    "IF"HSHCOMCOL(1,2,1,AR,AI,("-14*5)**2,K,C,S,T)"THEN"
    HSHCOMPRD(1,2,2,2,1,AR,AI,AR,AI,T);
    OUTPUT(61,"(""("AFTER USE HSHCOMCOL,HSHCOMPRD:")",/,
     2(2(-D.D,+D.D,"("*I")",BB),/)")",
     AR[1,1],AI[1,1],AR[1,2],AI[1,2],AR[2,1],AI[2,1],AR[2,2],AI[2,2]);
    OUTPUT(61,"(""("K,   C,   S,   T,")",/,3(-D.DB),-DD.D,/,")",K,C,S,
     T);
 "END"
 
 OUTPUT:
 AFTER USE HSHCOMCOL,HSHCOMPRD:
  8.0+0.0*I   0.0+1.6*I
  0.0+4.0*I   6.2+0.0*I
 K,   C,   S,   T,
  5.0 -1.0  0.0  40.0
 
 
1SECTION : 1.2.4              (MAY 1974)                          PAGE 6
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34354;
     "PROCEDURE" COMMATVEC(L, U, I, AR, AI, BR, BI, RR, RI);
     "VALUE" L, U, I; "INTEGER" L, U, I; "REAL" RR, RI;
     "ARRAY" AR, AI, BR, BI;
     "BEGIN"
         "REAL" MV;
         MV:= MATVEC(L, U, I, AR, BR) - MATVEC(L, U, I, AI, BI);
         RI:= MATVEC(L, U, I, AI, BR) + MATVEC(L, U, I, AR, BI);
         RR:=MV
     "END" COMMATVEC;
         "EOP"
0"CODE" 34355;
     "BOOLEAN" "PROCEDURE" HSHCOMCOL(L, U, J, AR, AI, TOL, K, C, S, T);
     "VALUE" L, U, J, TOL; "INTEGER" L, U, J; "REAL" TOL, K, C, S, T;
     "ARRAY" AR, AI;
     "BEGIN" "REAL" VR, DEL, MOD, H, ARLJ, AILJ;
         VR:= TAMMAT(L + 1, U, J, J, AR, AR) + TAMMAT(L + 1, U,
         J, J, AI, AI); ARLJ:= AR[L,J]; AILJ:= AI[L,J];
         CARPOL(ARLJ, AILJ, MOD, C, S); "IF" VR > TOL "THEN"
         "BEGIN" VR:= VR + ARLJ ** 2 + AILJ ** 2; H:= K:= SQRT(VR);
             T:= VR + MOD * H;
             "IF" ARLJ = 0 "AND" AILJ = 0 "THEN" AR[L,J]:= H "ELSE"
             "BEGIN" AR[L,J]:= ARLJ + C * K; AI[L,J]:= AILJ + S * K;
                 S:= - S
             "END";
             C:= - C; HSHCOMCOL:= "TRUE"
         "END"
         "ELSE"
         "BEGIN" HSHCOMCOL:= "FALSE"; K:= MOD; T:= - 1 "END"
     "END" HSHCOMCOL;
         "EOP"
0"CODE" 34356;
     "PROCEDURE" HSHCOMPRD(I, II, L, U, J, AR, AI, BR, BI, T);
     "VALUE" I, II, L, U, J, T; "INTEGER" I, II, L, U, J; "REAL" T;
     "ARRAY" AR, AI, BR, BI;
     "BEGIN"
     "FOR" L:= L "STEP" 1 "UNTIL" U "DO" ELMCOMCOL(I, II, L, J, AR, AI,
     BR, BI, ( - TAMMAT(I, II, J, L, BR, AR) - TAMMAT(I, II, J,
     L, BI, AI)) / T, (TAMMAT(I, II, J, L, BI, AR) - TAMMAT(I,
     II, J, L, BR, AI)) / T);
     "END" HSHCOMPRD;
         "EOP"
1SECTION : 1.2.5              (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET , C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED : 730813.
 
 
 BRIEF DESCRIPTION :
 
     THIS  SECTION  CONTAINS THE PROCEDURES ELMCOMVECCOL, ELMCOMCOL  AND
     ELMCOMROWVEC.
     ELMCOMVECCOL  ADDS  XR+I*XI  TIMES THE COMPLEX  COLUMN VECTOR GIVEN
     IN  ARRAY BR,BI[L:U,J:J]  TO  THE  COMPLEX VECTOR  GIVEN  IN  ARRAY
     AR,AI[L:U].
     ELMCOMCOL ADDS  XR+I*XI  TIMES THE  COMPLEX COLUMN VECTOR  GIVEN IN
     ARRAY  BR,BI[L:U,J:J]  TO THE COMPLEX COLUMN VECTOR GIVEN IN  ARRAY
     AR,AI[L:U,I:I].
     ELMCOMROWVEC ADDS  XR+I*XI  TIMES THE COMPLEX VECTOR GIVEN IN ARRAY
     BR,BI[L:U] TO THE COMPLEX ROW VECTOR GIVEN IN ARRAY AR,AI[I:I,L:U].
 
 
 KEYWORDS :
 
     COMPLEX VECTOR OPERATIONS ,
     ELIMINATION.
 
 
 SUBSECTION : ELMCOMVECCOL.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" ELMCOMVECCOL(L,U,J,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,J,XR,XI;
     "INTEGER" L,U,J;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "CODE" 34376;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     L,U:       <ARITHMETIC EXPRESSION>;
                LOWER AND UPPER BOUND OF THE VECTORS;
     J:         <ARITHMETIC EXPRESSION>;
                COLUMN-INDEX OF THE COLUMN VECTORS BR AND BI;
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[L:U]
                ENTRY:
                AR : REAL PART OF THE VECTOR,
                AI : IMAGINARY  PART  OF  THE  VECTOR.
                EXIT:
                THE RESULTING VECTOR (SEE ALSO BRIEF DESCRIPTION);
1SECTION : 1.2.5              (DECEMBER 1979)                     PAGE 2
 
 
 
     BR,BI:     <ARRAY IDENTIFIER>;
                "ARRAY" BR,BI[L:U,J:J];
                ENTRY:
                BR : REAL PART OF THE COLUMN VECTOR,
                BI : IMAGINARY PART OF THE COLUMN  VECTOR.
     XR,XI:     <ARITHMETIC EXPRESSION>;
                ENTRY:
                XR: REAL PART OF THE ELIMINATION FACTOR;
                XI: IMAGINARY PART OF THE ELIMINATION FACTOR .
 
 
 PROCEDURES USED : ELMVECCOL = CP34021 .
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (U-L) .
 
 
 LANGUAGE: ALGOL 60.
 
 
 SUBSECTION : ELMCOMCOL.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" ELMCOMCOL(L,U,I,J,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,I,J,XR,XI;
     "INTEGER" L,U,I,J;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "CODE" 34377;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     L,U:       <ARITHMETIC EXPRESSION>;
                LOWER AND UPPER BOUND OF THE VECTORS;
     I,J:       <ARITHMETIC EXPRESSION>;
                I: COLUMN-INDEX OF THE COLUMN VECTORS AR AND AI;
                J: COLUMN-INDEX OF THE COLUMN VECTORS BR AND BI;
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[L:U,I:I]
                ENTRY:
                AR : REAL PART OF THE COLUMN VECTOR,
                AI : IMAGINARY PART OF THE COLUMN VECTOR.
                EXIT:
                THE RESULTING VECTOR (SEE ALSO BRIEF DESCRIPTION);
     BR,BI:     <ARRAY IDENTIFIER>;
                "ARRAY" BR,BI[L:U,J:J]
                ENTRY:
                BR : REAL PART OF THE COLUMN VECTOR,
                BI : IMAGINARY PART OF THE COLUMN VECTOR.
     XR,XI:     <ARITHMETIC EXPRESSION>;
                ENTRY:
                XR: REAL PART OF THE ELIMINATION FACTOR;
                XI: IMAGINARY PART OF THE ELIMINATION FACTOR .
1SECTION : 1.2.5              (MAY 1974)                          PAGE 3
 
 
 
 PROCEDURES USED : ELMCOL = CP34023 .
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (U-L) .
 
 
 LANGUAGE: ALGOL 60.
 
 
 SUBSECTION : ELMCOMROWVEC .
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" ELMCOMROWVEC(L,U,I,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,I,XR,XI;
     "INTEGER" L,U,I;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "CODE" 34378;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     L,U:       <ARITHMETIC EXPRESSION>;
                LOWER AND UPPER BOUND OF THE VECTORS;
     I:         <ARITHMETIC EXPRESSION>;
                ROW-INDEX OF THE ROW VECTORS AR AND AI;
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[I:I,L:U]
                ENTRY:
                AR : REAL PART OF THE ROW VECTOR,
                AI : IMAGINARY PART OF THE ROW VECTOR.
                EXIT:
                THE RESULTING VECTOR (SEE ALSO BRIEF DESCRIPTION);
     BR,BI:     <ARRAY IDENTIFIER>;
                "ARRAY" BR,BI[L:U]
                ENTRY:
                BR : REAL PART OF THE VECTOR,
                BI : IMAGINARY PART OF THE VECTOR
     XR,XI:     <ARITHMETIC EXPRESSION>;
                ENTRY:
                XR: REAL PART OF THE ELIMINATION FACTOR;
                XI: IMAGINARY PART OF THE ELIMINATION FACTOR .
 
 
 PROCEDURES USED : ELMROWVEC = CP34027 .
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (U-L) .
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 1.2.5              (MAY 1974)                          PAGE 4
 
 
 
 EXAMPLE OF USE :
 
     "BEGIN"
     "COMMENT" EXAMPLE OF USE ELMCOMCOL;
     "REAL" "ARRAY" AR,AI[1:2,1:2];
     "INTEGER" I,J;
     "PROCEDURE" OUT(K);"INTEGER" K;
     OUTPUT(61,"("2(-D,+D,"("*I  ")"),/")",
               AR[K,1],AI[K,1],AR[K,2],AI[K,2]);
     AR[1,1]:=+1;AR[1,2]:=-9;AR[2,1]:=-1;AR[2,2]:=-1;
     AI[1,1]:=+2;AI[1,2]:=+2;AI[2,1]:=+2;AI[2,2]:=-2;
     OUTPUT(61,"(""("INPUT MATRIX:")",/")");
     "FOR" I:=1,2 "DO" OUT(I);
     ELMCOMCOL(1,2,2,1,AR,AI,AR,AI,1,-4);
     OUTPUT(61,"("/,"("MATRIX AFTER ELIMINATION:")",/")");
     OUTPUT(61,"("-D,+D,"("*I")",4B,Z,D/")",
               AR[1,1],AI[1,1],AR[1,2],AI[1,2]);
     OUT(2)
     "END"
 
     OUTPUT:
     INPUT MATRIX:
      1+2*I  -9+2*I
     -1+2*I  -1-2*I
 
     MATRIX AFTER ELIMINATION:
      1+2*I     0
     -1+2*I   6+4*I    .
 
 
1SECTION : 1.2.5              (MAY 1974)                          PAGE 5
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34376;
     "PROCEDURE" ELMCOMVECCOL(L,U,J,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,J,XR,XI;
     "INTEGER" L,U,J;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "BEGIN"
         ELMVECCOL(L,U,J,AR,BR,XR);
         ELMVECCOL(L,U,J,AR,BI,-XI);
         ELMVECCOL(L,U,J,AI,BR,XI);
         ELMVECCOL(L,U,J,AI,BI,XR)
     "END" ELMCOMVECCOL;
         "EOP"
0"CODE" 34377;
     "PROCEDURE" ELMCOMCOL(L,U,I,J,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,I,J,XR,XI;
     "INTEGER" L,U,I,J;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "BEGIN"
         ELMCOL(L,U,I,J,AR,BR,XR);
         ELMCOL(L,U,I,J,AR,BI,-XI);
         ELMCOL(L,U,I,J,AI,BR,XI);
         ELMCOL(L,U,I,J,AI,BI,XR)
     "END" ELMCOMCOL;
         "EOP"
0"CODE" 34378;
     "PROCEDURE" ELMCOMROWVEC(L,U,I,AR,AI,BR,BI,XR,XI);
     "VALUE" L,U,I,XR,XI;
     "INTEGER" L,U,I;"REAL" XR,XI;"ARRAY" AR,AI,BR,BI;
     "BEGIN"
         ELMROWVEC(L,U,I,AR,BR,XR);
         ELMROWVEC(L,U,I,AR,BI,-XI);
         ELMROWVEC(L,U,I,AI,BR,XI);
         ELMROWVEC(L,U,I,AI,BI,XR)
     "END" ELMCOMROWVEC;
         "EOP"
1SECTION : 1.2.7              (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHORS  : J.J.G. ADMIRAAL, C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : J.J.G. ADMIRAAL, H. FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE, UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED : 730817.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES ROTCOMCOL, ROTCOMROW AND CHSH2
     ROTCOMCOL REPLACES  THE COLUMN  VECTOR VR+I*VI GIVEN IN THE  ARRAYS
     AR,AI[L:U,I:I]  AND THE  COLUMN VECTOR YR+I*YI GIVEN IN THE  ARRAYS
     AR,AI[L:U,J:J] BY  THE VECTORS (VR+I*VI)*(CR-I*CI)-(YR+I*YI)*S  AND
     (YR+I*YI)*(CR+I*CI)+(VR+I*VI)*S, RESPECTIVELY.
     ROTCOMROW  REPLACES  THE  ROW VECTOR VR+I*VI   GIVEN IN  THE ARRAYS
     AR,AI[I:I,L:U]  AND THE ROW VECTOR  YR+I*YI  GIVEN  IN  THE  ARRAYS
     AR,AI[J:J,L:U] BY THE VECTORS (VR+I*VI)*(CR-I*CI)+(YR+I*YI)*S AND
     (YR+I*YI)*(CR+I*CI)-(VR+I*VI)*S, RESPECTIVELY.
     CHSH2 COMPUTES THE COMPLEX HOUSEHOLDERMATRIX THAT
     MAPS THE COMPLEX VECTOR (A1,A2) INTO THE DIRECTION (1,0).
     WARNING :  IN ROTCOMCOL AND ROTCOMROW THE COSINE IS COMPLEX AND THE
         SINE IS REAL, IN CONTRAST TO THIS, IN CHSH2 THE SINE IS COMPLEX
         AND THE COSINE IS REAL.
 
 
 KEYWORDS :
 
     COMPLEX VECTOR OPERATIONS,
     ROTATION,
     HOUSEHOLDER MATRIX.
 
 
1SECTION : 1.2.7              (JANUARY 1976)                      PAGE 2
 
 
 
 SUBSECTION : ROTCOMCOL .
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" ROTCOMCOL(L, U, I, J, AR, AI, CR, CI, S);
     "VALUE" L, U, I, J, CR, CI, S; "INTEGER" L, U, I, J;
     "REAL" CR, CI, S; "ARRAY" AR, AI;
     "CODE" 34357;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     L,U,I,J:   <ARITHMETIC EXPRESSION>;
                THE  ROTATION   IS  PERFORMED  ON  THE   COLUMN  VECTORS
                AR,AI[L:U,I:I] AND AR,AI[L:U,J:J];
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[L:U,I:J];
                ENTRY:
                AR:THE REAL PARTS OF THE COLUMN VECTORS
                AI:THE IMAGINARY PARTS OF THE COLUMN VECTORS
                EXIT:
                THE RESULTING VECTORS (SEE ALSO BRIEF DESCRIPTION);
     CR,CI,S:   <ARITHMETIC EXPRESSION>;
                ENTRY:
                ROTATION FACTORS; SEE ALSO BRIEF DESCRIPTION.
 
 
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (U-L) .
 
 
 LANGUAGE: ALGOL 60.
 
 
1SECTION : 1.2.7              (JANUARY 1976)                      PAGE 3
 
 
 
 SUBSECTION : ROTCOMROW .
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" ROTCOMROW(L, U, I, J, AR, AI, CR, CI, S);
     "VALUE" L, U, I, J, CR, CI, S; "INTEGER" L, U, I, J;
     "REAL" CR, CI, S; "ARRAY" AR, AI;
     "CODE" 34358;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     L,U,I,J:   <ARITHMETIC EXPRESSION>;
                THE   ROTATION   IS   PERFORMED  ON  THE  ROW    VECTORS
                AR,AI[I:I,L:U] AND AR,AI[J:J,L:U];
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[I:J,L:U];
                ENTRY:
                AR:THE REAL PARTS OF THE ROW VECTORS
                AI:THE IMAGINARY PARTS OF THE ROW VECTORS
                EXIT:
                THE RESULTING VECTORS (SEE ALSO BRIEF DESCRIPTION);
     CR,CI,S:   <ARITHMETIC EXPRESSION>;
                ENTRY:
                ROTATION FACTORS; SEE ALSO BRIEF DESCRIPTION.
 
 
 PROCEDURES USED : NONE .
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (U-L) .
 
 
 LANGUAGE: ALGOL 60.
 
 
 
 
 
1SECTION : 1.2.7              (JANUARY 1976)                      PAGE 4
 
 
 
 EXAMPLE OF USE :
 
     "BEGIN"
     "COMMENT" EXAMPLE OF USE ROTCOMCOL;
     "REAL" "ARRAY" AR,AI[1:2,1:2];
     "INTEGER" I,J;
     AR[1,1]:=+4;AR[1,2]:=+5;AR[2,1]:=-5;AR[2,2]:=+4;
     AI[1,1]:=+3;AI[1,2]:= 0;AI[2,1]:= 0;AI[2,2]:=-3;
     OUTPUT(61,"(""("INPUT MATRIX:")",/")");
     OUTPUT(61,"("-D,+D,"("*I")",4B,-D,Z/,BB-D,Z,3B,-D,+D,"("*I")",/")",
     AR[1,1],AI[1,1],AR[1,2],AI[1,2],AR[2,1],AI[2,1],AR[2,2],AI[2,2]);
     OUTPUT(61,"("//,"("AFTER POSTMULTIPLICATION WITH:")",/")");
     OUTPUT(61,"(""(".08-.06*I     -.1")",/,
               "("    .1     .08+.06*I")",//")");
     ROTCOMCOL(1,2,1,2,AR,AI,.08,.06,-.1);
     OUTPUT(61,"(""("DELIVERS:")",/")");
     OUTPUT(61,"("-D,Z,2BD,Z/,BD,Z,B-D,Z")",
     AR[1,1],AI[1,1],AR[1,2],AI[1,2],AR[2,1],AI[2,1],AR[2,2],AI[2,2]);
     "END"
 
     OUTPUT:
     INPUT MATRIX:
      4+3*I     5
       -5     4-3*I
 
     AFTER POSTMULTIPLICATION WITH:
     .08-.06*I     -.1
         .1     .08+.06*I
     DELIVERS:
      1   0
      0   1      .
 
 
1SECTION : 1.2.7              (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: CHSH2.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHSH2(A1R,A1I,A2R,A2I,C,SR,SI);
     "VALUE" A1R,A1I,A2R,A2I;"REAL" A1R,A1I,A2R,A2I,C,SR,SI;
     "CODE" 34611;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A1R: <ARITHMETIC EXPRESSION>;
          ENTRY: THE REAL PART OF THE FIRST VECTORCOMPONENT;
     A1I: <ARITHMETIC EXPRESSION>;
          ENTRY: THE IMAGINARY PART OF THE FIRST VECTORCOMPONENT;
     A2R: <ARITHMETIC EXPRESSION>;
          ENTRY: THE REAL PART OF THE SECOND VECTORCOMPONENT;
     A2I: <ARITHMETIC EXPRESSION>;
          ENTRY: THE IMAGINARY PART OF THE SECOND VECTORCOMPONENT;
     C,SR,SI: <VARIABLE>;
          EXIT: THE FACTORS THAT DETERMINE THE HOUSEHOLDER MATRIX.
                THE HOUSEHOLDERMATRIX, DEFINED BY:
                HA = B
                A  = (A1,A2)'
                B  = (-SIGN(A1R)*SQRT(A1*A1+A2*A2),O)',
                IS DETERMINED BY:
 
                (  -C    SR+I*SI)
                (SR+I*SI    C   )
 
 
 PROCEDURES USED: NONE;
 
 
 LANGUAGE: ALGOL 60;
 
 
 METHOD AND PERFORMANCE:
 
     AFTER A CALL OF CHSH2 YOU ARE ABLE TO ROTATE A COMPLEX VECTOR OF
     DIMENSION TWO BY MEANS OF THE FACTORS C,SR AND SI.
 
 
 EXAMPLE OF USE: CHSH2 IS USED IN QZI AND QZIVAL,SECTION 3.4
 
 
 
 
1SECTION : 1.2.7              (JANUARY 1976)                      PAGE 6
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34357;
     "PROCEDURE" ROTCOMCOL(L, U, I, J, AR, AI, CR, CI, S);
     "VALUE" L, U, I, J, CR, CI, S; "INTEGER" L, U, I, J;
     "REAL" CR, CI, S; "ARRAY" AR, AI;
     "BEGIN" "REAL" ARLI, AILI, ARLJ, AILJ;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" ARLI:= AR[L,I]; AILI:= AI[L,I]; ARLJ:= AR[L,J];
             AILJ:= AI[L,J];
             AR[L,I]:= CR * ARLI + CI * AILI - S * ARLJ;
             AI[L,I]:= CR * AILI - CI * ARLI - S * AILJ;
             AR[L,J]:= CR * ARLJ - CI * AILJ + S * ARLI;
             AI[L,J]:= CR * AILJ + CI * ARLJ + S * AILI;
         "END"
     "END" ROTCOMCOL;
         "EOP"
0"CODE" 34358;
     "PROCEDURE" ROTCOMROW(L, U, I, J, AR, AI, CR, CI, S);
     "VALUE" L, U, I, J, CR, CI, S; "INTEGER" L, U, I, J;
     "REAL" CR, CI, S; "ARRAY" AR, AI;
     "BEGIN" "REAL" ARIL, AIIL, ARJL, AIJL;
         "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
         "BEGIN" ARIL:= AR[I,L]; AIIL:= AI[I,L]; ARJL:= AR[J,L];
             AIJL:= AI[J,L];
             AR[I,L]:= CR * ARIL + CI * AIIL + S * ARJL;
             AI[I,L]:= CR * AIIL - CI * ARIL + S * AIJL;
             AR[J,L]:= CR * ARJL - CI * AIJL - S * ARIL;
             AI[J,L]:= CR * AIJL + CI * ARJL - S * AIIL;
         "END"
     "END" ROTCOMROW;
         "EOP"
0"CODE" 34611;
     "PROCEDURE"CHSH2(A1R,A1I,A2R,A2I,C,SR,SI);
     "VALUE"A1R,A1I,A2R,A2I;"REAL"A1R,A1I,A2R,A2I,C,SR,SI;
     "BEGIN" "REAL" R;
     "IF" A2R^=0 "OR" A2I^=0 "THEN"
     "BEGIN" "IF" A1R^=0 "OR" A1I^=0 "THEN"
         "BEGIN" R:=SQRT(A1R*A1R+A1I*A1I);C:=R;
             SR:=(A1R*A2R+A1I*A2I)/R;SI:=(A1R*A2I-A1I*A2R)/R;
             R:=SQRT(C*C+SR*SR+SI*SI);C:=C/R;SR:=SR/R;SI:=SI/R
         "END" "ELSE"
         "BEGIN" SI:=C:=0;SR:=1 "END"
     "END" "ELSE" "BEGIN" C:=1;SR:=SI:=0 "END"
     "END" CHSH2;
          "EOP"
1SECTION : 1.2.8              (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731016.
 
 
 BRIEF DESCRIPTION:
 
     COMEUCNRM CALCULATES THE EUCLIDEAN NORM OF A COMPLEX MATRIX
     WITH LW LOWER CODIAGONALS.
 
 
 KEYWORDS:
 
     EUCLIDEAN NORM,
     COMPLEX MATRIX.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" COMEUCNRM(AR, AI, LW, N); "VALUE" N, LW;
     "INTEGER" N, LW; "ARRAY" AR, AI;
     "CODE" 34359;
 
     COMEUCNRM DELIVERS THE EUCLIDEAN NORM OF A COMPLEX MATRIX WITH LW
             LOWER CODIAGONALS;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     LW:     <ARITHMETIC EXPRESSION>;
             THE NUMBER OF LOWER CODIAGONALS;
     AR,AI:  <ARRAY IDENTIFIER>;
             "ARRAY" AR,AI[1:N,1:N];
             ENTRY:
             THE REAL PART AND THE IMAGINARY PART OF THE COMPLEX
             MATRIX,WITH LW LOWER CODIAGONALS,MUST BE GIVEN IN THE
             ARRAYS AR AND AI,RESPECTIVELY.
 
 
 
1SECTION : 1.2.8              (DECEMBER 1975)                     PAGE 2
 
 
 
 PROCEDURES USED: MATTAM = CP34015.
 
 
 RUNNING TIME: PROPORTIONAL TO N**2.
 
 
 LANGUAGE: ALGOL 60.
 
 
 EXAMPLE OF USE:SEE EIGVALCOM OR EIGCOM (SECTION 3.3.2.2.2).
 
 
 SOURCE TEXT(S) :
0"CODE" 34359;
     "REAL" "PROCEDURE" COMEUCNRM(AR, AI, LW, N); "VALUE" N, LW;
     "INTEGER" N, LW; "ARRAY" AR, AI;
     "BEGIN" "INTEGER" I, L;
         "REAL" R;
         R:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" L:= "IF" I > LW "THEN" I - LW "ELSE" 1;
             R:= MATTAM(L, N, I, I, AR, AR) + MATTAM(L, N, I,
             I, AI, AI) + R;
         "END";
         COMEUCNRM:= SQRT(R)
     "END" COMEUCNRM;
         "EOP"
1SECTION : 1.2.9              (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHORS  :
 
     T.J. DEKKER, W. HOFFMANN (COMSCL),
     C.G. VAN DER LAAN (SCLCOM).
 
 
 CONTRIBUTORS:
 
     W. HOFFMANN, S.P.N. VAN KAMPEN (COMSCL),
     H. FIOLET, C.G. VAN DER LAAN (SCLCOM).
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731030.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES :
 
     COMSCL NORMALIZES  THE REAL AND  COMPLEX EIGENVECTORS
     GIVEN COLUMNWISE IN A TWO-DIMENSIONAL ARRAY; THE IMAGINARY PARTS OF
     THE CORRESPONDING  EIGENVALUES MUST  BE GIVEN IN A  ONE-DIMENSIONAL
     ARRAY;
     THE EIGENVECTORS ARE  NORMALIZED IN SUCH A WAY THAT, IN EACH EIGEN-
     VECTOR, AN ELEMENT OF MAXIMUM MODULUS EQUALS 1;
     THE NORMALIZED EIGENVECTORS ARE DELIVERED IN THE GIVEN ARRAY.
 
     SCLCOM NORMALIZES THE (NON-NULL) COLUMNS OF A COMPLEX MATRIX
     IN SUCH A WAY THAT IN EACH COLUMN AN ELEMENT OF MAXIMUM ABSOLUTE
     VALUE BECOMES EQUAL TO ONE.
 
 
 KEYWORDS:
 
     NORMALIZATION,
     SCALING OF COMPLEX EIGENVECTORS,
     COMPLEX SCALING.
 
 
1SECTION : 1.2.9              (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION : COMSCL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" COMSCL(A, N, N1, N2, IM); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, IM;
     "CODE" 34193;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,N1:N2];
             ENTRY: EACH REAL  EIGENVECTOR MUST BE  GIVEN IN A COLUMN OF
                    ARRAY  A, WHOSE  CORRESPONDING  ELEMENT OF  ARRAY IM
                    EQUALS 0;
                    THE REAL  AND IMAGINARY  PART OF EACH COMPLEX EIGEN-
                    VECTOR MUST BE GIVEN IN CONSECUTIVE COLUMNS OF ARRAY
                    A, WHOSE CORRESPONDING  ELEMENTS OF ARRAY IM ARE NOT
                    EQUAL TO 0;
             EXIT:  THE NORMALIZED EIGENVECTORS (I.E. IN EACH EIGEN-
                    VECTOR AN ELEMENT  OF MAXIMUM MODULUS  EQUALS 1) ARE
                    DELIVERED IN THE CORRESPONDING COLUMNS OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE NUMBER OF ROWS OF ARRAY A;
     N1, N2: <ARITHMETIC EXPRESSION>;
             THE LOWER AND UPPER BOUND OF THE COLUMN INDICES OF ARRAY A;
     IM:     <ARRAY IDENTIFIER>;
             "ARRAY" IM[N1:N2];
             THE IMAGINARY PARTS OF THE EIGENVALUES, OF WHICH THE EIGEN-
             VECTORS ARE GIVEN IN THE CORRESPONDING COLUMNS OF  ARRAY A,
             MUST BE GIVEN IN ARRAY IM.
 
 
 PROCEDURES USED: NONE.
 
 RUNNING TIME: PROPORTIONAL TO N * (N2 - N1 + 1).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE REF [1].
 
 
 REFERENCES:
 
     [1].T.J. DEKKER AND W. HOFFMANN.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2.
         MC TRACT 23, 1968, MATH. CENTR., AMSTERDAM.
 
 
 EXAMPLE OF USE:
     THE PROCEDURE COMSCL IS USED IN COMEIG1, SECTION 3.3.1.2.2.
1SECTION : 1.2.9              (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION : SCLCOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"SCLCOM(AR,AI,N,N1,N2);
     "VALUE"N,N1,N2;"INTEGER"N,N1,N2;"ARRAY"AR,AI;
     "CODE" 34360;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:  <ARRAY IDENTIFIER>;
             "ARRAY" AR,AI[1:N,N1:N2];
             ENTRY:
             THE REAL PART AND THE IMAGINARY PART OF THE MATRIX OF
             WHICH THE COLUMNS ARE TO BE SCALED MUST BE GIVEN IN THE
             ARRAYS AR AND AI,RESPECTIVELY;
             EXIT:
             THE REAL PART AND THE IMAGINARY PART OF THE MATRIX WITH
             SCALED COLUMNS  ARE DELIVERED IN THE ARRAYS AR AND AI,
             RESPECTIVELY;
     N,N1,N2:<ARITHMETIC EXPRESSION>;
             N    : ORDER OF THE MATRIX;
             N1,N2: THE N1-TH TO    N2-TH COLUMN VECTORS ARE TO BE
             SCALED.
 
 
 PROCEDURES USED: COMCOLCST = CP34352.
 
 
 RUNNING TIME: PROPORTIONAL TO N*(N2-N1).
 
 
 LANGUAGE: ALGOL 60.
 
 
 EXAMPLE OF USE: SEE EIGCOM (SECTION 3.3.2.2.2).
 
 
1SECTION : 1.2.9              (DECEMBER 1975)                     PAGE 4
 
 
 
 SOURCE TEXT(S) :
 
 "CODE" 34193;
     "COMMENT" MCA 2423;
     "PROCEDURE" COMSCL(A, N, N1, N2, IM); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, IM;
     "BEGIN" "INTEGER" I, J, K;
         "REAL" S, U, V, W;
 
         "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" S:= 0; "IF" IM[J] ^= 0 "THEN"
             "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" U:= A[I,J] ** 2 + A[I,J + 1] ** 2;
                     "IF" U > S "THEN" "BEGIN" S:= U; K:= I "END"
                 "END";
                 "IF" S ^= 0 "THEN"
                 "BEGIN" V:= A[K,J] / S; W:= - A[K,J + 1] / S;
                     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                     "BEGIN" U:= A[I,J]; S:= A[I,J + 1];
                         A[I,J]:= U * V - S * W;
                         A[I,J + 1]:= U * W + S * V
                     "END"
                 "END";
                 J:= J + 1
             "END"
             "ELSE"
             "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "IF" ABS(A[I,J]) > ABS(S) "THEN" S:= A[I,J];
                 "IF" S ^= 0 "THEN"
                 "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" A[I,J]:= A[I,J] / S
             "END"
         "END"
     "END" COMSCL;
         "EOP"
0"CODE" 34360;
     "PROCEDURE" SCLCOM(AR, AI, N, N1, N2); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" AR, AI;
     "BEGIN" "INTEGER" I, J, K;
         "REAL" S, R;
         "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" S:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" R:= AR[I,J] ** 2 + AI[I,J] ** 2; "IF" R > S "THEN"
                 "BEGIN" S:= R; K:= I "END"
             "END";
             "IF" S ^= 0 "THEN" COMCOLCST(1, N, J, AR, AI, AR[K,J] /
             S, - AI[K,J] / S)
         "END"
     "END" SCLCOM;
         "EOP"
1SECTION : 1.3.1             (MAY 1974)                           PAGE 1
 
 
 
 AUTHOR: C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730815.
 
 
 BRIEF DESCRIPTION:
 
 THIS SECTION CONTAINS THREE PROECEDURES:
     COMABS CALCULATES THE MODULUS OF A COMPLEX NUMBER.
     COMSQRT CALCULATES THE SQUARE ROOT OF A COMPLEX NUMBER
     CARPOL TRANSFORMS A COMPLEX NUMBER GIVEN IN CARTESIAN COORDINATES
     INTO POLAR COORDINATES
 
 
 KEYWORDS:
 
     COMPLEX NUMBER.
     MODULUS.
     SQUARE ROOT.
     TRANSFORMATION.
     CARTESIAN COORDINATES.
     POLAR COORDINATES.
 
 
 SUBSECTION: COMABS.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"COMABS(XR,XI);
     "VALUE"XR,XI;"REAL"XR,XI;
     "CODE" 34340;
 
     COMABS DELIVERS THE MODULUS OF THE COMPLEX NUMBER XR + I * XI;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     XR,XI:<ARITHMETIC EXPRESSION>;
           ENTRY:XR,XI ARE THE REAL PART AND THE IMAGINARY PART
                 OF THE COMPLEX NUMBER,RESPECTIVELY.
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE: ALGOL 60.
 
1SECTION : 1.3.1             (MAY 1974)                           PAGE 2
 
 
 
 EXAMPLE OF USE:
 
 "BEGIN"
 OUTPUT(61,"(""("THE MODULUS OF .3+.4*I EQUALS")",-D.DD")",
       COMABS(.3,.4))
 "END"
 
 THE MODULUS OF .3+.4*I EQUALS 0.50
 
 
 SUBSECTION : COMSQRT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMSQRT(AR,AI,PR,PI);
     "VALUE"AR,AI;"REAL"AR,AI,PR,PI;
     "CODE" 34343;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:<ARITHMETIC EXPRESSION>;
           ENTRY:AR,AI ARE THE REAL PART AND THE IMAGINARY PART
                 OF THE COMPLEX NUMBER,RESPECTIVELY;
     PR,PI;<VARIABLE>;
           EXIT:THE REAL PART AND THE IMAGINARY PART OF THE SQUARE ROOT
                ARE DELIVERED IN PR AND PI,RESPECTIVELY.
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE REPRESENTATION OF THE RESULTING COMPLEX NUMBER IS CHOSEN SUCH
     THAT ITS REAL PART IS NONNEGATIVE;THE PROCEDURE IS PROTECTED
     AGAINST INTERMEDIATE OVERFLOW.
 
 
 EXAMPLE OF USE:
 
 "BEGIN""REAL"R,I;
 COMSQRT(-3,4,R,I);
 OUTPUT(61,"(""("THE SQUARE ROOT OF -3+4*I IS")",-D.DD,+D.DD,"("*I")"
       ")",R,I);
 "END"
 
 THE SQUARE ROOT OF -3+4*I IS 1.00+2.00*I
1SECTION : 1.3.1             (MAY 1974)                           PAGE 3
 
 
 
 SUBSECTION : CARPOL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"CARPOL(AR,AI,R,C,S);
     "VALUE"AR,AI;"REAL"AR,AI,R,C,S;
     "CODE" 34344;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:<ARITHMETIC EXPRESSION>;
           ENTRY:AR,AI ARE THE REAL PART AND THE IMAGINARY PART OF THE
                 COMPLEX NUMBER ,RESPECTIVELY;
     R,C,S:<VARIABLE>;
           EXIT:THE MODULUS OF THE COMPLEX NUMBER IS DELIVERED IN R
                AND THE COSINE AND THE SINE OF THE ARGUMENT ARE
                DELIVERED IN C AND S,RESPECTIVELY;
                WHEN AR=AI=0 THEN C:=1 AND R:=S:=0.
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE: ALGOL 60.
 
 
 EXAMPLE OF USE:
 
 "BEGIN""REAL"R,C,S;
 CARPOL(.3,.4,R,C,S);
 OUTPUT(61,"(""("THE POLAR COORDINATES OF .3+.4*I ARE:")",/,
              "("MODULUS:")",-D.DD,/,
              "("COSINE OF ARGUMENT:")",-D.DD,/,
              "("SINE OF ARGUMENT:")",-D.DD")",R,C,S)
 "END"
 
 THE POLAR COORDINATES OF .3+.4*I ARE:
 MODULUS: 0.50
 COSINE OF ARGUMENT: 0.60
 SINE OF ARGUMENT: 0.80
 
1SECTION : 1.3.1             (MAY 1974)                           PAGE 4
 
 
 
 SOURCE TEXT(S):
0"CODE"34340;
 "REAL" "PROCEDURE" COMABS(XR,XI);"VALUE" XR,XI;"REAL" XR,XI;
 "BEGIN" XR:= ABS(XR); XI:= ABS(XI);
 COMABS:= "IF" XI > XR "THEN" SQRT((XR/XI)**2+1)*XI
 "ELSE" "IF" XI= 0 "THEN" XR "ELSE" SQRT((XI/XR)**2+1)*XR
 "END" COMABS;
         "EOP"
0"CODE"34343;
 "PROCEDURE" COMSQRT(AR,AI,PR,PI);
 "VALUE" AR,AI; "REAL" AR,AI,PR,PI;
 "IF" AR=0 & AI= 0 "THEN" PR:= PI:=0 "ELSE"
 "BEGIN" "REAL" BR,BI,H;
 BR:= ABS(AR); BI:= ABS(AI);
 H:= "IF" BI < BR "THEN"
 ("IF" BR<1 "THEN" SQRT((SQRT((BI/BR)**2+1)*.5+.5)*BR)
 "ELSE" SQRT((SQRT((BI/BR)**2+1)*.125+.125)*BR)*2)
 "ELSE" "IF" BI<1 "THEN" SQRT((SQRT((BR/BI)**2+1)*BI+BR)*2)*.5
 "ELSE" "IF" BR+1= 1 "THEN" SQRT(BI*.5)
 "ELSE" SQRT(SQRT((BR/BI)**2+1)*BI*.125+BR*.125)*2;
 "IF" AR >= 0 "THEN"
 "BEGIN" PR:= H; PI:= AI/H*.5 "END"
 "ELSE" "BEGIN" PI:= "IF" AI >= 0 "THEN" H "ELSE" -H;
 PR:= BI/H*.5
 "END"
 "END" COMSQRT;
         "EOP"
 
 "CODE"34344;
 "PROCEDURE"CARPOL(AR,AI,R,C,S);
 "VALUE" AR,AI; "REAL" AR,AI,R,C,S;
 "IF" AR=0&AI=0 "THEN"
   "BEGIN" C:=1;R:=S:=0 "END"
 "ELSE" "BEGIN"
    R:="IF" ABS(AR)>ABS(AI) "THEN"
     ABS(AR)*SQRT(1+(AI/AR)**2)
    "ELSE" ABS(AI)* SQRT(1+(AR/AI)**2);
    C:=AR/R;S:=AI/R
 "END"CARPOL;
         "EOP"
1SECTION : 1.3.2             (MAY 1974)                           PAGE 1
 
 
 
 AUTHOR: C.G. VAN DER LAAN.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730815.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES :
     COMMUL CALCULATES THE PRODUCT OF TWO COMPLEX NUMBERS.
     COMDIV CALCULATES THE QUOTIENT OF TWO COMPLEX NUMBERS.
 
 
 KEYWORDS:
 
     COMPLEX MULTIPLICATION.
     COMPLEX DIVISION.
 
 
 SUBSECTION COMMUL.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMMUL(AR,AI,BR,BI,RR,RI);
     "VALUE"AR,AI,BR,BI;"REAL"AR,AI,BR,BI,RR,RI;
     "CODE" 34341;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI,BR,BI:<ARITHMETIC EXPRESSION>;
                 ENTRY:AR,BR ARE THE REAL PARTS OF THE COMPLEX
                       NUMBERS AND AI,BI ARE THE IMAGINARY PARTS OF
                       THE COMPLEX NUMBERS;
     RR,RI:      <VARIABLE>;
                 EXIT:THE REAL PART AND THE IMAGINARY PART OF THE
                      RESULTING COMPLEX NUMBER ARE DELIVERED IN RR AND
                      RI,RESPECTIVELY.
 
 PROCEDURES USED: NONE.
 
 LANGUAGE: ALGOL 60.
 
1SECTION : 1.3.2             (DECEMBER 1975)                      PAGE 2
 
 
 
 EXAMPLE OF USE:
 
     "BEGIN""REAL"R,I;
     COMMUL(.1,.2,.3,.4,R,I);
     OUTPUT(61,"(""("(.1+.2*I)*(.3+.4*I)=")",-D.DD,+D.DD,"("*I")"")",R,I
          )
     "END"
 
     (.1+.2*I)*(.3+.4*I)=-0.05+0.10*I
 
 SUBSECTION : COMDIV.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMDIV(XR,XI,YR,YI,ZR,ZI);
     "VALUE"XR,XI,YR,YI;"REAL"XR,XI,YR,YI,ZR,ZI;
     "CODE" 34342;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     XR,XI,YR,YI:<ARITHMETIC EXPRESSION>;
                 ENTRY:XR,YR ARE THE REAL PARTS OF THE NUMERATOR
                       AND THE DENOMINATOR,RESPECTIVELY AND XI,YI ARE
                       THE CORRESPONDING IMAGINARY PARTS;
     ZR,ZI:      <VARIABLE>;
                 EXIT:THE REAL PART AND THE IMAGINARY PART OF THE
                      RESULTING COMPLEX NUMBER ARE DELIVERED IN RR
                      AND RI,RESPECTIVELY.
 
 
 RUNNING TIME:
 
     AT MOST SIX MULTIPLICATIONS AND/OR DIVISIONS ARE USED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE IS NOT PROTECTED AGAINST DIVISION BY ZERO.
 
 
1SECTION : 1.3.2             (MAY 1974)                           PAGE 3
 
 
 
 EXAMPLE OF USE:
 
 "BEGIN""REAL"R,I;
 COMDIV(-.05,.1,.1,.2,R,I);
 OUTPUT(61,"(""("(-.05+.1*I)/(.1+.2*I)=")",-D.DD,+D.DD,"("*I")"")"
        ,R,I)
 "END"
 
 (-.05+.1*I)/(.1+.2*I)= 0.30+0.40*I
 
 SOURCE TEXT(S):
0"CODE"34341;
 "PROCEDURE" COMMUL(AR,AI,BR,BI,RR,RI);
 "VALUE" AR,AI,BR,BI; "REAL" AR,AI,BR,BI,RR,RI;
 "BEGIN" RR:= AR * BR - AI * BI;
     RI:= AR * BI + AI * BR
 "END" COMMUL;
         "EOP"
0"CODE"34342;
 "PROCEDURE" COMDIV(XR,XI,YR,YI,ZR,ZI);
 "VALUE" XR,XI,YR,YI;"REAL" XR,XI,YR,YI,ZR,ZI;
 "BEGIN" "REAL" H,D;
 "IF" ABS(YI) < ABS(YR) "THEN"
 "BEGIN" "IF" YI= 0 "THEN"
 "BEGIN" ZR:= XR/YR; ZI:= XI/YR "END" "ELSE"
 "BEGIN" H:= YI/YR; D:= H*YI + YR;
 ZR:= (XR + H * XI)/D; ZI:= (XI-H*XR)/D
 "END"
 "END" "ELSE"
 "BEGIN" H:= YR/YI; D:= H*YR + YI;
 ZR:= (XR*H + XI)/D; ZI:= (XI*H - XR)/D
 "END"
 "END" COMDIV;
         "EOP"
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR: H.J.J. TE RIELE.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 740125; REVISED: 740514;
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS A SET OF FIVE PROCEDURES FOR
     THE BASIC ARITHMETIC OPERATIONS WITH LONG INTEGERS:
     LNG INT ADD EXACTLY COMPUTES THE SUM OF TWO NONNEGATIVE INTEGERS.
     LNG INT SUBTRACT EXACTLY COMPUTES THE DIFFERENCE OF TWO NONNEGATIVE
     INTEGERS.
     LNG INT MULT EXACTLY COMPUTES THE PRODUCT OF TWO NONNEGATIVE
     INTEGERS.
     LNG INT DIVIDE EXACTLY COMPUTES THE QUOTIENT WITH REMAINDER OF TWO
     NONNEGATIVE INTEGERS.
     LNG INT POWER EXACTLY COMPUTES U**POWER,
     WHERE U IS A NONNEGATIVE LONG INTEGER AND POWER IS THE
     POSITIVE (SINGLE-LENGTH) EXPONENT.
 
 
 KEYWORDS:
 
     LONG INTEGER ARITHMETIC,
     ADDITION,
     SUBTRACTION,
     MULTIPLICATION,
     DIVISION WITH REMAINDER,
     EXPONENTIATION.
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 2
 
 
 
 SUBSECTION : LNG INT ADD.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNG INT ADD(U,V,SUM);
     "INTEGER" "ARRAY" U,V,SUM;
     "CODE" 31200;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     U,V,SUM: <ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" U[0:U[0]], V[0:V[0]],
                               SUM[0:MAX(U[0],V[0])+1];
             BEFORE THE CALL OF LNG INT ADD, U AND V MUST
             CONTAIN THE LONG INTEGERS TO BE ADDED;
             AFTER THE CALL, SUM CONTAINS THE MULTI-LENGTH
             SUM OF U AND V, WHILE U AND V REMAIN UNCHANGED.
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY :
 
     EXECUTION FIELD LENGTH : 7.
 
 
 RUNNING TIME :
 
     WE GIVE A FORMULA FOR THE RUNNING TIME  IN MILLISECONDS ON THE
     CD CYBER 73-28 COMPUTER; THE RELATIVE PRECISION OF THE
     COEFFICIENTS IS AT MOST ONE OR TWO DIGITS:
     .10*MAX(U[0],V[0]) + .06*MIN(U[0],V[0]) + .56.
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE LNG INT POWER (THIS SECTION).
 
 
 EXAMPLE OF USE : SEE LNG INT POWER (THIS SECTION).
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 3
 
 
 
 SUBSECTION : LNG INT SUBTRACT.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" LNG INT SUBTRACT (U,V,DIFFERENCE);
     "INTEGER" "ARRAY" U,V,DIFFERENCE;
     "CODE" 31201;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     U,V,DIFFERENCE: <ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" U[0:U[0]],V[0:V[0]],DIFFERENCE[0:U[0]];
             BEFORE THE CALL OF LNG INT SUBTRACT, U AND V MUST
             CONTAIN THE LONG INTEGERS TO BE SUBTRACTED(V FROM U);
             AFTER THE CALL, DIFFERENCE CONTAINS THE MULTI-LENGTH
             DIFFERENCE U-V; IF U<V THEN DIFFERENCE[0]=0
             IS DELIVERED; U AND V REMAIN UNCHANGED.
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH : 7.
 
 
 RUNNING TIME :
 
     WE GIVE A FORMULA FOR THE RUNNING TIME  IN MILLISECONDS ON THE
     CD CYBER 73-28 COMPUTER; THE RELATIVE PRECISION OF THE
     COEFFICIENTS IS AT MOST ONE OR TWO DIGITS:
     .10*U[0] + .06*V[0] + .64.
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE LNG INT POWER (THIS SECTION).
 
 
 EXAMPLE OF USE : SEE LNG INT POWER (THIS SECTION).
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 4
 
 
 
 SUBSECTION : LNG INT MULT.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNG INT MULT(U,V,PRODUCT);
     "INTEGER" "ARRAY" U,V,PRODUCT;
     "CODE" 31202;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     U,V,PRODUCT: <ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" U[0:U[0]], V[0:V[0]],
                               PRODUCT[0:U[0]+V[0]];
             BEFORE THE CALL OF LNG INT MULT, U AND V MUST
             CONTAIN THE LONG INTEGERS TO BE MULTIPLIED;
             AFTER THE CALL, PRODUCT CONTAINS THE MULTI-LENGTH
             PRODUCT OF U AND V, WHILE U AND V REMAIN UNCHANGED.
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY  :
 
     EXECUTION FIELD LENGTH : 7.
 
 
 RUNNING TIME :
 
     WE GIVE A FORMULA FOR THE RUNNING TIME  IN MILLISECONDS ON THE
     CD CYBER 73-28 COMPUTER; THE RELATIVE PRECISION OF THE
     COEFFICIENTS IS AT MOST ONE OR TWO DIGITS:
     .18*U[0]*V[0] + .15*U[0] + .06*V[0] + .46.
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE LNG INT POWER (THIS SECTION).
 
 
 EXAMPLE OF USE : SEE LNG INT POWER (THIS SECTION).
 
 
1SECTION : 1.4                (MARCH 1977)                        PAGE 5
 
 
 
 SUBSECTION : LNG INT DIVIDE.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNG INT DIVIDE(U,V,QUOTIENT,REMAINDER); "VALUE" U;
     "INTEGER" "ARRAY" U,V,QUOTIENT,REMAINDER;
     "CODE" 31203;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     U,V,QUOTIENT,REMAINDER: <ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" U[0:U[0]], V[0:V[0]],
             QUOTIENT[0:U[0]-V[0]+1], REMAINDER[0:V[0]];
             BEFORE THE CALL OF LNG INT DIVIDE, U MUST CONTAIN THE
             DIVIDEND, V THE DIVISOR(V ^= 0);
             AFTER THE CALL, THE RESULTS OF THE LONG DIVISION
             OF U BY V (I.E. U//V AND U-U//V) ARE STORED INTO
             QUOTIENT AND REMAINDER; U AND V REMAIN UNCHANGED.
 
 
 PROCEDURES USED : NONE.
 
 
 REQUIRED CENTRAL MEMORY :
 
     11 + U[0] + (IF V[0]=1 OR U[0]<V[0] THEN 0 ELSE V[0]+1),
 
 
 RUNNING TIME :
 
     WE GIVE A FORMULA FOR THE RUNNING TIME  IN MILLISECONDS ON THE
     CD CYBER 73-28 COMPUTER; THE RELATIVE PRECISION OF THE
     COEFFICIENTS IS AT MOST ONE OR TWO DIGITS:
     IF V[0]=1 THEN (.34*U[0] + .67) ELSE IF V[1] >= 5 000 000 THEN
                         (.26*DIFF*V[0] + .57*DIFF + .10*V[0] + 1.8)
               ELSE  (.27*DIFF*V[0] + .66*DIFF + .66*V[0] + 2.0)
     (HERE DIFF=U[0]-V[0]+1, I.E. THE NUMBER OF EXECUTIONS
     OF THE STATEMENT, IN WHICH DIVISION OF A (V[0]+1)-PLACE
     NUMBER BY A V[0]-PLACE NUMBER IS PERFORMED).
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE LNG INT POWER (THIS SECTION).
 
 
 EXAMPLE OF USE : SEE LNG INT POWER (THIS SECTION).
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 6
 
 
 
 SUBSECTION : LNG INT POWER.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNG INT POWER(U,EXPONENT,RESULT);
     "VALUE" EXPONENT; "INTEGER" EXPONENT; "INTEGER" "ARRAY" U,RESULT;
     "CODE" 31204;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     EXPONENT: <ARITHMETIC EXPRESSION>;
             THE (POSITIVE) POWER TO WHICH THE LONG INTEGER U
             WILL BE RAISED;
     U,RESULT: <ARRAY IDENTIFIER>;
             "INTEGER" "ARRAY" U[0:U[0]], RESULT[0:U[0]*EXPONENT];
             BEFORE THE CALL OF LNG INT POWER, U MUST CONTAIN
             THE LONG INTEGER WHICH HAS TO BE RAISED TO THE
             POWER EXPONENT;
             AFTER THE CALL, RESULT CONTAINS THE VALUE OF THE
             LONG INTEGER U**EXPONENT; U REMAINS UNCHANGED.
 
 
 PROCEDURES USED :
 
     LNG INT MULT = CP31202.
 
 
 REQUIRED CENTRAL MEMORY :
 
     EXECUTION FIELD LENGTH : 4 + 3 * (U[0] * EXPONENT + 1).
 
 
 RUNNING TIME :
 
     FOR THIS PROCEDURE THE TIME FORMULA IS A COMPLICATED FUNCTION OF
     U[0], EXPONENT AND  THE NUMBER OF ONES IN THE BINARY REPRESENTATION
     OF EXPONENT, BUT ROUGHLY THE TIME IS  OF THE ORDER :
     (U(0)*EXPONENT)**2).
     TWO TESTCASES :
     EXPONENT    TIME(IN SEC.) FOR:
                   U[0]=1     U[0]=2
         20           .04        .10
         40           .13        .34
        100           .68       1.94
        300          5.48      16.6
        500         16.8       51.0
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 7
 
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     DEFINITION:
     A LONG INTEGER OF LENGTH N, OR AN N-PLACE INTEGER
     (N>0) IS ANY NONNEGATIVE INTEGER LESS THAN BASE**N,
     AND GREATER THAN OR EQUAL TO BASE**(N-1), WHERE BASE
     IS THE (POSITIVE) RADIX OF THE POSITIONAL NOTATION, IN
     WHICH THE INTEGERS ARE EXPRESSED.
 
     ALL FIVE PROCEDURES USE THE BASE 10 000 000; THIS IS THE LARGEST
     POWER OF 10, THE SQUARE OF WHICH CAN BE REPRESENTED EXACTLY
     ON THE CD CYBER 73-28 COMPUTER. IF ONE WANTS TO USE THE
     PROCEDURES WITH ANOTHER VALUE OF THE BASE, SAY R (NOT
     NECESSARILY A POWER OF 10), THEN IN THE SOURCE TEXTS OF THE
     PROCEDURES THE NUMBER 10 000 000 HAS TO BE REPLACED BY R
     (8 TIMES IN LNG INT ADD,
      2 TIMES IN LNG INT SUBTRACT,
      2 TIMES IN LNG INT MULT AND
     16 TIMES IN LNG INT DIVIDE).
     MOREOVER, IN LNG INT DIVIDE THE NUMBER 9 999 999 HAS TO BE
     REPLACED BY THE NUMBER R - 1.
 
     IF A[1], A[2], ..., A[N] ARE THE N "DIGITS" OF THE LONG
     INTEGER M OF LENGTH N (A[1] ^= 0), THEN
 
     M=((...(A[1]*BASE+A[2])*BASE+...+A[N-2])*BASE+A[N-1])*BASE+A[N].
 
     ACCORDINGLY, A LONG INTEGER M OF LENGTH N ALWAYS WILL
     BE STORED INTO A CORRESPONDING "INTEGER" "ARRAY" A,
     THE LENGTH N WILL BE STORED INTO THE ARRAY ELEMENT A[0].
 
     FOR THE METHOD OF THE PROCEDURES LNG INT ADD, LNG INT SUBTRACT,
     LNG INT MULT AND LNG INT DIVIDE, SEE [1; PP.229-248];
     PROCEDURE LNG INT POWER USES THE BINARY METHOD FOR
     EXPONENTIATION (SEE [1; PP.398-401]).
 
 
 REFERENCES:
 
     [1]. DONALD E. KNUTH.
          THE ART OF COMPUTER PROGRAMMING, VOLUME 2/
          SEMINUMERICAL ALGORITHMS.
          ADDISON-WESLEY PUBLISHING COMPANY, 1969.
 
1SECTION : 1.4                (MARCH 1977)                        PAGE 8
 
 
 
 EXAMPLE OF USE:
 
     "BEGIN"
 
        "PROCEDURE" OUT(A); "INTEGER" "ARRAY" A;
        "BEGIN" "INTEGER" I,L; L:= A[0];
           OUTPUT(61,"("B6ZD")",A[1]);
           "FOR" I:= 2 "STEP" 1 "UNTIL" L "DO" OUTPUT(61,"("B7D")",
              A[I]); OUTPUT(61,"("/")")
        "END" OUT;
        "INTEGER" "ARRAY" U,V,R1,R2[0:100];
 
        U[0]:=5; U[1]:=333; U[2]:=U[3]:=U[4]:=U[5]:=7 000 000; OUT(U);
        V[0]:=2; V[1]:=4 444; V[2]:=4 444 444; OUT(V);
 
        LNG INT ADD(U,V,R1); OUT(R1);
        LNG INT SUBTRACT(U,V,R1); OUT(R1);
        LNG INT MULT(U,V,R1); OUT(R1);
        LNG INT DIVIDE(U,V,R1,R2); OUT(R1); OUT(R2);
        LNG INT POWER(V,5,R1); OUT(R1)
     "END"
 
     DELIVERS:
         333 7000000 7000000 7000000 7000000
        4444 4444444
         333 7000000 7000000 7004445 1444444
         333 7000000 7000000 6995556 2555556
     1483111 1114073 9114221 9114221 9111110 8000000
      750825 0001650 0826575
         734 0700700
       17341 5299149 6553709 6327185 8964586 9972395 8069589 6628224
 
 
1SECTION : 1.4                (OCTOBER 1974)                      PAGE 9
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 31200;
 "PROCEDURE" LNG INT ADD(U,V,SUM); "INTEGER""ARRAY" U,V,SUM;
 "BEGIN""INTEGER" LU,LV,DIFF,CARRY,I,T,MAX;
    LU:=U[0]; LV:=V[0];
    "IF" LU >= LV "THEN"
    "BEGIN" MAX:=LU; DIFF:=LU - LV + 1; CARRY:=0;
       "FOR" I:=LU "STEP" -1 "UNTIL" DIFF "DO"
       "BEGIN" T:=U[I] + V[I-DIFF+1] + CARRY;
          CARRY:="IF" T<10 000 000 "THEN" 0 "ELSE" 1;
          SUM[I]:=T - CARRY * 10 000 000
       "END";
       "FOR" I:=DIFF - 1 "STEP" -1 "UNTIL" 1 "DO"
       "BEGIN" T:=U[I] + CARRY;
          CARRY:="IF" T<10 000 000 "THEN" 0 "ELSE" 1;
          SUM[I]:=T - CARRY * 10 000 000
       "END"
    "END" "ELSE"
    "BEGIN" MAX:=LV; DIFF:=LV - LU + 1; CARRY:=0;
       "FOR" I:=LV "STEP" -1 "UNTIL" DIFF "DO"
       "BEGIN" T:=V[I] + U[I-DIFF+1] + CARRY;
          CARRY:="IF" T<10 000 000 "THEN" 0 "ELSE" 1;
          SUM[I]:=T - CARRY * 10 000 000
       "END";
       "FOR" I:=DIFF - 1 "STEP" -1 "UNTIL" 1 "DO"
       "BEGIN" T:=V[I] + CARRY;
          CARRY:="IF" T<10 000 000 "THEN" 0 "ELSE" 1;
          SUM[I]:=T - CARRY * 10 000 000
       "END"
    "END";
    "IF" CARRY=1 "THEN"
    "BEGIN" "FOR" I:=MAX "STEP" -1 "UNTIL" 1 "DO"
       SUM[I+1]:=SUM[I]; SUM[1]:=1; MAX:=MAX + 1
    "END";
    SUM[0]:=MAX
 "END" LNG INT ADD
 
1SECTION : 1.4                (OCTOBER 1974)                     PAGE 10
 
 
                                                                  ;
         "EOP"
 "CODE" 31201;
 "PROCEDURE" LNG INT SUBTRACT(U,V,DIFFERENCE);
 "INTEGER""ARRAY" U,V,DIFFERENCE;
 "BEGIN""INTEGER" LU,LV,DIFF,I,T,J,CARRY;
    LU:=U[0]; LV:=V[0];
    "IF" LU<LV "OR" LU=LV "AND" U[1]<V[1] "THEN" DIFFERENCE[0]:=0 "ELSE"
    "BEGIN" DIFF:=LU - LV + 1; CARRY:=0;
       "FOR" I:=LU "STEP" -1 "UNTIL" DIFF "DO"
       "BEGIN" T:=U[I] - V[I-DIFF+1] + CARRY;
          CARRY:="IF" T<0 "THEN" -1 "ELSE" 0;
          DIFFERENCE[I]:=T - CARRY * 10 000 000
       "END";
       "FOR" I:=DIFF - 1 "STEP" -1 "UNTIL" 1 "DO"
       "BEGIN" T:=U[I] + CARRY; CARRY:="IF" T<0 "THEN" -1 "ELSE" 0;
          DIFFERENCE[I]:=T - CARRY * 10 000 000
       "END";
       "IF" CARRY=-1 "THEN"
       "BEGIN" DIFFERENCE[0]:=0; "GOTO" READY "END";
       I:=0; J:=LU;
       "FOR" I:=I+1 "WHILE" DIFFERENCE[I]=0 "AND" J>1 "DO" J:=J-1;
       DIFFERENCE[0]:=J;
       "IF" J<LU "THEN"
       "FOR" I:=1 "STEP" 1 "UNTIL" J "DO"
       DIFFERENCE[I]:=DIFFERENCE[LU+I-J]
    "END";
    READY:
 "END" LNG INT SUBTRACT;
         "EOP"
 
 "CODE" 31202;
 "PROCEDURE" LNG INT MULT(U,V,PRODUCT);
 "INTEGER""ARRAY" U,V,PRODUCT;
 "BEGIN""INTEGER" LU,LV,LUV,I,J,CARRY,T;
    LU:=U[0]; LV:=V[0]; LUV:=LU + LV;
    "FOR" I:=LU + 1 "STEP" 1 "UNTIL" LUV "DO" PRODUCT[I]:=0;
    "FOR" J:=LU "STEP" -1 "UNTIL" 1 "DO"
    "BEGIN" CARRY:=0;
       "FOR" I:=LV "STEP" -1 "UNTIL" 1 "DO"
       "BEGIN" T:=U[J] * V[I] + PRODUCT[J+I] + CARRY;
          CARRY:=T//10 000 000; PRODUCT[J+I]:=T - CARRY * 10 000 000
       "END"; PRODUCT[J]:=CARRY
    "END";
    "IF" PRODUCT[1]=0 "THEN"
    "BEGIN" "FOR" I:=2 "STEP" 1 "UNTIL" LUV "DO"
       PRODUCT[I-1]:=PRODUCT[I]; LUV:=LUV - 1
    "END"; PRODUCT[0]:=LUV
 "END" LNG INT MULT
1SECTION : 1.4                (OCTOBER 1974)                     PAGE 11
 
 
                                                                  ;
         "EOP"
 "CODE" 31203;
 "PROCEDURE" LNG INT DIVIDE(U,V,QUOTIENT,REMAINDER); "VALUE" U;
 "INTEGER""ARRAY" U,V,QUOTIENT,REMAINDER;
 "BEGIN""INTEGER" LU,LV,V1,DIFF,I,T,SCALE,D,Q1,J,CARRY;
    LU:=U[0]; LV:=V[0]; V1:=V[1]; DIFF:=LU - LV;
 
    "IF" LV=1 "THEN"
    "BEGIN" CARRY:=0;
       "FOR" I:=1 "STEP" 1 "UNTIL" LU "DO"
       "BEGIN" T:=CARRY * 10 000 000 + U[I]; QUOTIENT[I]:=T//V1;
          CARRY:=T - QUOTIENT[I] * V1
       "END"; REMAINDER[0]:=1; REMAINDER[1]:=CARRY;
       "IF" QUOTIENT[1]=0 "THEN"
       "BEGIN" "FOR" I:=2 "STEP" 1 "UNTIL" LU "DO"
          QUOTIENT[I-1]:=QUOTIENT[I];
          QUOTIENT[0]:=LU - ("IF" LU=1 "THEN" 0 "ELSE" 1)
       "END" "ELSE" QUOTIENT[0]:=LU
    "END" LV=1
    "ELSE"
 
    "IF" LU<LV "THEN"
    "BEGIN" QUOTIENT[0]:=1; QUOTIENT[1]:=0;
       "FOR" I:=0 "STEP" 1 "UNTIL" LU "DO" REMAINDER[I]:=U[I]
    "END" LU<LV
    "ELSE"
 
    "BEGIN""INTEGER""ARRAY" A[0:LV];
       SCALE:=10 000 000//(V1+1);
       "IF" SCALE>1 "THEN"
       "BEGIN""COMMENT" NORMALIZE U; CARRY:=0;
          "FOR" I:=LU "STEP" -1 "UNTIL" 1 "DO"
          "BEGIN" T:=SCALE * U[I] + CARRY; CARRY:=T//10 000 000;
             U[I]:=T - CARRY * 10 000 000
          "END"; U[0]:=CARRY;
          "COMMENT" NORMALIZE V; CARRY:=0;
          "FOR" I:=LV "STEP" -1 "UNTIL" 1 "DO"
          "BEGIN" T:=SCALE * V[I] + CARRY; CARRY:=T//10 000 000;
             V[I]:=T - CARRY * 10 000 000
          "END"; V1:=V[1]
       "END" NORMALIZATION
       "ELSE" U[0]:=0;                                         "COMMENT"
 
1SECTION : 1.4                (OCTOBER 1974)                     PAGE 12
                                                                 ;
 
 
       "COMMENT" COMPUTE QUOTIENT AND REMAINDER;
       "FOR" I:=0 "STEP" 1 "UNTIL" DIFF "DO"
       "BEGIN" D:=U[I] * 10 000 000 + U[I+1];
          Q1:="IF" U[I]=V1 "THEN" 9 999 999 "ELSE" D//V1;
          "IF" V[2] * Q1 > (D-Q1*V1) * 10 000 000 + U[I+2] "THEN"
          "BEGIN" Q1:=Q1 - 1;
             "IF" V[2]*Q1>(D-Q1*V1)*10 000 000+U[I+2] "THEN" Q1:=Q1-1
          "END";
 
          "COMMENT" U[I:I+LV]:=U[I:I+LV] - Q1 * V[1:LV];
          CARRY:=0;
          "FOR" J:=LV "STEP" -1 "UNTIL" 1 "DO"
          "BEGIN" T:=Q1 * V[J] + CARRY; CARRY:=T//10 000 000;
             A[J]:=T - CARRY * 10 000 000
          "END"; A[0]:=CARRY;
          CARRY:=0;
          "FOR" J:=LV "STEP" -1 "UNTIL" 0 "DO"
          "BEGIN" T:=U[I+J] - A[J] + CARRY; CARRY:="IF" T<0 "THEN" -1
             "ELSE" 0; U[I+J]:=T - CARRY * 10 000 000
          "END";
 
          "COMMENT" IF CARRY=-1 THEN Q1 IS ONE TOO LARGE,
          AND V MUST BE ADDED BACK TO U[I:I+LV];
          "IF" CARRY=-1 "THEN"
          "BEGIN" Q1:=Q1 - 1; CARRY:=0;
             "FOR" J:=LV "STEP" -1 "UNTIL" 1 "DO"
             "BEGIN" T:=U[I+J] + V[J] + CARRY; CARRY:="IF" T<10 000 000
                "THEN" 0 "ELSE" 1; U[I+J]:=T - CARRY * 10 000 000
             "END"
          "END"; QUOTIENT[I]:=Q1
       "END" I;
 
       "COMMENT" CORRECT STORAGE OF QUOTIENT;
       "IF" QUOTIENT[0] ^= 0 "THEN"
       "BEGIN" "FOR" I:=DIFF "STEP" -1 "UNTIL" 0 "DO"
          QUOTIENT[I+1]:=QUOTIENT[I]; QUOTIENT[0]:=DIFF + 1
       "END" "ELSE"
       "IF" DIFF < 2 "THEN"
       "BEGIN" QUOTIENT[0]:= 1; "IF" DIFF = 0 "THEN" QUOTIENT[1]:= 0
       "END" "ELSE"
       "IF" QUOTIENT[1] ^= 0 "THEN" QUOTIENT[0]:=DIFF "ELSE"
       "BEGIN" "FOR" I:=1 "STEP" 1 "UNTIL" DIFF - 1 "DO"
          QUOTIENT[I]:=QUOTIENT[I+1]; QUOTIENT[0]:=DIFF - 1
       "END";                                                  "COMMENT"
 
1SECTION : 1.4                (OCTOBER 1974)                     PAGE 13
                                                                 ;
 
 
       "COMMENT" REMAINDER := U[DIFF+1:LU]//SCALE;
       "IF" SCALE>1 "THEN"
       "BEGIN" CARRY:=0;
          "FOR" I:=1 "STEP" 1 "UNTIL" LV "DO"
          "BEGIN" T:=CARRY * 10 000 000 + U[DIFF+I];
             REMAINDER[I]:=T//SCALE; CARRY:=T - REMAINDER[I] * SCALE
          "END"
       "END" "ELSE"
       "FOR" I:=1 "STEP" 1 "UNTIL" LV "DO" REMAINDER[I]:=U[DIFF+I];
 
       "COMMENT" CORRECT STORAGE OF REMAINDER;
       I:=0; J:=LV;
       "FOR" I:=I+1 "WHILE" REMAINDER[I]=0 "AND" J>1 "DO" J:=J-1;
       REMAINDER[0]:=J;
       "IF" J<LV "THEN"
       "FOR" I:=1 "STEP" 1 "UNTIL" J "DO"
       REMAINDER[I]:=REMAINDER[LV + I - J];
 
       "COMMENT" UNNORMALIZE THE DIVISOR V;
       "IF" SCALE>1 "THEN"
       "BEGIN" CARRY:=0;
          "FOR" I:=1 "STEP" 1 "UNTIL" LV "DO"
          "BEGIN" T:=CARRY * 10 000 000 + V[I];
             V[I]:=T//SCALE; CARRY:=T - V[I] * SCALE
          "END"
       "END"
    "END"
 "END" LNG INT DIVIDE;
         "EOP"
 
 "CODE" 31204;
 "PROCEDURE" LNG INT POWER(U,EXPONENT,RESULT);
 "VALUE" EXPONENT; "INTEGER" EXPONENT; "INTEGER""ARRAY" U,RESULT;
 "BEGIN""INTEGER" MAX,I,N;
    MAX:=U[0] * EXPONENT;
    "BEGIN""INTEGER""ARRAY" Y,Z,H[0:MAX];
       "COMMENT" Y:=1, Z:=U;
       Y[0]:=Y[1]:=1;
       "FOR" I:=U[0] "STEP" -1 "UNTIL" 0 "DO" Z[I]:=U[I];
    HALVE: N:=EXPONENT//2; "IF" N+N=EXPONENT "THEN" "GOTO" SQUARE Z;
       LNG INT MULT(Y,Z,H);
       "FOR" I:=H[0] "STEP" -1 "UNTIL" 0 "DO" Y[I]:=H[I];
       "IF" N=0 "THEN" "GOTO" READY;
    SQUARE Z: LNG INT MULT(Z,Z,H);
       "FOR" I:=H[0] "STEP" -1 "UNTIL" 0 "DO" Z[I]:=H[I];
       EXPONENT:=N; "GOTO"HALVE;
    READY: "FOR" I:=Y[0] "STEP" -1 "UNTIL" 0 "DO" RESULT[I]:=Y[I]
    "END"
 "END" LNG INT POWER;
         "EOP"
1SECTION : 1.5.1              (MARCH 1977)                        PAGE 1
 
 
 
 AUTHORS: D.T.WINTER(A-D,F-I), T.J.DEKKER(E,J)
 
 
 CONTRIBUTOR: J.KOOPMAN(E,J)
 
 
 INSTITUTES: MATHEMATICAL CENTRE,UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED: 770328
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS  PROCEDURES FOR THE  ELEMENTARY OPERATIONS IN
     DOUBLE PRECISION ARITHMETIC.
 
     A. DPADD  ADDS TWO SINGLE PRECISION NUMBERS TO A DOUBLE PRECISION
               SUM.
     B. DPSUB  SUBTRACTS TWO SINGLE PRECISION NUMBERS TO A DOUBLE
               PRECISION DIFFERENCE.
     C. DPMUL  MULTIPLIES   TWO  SINGLE  PRECISION  NUMBERS   TO  A
               DOUBLE PRECISION PRODUCT.
     D. DPDIV  DIVIDES  TWO SINGLE PRECISION NUMBERS  TO A DOUBLE
               PRECISION QUOTIENT.
     E. DPPOW  COMPUTES A**EXPON IN DOUBLE PRECISION,WHERE
               A IS A SINGLE PRECISION REAL NUMBER AND EXPON THE
               INTEGER EXPONENT.
     F. LNGADD ADDS TWO DOUBLE PRECISION NUMBERS.
     G. LNGSUB SUBTRACTS TWO DOUBLE PRECISION NUMBERS.
     H. LNGMUL MULTIPLIES TWO DOUBLE PRECISION NUMBERS.
     I. LNGDIV DIVIDES TWO DOUBLE PRECISION NUMBERS.
     J. LNGPOW COMPUTES (A,AA)**EXPON IN DOUBLE PRECISION,WHERE
               (A,AA) IS A DOUBLE PRECISION REAL NUMBER AND EXPON
               THE INTEGER EXPONENT.
 
 
 KEYWORDS:
 
     DOUBLE PRECISION ARITHMETIC
     EXPONENTIATION.
 
 
 LANGUAGE: COMPASS(A-D,F-I),ALGOL 60(E,J)
1SECTION : 1.5.1              (DECEMBER 1979)                     PAGE 2
 
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURES A-D,F-I USE THE HARDWARE FUNCTIONS FOR DOUBLE
     PRECISION THAT ARE AVAILIBLE ON THE CYBER.
     THE PROCEDURES  LNG ADD,  LNG SUB,  LNG MUL AND  LNG DIV  CHECK THE
     INPUT PARAMETERS  (A,AA)  AND  (B,BB)  FOR CORRECTNESS. A HEAD/TAIL
     PAIR IS  A CORRECT  DOUBLE  PRECISION  PARAMETER  IN THE  FOLLOWING
     CASES:
     A)  THE TAIL IS ZERO;
     B)  THE EXPONENT  IN THE BINARY  REPRESENTATION  OF THE TAIL  IS 48
         LESS THAN THE EXPONENT OF THE HEAD.
     AN OUTPUT PARAMETER  OF THESE PROCEDURES ALWAYS IS A CORRECT DOUBLE
     PRECISION NUMBER.  IF AN INPUT PARAMETER IS NOT CORRECT,  THE ERROR
     MESSAGE "DP PARAMETER TAIL ERROR" WILL BE ISSUED.
 
     BOTH PROCEDURES E AND J MAKE USE OF THE BINARY REPRESENTATION OF
     THE INTEGER EXPONENT. IF X DENOTES THE NUMBER THAT IS TO BE
     EXPONENTIATED, THE PROCEDURES E AND J RUN AS FOLLOWS:
     THE SEQUENCE X,X**2,X**4,X**8,... IS FORMED WHILE
     SIMULTANEOUSLY THE BINARY REPRESENTATION OF THE EXPONENT
     IS CHECKED; WHEN THE I-TH DIGIT EQUALS ONE,THE FACTOR
     X**(2**(I-1)) IS TAKEN INTO ACCOUNT.
 
 
 EXAMPLE OF USE:
 
     SEE THE PROCEDURE LNGREATODECI (SECTION 1.5.3).
 
1SECTION : 1.5.1              (MARCH 1977)                        PAGE 3
 
 
 
 SUBSECTION: DP ADD
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" DP ADD(A, B, C, CC);
     "VALUE" A, B; "REAL" A, B, C, CC;
     "CODE" 31101;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,B: <ARITHMETIC EXPRESSIONS>;
         THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE DOUBLE PRECISION RESULT OF A+B.
 
 
 SUBSECTION: DP SUB
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" DP SUB(A, B, C, CC);
     "VALUE" A, B; "REAL" A, B, C, CC;
     "CODE" 31102;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,B: <ARITHMETIC EXPRESSIONS>;
         THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE DOUBLE PRECISION RESULT OF A-B.
 
 
 SUBSECTION: DP MUL
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" DP MUL(A, B, C, CC);
     "VALUE" A, B; "REAL" A, B, C, CC;
     "CODE" 31103;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,B: <ARITHMETIC EXPRESSIONS>;
         THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE DOUBLE PRECISION RESULT OF A*B.
 
1SECTION : 1.5.1              (MARCH 1977)                        PAGE 4
 
 
 
 SUBSECTION: DP DIV
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" DP DIV(A, B, C, CC);
     "VALUE" A, B; "REAL" A, B, C, CC;
     "CODE" 31104;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,B: <ARITHMETIC EXPRESSIONS>;
         THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE DOUBLE PRECISION RESULT OF A/B.
 
 
 SUBSECTION: DP POW.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE"DP POW(A ,EXPON ,C ,CC );
     "VALUE"A,EXPON;"INTEGER"EXPON;"REAL"A,C,CC;
     "CODE"31109;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A       : <ARITHMETIC EXPRESSION>;
               THE NUMBER THAT IS TO BE EXPONENTIATED;
     EXPON   : <ARITHMETIC EXPRESSION>;
               THE (INTEGER) POWER TO WHICH A WILL BE RAISED;
     C , CC  : <REAL VARIABLES>;
               EXIT: THE HEAD (C) AND TAIL (CC) OF THE DOUBLE
                     PRECISION RESULT A**EXPON.
 
 
 PROCEDURES USED:
 
     LNG POW = CP31110.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO LN(EXPON).
1SECTION : 1.5.1              (MARCH 1977)                        PAGE 5
 
 
 
 SUBSECTION: LNG ADD
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" LNG ADD(A, AA, B, BB, C, CC);
     "VALUE" A, AA, B, BB; "REAL" A, AA, B, BB, C, CC;
     "CODE" 31105;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,AA,B,BB: <ARITHMETIC EXPRESSIONS>;
         THE HEADS (A AND B) AND THE TAILS (AA AND BB) OF THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE RESULT (A,AA)+(B,BB).
 
 
 SUBSECTION: LNG SUB
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" LNG SUB(A, AA, B, BB, C, CC);
     "VALUE" A, AA, B, BB; "REAL" A, AA, B, BB, C, CC;
     "CODE" 31106;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,AA,B,BB: <ARITHMETIC EXPRESSIONS>;
         THE HEADS (A AND B) AND THE TAILS (AA AND BB) OF THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE RESULT (A,AA)-(B,BB).
 
 
 SUBSECTION: LNG MUL
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" LNG MUL(A, AA, B, BB, C, CC);
     "VALUE" A, AA, B, BB; "REAL" A, AA, B, BB, C, CC;
     "CODE" 31107;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,AA,B,BB: <ARITHMETIC EXPRESSIONS>;
         THE HEADS (A AND B) AND THE TAILS (AA AND BB) OF THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE RESULT (A,AA)*(B,BB).
1SECTION : 1.5.1              (MARCH 1977)                        PAGE 6
 
 
 
 SUBSECTION: LNG DIV
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" LNG DIV(A, AA, B, BB, C, CC);
     "VALUE" A, AA, B, BB; "REAL" A, AA, B, BB, C, CC;
     "CODE" 31108;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,AA,B,BB: <ARITHMETIC EXPRESSIONS>;
         THE HEADS (A AND B) AND THE TAILS (AA AND BB) OF THE OPERANDS;
     C,CC: <REAL VARIABLES>;
         THE HEAD AND TAIL OF THE RESULT (A,AA)/(B,BB).
 
 
 SUBSECTION: LNG POW.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE"LNG POW(A ,AA ,EXPON ,C ,CC );
     "VALUE"A,AA,EXPON;"INTEGER"EXPON;"REAL"A,AA,C,CC;
     "CODE"31110;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A,AA    : <ARITHMETIC EXPRESSIONS>;
               THE HEAD (A) AND TAIL (AA) OF THE NUMBER THAT
               IS TO BE EXPONENTIATED;
     EXPON   : <ARITHMETIC EXPRESSION>;
               THE (INTEGER) POWER TO WHICH (A,AA) WILL BE RAISED;
     C,CC    : <REAL VARIABLES>;
               EXIT: THE HEAD (C) AND TAIL (CC) OF THE DOUBLE
                     PRECISION RESULT (A,AA)**EXPON.
 
 
 PROCEDURES USED:
 
     LNG MUL = CP31107.
     LNG DIV = CP31108.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO LN(EXPON).
1SECTION : 1.5.1              (DECEMBER 1979)                     PAGE 7
 
 
 
 SOURCE TEXT(S):
 
 ALL PROCEDURES, EXCEPT POW AND LNG POW, ARE WRITTEN IN COMPASS,  IT IS
 NOT POSSIBLE TO SIMULATE THESE PROCEDURES IN ALGOL 60, SO ONLY THE TEXT
 IS GIVEN FOR POW AND LNG POW.
 
 
 
 "CODE"31109;
 "PROCEDURE"DP POW(A,EXPON,C,CC);
 "VALUE"A,EXPON;"INTEGER"EXPON;"REAL"A,C,CC;
 "BEGIN"
        LNG POW(A,0,EXPON,C,CC)
 "END" DP POW;
    "EOP"
 
 
 "CODE"31110;
 "PROCEDURE"LNG POW(A,AA,EXPON,C,CC);
 "VALUE"A,AA,EXPON;"INTEGER"EXPON;"REAL"A,AA,C,CC;
 "BEGIN""INTEGER"OLDEX,NEWEX;"REAL"D,DD;
        D:=A;DD:=AA;C:=1;CC:=0;NEWEX:=ABS(EXPON);
        "FOR"OLDEX:=NEWEX"WHILE"NEWEX^=0"DO"
        "BEGIN"NEWEX:=OLDEX//2;
               "IF"NEWEX+NEWEX^=OLDEX
               "THEN"LNG MUL(C,CC,D,DD,C,CC);
               "IF"NEWEX^=0
               "THEN"LNG MUL(D,DD,D,DD,D,DD)
        "END";
        "IF"EXPON<0"THEN"LNG DIV(1,0,C,CC,C,CC)
 "END" LNG POW;
    "EOP"
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 1
 
 
 
 AUTHORS: J. WOLLESWINKEL AND D. WINTER.
 
 
 CONTRIBUTOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 750501.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOURTEEN PROCEDURES FOR CALCULATING,  WITH
     DOUBLE LENGTH ARITHMETIC, THE (SCALAR) PRODUCTS OF SINGLE LENGTH
     VECTORS AND MATRICES.
 
     LNGVECVEC:  CALCULATES  THE SCALAR PRODUCT OF TWO VECTORS  GIVEN IN
                 ONE-DIMENSIONAL ARRAYS;
     LNGMATVEC:  CALCULATES  THE SCALAR PRODUCT OF A VECTOR  GIVEN  IN A
                 ONE-DIMENSIONAL ARRAY AND A ROW OF A MATRIX  GIVEN IN A
                 TWO DIMENSIONAL ARRAY;
     LNGTAMVEC:  CALCULATES  THE SCALAR PRODUCT OF A VECTOR  GIVEN  IN A
                 ONE-DIMENSIONAL ARRAY AND A COLUMN OF A MATRIX GIVEN IN
                 A  TWO-DIMENSIONAL ARRAY;
     LNGMATMAT:  CALCULATES THE SCALAR PRODUCT OF A ROW OF A MATRIX  AND
                 A COLUMN OF ANOTHER MATRIX,  WHICH  ARE  BOTH  GIVEN IN
                 TWO-DIMENSIONAL ARRAYS;
     LNGTAMMAT:  CALCULATES  THE SCALAR PRODUCT  OF COLUMNS OF MATRICES,
                 WHICH  ARE  BOTH  GIVEN IN TWO-DIMENSIONAL ARRAYS;
     LNGMATTAM:  CALCULATES  THE  SCALAR  PRODUCT  OF ROWS  OF MATRICES,
                 WHICH  ARE  BOTH  GIVEN IN TWO-DIMENSIONAL ARRAYS;
     LNGSEQVEC:  CALCULATES THE SCALAR PRODUCT  OF TWO VECTORS  GIVEN IN
                 ONE-DIMENSIONAL  ARRAYS,   WHERE  THE  MUTUAL  SPACINGS
                 BETWEEN   THE  INDICES  OF  THE  FIRST  VECTOR   CHANGE
                 LINEARLY;
     LNGSCAPRD1: CALCULATES  THE SCALAR PRODUCT OF TWO VECTORS  GIVEN IN
                 ONE-DIMENSIONAL  ARRAYS,  WHERE  THE SPACINGS  OF  BOTH
                 VECTORS ARE CONSTANT;
     LNGSYMMATVEC: CALCULATES  THE SCALAR PRODUCT OF A VECTOR GIVEN IN A
                 ONE-DIMENSIONAL ARRAY  AND A ROW OF A SYMMETRIC MATRIX,
                 WHOSE  UPPER TRIANGLE  IS STORED  COLUMN-WISE IN A ONE-
                 DIMENSIONAL ARRAY;
     THE ABOVE PROCEDURES HAVE THE POSSIBILITY OF ADDING A DOUBLE LENGTH
     SCALAR TO THE CALCULATED SCALAR PRODUCT;
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 2
 
 
 
     LNGFULMATVEC: CALCULATES THE VECTOR A * B, WHERE A IS A GIVEN
                 MATRIX AND B IS A VECTOR;
     LNGFULTAMVEC: CALCULATES THE VECTOR A' * B, WHERE A' IS THE
                 TRANSPOSED OF THE MATRIX A AND B IS A VECTOR;
     LNGFULSYMMATVEC: CALCULATES THE VECTOR A * B, WHERE A IS A
                 SYMMETRIC MATRIX, WHOSE UPPERTRIANGLE IS STORED
                 COLUMNWISE IN A ONE-DIMENSIONAL ARRAY, AND B IS A
                 VECTOR;
     LNGRESVEC:  CALCULATES THE RESIDUAL VECTOR A * B + X * C, WHERE A
                 IS A GIVEN MATRIX, B AND C ARE VECTORS AND X IS A
                 SCALAR;
     LNGSYMRESVEC: CALCULATES THE RESIDUAL VECTOR A * B + X * C, WHERE A
                 IS A SYMMETRIC MATRIX, WHOSE UPPERTRIANGLE IS STORED
                 COLUMNWISE IN A ONE-DIMENSIONAL ARRAY, B AND C ARE
                 VECTORS AND, X IS A SCALAR.
     IN THIS SECTION (X, XX) DENOTES A DOUBLE-LENGTH NUMBER WITH HEAD X
     AND TAIL XX (SEE METHOD AND PERFORMANCE).
 
 
 KEYWORDS:
 
     ELEMENTARY OPERATIONS,
     VECTOR OPERATIONS,
     SCALAR PRODUCTS,
     DOUBLE-LENGTH ARITHMETIC.
 
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 3
 
 
 
 SUBSECTION: LNGVECVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGVECVEC(L, U, SHIFT, A, B, C, CC, D, DD);
     "VALUE" L, U, SHIFT, C, CC; "INTEGER" L, U, SHIFT;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34410;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             THE INDEX-SHIFTING PARAMETER OF THE VECTOR GIVEN IN B;
     A:      <ARRAY IDENTIFIER>;
             ONE OF THE VECTORS SHOULD BE GIVEN IN ARRAY A[L:U];
     B:      <ARRAY IDENTIFIER>;
             THE   OTHER   VECTOR    SHOULD    BE    GIVEN    IN   ARRAY
             B[L + SHIFT : U + SHIFT];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[L:U]  AND  B[L + SHIFT : U + SHIFT].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 4
 
 
 
 SUBSECTION: LNGMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGMATVEC(L, U, I, A, B, C, CC, D, DD);
     "VALUE" L, U, I, C, CC; "INTEGER" L, U, I;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34411;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE ROW-VECTOR GIVEN IN ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             THE ROW-VECTOR SHOULD BE GIVEN IN ARRAY A[I:I, L:U];
     B:      <ARRAY IDENTIFIER>;
             THE VECTOR SHOULD BE GIVEN IN ARRAY B[L:U];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[I:I, L:U]  AND  B[L:U].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 5
 
 
 
 SUBSECTION: LNGTAMVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGTAMVEC(L, U, I, A, B, C, CC, D, DD);
     "VALUE" L, U, I, C, CC; "INTEGER" L, U, I;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34412;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE COLUMN-VECTOR GIVEN IN ARRAY A;
     A:      <ARRAY IDENTIFIER>;
             THE COLUMN-VECTOR SHOULD BE GIVEN IN ARRAY A[L:U, I:I];
     B:      <ARRAY IDENTIFIER>;
             THE VECTOR SHOULD BE GIVEN IN ARRAY B[L:U];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[L:U, I:I]  AND  B[L:U].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 6
 
 
 
 SUBSECTION: LNGMATMAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGMATMAT(L, U, I, J, A, B, C, CC, D, DD);
     "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34413;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE ROW-VECTOR GIVEN IN ARRAY A;
     J:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE COLUMN-VECTOR GIVEN IN ARRAY B;
     A:      <ARRAY IDENTIFIER>;
             THE ROW-VECTOR SHOULD BE GIVEN IN ARRAY A[I:I, L:U];
     B:      <ARRAY IDENTIFIER>;
             THE COLUMN-VECTOR SHOULD BE GIVEN IN ARRAY B[L:U, J:J];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[I:I, L:U]  AND  B[L:U, J:J].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 7
 
 
 
 SUBSECTION: LNGTAMMAT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGTAMMAT(L, U, I, J, A, B, C, CC, D, DD);
     "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34414;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE COLUMN-VECTOR GIVEN IN ARRAY A;
     J:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE COLUMN-VECTOR GIVEN IN ARRAY B;
     A:      <ARRAY IDENTIFIER>;
             ONE  OF  THE  COLUMN-VECTORS   SHOULD  BE  GIVEN  IN  ARRAY
             A[L:U, I:I];
     B:      <ARRAY IDENTIFIER>;
             THE  OTHER  COLUMN-VECTOR   SHOULD   BE   GIVEN   IN  ARRAY
             B[L:U, J:J];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[L:U, I:I]  AND  B[L:U, J:J].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 8
 
 
 
 SUBSECTION: LNGMATTAM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGMATTAM(L, U, I, J, A, B, C, CC, D, DD);
     "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34415;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE ROW-VECTOR GIVEN IN ARRAY A;
     J:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE ROW-VECTOR GIVEN IN ARRAY B;
     A:      <ARRAY IDENTIFIER>;
             ONE OF THE ROW-VECTORS SHOULD BE GIVEN IN ARRAY A[I:I,L:U];
     B:      <ARRAY IDENTIFIER>;
             THE OTHER ROW-VECTOR SHOULD BE GIVEN IN ARRAY B[J:J, L:U];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS  A[I:I, L:U]  AND  B[J:J, L:U].
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                      PAGE 9
 
 
 
 SUBSECTION: LNGSEQVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGSEQVEC(L, U, IL, SHIFT, A, B, C, CC, D, DD);
     "VALUE" L, U, IL, SHIFT, C, CC; "INTEGER" L, U, IL, SHIFT;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34416;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     IL:     <ARITHMETIC EXPRESSION>;
             THE FIRST INDEX OF THE VECTOR GIVEN IN ARRAY A;
     SHIFT:  <ARITHMETIC EXPRESSION>;
             THE INDEX-SHIFTING PARAMETER OF THE VECTOR GIVEN IN B;
     A:      <ARRAY IDENTIFIER>;
             ONE OF THE VECTORS SHOULD BE GIVEN IN ARRAY  A[P:Q],  WHERE
             P = MIN(IL + (J + L - 1) * (J - 1) // 2; J = L, ..., U) AND
             Q = MAX(IL + (J + L - 1) * (J - 1) // 2; J = L, ..., U);
     B:      <ARRAY IDENTIFIER>;
             THE   OTHER   VECTOR    SHOULD    BE    GIVEN    IN   ARRAY
             B[L + SHIFT : U + SHIFT];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE  ARRAYS   A[P:Q]   (SEE  THE  MEANING  OF  PARAMETER   A )  AND
     B[L + SHIFT: U + SHIFT], WHERE THE ELEMENTS OF THE FIRST VECTOR ARE
     A[IL + (J + L - 1) * (J - 1) // 2], J = L, ..., U.
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 10
 
 
 
 SUBSECTION: LNGSCAPRD1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGSCAPRD1(LA, SA, LB, SB, N, A, B, C, CC, D, DD);
     "VALUE" LA, SA, LB, SB, N, C, CC; "INTEGER" LA, SA, LB, SB, N;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34417;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LA:     <ARITHMETIC EXPRESSION>;
             THE FIRST INDEX OF THE VECTOR GIVEN IN ARRAY A;
     SA:     <ARITHMETIC EXPRESSION>;
             THE SPACING OF THE VECTOR GIVEN IN ARRAY A;
     LB:     <ARITHMETIC EXPRESSION>;
             THE FIRST INDEX OF THE VECTOR GIVEN IN ARRAY B;
     SB:     <ARITHMETIC EXPRESSION>;
             THE SPACING OF THE VECTOR GIVEN IN ARRAY B;
     N:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT; IF N < 1, THEN ON
             EXIT THE RESULT (D, DD) WILL SATISFY: (D, DD) = (C, CC);
     A:      <ARRAY IDENTIFIER>;
             ONE   OF   THE   VECTORS   SHOULD   BE   GIVEN   IN   ARRAY
             A[MIN(LA, LA + (N - 1) * SA) : MAX(LA, LA + (N - 1) * SA)];
     B:      <ARRAY IDENTIFIER>;
             THE   OTHER   VECTOR    SHOULD    BE    GIVEN    IN   ARRAY
             B[MIN(LB, LB + (N - 1) * SB) : MAX(LB, LB + (N - 1) * SB)];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE ARRAYS A[MIN(LA, LA + (N - 1) * SA):MAX(LA, LA + (N - 1) * SA)]
     AND   B[MIN(LB,  LB + (N - 1) * SB) : MAX(LB,  LB + (N - 1) * SB)],
     WHERE  THE ELEMENTS  OF THE VECTORS  ARE  A[LA + (J - 1) * SA]  AND
     B[LB + (J - 1) * SB], FOR J = 1, .., N.
 
 
 LANGUAGE:   COMPASS.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 11
 
 
 
 SUBSECTION: LNGSYMMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGSYMMATVEC(L, U, I, A, B, C, CC, D, DD);
     "VALUE" L, U, I, C, CC; "INTEGER" L, U, I;
     "REAL" C, CC, D, DD; "ARRAY" A, B;
     "CODE" 34418;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     L:      <ARITHMETIC EXPRESSION>;
             THE LOWER BOUND OF THE RUNNING SUBSCRIPT;
     U:      <ARITHMETIC EXPRESSION>;
             THE UPPER BOUND OF THE RUNNING SUBSCRIPT;
     I:      <ARITHMETIC EXPRESSION>;
             THE INDEX OF THE ROW  OF THE SYMMETRIC MATRIX,  WHOSE UPPER
             TRIANGLE IS STORED COLUMN-WISE IN THE ONE-DIMENSIONAL ARRAY
             A;
     A:      <ARRAY IDENTIFIER>;
             THE ROW OF THE SYMMETRIC MATRIX  SHOULD BE GIVEN  IN  ARRAY
             A[P:Q], WHERE, IF I > L THEN P = (I - 1) * I // 2 + L  ELSE
             P  =  (L - 1) * L  //  2  +  I,    AND    IF  I > U    THEN
             Q = (I - 1) * I // 2 + U  ELSE  Q = (U - 1) * U // 2 + I;
     B:      <ARRAY IDENTIFIER>;
             THE VECTOR SHOULD BE GIVEN IN ARRAY B[L:U];
     C, CC:  <ARITHMETIC EXPRESSION>;
             THE HEAD AND TAIL OF  THE DOUBLE-LENGTH SCALAR  THAT HAS TO
             BE ADDED TO THE CALCULATED SCALAR PRODUCT; IF  CC  IS NOT A
             TAIL TO C THEN AN ERROR MESSAGE WILL BE PRINTED (SEE METHOD
             AND PERFORMANCE);
     D, DD:  <REAL VARIABLE>;
             EXIT:   THE HEAD AND TAIL  OF  THE CALCULATED DOUBLE-LENGTH
                     RESULT.
 
 
 PROCEDURES USED:
     DPMUL  = CP31103;
     LNGADD = CP31105.
 
 
 DATA AND RESULTS:
 
     (D, DD):= (C, CC) + THE SCALAR PRODUCT  OF  THE  VECTORS  GIVEN  IN
     THE ARRAYS  A[P:Q]  (SEE THE MEANING OF PARAMETER  A)  AND  B[L:U],
     WHERE  THE  ELEMENTS  OF  THE  FIRST  VECTOR  ARE:  IF  L < I  THEN
     A[(I - 1)  *  I  //  2  +  J],    J = L, ...,  MIN(U,  I - 1)   AND
     A[(J - 1) * J // 2 + I],  J = I, ..., U,  RESPECTIVELY,   OTHERWISE
     A[(J - 1) * J // 2 + I],  J = L, ..., U;   THE VALUES OF  L,  U,  I
     SHOULD BE POSITIVE.
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 12
 
 
 
 SUBSECTION: LNGFULMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGFULMATVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31505;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B, CALCULATED WITH DOUBLE LENGTH ARITHMETIC,
             IS DELIVERED IN C.
 
 
 LANGUAGE:   COMPASS.
     (FOR THE COMPASS-VERSION THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 13
 
 
 
 SUBSECTION: LNGFULTAMVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGFULTAMVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31506;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LR:UR]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LC:UC];
            THE RESULT A' * B, CALCULATED WITH DOUBLE LENGTH ARITHMETIC,
             IS DELIVERED IN C; HERE A' DENOTES THE TRANSPOSED OF THE
             MATRIX A.
 
 
 LANGUAGE:   COMPASS.
     (FOR THE COMPASS-VERSION THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 14
 
 
 
 SUBSECTION: LNGFULSYMMATVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGFULSYMMATVEC(LR, UR, LC, UC, A, B, C);
     "VALUE" LR, UR, LC, UC, B; "INTEGER" LR, UR, LC, UC;
     "ARRAY" A, B, C;
     "CODE" 31507;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX; LR >= 1;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX; LC >= 1;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U], WHERE:
             L = MIN(LR * (LR - 1) // 2 + LC, LC * (LC - 1) // 2 + LR),
             U = MAX(UR * (UR - 1) // 2 + UC, UC * (UC - 1) // 2 + UR)
             AND THE (I,J)-TH ELEMENT OF THE SYMMETRIC MATRIX SHOULD BE
             GIVEN IN A[J * (J - 1) // 2 + I];
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B, CALCULATED WITH DOUBLE LENGTH ARITHMETIC,
             IS DELIVERED IN C.
 
 
 PROCEDURES USED:
 
     LNGSYMMATVEC = CP34418.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 15
 
 
 
 SUBSECTION: LNGRESVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGRESVEC(LR, UR, LC, UC, A, B, C, X);
     "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" A, B, C;
     "CODE" 31508;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[LR:UR,LC:UC]; THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     X:      <ARITHMETIC EXPRESSION>;
             THE VALUE OF THE MULTIPLYING SCALAR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B + X * C, CALCULATED WITH DOUBLE LENGTH
             ARITHMETIC, IS OVERWRITTEN ON C.
 
 
 LANGUAGE:   COMPASS.
     (FOR THE COMPASS-VERSION THE PARAMETER B CAN BE ASSUMED TO HAVE
     BEEN SPECIFIED "VALUE".)
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 16
 
 
 
 SUBSECTION: LNGSYMRESVEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LNGSYMRESVEC(LR, UR, LC, UC, A, B, C, X);
     "VALUE" LR, UR, LC, UC, B, X; "INTEGER" LR, UR, LC, UC;
     "REAL" X; "ARRAY" A, B, C;
     "CODE" 31509;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     LR, UR: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE ROW-INDEX; LR >= 1;
     LC, UC: <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND OF THE COLUMN-INDEX; LC >= 1;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[L:U], WHERE:
             L = MIN(LR * (LR - 1) // 2 + LC, LC * (LC - 1) // 2 + LR),
             U = MAX(UR * (UR - 1) // 2 + UC, UC * (UC - 1) // 2 + UR)
             AND THE (I,J)-TH ELEMENT OF THE SYMMETRIC MATRIX SHOULD BE
             GIVEN IN A[J * (J - 1) // 2 + I];
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[LC:UC]; THE VECTOR;
     X:      <ARITHMETIC EXPRESSION>;
             THE VALUE OF THE MULTIPLYING SCALAR;
     C:      <ARRAY IDENTIFIER>;
             "ARRAY" C[LR:UR];
             THE RESULT A * B  + X * C, CALCULATED WITH DOUBLE LENGTH
             ARITHMETIC, IS OVERWRITTEN ON C.
 
 
 PROCEDURES USED:
 
     DPMUL        = CP31103;
     LNGSYMMATVEC = CP34418.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     ELEMENTARY.
 
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 17
 
 
 
 METHOD AND PERFORMANCE:
 
     ALL PROCEDURES GIVEN IN THIS SECTION MAKE USE  OF THE DOUBLE-LENGTH
     ARITHMETIC  OPERATIONS  AVAILABLE  IN HARDWARE  ON  THE CYBER 73.
     LET (X, XX) DENOTE A DOUBLE-LENGTH NUMBER, THEN WE WILL SAY THAT XX
     IS A TAIL TO X, WHEN THE FOLLOWING CONDITIONS HOLD:
                         X = FL1(X + XX),
                   (X, XX) = FL2(X + XX),
     WHERE  FL1(. + .)  AND FL2(. + .) DENOTE SINGLE-LENGTH RESPECTIVELY
     DOUBLE-LENGTH ADDITION WITH TRUNCATING OF THE RESULT TO  48 AND  96
     BITS RESPECTIVELY.
     WHEN A PROCEDURE DELIVERS A DOUBLE LENGTH RESULT IN D AND DD, THEN
     THESE RESULTS ARE SUCH THAT DD IS A TAIL TO D; WHEN ONE SHOULD
     PROVIDE AN INITIALIZING DOUBLE LENGTH SCALAR IN C AND CC, THEN CC
     SHOULD BE A TAIL TO C, OTHERWISE THE FOLLOWING ERROR MESSAGE WILL
     BE PRINTED:
             DP PARAMETER TAIL ERROR
     AND EXECUTION OF THE PROGRAM WILL TERMINATE IN THE USUAL WAY.
     NOTE THAT CC = 0 IS A TAIL TO C FOR ALL VALUES OF C. FURTHERMORE,
     IT SEEMS WORTHWHILE TO NOTE THAT THE ARRAY B MUST BE A VALUE
     PARAMETER IN ALGOL 60, HOWEVER, IN THE COMPASS ROUTINE THE
     DUPLICATION OF THIS ARRAY IS ONLY DONE IF NECESSARY, I.E. IF THE
     ACTUAL PARAMETERS B AND C ARE THE SAME.
 
 
 SOURCE TEXTS:
 
     THE PROCEDURES IN THIS SECTION ARE WRITTEN IN COMPASS, EXCEPT FOR
     LNGSYMMATVEC, LNGFULSYMMATVEC AND LNGSYMRESVEC.
     WE GIVE EQUIVALENT ALGOL 60 TEXTS OF THE COMPASS ROUTINES. FOR THE
     COMPASS TEXT SEE APPENDIX C, SECTION 1.5.2.
 
 
 
0"CODE" 34410;
    "PROCEDURE" LNGVECVEC(L, U, SHIFT, A, B, C, CC, D, DD);
    "VALUE" L, U, SHIFT, C, CC; "INTEGER" L,U,SHIFT;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[L], B[L + SHIFT], E, EE);
          LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGVECVEC
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 18
 
 
                                                                  ;
         "EOP"
0"CODE" 34411;
    "PROCEDURE" LNGMATVEC(L, U, I, A, B, C, CC, D, DD);
    "VALUE" L, U, I, C, CC; "INTEGER" L, U, I;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[I,L], B[L], E, EE); LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGMATVEC;
         "EOP"
 
0"CODE" 34412;
    "PROCEDURE" LNGTAMVEC(L, U, I, A, B, C, CC, D, DD);
    "VALUE" L, U, I, C, CC; "INTEGER" L, U, I;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[L,I], B[L], E, EE); LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGTAMVEC;
         "EOP"
 
0"CODE" 34413;
    "PROCEDURE" LNGMATMAT(L, U, I, J, A, B, C, CC, D, DD);
    "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[I,L], B[L,J], E, EE); LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGMATMAT
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 19
 
 
                                                                  ;
         "EOP"
0"CODE" 34414;
    "PROCEDURE" LNGTAMMAT(L, U, I, J, A, B, C, CC, D, DD);
    "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[L,I], B[L,J], E, EE); LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGTAMMAT;
         "EOP"
 
0"CODE" 34415;
    "PROCEDURE" LNGMATTAM(L, U, I, J, A, B, C, CC, D, DD);
    "VALUE" L, U, I, J, C, CC; "INTEGER" L, U, I, J;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[I,L], B[J,L], E, EE); LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGMATTAM;
         "EOP"
 
0"CODE" 34416;
    "PROCEDURE" LNGSEQVEC(L, U, IL, SHIFT, A, B, C, CC, D, DD);
    "VALUE" L, U, IL, SHIFT, C, CC; "INTEGER" L, U, IL, SHIFT;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE;
       "FOR" L:= L "STEP" 1 "UNTIL" U "DO"
       "BEGIN" DPMUL(A[IL], B[L + SHIFT], E, EE); IL:= IL + L;
          LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END" LNGSEQVEC
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 20
 
 
                                                                  ;
         "EOP"
 "CODE" 34417;
    "PROCEDURE" LNGSCAPRD1(LA, SA, LB, SB, N, A, B, C, CC, D, DD);
    "VALUE" LA, SA, LB, SB, N, C, CC; "INTEGER" LA, SA, LB, SB,N;
    "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "REAL" E, EE; "INTEGER" K;
       "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
       "BEGIN" DPMUL(A[LA], B[LB], E, EE); LA:= LA + SA; LB:= LB + SB;
          LNGADD(C, CC, E, EE, C, CC)
       "END";
       D:= C; DD:= CC
    "END";
         "EOP"
 
 "CODE" 34418;
    "PROCEDURE" LNGSYMMATVEC(L, U, I, A, B, C, CC, D, DD);
    "VALUE" L, U, I, C, CC;
    "INTEGER" L, U, I; "REAL" C, CC, D, DD; "ARRAY" A, B;
    "BEGIN" "INTEGER" K, M;
       M:= "IF" L > I "THEN" L "ELSE" I; K:= M * (M - 1) // 2;
       LNGVECVEC(L, "IF" I <= U "THEN" I - 1 "ELSE" U,
       K, B, A, C, CC, C, CC);
       LNGSEQVEC(M, U, K + I, 0, A, B, C, CC, D, DD)
    "END" LNGSYMMATVEC;
         "EOP"
 
 "CODE" 31505;
    "PROCEDURE" LNGFULMATVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN" "REAL" D, DD;
       "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
       "BEGIN" LNGMATVEC(LC, UC, LR, A, B, 0, 0, D, DD); C[LR]:= D + DD
       "END"
    "END" LNGFULMATVEC;
         "EOP"
 
 "CODE" 31506;
    "PROCEDURE" LNGFULTAMVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN" "REAL" D, DD;
       "FOR" LC:= LC "STEP" 1 "UNTIL" UC "DO"
       "BEGIN" LNGTAMVEC(LR, UR, LC, A, B, 0, 0, D, DD); C[LC]:= D + DD
       "END"
    "END" LNGFULTAMVEC
 
1SECTION : 1.5.2              (JANUARY 1976)                     PAGE 21
 
 
                                                                  ;
         "EOP"
0"CODE" 31507;
    "PROCEDURE" LNGFULSYMMATVEC(LR, UR, LC, UC, A, B, C);
    "VALUE" LR, UR, LC, UC, B; "INTEGER" LR, UR, LC, UC;
    "ARRAY" A, B, C;
    "BEGIN" "REAL" D, DD;
       "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
       "BEGIN" LNGSYMMATVEC(LC, UC, LR, A, B, 0, 0, D, DD);
          C[LR]:= D + DD
       "END"
    "END" LNGFULSYMMATVEC;
         "EOP"
 
0"CODE" 31508;
    "PROCEDURE" LNGRESVEC(LR, UR, LC, UC, A, B, C, X);
    "VALUE" LR, UR, LC, UC, X; "INTEGER" LR, UR, LC, UC;
    "REAL" X; "ARRAY" A, B, C;
    "BEGIN" "REAL" D, DD, E, EE;
       "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
       "BEGIN" DPMUL(C[LR], X, E, EE);
          LNGMATVEC(LC, UC, LR, A, B, E, EE, D, DD); C[LR]:= D + DD
       "END"
    "END" LNGRESVEC;
         "EOP"
 
0"CODE" 31509;
    "PROCEDURE" LNGSYMRESVEC(LR, UR, LC, UC, A, B, C, X);
    "VALUE" LR, UR, LC, UC, B, X; "INTEGER" LR, UR, LC, UC;
    "REAL" X; "ARRAY" A, B, C;
    "BEGIN" "REAL" D, DD, E, EE;
       "FOR" LR:= LR "STEP" 1 "UNTIL" UR "DO"
       "BEGIN" DPMUL(C[LR], X, E, EE);
          LNGSYMMATVEC(LC, UC, LR, A, B, E, EE, D, DD); C[LR]:= D + DD
       "END"
    "END" LNGSYMRESVEC;
         "EOP"
1SECTION : 1.5.3              (MARCH 1977)                        PAGE 1
 
 
 
 AUTHORS: T.J.DEKKER & J.KOOPMAN.
 
 
 CONTRIBUTOR: J.KOOPMAN.
 
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 
 RECIEVED: 770328
 
 
 BRIEF DESCRIPTION:
 
     LNGREATODECI CONVERTS A DOUBLE-LENGTH NUMBER TO A
     NUMBER IN DECIMAL FLOATING-POINT REPRESENTATION.
     THE RESULT CONSISTS OF A MANTISSA MANT OF MAGNITUDE<1
     (AND >=.1) AND A DECIMAL EXPONENT EXPO.
 
 
 KEYWORDS:
 
     DOUBLE PRECISION ARITHMETIC,
     CONVERSION,
     DECIMAL REPRESENTATION.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" LNGREATODECI(X, XX, S, MANT, EXPO);
     "VALUE"X,XX,S;"INTEGER"S,EXPO;"REAL"X,XX;"INTEGER""ARRAY"MANT;
     "CODE" 31100;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     X,XX   : <ARITHMETIC EXPRESSIONS>;
              ENTRY: THE HEAD (X) AND TAIL (XX) OF THE NUMBER
                     THAT IS TO BE CONVERTED;
     S      : <ARITHMETIC EXPRESSION>;
              ENTRY: THE DESIRED NUMBER OF SIGNIFICANT DIGITS
                     OF THE CONVERTED VARIABLE.
                     ONE SHOULD NOT CHOOSE S LARGER THAN THE NUMBER
                     OF DIGITS CORRESPONDING TO THE DOUBLE LENGTH
                     MACHINE PRECISION (FOR CDC: S<29 ). OTHERWISE,
                     THE LAST DIGITS ARE USELESS, AS ALL OPERATIONS
                     IN LNGREATODECI ARE PERFORMED IN DOUBLE-LENGTH A-
                     RITHMETIC; IF S IS CHOSEN NONPOSITIVE,ONLY THE SIGN
                     AND THE DECIMAL EXPONENT OF THE CONVERTED NUMBER
                     ARE DELIVERED;
1SECTION : 1.5.3              (MARCH 1977)                        PAGE 2
 
 
 
     MANT   : <ARRAY IDENTIFIER>;
              "INTEGER""ARRAY"MANT[0:S];
              EXIT: MANT[0]: THE SIGN OF THE DECIMAL NUMBER;
                    MANT[I] (I^=0): THE I-TH  SIGNIFICANT
                    DIGIT OF THE MANTISSA OF THE CONVERTED NUMBER;
                    I.E. THE VALUE OF THE MANTISSA EQUALS
                    MANT[0]*(MANT[1]/10+MANT[2]/100+...MANT[S]/10**S);
     EXPO   : <INTEGER VARIABLE>;
              EXIT: THE DECIMAL EXPONENT OF THE CONVERTED NUMBER,
                    I.E. THE DOUBLE-LENGTH NUMBER (X,XX) APPROXIMATELY
                    EQUALS MANTISSA*10**EXPO WITH THE VALUE OF
                    MANTISSA GIVEN IN MANT.
 
 
 PROCEDURES USED:
 
     LNG SUB = CP31106.
     LNG MUL = CP31108.
     DP POW  = CP31109.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO LN(LN(X))+S.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     LNGREATODECI DETERMINES THE DECIMAL EXPONENT EXPO. AFTER
     THAT, THE LONG REAL NUMBER (X,XX) IS DIVIDED BY 10**EXPO
     IN DOUBLE PRECISION. BY TRUNCATING THE RESULT, THE
     FIRST MOST SIGNIFICANT DIGIT OF THE MANTISSA IS OB-
     TAINED. SUBTRACTING THIS DIGIT FROM (X,XX)/10**EXPO,
     MULTIPLYING THE RESULT WITH 10, THE NEXT MOST SIGNI-
     FICANT DIGIT CAN BE OBTAINED BY TRUNCATION. THIS PRO-
     CESS OF SUBTRACTION, MULTIPLICATION AND TRUNCATION WILL
     BE REPEATED UNTIL S DIGITS ARE OBTAINED. FINALLY,
     THE MANTISSA THUS OBTAINED IS PROPERLY ROUNDED.
1SECTION : 1.5.3              (MARCH 1977)                        PAGE 3
 
 
 
 EXAMPLE OF USE:
 
 "BEGIN""COMMENT"EXAMPLE OF USE OF LNGREATODECI AND DP POW;
        "INTEGER"S,EXPO;
        "REAL"OP,OPL;
 
        "PROCEDURE"PRINT(S,MANT,EXPONENT);
        "VALUE"S,EXPONENT;"INTEGER"S,EXPONENT;"INTEGER""ARRAY"MANT;
        "BEGIN""INTEGER"K;
               OUTCHARACTER(61,"("-++")",MANT[0]+2);
               "FOR"K:=1"STEP"1"UNTIL"S"DO"
               "BEGIN""IF"K=1"THEN"OUTPUT(61,"(""(".")"")");
                      OUTPUT(61,"("D")",MANT[K])
               "END";OUTPUT(61,"(""(""")",+3D")",EXPONENT)
        "END"PRINT;
 
        DP POW(2,48,OP,OPL);
        "FOR"S:=0"STEP"4 "UNTIL"28"DO"
        "BEGIN""INTEGER""ARRAY"MANT[0:S];
               LNGREATODECI(OP,OPL,S,MANT,EXPO);
               PRINT(S,MANT,EXPO);
               OUTPUT(61,"("/")")
        "END"
 "END"
 
 
 DELIVERS:
 
 +"+015
 +.2815"+015
 +.28147498"+015
 +.281474976711"+015
 +.2814749767106560"+015
 +.28147497671065600000"+015
 +.281474976710656000000000"+015
 +.2814749767106560000000000000"+015
1SECTION : 1.5.3              (MARCH 1977)                        PAGE 4
 
 
 
 SOURCE TEXT(S):
 
 
 "CODE"31100;
 "PROCEDURE"LNGREATODECI(X,XX,S,MANT,EXPO);
 "VALUE"X,XX,S;"INTEGER"S,EXPO;"REAL"X,XX;"INTEGER""ARRAY"MANT;
 "BEGIN""INTEGER"I,K;
        "REAL"P,PP;
        MANT[0]:=SIGN(X);"IF"X<0"THEN""BEGIN"X:=-X;XX:=-XX"END";
        "IF"X=0"THEN"EXPO:=0
               "ELSE"EXPO:=ENTIER(LN(X)/LN(10))+1;
        DP POW(10,-EXPO,P,PP);
        LNG MUL(X,XX,P,PP,X,XX);
        "FOR"I:=0"WHILE"ENTIER(X)=0 & X^=0 "DO"
        "BEGIN"LNG MUL(X,XX,10,0,X,XX);EXPO:=EXPO-1"END";
        "FOR"I:=1"STEP"1"UNTIL"S"DO"
        "BEGIN"K:=ENTIER(X);"IF"K>9"THEN"K:=9;MANT[I]:=K;
               LNG SUB(X,XX,K,0,P,PP);LNG MUL(P,PP,10,0,X,XX)
        "END";
        "IF"ENTIER(X)>=5
        "THEN""BEGIN""FOR"I:=S"STEP"-1"UNTIL"1"DO"
                 "BEGIN"K:=MANT[I]+1;
                        "IF"K<10"THEN""BEGIN"MANT[I]:=K;"GOTO"READY
                                      "END";
                        MANT[I]:=0
                 "END";
                 EXPO:=EXPO+1;
                 "IF"S>0"THEN"MANT[1]:=1;
                  READY:
              "END";
        EXPO:=EXPO+1
 "END" LNGREATODECI;
    "EOP"
1SECTION : 2.2.1.1            (OCTOBER 1975)                      PAGE 1
 
 
 
 AUTHOR: C.G. VAN DER LAAN.
 
 
 INSTITUTE: REKENCENTRUM RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED: 741114.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THE PROCEDURES POL, TAYPOL, NORDERPOL AND
     DERPOL.
 
     POL EVALUATES A POLYNOMIAL;
 
     DERPOL EVALUATES THE FIRST K DERIVATIVES OF A POLYNOMIAL;
 
     NORDERPOL EVALUATES THE FIRST K NORMALIZED DERIVATIVES OF A
     POLYNOMIAL (I.E. J-TH DERIVATIVE/(J FACTORIAL),J=0,1,...,K<=DEGREE;
 
     TAYPOL EVALUATES X**J*(J-TH DERIVATIVE)/(J FACTORIAL),
     J=0,1,...,K<=DEGREE.
 
 
 KEYWORDS:
 
     POLYNOMIAL EVALUATION,
     (NORMALIZED) DERIVATIVES,
     DERIVATIVES OF A POLYNOMIAL.
 
 SUBSECTION: POL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE" POL(N,X,A);
     "VALUE"N,X;"INTEGER"N;"REAL"X;"ARRAY"A;
     "CODE" 31040;
 
     POL:=A[0]+A[1]*X+...+A[N]*X**N;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE DEGREE OF THE POLYNOMIAL;
     X:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE ARGUMENT OF THE POLYNOMIAL;
     A:   <ARRAY IDENTIFIER>;
          "ARRAY"A[0:N];
          ENTRY: THE COEFFICIENTS OF THE POLYNOMIAL
                 A[0]+A[1]*X+...+A[N]*X**N.
 
 
 PROCEDURES USED: NONE.
 
 
1SECTION : 2.2.1.1            (OCTOBER 1975)                      PAGE 2
 
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (N MULTIPLICATIONS AND ADDITIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE METHOD USED FOR EVALUATION IS HORNER'S RULE (SYNTHETIC
     DIVISION). THE ERROR GROWTH IS GIVEN BY A LINEAR FUNCTION OF THE
     DEGREE OF THE POLYNOMIAL (SEE VAN DER LAAN, STOER(1972) P. 29 (EX.
     11) OR WILKINSON(1963) P. 36,37).
 
 
 SUBSECTION: DERPOL.
 
 
 CALLING SEQUENCE:
 
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" DERPOL(N,K,X,A);
     "VALUE"N,K,X;"INTEGER"N,K;"REAL"X;"ARRAY"A;
     "CODE" 31243;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE DEGREE OF THE POLYNOMIAL;
     K:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE FIRST K DERIVATIVES ARE TO BE CALCULATED;
     X:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE ARGUMENT OF THE POLYNOMIAL;
     A:   <ARRAY IDENTIFIER>;
          "ARRAY"A[0:N];
          ENTRY: THE COEFFICIENTS OF THE POLYNOMIAL
                 A[0]+A[1]*X+...+A[N]*X**N;
          EXIT: THE J-TH DERIVATIVE IS DELIVERED IN A[J], J=0,1,...,K<=
                DEGREE; THE OTHER ELEMENTS ARE GENERALLY ALTERED.
 
 
 PROCEDURES USED :
 
 
      NORDERPOL  =  CP31242
 
 
 RUNNING TIME: THE NUMBER OF ADDITIONS IS (K+1)*(N-K/2) AND
               THE NUMBER OF MULTIPLICATIONS IS N, IN FIRST ORDER.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE TAYPOL(THIS SECTION).
 
 
1SECTION : 2.2.1.1            (OCTOBER 1975)                      PAGE 3
 
 
 
 SUBSECTION: NORDERPOL.
 
 
 CALLING SEQUENCE:
 
 
     THE HEADING OF THE PROCEDURE READS:
 
     "PROCEDURE" NORDERPOL(N,K,X,A);
     "VALUE"N,K,X;"INTEGER"N,K;"REAL"X;"ARRAY"A;
     "CODE" 31242;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     N:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE DEGREE OF THE POLYNOMIAL;
     K:   <ARITHMETIC EXPRESSION>;
          THE FIRST K NORMALIZED DERIVATIVES ARE TO BE CALCULATED
          (I.E. (J-TH DERIVATIVE)/(J FACTORIAL), J=0,1,...,K<=DEGREE).
     X:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE ARGUMENT OF THE POLYNOMIAL;
     A:   <ARRAY IDENTIFIER>;
          "ARRAY"A[0:N];
          ENTRY: THE COEFFICIENTS OF THE POLYNOMIAL
                 A[0]+A[1]*X+...+A[N]*X**N;
          EXIT: THE J-TH NORMALIZED DERIVATIVE IS DELIVERED IN A[J]
                J=0,1,...,K<=DEGREE; THE OTHER ELEMENTS ARE GENERALLY
                ALTERED.
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY: AN AUXILIARY ARRAY OF ORDER N + 1 IS DECLARED.
 
 
 RUNNING TIME: THE NUMBER OF ADDITIONS IS (K+1)*(N-K/2) AND
               THE NUMBER OF MULTIPLICATIONS/DIVISIONS IS 2 * N + K.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE TAYPOL(THIS SECTION).
 
 
1SECTION : 2.2.1.1            (OCTOBER 1975)                      PAGE 4
 
 
 
 SUBSECTION: TAYPOL.
 
 
 CALLING SEQUENCE:
 
 
     THE HEADING OF THE PROCEDURE READS:
 
     "PROCEDURE" TAYPOL(N,K,X,A);
     "VALUE"N,K,X;"INTEGER"N,K;"REAL"X;"ARRAY"A;
     "CODE" 31241;
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     N:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE DEGREE OF THE POLYNOMIAL;
     K:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE FIRST K TERMS X**J*(J-TH DERIVATIVE)/(J FACTORIAL),
                 J=0,1,...,K<=DEGREE, ARE TO BE CALCULATED;
     X:   <ARITHMETIC EXPRESSION>;
          ENTRY: THE ARGUMENT OF THE POLYNOMIAL;
     A:   <ARRAY IDENTIFIER>;
          "ARRAY"A[0:N];
          ENTRY: THE COEFFICIENTS OF THE POLYNOMIAL
                 A[0]+A[1]*X+...+A[N]*X**N;
          EXIT: THE J-TH TERM X**J*(J-TH DERIVATIVE)/(J FACTORIAL), IS
                DELIVERED IN A[J], J=0,1,...,K<=DEGREE; THE OTHER
                ELEMENTS ARE GENERALLY ALTERED.
 
 PROCEDURES USED: NONE.
 
 RUNNING TIME: THE NUMBER OF ADDITIONS IS (K+1)*(N-K/2) AND
               THE NUMBER OF MULTIPLICATIONS IS 2 * N.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE METHOD OF EVALUATION IS GIVEN BY TRAUB AND SHAW(1972,1974).
     LET X**J*(J-TH DERIVATIVE OF THE POLYNOMIAL)/(J FACTORIAL)=
     (J OVER J)*A[J]*X**J+(J+1 OVER J)*A[J+1]*X**(J+1)+...+(N OVER J)*
     A[N]*X**N,THEN THE J-TH DERIVATIVE (UP TO A FACTOR) CAN BE OBTAINED
     FROM THE BINOMIAL COEFFICIENTS FOLLOWED BY EVALUATION OF THE ABOVE
     INPRODUCT. THE SHAW AND TRAUB ALGORITHM PERFORMS THE BUILDING UP OF
     THE BINOMIAL COEFFICIENTS IMPLICITLY.
     WE HAVE NOT IMPLEMENTED THE MORE SOPHISTICATED ALGORITHM, BASED
     ON DIVISORS OF N+1, BECAUSE OF THE MORE COMPLEX APPEARANCE
     OF  THE IMPLEMENTATION AND BECAUSE OF THE DIFFICULTY IN CHOSING
     THE MOST EFFICIENT DIVISOR. OUR (RESTRICTED) IMPLEMENTATION OF THE
     ONE-PARAMETER FAMILY OF ALGORITHMS PRESERVES THE LINEAR NUMBER OF
     MULTIPLICATIONS (2*N (NORDERPOL, TAYPOL) AND 3*N (DERPOL)).
     THE ABSOLUTE ERROR IS OF ORDER MAX((N OVER N)*A[N]*X**(N-K),...,
     (N OVER K)*A[K]), FOR THE K-TH NORMALIZED DERIVATIVE (SEE VAN DER
     LAAN OR WOZNIAKOWSKI).
 
1SECTION : 2.2.1.1            (DECEMBER 1979)                     PAGE 5
 
 
 
 REFERENCES:
 
     [1].SHAW,M. AND J. TRAUB:
         ON THE NUMBER OF MULTIPLICATIONS FOR THE EVALUATION OF A
         POLYNOMIAL AND SOME OF ITS DERIVATIVES (21 P.).
         JOURN. ACM, 1974, VOL. 21, NO. 1, P. 161-167.
 
     [2].STOER,J. :
         EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK 1.
         SPRINGER, 1972.
 
     [3].VAN DER LAAN C.G.:
         ORTHOGONAL POLYNOMIALS IN NUMERICAL ANALYSIS.
         1. ERROR ANALYSIS OF RECURRENCE RELATIONS IN FLOATING-POINT
         COMPUTATION, (TO APPEAR).
 
     [4].WILKINSON,J.H. :
         ROUNDING ERRORS IN ALGEBRAIC PROCESSES.
         HSO, NOTES ON APPLIED SCIENCES NO. 32, 1963.
 
     [5].WOZNIAKOWSKI,H.:
         ROUNDING ERROR ANALYSIS FOR THE EVALUATION OF A POLYNOMIAL AND
         SOME OF ITS DERIVATIVES.
         SIAM J. OF NUM. AN. VOL 11, NO. 4, P. 780-787.
 
 EXAMPLE OF USE:
 
     AS A FORMAL TEST OF THE PROCEDURE DERPOL THE DERIVATIVES OF THE
     POLYNOMIAL 3*X**3-2*X**2+X-1 ARE CALCULATED AT X=1.
 
     "BEGIN""ARRAY"A[0:3];
          A[3]:=3;A[2]:=-2;A[1]:=1;A[0]:=-1;
          DERPOL(3,3,1,A); OUTPUT(61,"("
          "("THE 0-TH UNTIL AND INCLUDING THE 3-TH DERIVATIVES :")",
          4(BZDB)")",A[0],A[1],A[2],A[3]);
     "END" EXAMPLE OF USE;
 
     THE 0-TH UNTIL AND INCLUDING THE 3-TH DERIVATIVES :  1  6  14  18
 
 
 SOURCE TEXT(S):
0"CODE" 31040;
      "REAL" "PROCEDURE" POL(N,X,A);
      "VALUE" N,X;"INTEGER" N;"REAL" X;"ARRAY" A;
      "BEGIN" "REAL" R;
         R:= 0;
         "FOR" N:= N "STEP" -1 "UNTIL" 0 "DO"
         R:=R*X  + A[N];
         POL:= R
      "END" POL
1SECTION : 2.2.1.1            (OCTOBER 1975)                      PAGE 6
 
                                                                   ;
         "EOP"
0"CODE" 31241;
      "PROCEDURE" TAYPOL(N,K,X,A);
      "VALUE" N,K,X;
      "INTEGER" N,K;"REAL" X;"ARRAY" A;
      "IF" X^= 0 "THEN"
      "BEGIN" "INTEGER" I,J,NM1;
         "REAL" XJ,AA,H;
         XJ:=1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" XJ:=XJ*X;A[J]:=A[J]*XJ "END";
         AA:=A[N];NM1:=N-1;
         "FOR" J:= 0 "STEP" 1 "UNTIL" K "DO"
         "BEGIN" H:=AA;
            "FOR" I:= NM1 "STEP" -1 "UNTIL" J "DO"
            H:= A[ I]:=A[I]+H
         "END"
      "END" "ELSE"
      "FOR" K:= K "STEP" -1 "UNTIL" 1 "DO" A[K]:=0;
         "EOP"
0"CODE" 31242;
      "PROCEDURE" NORDERPOL (N,K,X,A);
      "VALUE" N,K,X;
      "INTEGER" N,K;"REAL" X;"ARRAY" A;
      "IF" X^= 0 "THEN"
      "BEGIN" "INTEGER" I,J,NM1;
         "REAL" XJ,AA,H;
         "ARRAY" XX[0:N];
         XJ:=1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" XJ:=XX[J]:=XJ*X;A[J]:=A[J]*XJ "END";
         H:=AA:=A[N];NM1:=N-1;
         "FOR" I:= NM1 "STEP" -1 "UNTIL" 0 "DO" H:= A[I]:=A[I]+H;
         "FOR" J:= 1 "STEP" 1 "UNTIL" K "DO"
         "BEGIN" H:=AA;
            "FOR" I:= NM1 "STEP" -1 "UNTIL" J "DO"
            H:= A[ I]:=A[I]+H;
            A[J]:=H/XX[J]
         "END"
      "END" NORDERPOL ;
         "EOP"
0"CODE" 31243;
      "PROCEDURE" DERPOL (N,K,X,A);
      "VALUE" N,K,X;
      "INTEGER" N,K;"REAL" X;"ARRAY" A;
      "BEGIN" "INTEGER" J; "REAL" FAC;
         FAC:=1;
         NORDERPOL (N,K,X,A);
         "FOR" J:= 2 "STEP" 1 "UNTIL" K "DO"
         "BEGIN" FAC:=FAC*J;A[J]:=A[J]*FAC "END"
      "END" DERPOL ;
         "EOP"
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 1
 
 
 
 AUTHOR:         C.G. VAN DER LAAN
 
 
 CONTRIBUTORS:   C.G. VAN DER LAAN, M. VOORINTHOLT
 
 
 INSTITUTE:      REKENCENTRUM RIJKSUNIVERSITEIT GRONINGEN
 
 
 RECEIVED:       780601
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS SIX PROCEDURES FOR THE EVALUATION
     OF ORTHOGONAL POLYNOMIALS:
     ORTPOL,ORTPOLSYM:       EVALUATE AN ORTHOGONAL POLYNOMIAL,
     ALLORTPOL,ALLORTPOLSYM: EVALUATE ALL ORTHOGONAL POLYNOMIALS OF
                             DEGREE LESS THAN A GIVEN POSITIVE INTEGER.
     SUMORTPOL,SUMORTPOLSYM: EVALUATE A SERIES OF
                             ORTHOGONAL POLYNOMIALS.
     THE PROCEDURES ENDING WITH SYM ARE EFFICIENT VERSIONS FOR
     SYMMETRICAL POLYNOMIALS (I.E. ODD INDEXED POLYNOMIALS THAT ARE ODD
     FUNCTIONS AND EVEN INDEXED POLYNOMIALS THAT ARE EVEN FUNCTIONS);
 
 
 KEYWORDS:
 
     ORTHOGONAL POLYNOMIAL,
     SERIES OF ORTHOGONAL POLYNOMIALS,
     LINEAR THREE TERM (IN)HOMOGENEOUS RECURRENCE RELATION.
 
 
 DATA AND RESULTS:
 
     ORTHOGONAL POLYNOMIALS CAN BE CHARACTERIZED BY A RECURRENCE
     RELATION OF THE FOLLOWING FORM
 
            A1[K] * F[K+1](X) = (A2[K] + X * A3[K]) * F[K](X)
                                - A4[K] * F[K-1](X),
 
     WHERE AI[K] ARE REAL NUMBERS. SEE FOR INSTANCE TABLE 22.7 IN
     ABRAMOWITZ AND STEGUN (1964) FOR THE CLASSICAL ORTHOGONAL
     POLYNOMIALS. BY AN ELEMENTARY TRANSFORMATION, THE COEFFICIENTS
     IN THE RECURRENCE RELATION ABOVE CAN BE MADE SUCH THAT
     THE RECURRENCE RELATION IS GIVEN BY
 
          P[K+1](X) = (X - B[K]) * P[K](X) - C[K] * P[K-1](X),
 
     P[0](X) = 1, P[1](X) = X - B[0].
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 2
 
 
 
     IN THIS WAY WE OBTAIN A NORMALIZATION OF THE ORTHOGONAL POLYNOMIAL
     SUCH THAT THE LEADING COEFFICIENT IN THE EXPLICIT REPRESENTATION OF
     P[K](X) EQUALS 1.
     AS A CONSEQUENCE THE FOLLOWING RELATION HOLDS BETWEEN THE VALUES
     OBTAINED BY OUR PROCEDURES (E.G. ORTPOL) AND THE VALUES FROM
     THE REPRESENTATION IN ABRAMOWITZ AND STEGUN (1964) (I.C. F)
 
                                 N-1
               ORTPOL[N](X)  =  PROD (A1[K]/A3[K]) * F[N](X) ,
                                 K=0
 
     WHERE A1[K], A3[K], F[N] ARE DETERMINED BY 22.4 AND 22.7 IN
     ABRAMOWITZ AND STEGUN(1964). WE NOTICE THAT OVERFLOW/UNDERFLOW
     MAY OCCUR EARLIER AS A CONSEQUENCE OF OUR NORMALIZATION.
     IN ORDER TO AVOID MISTAKES WHEN OBTAINING THE RECURRENCE
     COEFFICIENTS THE FOLLOWING TABLE GIVES THE RECURRENCE COEFFICIENTS
     FOR THE CLASSICAL ORTHOGONAL POLYNOMIALS (NOTE THAT THE FIRST AND
     SECOND POLYNOMIAL ARE DEFINED BY THE NORMALIZATION AND B[0]):
 
     POLYNOMIAL KIND       : RECURRENCE COEFFICIENTS
     ----------------------:--------------------------------------------
                           :         B[K]          :         C[K]
                           :-----------------------:--------------------
     CHEBYSHEV (1-ST KIND) :          0            :       1/2 , K=1
                           :                       :       1/4 , K>1
                           :                       :
     CHEBYSHEV (2-ND KIND) :          0            :         1/4
                           :                       :
     LEGENDRE              :          0            :   K**2/(4*K**2-1)
                           :                       :
     JACOBI                : -(ALPHA**2-BETA**2)/  : 4*(1+ALPHA)*
                           : ((2*K+ALPHA+BETA)*    : (1+BETA)/((ALPHA+
                           : (2*K+ALPHA+BETA+2))   : BETA+2)**2*(ALPHA+
                           :                       : BETA+3))  , K=1
                           :                       :
                           :                       : 4*K*(K+ALPHA)*
                           :                       : (K+BETA)*(K+ALPHA+
                           :                       : BETA)/((2*K+ALPHA+
                           :                       : BETA)**2*((2*K+
                           :                       : ALPHA+BETA)**2-1))
                           :                       :           , K>1
                           :                       :
                           :                       : (ALPHA,BETA > -1)
                           :                       :
     LAGUERRE              :     2*K+ALPHA+1       :     K*(K+ALPHA)
                           :                       :
     HERMITE               :          0            :         K/2
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 3
 
 
 
     IN GENERAL THE RECURRENCE COEFFICIENTS MAY BE OBTAINED BY USE OF
     THE PROCEDURE RECCOF. THE ABOVE TABLE IS OBTAINED BY ADAPTION
     OF TABLE 22.7,ABRAMOWITZ AND STEGUN (1964) P. 782, AS FOLLOWS:
     (NOTE THAT N>=1; FOR N=0 CONSULT 22.4)
 
     B[I]:=-A2[I]/A3[I]                    , I=0,1,...,N-1
     C[I]:=(A4[I]*A1[I-1])/(A3[I]*A3[I-1]) , I=1,2,...,N-1.
 
 
 METHOD AND PERFORMANCE:
 
     LET THE ORTHOGONAL POLYNOMIAL BE DEFINED BY
        P[K+1](X)=(X-B[K])*P[K](X)-C[K]*P[K-1](X)  , K=1,2,...N-1
     WHERE B[0:N-1], C[1:N-1] CONTAIN THE RECURRENCE COEFFICIENTS AND
     P[1](X)=X-B[0], P[0](X)=1   (SEE STOER 1972, P. 119).
     THEN
                                N-1  / X-B[K]   1 \ / 1 \
        P[N](X) = (X-B[0],1) * PROD  [            ] [   ]  , N=1,2,.....
                                K=1  \  -C[K]   0 / \ 0 /
        AND
 
        A[0]+A[1]*P[1](X)+...+A[N]*P[N](X)=
                                      N   J-1  / X-B[K]   1 \ / A[J] \
                 A[0] + (X-B[0],1) * SUM PROD  [            ] [      ] .
                                     J=1  K=1  \  -C[K]   0 / \  0   /
        THESE EXPRESSIONS ARE EVALUATED BY A GENERALISED HORNER RULE.
 
     (SEE ALSO LUKE, 1969, P. 327).
 
 
 REFERENCES:
 
     ABRAMOWITZ, M. & I. STEGUN (1964):
         HANDBOOK OF MATHEMATICAL FUNCTIONS,
         NATIONAL BUREAU OF STANDARDS, WASHINGTON D.C.
 
     LUKE, Y.L. (1969):
         THE SPECIAL FUNCTIONS AND THEIR APPROXIMATIONS I,
         ACADEMIC PRESS, LONDON, NEW YORK.
 
     STOER, J. (1972):
         EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK I,
         SPRINGER VERLAG, BERLIN.
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 4
 
 
 
 SUBSECTION: ORTPOL.
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "REAL" "PROCEDURE" ORTPOL(N,X,B,C); "VALUE" N,X;
     "INTEGER" N; "REAL" X; "ARRAY" B,C;
     "CODE" 31044;
 
     ORTPOL DELIVERS THE VALUE OF THE ORTHOGONAL POLYNOMIAL OF
     DEGREE N FOR THE ARGUMENT X AS DETERMINED BY THE
     RECURRENCE COEFFICIENTS.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE DEGREE OF THE POLYNOMIAL;
     X:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE ARGUMENT OF THE ORTHOGONAL POLYNOMIAL;
     B,C:     <ARRAY IDENTIFIER>;
              "ARRAY" B[0:N-1], C[1:N-1];
              ENTRY: THE RECURRENCE COEFFICIENTS (SEE DATA AND RESULTS).
 
 
 SUBSECTION: ORTPOLSYM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "REAL" "PROCEDURE" ORTPOLSYM(N,X,C); "VALUE" N,X;
     "INTEGER" N; "REAL" X; "ARRAY" C;
     "CODE" 31048;
 
     ORTPOLSYM DELIVERS THE VALUE OF THE ORTHOGONAL POLYNOMIAL OF
     DEGREE N FOR THE ARGUMENT X AS DETERMINED BY THE
     RECURRENCE COEFFICIENTS.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE DEGREE OF THE POLYNOMIAL;
     X:       <ARITHMETIC EXPRESSION>;
              ENTRY: THE ARGUMENT OF THE ORTHOGONAL POLYNOMIAL;
     C:       <ARRAY IDENTIFIER>;
              "ARRAY" C[1:N-1];
              ENTRY: THE RECURRENCE COEFFICIENTS (SEE DATA AND RESULTS).
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 5
 
 
 
 SUBSECTION: ALLORTPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" ALLORTPOL(N,X,B,C,P);
     "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" B,C,P;
     "CODE" 31045;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N,X,B,C: SEE ORTPOL      (THIS SECTION);
     P:       <ARRAY IDENTIFIER>;
              "ARRAY" P[0:N];
              EXIT: P[K] CONTAINS, FOR THE ARGUMENT, THE VALUE OF THE
                    K-TH ORTHOGONAL POLYNOMIAL AS DEFINED BY THE
                    RECURRENCE COEFFICIENTS.
 
 
 SUBSECTION: ALLORTPOLSYM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "PROCEDURE" ALLORTPOLSYM(N,X,C,P);
     "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" C,P;
     "CODE" 31049;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N,X,C:   SEE ORTPOLSYM   (THIS SECTION);
     P:       <ARRAY IDENTIFIER>;
              "ARRAY" P[0:N];
              EXIT: P[K] CONTAINS, FOR THE ARGUMENT, THE VALUE OF THE
                    K-TH ORTHOGONAL POLYNOMIAL AS DEFINED BY THE
                    RECURRENCE COEFFICIENTS.
 
 
 SUBSECTION: SUMORTPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "REAL" "PROCEDURE" SUMORTPOL(N,X,B,C,A);
     "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" B,C,A;
     "CODE" 31047;
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 6
 
 
 
     SUMORTPOL : DELIVERS THE VALUE OF THE POLYNOMIAL
     A[0]+A[1]*P[1](X)+...+A[N]*P[N](X)
     WHERE P[K](X) IS THE K-TH ORTHOGONAL POLYNOMIAL.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N,X,B,C:   SEE ORTPOL      (THIS SECTION);
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[0:N];
                ENTRY: THE COEFFICIENTS OF THE SERIES EXPANSION
                       A[0]+A[1]*P[1](X)+...+A[N]*P[N](X)
                       WHERE P[K](X) IS THE K-TH ORTHOGONAL POLYNOMIAL
                       AS DEFINED BY THE RECURRENCE COEFFICIENTS.
 
 
 SUBSECTION: SUMORTPOLSYM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
 
     "REAL" "PROCEDURE" SUMORTPOLSYM(N,X,C,A);
     "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" C,A;
     "CODE" 31058;
 
     SUMORTPOLSYM : DELIVERS THE VALUE OF THE POLYNOMIAL
     A[0]+A[1]*P[1](X)+...+A[N]*P[N](X)
     WHERE P[K](X) IS THE K-TH ORTHOGONAL POLYNOMIAL.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N,X,C:     SEE ORTPOLSYM   (THIS SECTION);
     A:         <ARRAY IDENTIFIER>;
                "ARRAY" A[0:N];
                ENTRY: THE COEFFICIENTS OF THE SERIES EXPANSION
                       A[0]+A[1]*P[1](X)+...+A[N]*P[N](X)
                       WHERE P[K](X) IS THE K-TH ORTHOGONAL POLYNOMIAL
                       AS DEFINED BY THE RECURRENCE COEFFICIENTS.
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 7
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM DELIVERS THE VALUES OF THE
     LAGUERRE POLYNOMIAL OF DEGREES 0,1,2,3,4,5 FOR X=0 BY MEANS OF THE
     PROCEDURE ALLORTPOL (B[K]=2*K+1, C[K]=K**2):
 
     "BEGIN" "ARRAY" B[0:4], C[1:4], P[0:5];
       "INTEGER" I;
       B[0]:=1;
       "FOR" I:=1 "STEP" 1 "UNTIL"  4 "DO"
       "BEGIN" B[I]:=2*I+1;
         C[I]:=I**2;
       "END" I;
       ALLORTPOL(5,0,B,C,P);
       OUTPUT(61,"("2/,6(2B,+2ZD.D)")",P);
     "END" PROGRAM;
 
 
     RESULTS (NOTE THE DIFFERENCE WITH FIGURE 22.9 IN ABRAMOWITZ AND
     STEGUN (1964) BECAUSE OF THE NORMALIZATION):
 
         +1.0  -1.0  +2.0  -6.0  +24.0  -120.0
 
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 8
 
 
 
 SOURCE TEXTS:
 
 "CODE" 31044;
 "REAL" "PROCEDURE" ORTPOL(N,X,B,C);
 "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" B,C;
 "IF" N=0 "THEN" ORTPOL:=1 "ELSE"
 "BEGIN" "INTEGER" K,L; "REAL" R,S,H;
   R:=X-B[0]; S:=1; L:=N-1;
   "FOR" K:=1 "STEP" 1 "UNTIL" L "DO"
 "BEGIN" H:=R;
   R:=(X-B[K])*R-C[K]*S;
   S:=H;
 "END";
   ORTPOL:=R;
 "END" ORTPOL;
         "EOP"
0
 
 "CODE" 31048;
 "REAL" "PROCEDURE" ORTPOLSYM(N,X,C);
 "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" C;
 "IF" N=0 "THEN" ORTPOLSYM:=1.0 "ELSE"
 "BEGIN"
      "INTEGER" K,L; "REAL" R,S,H;
      R:=X; S:=1.0; L:=N-1;
      "FOR" K:=1 "STEP" 1 "UNTIL" L "DO"
      "BEGIN"
           H:=R; R:=X*R-C[K]*S;
           S:=H
      "END";
      ORTPOLSYM:=R
 "END" ORTPOLSYM;
         "EOP"
0
 
 "CODE" 31045;
 "PROCEDURE"ALLORTPOL(N,X,B,C)RESULTS:(P);
 "VALUE" N,X; "INTEGER" N;"REAL" X;"ARRAY" B,C,P;
 "IF" N=0 "THEN" P[0]:=1"ELSE"
 "BEGIN" "INTEGER" K,K1; "REAL" R,S,H;
   R:=P[1]:=X-B[0]; S:=P[0]:=1;K:=1;
   "FOR" K1:=2 "STEP" 1 "UNTIL" N "DO"
 "BEGIN" H:=R;  P[K1]:=R:=(X-B[K])*R-C[K]*S;
   S:=H; K:=K1;
 "END";
 "END" ALLORTPOL
1SECTION : 2.2.2.1           (NOVEMBER 1978)                      PAGE 9
 
 
                                                                   ;
         "EOP"
 "CODE" 31049;
 "PROCEDURE" ALLORTPOLSYM(N,X,C)RESULTS:(P);
 "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" C,P;
 "IF" N=0 "THEN" P[0]:=1.0 "ELSE"
 "BEGIN"
      "INTEGER" K; "REAL" R,S,H;
      R:=P[1]:=X; S:=P[0]:=1.0;
      "FOR" K:=2 "STEP" 1 "UNTIL" N "DO"
      "BEGIN"
           H:=R;
           P[K]:=R:=X*R-C[K-1]*S;
           S:=H
      "END";
 "END" ALLORTPOLSYM;
         "EOP"
0
 
 "CODE" 31047;
 "REAL" "PROCEDURE" SUMORTPOL(N,X,B,C,A);
 "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" B,C,A;
 "IF" N=0 "THEN" SUMORTPOL:=A[0] "ELSE"
 "BEGIN" "INTEGER" K; "REAL" H,R,S;
   R:=A[N]; S:=0;
   "FOR" K:=N-1 "STEP" -1 "UNTIL" 1 "DO"
   "BEGIN"
     H:=R;
     R:=A[K]+(X-B[K])*R+S;
     S:=       -C[K]*H
   "END";
   SUMORTPOL:=A[0]+(X-B[0])*R+S
 "END" SUMORTPOL;
         "EOP"
0
 
 "CODE" 31058;
 "REAL" "PROCEDURE" SUMORTPOLSYM(N,X,C,A);
 "VALUE" N,X; "INTEGER" N; "REAL" X; "ARRAY" C,A;
 "IF" N=0 "THEN" SUMORTPOLSYM:=A[0] "ELSE"
 "BEGIN"
      "INTEGER" K; "REAL" H,R,S;
      R:=A[N]; S:=0;
      "FOR" K:=N-1 "STEP" -1 "UNTIL" 1 "DO"
      "BEGIN"
           H:=R;
           R:=A[K]+X*R+S;
           S:= -C[K]*H
      "END";
      SUMORTPOLSYM:=A[0]+X*R+S
 "END" SUMORTPOLSYM;
         "EOP"
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 1
 
 
 
 AUTHOR:        C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS:  C.G. VAN DER LAAN, M. VOORINTHOLT.
 
 
 INSTITUTE:     REKENCENTRUM RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED:      780601.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOUR PROCEDURES ABOUT CHEBYSHEV POLYNOMIALS
     OF THE FIRST KIND:
     CHEPOLSUM:    EVALUATES A (FINITE) SUM OF CHEBYSHEV POLYNOMIALS,
     ODDCHEPOLSUM: EVALUATES A (FINITE) SUM OF CHEBYSHEV POLYNOMIALS
                   OF ODD DEGREE,
     CHEPOL:       EVALUATES A CHEBYSHEV POLYNOMIAL,
     ALLCHEPOL:    EVALUATES ALL CHEBYSHEV POLYNOMIALS WITH DEGREE LESS
                   THAN A GIVEN POSITIVE INTEGER.
 
 
 KEYWORDS:
 
     (FINITE) SUM OF (SHIFTED) CHEBYSHEV POLYNOMIALS OF THE FIRST KIND,
     GOERTZEL,WATT,CLENSHAW,GENERALIZED HORNER ALGORITHM,
     LINEAR THREE TERM (INHOMOGENEOUS) RECURRENCE RELATION.
 
 
 REFERENCES:
 
     CLENSHAW, C.W. (1962):
     CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS.
     MATH. TAB. NAT. PHYS. LAB. 5, LONDON. HMO.
 
     FOX, L. & I.B. PARKER (1972):
     CHEBYSHEV POLYNOMIALS IN NUMERICAL ANALYSIS.
     OXFORD UNIVERSITY PRESS.
 
     RIVLIN, T.J. (1974):
     THE CHEBYSHEV POLYNOMIALS.
     WILEY.
 
     STOER,J.(1972):
     EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK 1.
     HEIDELBERGER TASCHENBUECHER 105,SPRINGER-VERLAG.
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 2
 
 
 
 SUBSECTION: CHEPOLSUM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "REAL""PROCEDURE"CHEPOLSUM(N,X,A);
     "VALUE"N,X;"INTEGER"N;"REAL"X;"ARRAY"A;
     "CODE"31046;
 
     CHEPOLSUM:=THE VALUE OF THE CHEBYSHEV SUM
              A[0] + A[1]*T[1](X) + .... + A[N]*T[N](X),
              WHERE T[1](X),....,T[N](X) ARE CHEBYSHEV POLYNOMIALS
              OF THE FIRST KIND, OF DEGREE 1,....,N, RESPECTIVELY.
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     N : <ARITHMETIC EXPRESSION>;
         ENTRY: THE DEGREE OF THE POLYNOMIAL REPRESENTED BY THE
                CHEBYSHEV SUM (N>=0);
     X : <ARITHMETIC EXPRESSION>;
         ENTRY: THE ARGUMENT OF THE CHEBYSHEV POLYNOMIALS , ABS(X)<=1;
     A : <ARRAY IDENTIFIER>;
         "ARRAY" A[0:N];
         ENTRY: THE COEFFICIENTS OF THE CHEBYSHEV SUM MUST BE GIVEN IN
                ARRAY A, WHERE A[K] IS THE COEFFICIENT OF THE CHEBYSHEV
                POLYNOMIAL OF DEGREE K, 0<=K<=N.
 
 
 PROCEDURES USED: NONE.
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 METHOD AND PERFORMANCE:
 
          N                          N  / 2*X  1 \ K  / A[K] \
         SUM A[K]*T[K](X) = (1,X) * SUM [        ]  * [      ]
         K=0                        K=0 \  -1  0 /    \  0   /
     WE USE THE CLENSHAW OR GENERALIZED HORNER ALGORITHM:
                          N
                         SUM A[K]*T[K](X) = (1,X) *
                         K=0
 
     / / A[0] \   / 2*X 1 \   / / A[1] \      / 2*X 1 \   / A[N] \ \  \
     [ [      ] + [       ] * [ [      ] +..+ [       ] * [      ] ]..].
     \ \  0   /   \ -1  0 /   \ \  0   /      \  -1 0 /   \  0   / /  /
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 3
 
 
 
     THIS PROCEDURE MAY BE USED:
     - TO EVALUATE THE SUM OF CHEBYSHEV POLYNOMIALS OF EVEN DEGREE
          N
         SUM A[K]*T[2*K](X) ,
         K=0
       BY THE CALL OF
         CHEPOLSUM(N,"IF" ABS(X)<ARREB "THEN" -1 "ELSE" 2*X*X-1,A)
       BECAUSE OF
         T[2*K](X) = T[K](T[2](X));
       (ARREB DENOTES THE MACHINE PRECISION)
     - TO EVALUATE THE SUM OF SHIFTED CHEBYSHEV POLYNOMIALS FOR 0<=X<=1
          N
         SUM A[K]*T'[K](X) ,
         K=0
       BY THE CALL OF
         CHEPOLSUM(N,2*X-1,A)
       BECAUSE OF
         T'[K](X) = T[K](2*X-1).
 
 
 EXAMPLE OF USE :
 
     THE POLYNOMIAL : 1 + 1/2*T[1](X) + 1/4*T[2](X) IS EVALUATED FOR
     X = -1,0,1, WHERE T[1](X) AND T[2](X) ARE THE CHEBYSHEV POLYNOMIALS
     OF FIRST AND SECOND DEGREE, RESPECTIVELY.
 
     "BEGIN""ARRAY"A[0:2];
            A[2]:=.25;A[1]:=.5;A[0]:=1;
            OUTPUT(61,"("3(BZ.DD)")",CHEPOLSUM(2,-1,A),CHEPOLSUM(2,0,A),
            CHEPOLSUM(2,1,A))
     "END"
 
 
         .75  .75 1.75
 
 
 SUBSECTION: ODDCHEPOLSUM.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "REAL""PROCEDURE" ODDCHEPOLSUM(N,X,A);
     "VALUE"N,X;"INTEGER"N;"REAL"X;"ARRAY"A;
     "CODE"31059;
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 4
 
 
 
     ODDCHEPOLSUM:= THE VALUE OF THE CHEBYSHEV SUM
              A[1]*T[1](X) + .... + A[N]*T[2*N+1](X),
              WHERE T[1](X),....,T[2*N+1](X) ARE CHEBYSHEV POLYNOMIALS
              OF THE FIRST KIND, OF (ODD) DEGREE 1,....,2*N+1.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N : <ARITHMETIC EXPRESSION>;
         ENTRY: THE DEGREE OF THE POLYNOMIAL REPRESENTED BY
                THE CHEBYSHEV SUM IS 2*N+1 (N>=0);
     X : <ARITHMETIC EXPRESSION>;
         ENTRY: THE ARGUMENT OF THE CHEBYSHEV POLYNOMIALS, ABS(X)<=1;
     A : <ARRAY IDENTIFIER>;
         "ARRAY" A[0:N];
         ENTRY: THE COEFFICIENTS OF THE CHEBYSHEV SUM MUST BE GIVEN IN
                ARRAY A, WHERE A[K] IS THE COEFFICIENT OF THE CHEBYSHEV
                POLYNOMIAL OF DEGREE 2*K+1, 0<=K<=N.
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 METHOD AND PERFORMANCE:
 
     FROM THE REPRESENTATION, FOR ABS(X)<=1,
      N                                   N  / 2*T[2](X) -1 \ K  /A[K] \
     SUM A[K]*T[2*K+1](X) = X * (1,-1) * SUM [              ]  * [     ]
     K=0                                 K=0 \    1       0 /    \  0  /
     WE USE THE CLENSHAW OR GENERALIZED HORNER ALGORITHM:
                         N                                  / / A[0] \
                        SUM A[K]*T[2*K+1](X) = X * (1,-1) * [ [      ] +
                        K=0                                 \ \   0  /
 
     / 2*T[2](X) -1 \   / / A[1] \     / 2*T[2](X) -1 \   / A[N] \ \  \
     [              ] * [ [      ]+...+[              ] * [      ] ]..].
     \     1      0 /   \ \   0  /     \     1      0 /   \   0  / /  /
 
     THIS PROCEDURE MAY BE USED TO EVALUATE THE SUM OF SHIFTED CHEBYSHEV
     POLYNOMIALS OF ODD DEGREE FOR 0<=X<=1,
          N
         SUM A[K]*T'[2*K+1](X) ,
         K=0
     BY THE CALL OF
         ODDCHEPOLSUM(N,2*X-1,A)
     BECAUSE OF
         T'[K](X) = T[K](2*X-1).
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 5
 
 
 
 EXAMPLE OF USE:
 
     THE POLYNOMIAL 1/2*T[1](X) + 1/5*T[3](X) IS EVALUATED FOR X=-1,0,1,
     WHERE T[1](X) AND T[3](X) ARE CHEBYSHEV POLYNOMIALS OF THE FIRST
     AND THIRD DEGREE, RESPECTIVELY.
 
     "BEGIN"
          "ARRAY"A[0:1];
          A[1]:=.2;A[0]:=.5;
          OUTPUT(61,"("/,3(B,-Z.DD)")",ODDCHEPOLSUM(1,-1,A),
                                       ODDCHEPOLSUM(1,0,A),
                                       ODDCHEPOLSUM(1,1,A));
     "END"
 
     -.70  .00  .70
 
 
 SUBSECTION: CHEPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "REAL""PROCEDURE"CHEPOL(N,X);
     "VALUE"N,X;"INTEGER"N;"REAL"X;
     "CODE"31042;
 
     CHEPOL:=THE VALUE OF THE CHEBYSHEV POLYNOMIAL OF THE FIRST KIND OF
              DEGREE N FOR THE ARGUMENT X.
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N : <ARITHMETIC EXPRESSION>;
         ENTRY: THE DEGREE OF THE POLYNOMIAL (N>=0);
     X : <ARITHMETIC EXPRESSION>;
         ENTRY: THE ARGUMENT OF THE CHEBYSHEV POLYNOMIAL, ABS(X)<=1.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 METHOD AND PERFORMANCE: SEE ALLCHEPOL (NEXT SUBSECTION).
 
 
 EXAMPLE OF USE: SEE NEXT SUBSECTION.
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 6
 
 
 
 SUBSECTION: ALLCHEPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE"ALLCHEPOL(N,X,T);
     "VALUE"N,X;"INTEGER"N;"REAL"X;"REAL""ARRAY"T;
     "CODE"31043;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N : <ARITHMETIC EXPRESSION>;
         ENTRY: THE DEGREE OF THE LAST POLYNOMIAL (N>=0);
     X : <ARITHMETIC EXPRESSION>;
         ENTRY: THE ARGUMENT OF THE CHEBYSHEV POLYNOMIALS, ABS(X)<=1;
     T : <ARRAY IDENTIFIER>;
         "ARRAY" T[0:N];
         EXIT:  THE VALUES OF THE CHEBYSHEV POLYNOMIALS OF THE FIRST
                KIND OF DEGREES 0,1,...,N , FOR THE ARGUMENT X, ARE
                DELIVERED IN T[0],T[1],...,T[N], RESPECTIVELY.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 METHOD AND PERFORMANCE:
 
     FOR A DESCRIPTION OF THE ALGORITHM  SEE STOER,1972,P.21.
     THE MAXIMUM (ABSOLUTE) VALUE OF THE CHEBYSHEV POLYNOMIAL
     EQUALS 1 AS A NORMALIZATION.
     AN UPPER BOUND FOR THE (ABSOLUTE) ERROR IS A QUADRATIC FUNCTION
     OF THE DEGREE OF THE CHEBYSHEV POLYNOMIAL.THIS UPPER BOUND IS A
     ROUGH OVER-ESTIMATE FOR THE SPECIAL CASE ABS(X)<.5 (STOER,1972,
     P. 21-24).
 
 
 EXAMPLE OF USE :
 
     BY THE PROCEDURE (ALL)CHEPOL THE CHEBYSHEV POLYNOMIALS OF THE FIRST
     KIND OF DEGREES 0,1,2 ARE EVALUATED AT -1,0,1.
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 7
 
 
 
     "BEGIN"
         "ARRAY"T[0:2];
         ALLCHEPOL(2,-1,T);OUTPUT(61,"("/,3(-DB)")",T[0],T[1],T[2]);
         ALLCHEPOL(2, 0,T);OUTPUT(61,"("/,3(-DB)")",T[0],T[1],T[2]);
         ALLCHEPOL(2, 1,T);OUTPUT(61,"("/,3(-DB)")",T[0],T[1],T[2]);
         OUTPUT(61,"("/,3(/,-D)")",CHEPOL(2,-1),CHEPOL(2,0),CHEPOL(2,1))
     "END"
 
 
        1 -1  1
        1  0 -1
        1  1  1
 
        1
       -1
        1
 
 
 
 SOURCE TEXT(S):
 
 "CODE"31046;
 "REAL" "PROCEDURE" CHEPOLSUM(N,X,A);
 "VALUE" N,X;"INTEGER" N;"REAL" X;"ARRAY" A;
 "IF" N=0 "THEN" CHEPOLSUM:=A[0] "ELSE"
 "IF" N=1 "THEN" CHEPOLSUM:=A[0]+A[1]*X "ELSE"
 "BEGIN" "INTEGER" K;"REAL" H,R,S,TX;
    TX:=X+X;R:=A[N];
    H:=A[N-1]+R*TX;
    "FOR" K:=N-2 "STEP" -1 "UNTIL" 1 "DO"
    "BEGIN" S:=R;R:=H;
       H:=A[K]+R*TX-S
    "END"K;
    CHEPOLSUM:=A[0]-R+H*X
 "END" CHEPOLSUM
1SECTION : 2.2.2.2           (DECEMBER 1978)                      PAGE 8
 
 
                                                                   ;
         "EOP"
 "CODE"31059;
 "REAL""PROCEDURE"ODDCHEPOLSUM(N,X,A);
 "VALUE"N,X;"INTEGER"N;"REAL"X;"ARRAY"A;
 "COMMENT" ODDCHEPOLSUM:=A[0]T[1](X)+A[1]T[3](X)+....+A[N]T[2N+1](X);
 "IF" N=0 "THEN" ODDCHEPOLSUM:=X*A[0] "ELSE"
 "IF" N=1 "THEN" ODDCHEPOLSUM:=X*(A[0]+A[1]*(4*X*X-3)) "ELSE"
 "BEGIN"
    "INTEGER" K;
    "REAL" H,R,S,Y;
    Y:=4*X*X-2;
    R:=A[N];
    H:=A[N-1]+R*Y;
    "FOR" K:=N-2 "STEP" -1 "UNTIL" 0 "DO"
    "BEGIN"
      S:=R;
      R:=H;
      H:=A[K]+R*Y-S;
    "END" K;
    ODDCHEPOLSUM:=X*(H-R);
 "END" ODDCHEPOLSUM;
         "EOP"
 
 
 "CODE"31042;
 "REAL""PROCEDURE"CHEPOL(N,X);
 "VALUE"N,X;"INTEGER"N;"REAL"X;
 "IF" N = 0 "THEN" CHEPOL :=1 "ELSE"
 "IF" N = 1 "THEN" CHEPOL :=X "ELSE"
 "BEGIN""INTEGER"I;"REAL"T1,T2,H,X2;
    T2:=X;T1:=1;X2:=X+X;
    "FOR"I:=2"STEP"1"UNTIL"N"DO"
    "BEGIN"H:=X2*T2-T1;T1:=T2;T2:=H"END";
    CHEPOL:=H
 "END"CHEPOL;
         "EOP"
 
 
 "CODE"31043;
 "PROCEDURE"ALLCHEPOL(N,X,T);
 "VALUE"N,X;"INTEGER"N;"REAL"X;"REAL""ARRAY"T;
 "IF" N = 0 "THEN" T[0] :=1 "ELSE"
 "IF" N = 1 "THEN" "BEGIN" T[0] := 1; T[1] := X "END" "ELSE"
 "BEGIN""INTEGER"I;"REAL"T1,T2,H,X2;
    T[0]:=T1:=1;T[1]:=T2:=X;X2:=X+X;
    "FOR"I:=2"STEP"1"UNTIL"N"DO"
    "BEGIN"T[I]:=H:=X2*T2-T1;T1:=T2;T2:=H"END"
 "END"ALLCHEPOL;
         "EOP"
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 1
 
 
 
 AUTHOR:     C.G. VAN DER LAAN.
 
 
 INSTITUTE:  RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED:   740701.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS THE PROCEDURES:
     SINSER FOR EVALUATING A SINE SERIES;
     COSSER FOR EVALUTING A COSINE SERIES;
     FOUSER,FOUSER1,FOUSER2 FOR EVALUATING A FOURIER SERIES
     (IN FOUSER THE SERIES IS RESTRICTED TO A SERIES WITH SINE
      COEFFICIENTS EQUAL TO COSINE COEFFICIENTS);
     COMFOUSER,COMFOUSER1,COMFOUSER2 FOR EVALUATING A COMPLEX FOURIER
     SERIES
     (IN COMFOUSER THE SERIES IS RESTRICTED TO A SERIES WITH REAL
     COEFFICIENTS).
 
 
 KEYWORDS:
 
     FINITE FOURIER SERIES EVALUATION,
     TRIGONOMETRIC POLYNOMIAL EVALUATION,
     GOERTZEL,WATT,CLENSHAW,REINSCH ALGORITHM,
     LINEAR THREE-TERM INHOMOGENEOUS RECURRENCE RELATION.
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 2
 
 
 
 SUBSECTION : SINSER.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"SINSER(N,THETA,B);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"B;
     "CODE" 31090;
 
     SINSER:= THE VALUE OF THE SINE SERIES
              B[1]*SIN(THETA)+...+B[N]*SIN(N*THETA).
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE NUMBER OF TERMS IN THE SINE SERIES;
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE SINE SERIES;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY"B[1:N];
             ENTRY: THE COEFFICIENTS OF THE SINE SERIES.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: N MULTIPLICATIONS; 3N ADDITIONS;
                3 SINE/COSINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 3
 
 
 
 SUBSECTION : COSSER.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"COSSER(N,THETA,A);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A;
     "CODE" 31091;
 
     COSSER:= THE VALUE OF THE COSINE SERIES
              A[0]+A[1]*COS(THETA)+...+A[N]*COS(N*THETA).
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE TRIGONOMETRIC POLYNOMIAL.
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE COSINE SERIES.
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[0:N];
             ENTRY: THE COEFFICIENTS OF THE COSINE SERIES.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
              (IN FIRST ORDER: N MULTIPLICATIONS; 3N ADDITIONS;
               2 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 4
 
 
 
 SUBSECTION : FOUSER.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"FOUSER (N,THETA,A);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A;
     "CODE" 31092;
 
     FOUSER := THE VALUE OF THE FOURIER SERIES
               A[0]+A[1]*(COS(THETA)+SIN(THETA))+...+A[N]*(COS(N*THETA)
               +SIN(N*THETA)).
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE TRIGONOMETRIC POLYNOMIAL;
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[0:N];
             ENTRY: THE COEFFICIENTS OF THE (FINITE) FOURIER SERIES.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: N MULTIPLICATIONS; 3N ADDITIONS;
                3 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 5
 
 
 
 SUBSECTION : FOUSER1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"FOUSER1(N,THETA,A,B);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A,B;
     "CODE" 31093;
 
     FOUSER1:= THE VALUE OF THE FOURIER SERIES
               A[0]+A[1]*COS(THETA)+B[1]*SIN(THETA)+...
               +A[N]*COS(N*THETA)+B[N]*SIN(N*THETA).
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE TRIGONOMETRIC POLYNOMIAL;
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY"A[0:N],B[1:N];
             ENTRY: THE COEFFICIENTS OF THE (FINITE) FOURIER SERIES,
                    WITH A[K] COEFFICIENT OF COS(K*THETA), (K=0,...,N)
                    AND  B[K] COEFFICIENT OF SIN(K*THETA), (K=1,...,N).
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: 4N MULTIPLICATIONS; 4N ADDITIONS;
                2 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 6
 
 
 
 SUBSECTION : FOUSER2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "REAL""PROCEDURE"FOUSER2(N,THETA,A,B);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A,B;
     "CODE" 31094;
 
     FOUSER2:= THE VALUE OF THE FOURIER SERIES
               A[0]+A[1]*COS(THETA)+B[1]*SIN(THETA)+...
               +A[N]*COS(N*THETA)+B[N]*SIN(N*THETA).
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE TRIGONOMETRIC POLYNOMIAL;
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     A,B:    <ARRAY IDENTIFIER>;
             "ARRAY"A[0:N],B[1:N];
             ENTRY: THE COEFFICIENTS OF THE (FINITE) FOURIER SERIES,
                    WITH A[K] COEFFICIENT OF COS(K*THETA), (K=0,...,N)
                    AND  B[K] COEFFICIENT OF SIN(K*THETA), (K=1,...,N).
 
 
 PROCEDURES USED: SINSER = CP31090,
                  COSSER = CP31091.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: 2N MULTIPLICATIONS; 6N ADDITIONS;
                6 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE : ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 7
 
 
 
 SUBSECTION : COMFOUSER.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMFOUSER (N,THETA,A,RR,RI);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"A;
     "CODE" 31095;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL IN EXP(I*THETA);
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[0:N];
             ENTRY: THE REAL COEFFICIENTS A[K] (K=0,...,N) IN THE SERIES
                    FN(THETA)=A[0]+A[1]*EXP(I*THETA)+...+A[N]*EXP(I*
                    THETA)**N, MUST BE GIVEN IN ARRAY A;
     RR,RI:  <VARIABLE>;
             EXIT:  THE REAL PART AND THE IMAGINARY PART OF FN(THETA)
                    ARE DELIVERED IN RR AND RI, RESPECTIVELY.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER:  N MULTIPLICATIONS; 3N ADDITIONS;
                3 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 8
 
 
 
 SUBSECTION : COMFOUSER1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMFOUSER1(N,THETA,AR,AI,RR,RI);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"AR,AI;
     "CODE" 31096;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL IN EXP(I*THETA);
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     AR,AI:  <ARRAY IDENTIFIER>;
             "ARRAY"AR,AI[0:N];
             ENTRY: THE REAL PART AND THE IMAGINARY PART OF THE COMPLEX
                    COEFFICIENTS C[K] (K=0,...,N) IN THE SERIES
                    FN(THETA)=C[0]+C[1]*EXP(I*THETA)+...+C[N]*EXP(I*
                              THETA)**N
                    MUST BE GIVEN IN ARRAY AR AND AI, RESPECTIVELY;
     RR,RI:  <VARIABLE>;
             EXIT:  THE REAL PART AND THE IMAGINARY PART OF FN(THETA)
                    ARE DELIVERED IN RR AND RI, RESPECTIVELY.
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: 4N MULTIPLICATIONS; 4N ADDITIONS;
                2 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE : SEE COMFOUSER2 (THIS SECTION).
 
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                      PAGE 9
 
 
 
 SUBSECTION : COMFOUSER2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE"COMFOUSER2(N,THETA,AR,AI,RR,RI);
     "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"AR,AI;
     "CODE" 31097;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL IN EXP(I*THETA);
     THETA:  <ARITHMETIC EXPRESSION>;
             ENTRY: THE ARGUMENT OF THE FOURIER SERIES;
     AR,AI:  <ARRAY IDENTIFIER>;
             "ARRAY"AR,AI[0:N];
             ENTRY: THE REAL PART AND THE IMAGINARY PART OF THE COMPLEX
                    COEFFICIENTS C[K] (K=0,...,N) IN THE SERIES
                    FN(THETA)=C[0]+C[1]*EXP(I*THETA)+...+C[N]*EXP(I*
                              THETA)**N
                    MUST BE GIVEN IN ARRAY AR AND AI, RESPECTIVELY;
     RR,RI:  <VARIABLE>;
             EXIT:  THE REAL PART AND THE IMAGINARY PART OF FN(THETA)
                    ARE DELIVERED IN RR AND RI, RESPECTIVELY.
 
 
 PROCEDURES USED: COMFOUSER= CP31095.
 
 
 RUNNING TIME: PROPORTIONAL TO N
               (IN FIRST ORDER: 2N MULTIPLICATIONS; 6N ADDITIONS;
                6 COSINE/SINE EVALUATIONS).
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORANCE:
 
     FOR THE EVALUATION OF A FINITE FOURIER SERIES
     (=TRIGONOMETRIC POLYNOMIAL OF DEGREE N SEE POLYA AND SZEGOE, 1971,
     P. 76)
     FN(THETA)=A[0]+A[1]*COS(THETA)+B[1]*SIN(THETA)+...+
               A[N]*COS(N*THETA)+B[N]*SIN(N*THETA),
     TWO ALGORITHMS ARE USED:
1SECTION : 2.2.3.1            (OCTOBER 1974)                     PAGE 10
 
 
 
     1.  HORNER SCHEME
         LET C[K]=A[K]+I*B[K], K=0,...,N
         AND Z=EXP(-I*THETA)
         THEN
             FN(THETA)=RE(C[0]+C[1]*Z+...+C[N]*Z**N).
         THE ALGORITHM IS GIVEN BY:
             P:=C[N]
             P:=P*Z+C[K], K=N-1,...,0
             FN(THETA):=RE(P).
         (FOUSER1)
     2.  A COMBINATION OF THE CLENSHAW ALGORITHM (SEE GENTLEMAN(1969,II)
         , VAN DER LAAN, LUKE(1969, P.327-329) OR STOER(1972, P.62,63))
         AND THE MODIFICATION OF REINSCH (SEE REINSCH(1967), VAN DER
         LAAN, STOER(1972, P.64,65)).
         (SINSER,COSSER,FOUSER,FOUSER2)
     A MODIFICATION OF THE IDEA OF NEWBERY IS NOT IMPLEMENTED BECAUSE
     OF THE INTRODUCTION OF SINE (COSINE) TERMS IN A COSINE (SINE)
     SERIES AND THE INEFFICIENCY OF THE ALGORITHM (SEE VAN DER
     LAAN OR NEWBERY(1973)).
 
     FOR THE EVALUATION OF A FINITE COMPLEX FOURIER SERIES
     FN(THETA)=AR[0]+I*AI[0]+(AR[1]+I*AI[1])*EXP(I*THETA)+...
               +(AR[N]+I*AI[N])*EXP(I*THETA)**N,
     TWO ALGORITHMS, IN REAL ARITHMETIC, ARE USED:
     1. HORNER SCHEME
        LET C[K]=AR[K]+I*AI[K], K=0,...,N
        AND Z=EXP(I*THETA)
        THEN
            FN(THETA)=C[0]+C[1]*Z+...+C[N]*Z**N.
        THE ALGORITHM IS GIVEN BY
            P:=C[N]
            P:=P*Z+C[K], K=N-1,N-2,...,0
            FN(THETA):=P.
        (COMFOUSER1)
     2. A COMBINATION OF THE CLENSHAW ALGORITHM AND THE MODIFICATION OF
        REINSCH.
        LET CAR=AR[0]+AR[1]*COS(THETA)+...+AR[N]*COS(N*THETA),
            SAI=      AI[1]*SIN(THETA)+...+AI[N]*SIN(N*THETA),
            SAR=      AR[1]*SIN(THETA)+...+AR[N]*SIN(N*THETA),
            CAI=AI[0]+AI[1]*COS(THETA)+...+AI[N]*COS(N*THETA)
        THEN FN(THETA)=CAR-SAI+I*(SAR+CAI).
        (COMFOUSER,COMFOUSER2)
     THE HORNER SCHEME IS IMPLEMENTED BECAUSE OF THE SIMPLICITY OF
     THE ALGORITHM (ALTHOUGH THIS ALGORITHM IS LESS EFFICIENT THAN THE
     GOERTZEL/WATT/CLENSHAW/REINSCH ALGORITHM) AND THE STABLE NATURE
     OF ORTHOGONAL TRANSFORMATIONS.
     A COMBINATION OF THE ALGORITHM OF GOERTZEL/WATT/CLENSHAW AND THE
     MODIFICATION OF REINSCH IS IMPLEMENTED BECAUSE OF THE EFFICIENCY
     OF THE GWC ALGORITHM AND THE STABILITY OF THE MODIFICATION OF
     REINSCH, ESPECIALLY FOR SMALL VALUES OF THE ARGUMENT (MOD. PI).
     AN UPPER BOUND FOR THE ERROR GROWTH IS GIVEN BY A LINEAR FUNCTION
     OF THE DEGREE FOR BOTH (IMPLEMENTED) ALGORITHMS (SEE VAN DER LAAN).
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                     PAGE 11
 
 
 
 REFERENCES:
 
     GENTLEMAN,W.M.(1969):
     AN ERROR ANALYSIS OF GOERTZEL'S(WATT'S) METHOD FOR COMPUTING
     FOURIER COEFFICIENTS.
     COMP.J.,VOL.12,P.160-165.
 
     LAAN,C.G.VAN DER(TO APPEAR):
     ORTHOGONAL POLYNOMIALS IN NUMERICAL ANALYSIS 1.
     ERROR ANALYSIS OF LINEAR TWO-TERM AND THREE-TERM RECURRENCE
     RELATIONS.
 
     LUKE,Y.L.(1969):
     THE SPECIAL FUNCTIONS AND THEIR APPROXIMATIONS.VOL.1.
     ACADEMIC PRESS.
 
     NEWBERY,A.C.R.(1973):
     ERROR ANALYSIS FOR FOURIER SERIES EVALUATION.
     MATH.COMP.,VOL.26,P.923-924.
 
     POLYA,G. AND G.SZEGOE(1971):
     AUFGABEN UND LEHRSAETZE AUS DER ANALYSIS II.
     HEIDELBERGER TASCHENBUECHER 74. SPRINGER.
 
     REINSCH,C.(1967):
     A NOTE ON TRIGONOMETRIC INTERPOLATION.
     BERICHT NR. 6709.
     ABTEILUNG MATHEMATIK DER TECHNISCHEN UNIVERSITAET MUENCHEN.
 
     STOER,J.(1972):
     EINFUEHRUNG IN DIE NUMERISCHE MATHEMATIK 1.
     HEIDELBERGER TASCHENBUECHER 105. SPRINGER.
 
 
 EXAMPLE OF USE:
 
     THE FOURIER SERIES .5+COS(THETA)+SIN(THETA)
     IS EVALUATED FOR THE ARGUMENTS 0,PI/2,PI, BY MEANS OF FOUSER
 
     "BEGIN""REAL"THETA,PI;"ARRAY"A[0:1];
        PI:=ARCTAN(1)*4;A[0]:=.5;A[1]:=1;
        "FOR"THETA:=0,PI/2,PI"DO"
        OUTPUT(61,"("/,B-D.DD")",FOUSER(1,THETA,A))
     "END"
 
      1.50
      1.50
     -0.50
 
1SECTION : 2.2.3.1            (OCTOBER 1974)                     PAGE 12
 
 
 
 SOURCE TEXTS:
 
 "CODE" 31090;
 "REAL""PROCEDURE"SINSER(N,THETA,B);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"B;
 "BEGIN""INTEGER"K;"REAL"C,CC,LAMBDA,H,DUN,UN,UN1;
    C:=COS(THETA);
    "IF"C<-.5"THEN"
    "BEGIN"LAMBDA:= 4*COS(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"DUN:=LAMBDA*UN-DUN+B[K] ;
                  UN:=DUN-UN;
           "END"
    "END""ELSE""IF"C> .5"THEN"
    "BEGIN"LAMBDA:=-4*SIN(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"DUN:=LAMBDA*UN+DUN+B[K] ;
                  UN:=DUN+UN;
           "END"
    "END""ELSE"
    "BEGIN"CC:=C+C;UN:=UN1:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"H:=CC*UN-UN1+B[K]; UN1 := UN; UN := H; "END"
    "END";
    SINSER:=UN*SIN(THETA)
 "END"SINSER;
         "EOP"
 
 "CODE" 31091;
 "REAL""PROCEDURE"COSSER(N,THETA,A);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A;
 "BEGIN""INTEGER"K;"REAL"C,CC,LAMBDA,H,DUN,UN,UN1;
    C:=COS(THETA);
    "IF"C<-.5"THEN"
    "BEGIN"LAMBDA:= 4*COS(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN-UN;
                  DUN:=LAMBDA*UN-DUN+A[K]
           "END";COSSER:=DUN-LAMBDA/2*UN
    "END""ELSE""IF"C> .5"THEN"
    "BEGIN"LAMBDA:=-4*SIN(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN+UN;
                  DUN:=LAMBDA*UN+DUN+A[K]
           "END";COSSER:=DUN-LAMBDA/2*UN
    "END""ELSE"
    "BEGIN"CC:=C+C;UN:=UN1:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"H:=CC*UN-UN1+A[K];
                  UN1:=UN;UN:=H
           "END";COSSER:=A[0]+UN*C-UN1
    "END"
 "END"COSSER
1SECTION : 2.2.3.1            (OCTOBER 1974)                     PAGE 13
 
 
                                                                  ;
         "EOP"
 "CODE" 31092;
 "REAL""PROCEDURE"FOUSER (N,THETA,A);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A;
 "BEGIN""INTEGER"K;"REAL"C,CC,LAMBDA,H,DUN,UN,UN1,C2,S2;
    C:=COS(THETA);
    "IF"C<-.5"THEN"
    "BEGIN"C2:=COS(THETA/2);LAMBDA:=4*C2**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN-UN;
                  DUN:=LAMBDA*UN-DUN+A[K]
           "END";FOUSER :=DUN+2*C2*(SIN(THETA/2)-C2)*UN
    "END""ELSE""IF"C> .5"THEN"
    "BEGIN"S2:=SIN(THETA/2);LAMBDA:=-4*S2*S2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN+UN;
                  DUN:=LAMBDA*UN+DUN+A[K]
           "END";FOUSER :=DUN+2*S2*(S2+COS(THETA/2))*UN
    "END""ELSE"
    "BEGIN"CC:=C+C;UN:=UN1:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"H:=CC*UN-UN1+A[K];
                  UN1:=UN;UN:=H
           "END";FOUSER :=A[0]-UN1+(C+SIN(THETA))*UN
    "END"
 "END"FOUSER;
         "EOP"
 
 "CODE" 31093;
 "REAL""PROCEDURE" FOUSER1(N,THETA,A,B);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A,B;
 "BEGIN""INTEGER"I;"REAL"R,S,H,CO,SI;
    R:=S:=0;CO:=COS(THETA);SI:=SIN(THETA);
    "FOR"I:=N"STEP"-1"UNTIL"1"DO"
    "BEGIN" H:=CO*R+SI*S+A[I];
            S:=CO*S-SI*R+B[I];
            R:=H
    "END";FOUSER1:=CO*R+SI*S+A[0]
 "END"FOUSER1;
         "EOP"
 
 "CODE" 31094;
 "REAL""PROCEDURE"FOUSER2(N,THETA,A,B);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA;"ARRAY"A,B;
 "BEGIN"
    FOUSER2:=COSSER(N,THETA,A)+SINSER(N,THETA,B);
 "END"FOUSER2
1SECTION : 2.2.3.1            (OCTOBER 1974)                     PAGE 14
 
 
                                                                  ;
         "EOP"
 "CODE" 31095;
 "PROCEDURE"COMFOUSER(N,THETA,A,RR,RI);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"A;
 "BEGIN""INTEGER"K;"REAL"C,CC,LAMBDA,H,DUN,UN,UN1;
    C:=COS(THETA);
    "IF"C<-.5"THEN"
    "BEGIN"LAMBDA:= 4*COS(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN-UN;
                  DUN:=LAMBDA*UN-DUN+A[K]
           "END";RR    :=DUN-LAMBDA/2*UN
    "END""ELSE""IF"C> .5"THEN"
    "BEGIN"LAMBDA:=-4*SIN(THETA/2)**2;UN:=DUN:=0;
           "FOR"K:=N"STEP"-1"UNTIL"0"DO"
           "BEGIN"UN:=DUN+UN;
                  DUN:=LAMBDA*UN+DUN+A[K]
           "END";RR    :=DUN-LAMBDA/2*UN
    "END""ELSE"
    "BEGIN"CC:=C+C;UN:=UN1:=0;
           "FOR"K:=N"STEP"-1"UNTIL"1"DO"
           "BEGIN"H:=CC*UN-UN1+A[K];
                  UN1:=UN;UN:=H
           "END";RR    :=A[0]+UN*C-UN1
    "END";RI:=UN*SIN(THETA)
 "END"COMFOUSER;
         "EOP"
 
 "CODE" 31096;
 "PROCEDURE"COMFOUSER1(N,THETA,AR,AI,RR,RI);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"AR,AI;
 "BEGIN""INTEGER"K;"REAL"H,HR,HI,CO,SI;
    HR:=HI:=0;CO:=COS(THETA);SI:=SIN(THETA);
    "FOR"K:=N"STEP"-1"UNTIL"1"DO"
    "BEGIN"H:=CO*HR-SI*HI+AR[K];
          HI:=CO*HI+SI*HR+AI[K];
          HR:=H
    "END";
    RR:=CO*HR-SI*HI+AR[0];
    RI:=CO*HI+SI*HR+AI[0]
 "END"COMFOUSER1;
         "EOP"
 
 "CODE" 31097;
 "PROCEDURE"COMFOUSER2(N,THETA,AR,AI,RR,RI);
 "VALUE"N,THETA;"INTEGER"N;"REAL"THETA,RR,RI;"ARRAY"AR,AI;
 "BEGIN""REAL"CAR,CAI,SAR,SAI;
    COMFOUSER(N,THETA,AR,CAR,SAR);
    COMFOUSER(N,THETA,AI,CAI,SAI);
    RR:=CAR-SAI;
    RI:=CAI+SAR
 "END"COMFOUSER2;
         "EOP"
1SECTION: 2.3                 (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR   : H.FIOLET
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731105.
 
 
 BRIEF DESCRIPTION:
 
     JFRAC CALCULATES A TERMINATING CONTINUED FRACTION.
 
 
 KEYWORDS:
 
     CONTINUED FRACTION,
     TERMINATING CONTINUED FRACTION.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE READS:
     "REAL" "PROCEDURE" JFRAC(N,A,B);
     "VALUE" N;"INTEGER" N;"ARRAY" A,B;
     "CODE" 35083;
 
     JFRAC DELIVERS THE VALUE OF THE TERMINATING CONTINUED FRACTION:
     B[0]+A[1]/(B[1]+A[2]/(B[2]+A[3]/(B[3]+ . . . + A[N]/B[N])))...))
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:         <ARITHMETIC EXPRESSION>;
                THE UPPER INDEX OF THE ARRAYS A AND B;
     A,B:       <ARRAY IDENTIFIER>;
                "ARRAY" A[1:N];
                "ARRAY" B[0:N];
                THE ELEMENTS OF THE CONTINUED FRACTION:
                B[0]+A[1]/(B[1]+A[2]/(B[2]+A[3]/(B[3]+ . . . +
                + A[N]/B[N])))...)).
 
 
 PROCEDURES USED: NONE.
 
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 
 
1SECTION: 2.3                 (MAY 1974)                          PAGE 2
 
 
 
 EXAMPLE OF USE:
 
     "BEGIN"
     "REAL" "ARRAY" P[1:10],Q[0:10];
     "INTEGER" I;
     "FOR" I:=1 "STEP" 1 "UNTIL" 10 "DO"
     "BEGIN" P[I]:=1;Q[I]:=2 "END";
     Q[0]:=1;
     "FOR" I:=7 "STEP" 1 "UNTIL" 10 "DO"
     OUTPUT(61,"("N/")",JFRAC(I,P,Q))
     "END"
 
     DELIVERS:
 
     +1.4142156862745"+000
     +1.4142131979695"+000
     +1.4142136248949"+000
     +1.4142135516461"+000     .
 
 
 SOURCE TEXT:
 
 "CODE" 35083;
     "REAL" "PROCEDURE" JFRAC(N,A,B);
     "VALUE" N;"INTEGER" N;"ARRAY" A,B;
     "BEGIN" "REAL" D;"INTEGER" I;
         D:=0;
         "FOR" I:=N "STEP" -1 "UNTIL" 1 "DO" D:=A[I]/(B[I]+D);
         JFRAC:=D+B[0]
     "END" JFRAC;
         "EOP"
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  1
 
 
 
 AUTHOR:       C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS: C.G. VAN DER LAAN, M. VOORINTHOLT.
 
 
 INSTITUTE:    REKENCENTRUM DER RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED:     780601.
 
 
 BRIEF DESCRIPTION:
 
     WE CONSIDER THE REPRESENTATIONS
                                          N
             POWER SUM                :  SUM A[K]*X**K,
                                         K=0
                                          N
             CHEBYSHEV SUM            :  SUM A[K]*T[K](X),
                                         K=0
                                          N
             SHIFTED CHEBYSHEV SUM    :  SUM A[K]*T'[K](X),
                                         K=0
                                          N           K-1
             NEWTON SUM               :  SUM (A[K] * PROD (X-X[J])).
                                         K=0          J=0
 
     THE SHIFTED CHEBYSHEV POLYNOMIAL T'[N] IS
     DEFINED BY  T'[N](X) = T[N](2*X-1).
 
 
     THIS SECTION CONTAINS THE TRANSFORMATIONS:
 
     PROCEDURE NAME :  TRANSFORMATION
     ---------------:------------------------------------------------
        POLCHS      :  POWER SUM INTO CHEBYSHEV SUM
        CHSPOL      :  CHEBYSHEV SUM INTO POWER SUM
        POLSHTCHS   :  POWER SUM INTO SHIFTED CHEBYSHEV SUM
        SHTCHSPOL   :  SHIFTED CHEBYSHEV SUM INTO POWER SUM
        GRNNEW      :  POWER SUM INTO NEWTON SUM
        NEWGRN      :  NEWTON SUM INTO POWER SUM
        LINTFMPOL   :  POWER SUM IN X INTO POWER SUM IN Y, X=P*Y+Q
 
 
 KEYWORDS:
 
     TRANSFORMATION OF POLYNOMIAL REPRESENTATION.
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  2
 
 
 
 RUNNING TIME:  PROPORTIONAL TO THE SQUARED DEGREE OF THE POLYNOMIAL.
 
 METHOD AND PERFORMANCE:
 
     ALTHOUGH THE TRANSFORMATION OF REPRESENTATIONS OF POLYNOMIALS
     COULD HAVE BEEN OBTAINED BY FAST EVALUATION AND FAST INTERPOLATION
     WE IMPLEMENTED THE ALGORITHM OF HAMMING (1973, 474,475), BECAUSE
     OF ITS SIMPLE APPEARANCE. AN EXPLANATION OF THE HAMMING ALGORITHM
     IS GIVEN IN VAN DER LAAN (1977,224-229).
 
 
 REFERENCES:
 
     HAMMING, R.W. (1973):
        NUMERICAL METHODS FOR SCIENTISTS AND ENGINEERS.
        MCGRAW-HILL.
     LAAN, C.G. VAN DER (1977):
        APPROXIMATIE VAN FUNCTIES EN DATA.
        IN: RIELE, H.J.J. TE (ED.);
            COLLOQUIUM NUMERIEKE PROGRAMMATUUR, DEEL 2,
            MC SYLLABUS 29.2, MATHEMATISCH CENTRUM AMSTERDAM.
 
 
 SUBSECTION: POLCHS.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" POLCHS(N,A);
     "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 31051;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE POWER SUM;
             EXIT:  THE COEFFICIENTS OF THE CHEBYSHEV SUM;
 
 
 PROCEDURES USED: NONE.
 
 
 EXAMPLE OF USE: SEE NEXT SUBSECTION.
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  3
 
 
 
 SUBSECTION: CHSPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" CHSPOL(N,A);
     "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 31052;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE CHEBYSHEV SUM;
             EXIT:  THE COEFFICIENTS OF THE POWER SUM;
 
 
 PROCEDURES USED: NONE.
 
 
 EXAMPLE OF USE:
 
     AS AN EXAMPLE WE TRANSFORMED
             THE POWER SUM:  1 + 2*X + 3*X**2
     INTO
             ITS CHEBYSHEV SUM;
     AS A CHECK WE TRANSFORMED THE LATTER REPRESENTATION
     BACK INTO THE ORIGINAL POWER SUM.
 
     "BEGIN"
         "ARRAY" A[0:2];
         A[0]:=1; A[1]:=2; A[2]:=3;
         OUTPUT(61,"("/,16B,"("A[0]")",4B,"("A[1]")",4B,"("A[2]")"")");
         OUTPUT(61,"("/,"(" INPUT")",5B,"(":")",3(2B,+ZD.DD)")",A);
         POLCHS(2,A);
         OUTPUT(61,"("/,"(" POLCHS")",4B,"(":")",3(2B,+ZD.DD)")",A);
         CHSPOL(2,A);
         OUTPUT(61,"("/,"(" CHSPOL")",4B,"(":")",3(2B,+ZD.DD)")",A);
     "END" PROGRAM
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  4
 
 
 
                    A[0]    A[1]    A[2]
     INPUT     :   +1.00   +2.00   +3.00
     POLCHS    :   +2.50   +2.00   +1.50
     CHSPOL    :   +1.00   +2.00   +3.00
 
 
 
 SUBSECTION: POLSHTCHS.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" POLSHTCHS(N,A);
     "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 31053;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE POWER SUM;
             EXIT:  THE COEFFICIENTS OF THE SHIFTED CHEBYSHEV SUM;
 
 
 PROCEDURES USED: LINTFMPOL = CP31250,
                 POLCHS    = CP31051.
 
 
 EXAMPLE OF USE: SEE NEXT SUBSECTION.
 
 
 SUBSECTION: SHTCHSPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" SHTCHSPOL(N,A);
     "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 31054;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE SHIFTED CHEBYSHEV SUM;
             EXIT:  THE COEFFICIENTS OF THE POWER SUM.
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  5
 
 
 
 PROCEDURES USED: LINTFMPOL = CP31250,
                 CHSPOL    = CP31052.
 
 EXAMPLE OF USE:
 
     AS AN EXAMPLE WE TRANSFORMED
             THE POWER SUM:  1 + 2*X + 3*X**2
     INTO
             ITS SHIFTED CHEBYSHEV SUM;
     AS A CHECK WE TRANSFORMED THE LATTER REPRESENTATION
     BACK INTO THE ORIGINAL POWER SUM.
 
     "BEGIN"
         "ARRAY" A[0:2];
         A[0]:=1; A[1]:=2; A[2]:=3;
         OUTPUT(61,"("/,16B,"("A[0]")",4B,"("A[1]")",4B,"("A[2]")"")");
         OUTPUT(61,"("/,"(" INPUT")",5B,"(":")",3(2B,+ZD.DD)")",A);
         POLSHTCHS(2,A);
         OUTPUT(61,"("/,"(" POLSHTCHS")",B,"(":")",3(2B,+ZD.DD)")",A);
         SHTCHSPOL(2,A);
         OUTPUT(61,"("/,"(" SHTCHSPOL")",B,"(":")",3(2B,+ZD.DD)")",A);
     "END" PROGRAM
 
                    A[0]    A[1]    A[2]
     INPUT     :   +1.00   +2.00   +3.00
     POLSHTCHS :   +3.13   +2.50   +0.38
     SHTCHSPOL :   +1.00   +2.00   +3.00
 
 
 SUBSECTION: GRNNEW.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" GRNNEW(N,X,A);
     "VALUE" N; "INTEGER" N; "ARRAY" X,A;
     "CODE" 31055;
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  6
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[0:N-1];
             ENTRY: THE INTERPOLATION POINTS;
     A:      <ARRAY IDENTIFIER>;
             ENTRY: THE COEFFICIENTS OF THE POWER SUM;
             EXIT:  THE COEFFICIENTS OF THE NEWTON SUM;
 
 
 PROCEDURES USED: NONE.
 
 
 EXAMPLE OF USE: SEE NEXT SUBSECTION.
 
 
 
 SUBSECTION: NEWGRN.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" NEWGRN(N,X,A);
     "VALUE" N; "INTEGER" N; "ARRAY" X,A;
     "CODE" 31050;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[0:N-1];
             ENTRY: THE INTERPOLATION POINTS;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE NEWTON SUM;
             EXIT:  THE COEFFICIENTS OF THE POWER SUM;
 
 
 PROCEDURES USED : ELMVEC    = CP34020.
 
 
 EXAMPLE OF USE:
 
     AS AN EXAMPLE WE TRANSFORMED
             THE POWER SUM:  1 + 2*X + 3*X**2
     INTO
             ITS NEWTON SUM WITH
             INTERPOLATION POINTS: X[0]:=1.0, X[1]:=2.0;
     AS A CHECK WE TRANSFORMED THE LATTER REPRESENTATION
     BACK INTO THE ORIGINAL POWER SUM.
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  7
 
 
 
     "BEGIN"
         "ARRAY" X[0:1], A[0:2];
         A[0]:=1; A[1]:=2; A[2]:=3;
         X[0]:=1; X[1]:=2;
         OUTPUT(61,"("/,16B,"("A[0]")",4B,"("A[1]")",4B,"("A[2]")"")");
         OUTPUT(61,"("/,"(" INPUT")",5B,"(":")",3(2B,+ZD.DD)")",A);
         GRNNEW(2,X,A);
         OUTPUT(61,"("/,"(" GRNNEW")",4B,"(":")",3(2B,+ZD.DD)")",A);
         NEWGRN(2,X,A);
         OUTPUT(61,"("/,"(" NEWGRN")",4B,"(":")",3(2B,+ZD.DD)")",A);
     "END" PROGRAM
 
                    A[0]    A[1]    A[2]
     INPUT     :   +1.00   +2.00   +3.00
     GRNNEW    :   +6.00  +11.00   +3.00
     NEWGRN    :   +1.00   +2.00   +3.00
 
 
 
 SUBSECTION: LINTFMPOL.
 
 
 CALLING SEQUENCE:
 
     THE DECLARATION OF THE PROCEDURE IN THE CALLING PROGRAM READS:
     "PROCEDURE" LINTFMPOL(P,Q,N,A); "VALUE" N,P,Q;
     "INTEGER" N; "REAL" P,Q; "ARRAY" A;
     "CODE" 31250;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             ENTRY: THE DEGREE OF THE POLYNOMIAL;
     P,Q:    <ARITHMETIC EXPRESSION>;
             ENTRY: DEFINING THE LINEAR TRANSFORMATION OF
                    THE INDEPENDENT VARIABLE X=P*Y+Q;
                    (P=0 GIVES THE VALUE OF THE POLYNOMIAL
                     WITH ARGUMENT Q.)
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[0:N];
             ENTRY: THE COEFFICIENTS OF THE POWER SUM IN X;
             EXIT:  THE COEFFICIENTS OF THE POWER SUM IN Y;
 
 
 PROCEDURES USED: NORDERPOL  = CP31242.
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  8
 
 
 
 EXAMPLE OF USE:
 
     AS AN EXAMPLE WE TRANSFORMED
             THE POWER SUM:  1 + 2*X + 3*X**2
     INTO
             ITS POWER SUM IN Y WITH
             X = 2*Y + 3;
     AS A CHECK WE TRANSFORMED THE LATTER REPRESENTATION
     BACK INTO THE ORIGINAL POWER SUM.
 
     "BEGIN"
         "ARRAY" A[0:2];
         A[0]:=1; A[1]:=2; A[2]:=3;
         OUTPUT(61,"("/,16B,"("A[0]")",4B,"("A[1]")",4B,"("A[2]")"")");
         OUTPUT(61,"("/,"(" INPUT")",5B,"(":")",3(2B,+ZD.DD)")",A);
         LINTFMPOL(2,3,2,A);
         OUTPUT(61,"("/,"(" LINTFMPOL")",B,"(":")",3(2B,+ZD.DD)")",A);
         LINTFMPOL(1/2,-3/2,2,A);
         OUTPUT(61,"("/,"(" LINTFMPOL")",B,"(":")",3(2B,+ZD.DD)")",A);
     "END" PROGRAM
 
                    A[0]    A[1]    A[2]
     INPUT     :   +1.00   +2.00   +3.00
     LINTFMPOL :  +34.00  +40.00  +12.00   (POWER SUM IN Y)
     LINTFMPOL :   +1.00   +2.00   +3.00   (POWER SUM IN X)
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE  9
 
 
 
 SOURCE TEXTS:
 
 "CODE" 31051;
 "PROCEDURE" POLCHS(N,A);
 "VALUE" N; "INTEGER" N; "ARRAY" A;
 "IF" N>1 "THEN"
 "BEGIN"
    "COMMENT"  SCALING;
    "INTEGER" K,L,TWOPOW;
    TWOPOW:=2;
    "FOR" K:=1 "STEP" 1 "UNTIL" N-2 "DO"
    "BEGIN"
       A[K]:=A[K]/TWOPOW; TWOPOW:=TWOPOW*2;
    "END";
    A[N-1]:=2*A[N-1]/TWOPOW;
    A[N]:=A[N]/TWOPOW;
    A[N-2]:=A[N-2]+A[N];
    "COMMENT" N<=2 READY;
    "FOR" K:=N-2 "STEP" -1 "UNTIL" 1 "DO"
    "BEGIN"
       A[K-1]:=A[K-1]+A[K+1]; A[K]:=A[K]*2 + A[K+2];
       "FOR" L:=K+1 "STEP" 1 "UNTIL" N-2 "DO"
       A[L]:=A[L]+A[L+2];
    "END";
 "END" POLCHS;
         "EOP"
 
 
 
 "CODE" 31052;
 "PROCEDURE" CHSPOL(N,A);
 "VALUE" N; "INTEGER" N; "ARRAY" A;
 "IF" N>1 "THEN"
 "BEGIN"
     "INTEGER" K,L,TWOPOW;
     "FOR" K:=0 "STEP" 1 "UNTIL" N-2 "DO"
     "BEGIN"
         "FOR" L:=N-2 "STEP" -1 "UNTIL" K "DO"
         A[L]:=A[L]-A[L+2]; A[K+1]:=A[K+1]/2;
     "END";
     TWOPOW:=2;
     "FOR" K:=1 "STEP" 1 "UNTIL" N-2 "DO"
     "BEGIN"
         A[K]:=A[K]*TWOPOW; TWOPOW:=TWOPOW*2;
     "END";
     A[N-1]:=TWOPOW*A[N-1];
     A[N]:=TWOPOW*A[N];
 "END" CHSPOL
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE 10
 
 
                                                                  ;
         "EOP"
 "CODE" 31053;
 "PROCEDURE" POLSHTCHS(N,A);
 "VALUE" N; "INTEGER" N; "ARRAY" A;
 "BEGIN"
     LINTFMPOL(.5,.5,N,A);
     POLCHS(N,A);
 "END" POLSHTCHS;
         "EOP"
 
 
 
 "CODE" 31054;
 "PROCEDURE" SHTCHSPOL(N,A);
 "VALUE" N; "INTEGER" N; "ARRAY" A;
 "BEGIN"
     CHSPOL(N,A);
     LINTFMPOL(2,-1,N,A);
 "END" SHTCHSPOL;
         "EOP"
 
 
 
 "CODE" 31055;
 "PROCEDURE" GRNNEW(N,X,A);
 "VALUE" N; "INTEGER" N; "ARRAY" X,A;
 "BEGIN"
     "PROCEDURE" ELMCEV(L,U,SHIFT,A,B,X);
     "VALUE" L,U,SHIFT,X; "INTEGER" L,U,SHIFT;
     "REAL" X; "ARRAY" A,B;
     "FOR" L:=L "STEP" -1 "UNTIL" U "DO" A[L]:=A[L]+B[L+SHIFT]*X;
     "INTEGER" K;
     "FOR" K:=N-1 "STEP" -1 "UNTIL" 0 "DO"
     ELMCEV(N-1,N-1-K,1,A,A,X[N-1-K]);
 "END" GRNNEW
1SECTION : 2.4.1             (DECEMBER 1978)                     PAGE 11
 
 
                                                                  ;
         "EOP"
 "CODE" 31050;
 "PROCEDURE" NEWGRN(N,X,A);
 "VALUE" N; "INTEGER" N; "ARRAY" X,A;
 "BEGIN"
     "INTEGER" K;
     "FOR" K:=N-1 "STEP" -1 "UNTIL" 0 "DO"
     ELMVEC(K,N-1,1,A,A,-X[K]);
 "END" NEWGRN;
         "EOP"
 
 
 
 "CODE" 31250;
 "PROCEDURE" LINTFMPOL(P,Q,N,A);
 "VALUE" N,P,Q; "INTEGER" N; "REAL" P,Q; "ARRAY" A;
 "BEGIN"
     "INTEGER" K;
     "REAL" PPOWER;
     NORDERPOL(N,N,Q,A);
     PPOWER:=P;
     "FOR" K:=1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN"
         A[K]:=PPOWER*A[K];
         PPOWER:=P*PPOWER;
     "END";
 "END" LINTFMPOL;
         "EOP"
1SECTION : 2.4.3              (OCTOBER 1974)                      PAGE 1
 
 
 AUTHOR : C.G. VAN DER LAAN.
 
 
 INSTITUTE : RIJKSUNIVERSITEIT GRONINGEN.
 
 
 RECEIVED : 740131.
 
 
 BRIEF DESCRIPTION :
 
     INTCHS COMPUTES THE INDEFINITE INTEGRAL OF A GIVEN CHEBYSHEV
     SERIES.
 
 
 KEYWORDS :
 
     INDEFINITE INTEGRATION,
     CHEBYSHEV SERIES.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE"INTCHS(N,A,B);
     "VALUE"N;"INTEGER"N;"ARRAY"A,B;
     "CODE" 31248;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     N  : <ARITHMETIC EXPRESSION>;
          ENTRY:
          THE DEGREE OF THE POLYNOMIAL REPRESENTED BY THE CHEBYSHEV
          SERIES;
     A,B: <ARRAY IDENTIFIER>;
          "ARRAY" A[0:N],B[1:N+1];
          ENTRY:
          THE COEFFICIENTS OF THE CHEBYSHEV SERIES,A[0]+A[1]*T1(X)+...+
          +A[N]*TN(X),SHOULD BE GIVEN IN ARRAY A.
          EXIT:
          THE COEFFICIENTS OF THE INTEGRAL CHEBYSHEV SERIES,
          B[1]*T1(X)+...+B[N+1]*TN+1(X), ARE DELIVERED IN ARRAY B.
          (T1(X),...TN+1(X) DENOTE CHEBYSHEV POLYNOMIALS OF THE FIRST
          KIND,OF DEGREE 1,...N+1,RESPECTIVELY).
 
 
1SECTION : 2.4.3              (OCTOBER 1974)                      PAGE 2
 
 
 
 METHOD AND PERFORMANCE :
 
     FOR A DESCRIPTION OF THE ALGORITHM SEE AMONG OTHERS :
     CLENSHAW,1962,P.11,OR FOX AND PARKER,1968,P.59.
 
 
 REFERENCES :
 
     BROUCKE,R.(1973):
     TEN SUBROUTINES FOR THE MANIPULATION OF CHEBYSHEV SERIES.
     ALGORITHM 446.(FORTRAN).
     COMM.ACM,VOL.16,1,P.254-256.
 
     CLENSHAW,C.W.(1962):
     CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS.
     MATH.TAB.NAT.PHYS.LAB. 5,LONDON.
     H.M. STATIONARY OFFICE.
 
     FOX,L.&I.B.PARKER(1968):
     CHEBYSHEV POLYNOMIALS IN NUMERICAL ANALYSIS.
     OXFORD UNIVERSITY PRESS.
 
 
 EXAMPLE OF USE :
 
     AS A FORMAL TEST OF THE PROCEDURE INTCHS THE CHEBYSHEV SERIES :
     1+1/2*T1(X)+1/5*T2(X)+1/10*T3(X) IS TRANSFORMED INTO ITS INTEGRAL.
 
     "BEGIN""ARRAY"A[0:3],B[1:4];
        A[0]:=1;A[1]:=.5;A[2]:=.2;A[3]:="-1;
        INTCHS(3,A,B);
        OUTPUT(61,"("/,4(BZ.4D)")",B[1],B[2],B[3],B[4]);
     "END"
 
 
   .9000  .1000  .0333  .0125
1SECTION : 2.4.3              (OCTOBER 1974)                      PAGE 3
 
 
 
 SOURCE TEXT(S):
 
 "CODE"31248;
 "PROCEDURE"INTCHS(N,A,B);
 "VALUE"N;"INTEGER"N;"ARRAY"A,B;
 "COMMENT"
     INTCHS DELIVERS THE COEFFICIENTS B[I],I=1,...N+1, OF THE INTEGRAL
     CHEBYSHEV SERIES B[1]*T1(X)+...+B[N]*TN(X)+B[N+1]*TN+1(X).
     THESE COEFFICIENTS ARE OBTAINED BY MEANS OF INDEFINITE INTEGRATION
     OF THE CHEBYSHEV SERIES A[0]+A[1]*T1(X)+...+A[N]*TN(X).
     T1(X),...TN+1(X) DENOTE CHEBYSHEV POLYNOMIALS OF THE FIRST KIND,
     OF DEGREE 1,...N+1,RESPECTIVELY;
 "IF"N=0"THEN"B[1]:=A[0]
 "ELSE""IF"N=1"THEN""BEGIN"B[2]:=A[1]/4;B[1]:=A[0]"END"
       "ELSE""BEGIN""INTEGER"I;"REAL"H,L,DUM;
          H:=A[N];DUM:=A[N-1];B[N+1]:=H/((N+1)*2);B[N]:=DUM/(N*2);
          "FOR"I:=N-1"STEP"-1"UNTIL"2"DO"
          "BEGIN"L:=A[I-1];B[I]:=(L-H)/(2*I);H:=DUM;DUM:=L
          "END";B[1]:=A[0]-H/2
       "END"INTCHS;
         "EOP"
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 1
 
 
 
 AUTHORS: J. C. P. BUS AND T. J. DEKKER.
 
 
 CONTRIBUTOR: J.C.P. BUS AND P. A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730830.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION  CONTAINS  SIX  PROCEDURES:
     A: DEC PERFORMS A TRIANGULAR DECOMPOSITION WITH PARTIAL PIVOTING;
     B: GSSELM PERFORMS A TRIANGULAR DECOMPOSITION WITH A COMBINATION OF
        PARTIAL AND COMPLETE PIVOTING;
     C: ONENRMINV DELIVERS THE 1-NORM OF THE INVERSE OF A MATRIX WHOSE
       TRIANGULARLY DECOMPOSED FORM HAS BEEN DELIVERED BY DEC OR GSSELM;
     D:ERBELM CALCULATES A ROUGH UPPERBOUND FOR THE SOLUTION OF A LINEAR
        SYSTEM WHOSE MATRIX IS TRIANGULARLY DECOMPOSED BY GSSELM;
     E: GSSERB PERFORMS A TRIANGULAR DECOMPOSTION OF THE MATRIX OF A
       LINEAR SYSTEM AND CALCULATES AN UPPERBOUND FOR THE RELATIVE ERROR
        OF THE SOLUTION OF THAT SYSTEM;
     F: GSSNRI PERFORMS A TRIANGULAR DECOMPOSITION AND CALCULATES THE
        1-NORM OF THE INVERSE MATRIX;
 
     THE METHOD USED IN DEC AND GSSELM YIELDS A LOWER-TRIANGULAR MATRIX
     L AND A UNIT UPPER-TRIANGULAR MATRIX U SUCH THAT THE PRODUCT
     LU EQUALS THE GIVEN MATRIX WITH PERMUTED ROWS (DEC) OR ROWS AND
     COLUMNS (GSSELM); IN DEC, ONLY PARTIAL PIVOTING IS USED ([3],
     [4, P.115], [5, P.201]); THE PIVOTING STRATEGY IN GSSELM IS
     A COMBINATION OF PARTIAL AND COMPLETE PIVOTING ([2], [1]); IN THIS
     STRATEGY THE PROCESS WILL SWITCH TO COMPLETE PIVOTING IF PARTIAL
     PIVOTING MIGHT NOT YIELD STABLE RESULTS; SO IN GSSELM THE
     EFFICIENCY OF PARTIAL PIVOTING IS COMBINED WITH THE STABILITY OF
     COMPLETE PIVOTING;
     SINCE, IN EXCEPTIONAL CASES, PARTIAL PIVOTING MAY YIELD USELESS
     RESULTS, EVEN FOR WELL-CONDITIONED MATRICES, THE USER IS ADVISED TO
     USE GSSELM; HOWEVER, IF THE NUMBER OF VARIABLES IS SMALL RELATIVE
     TO THE NUMBER OF BINARY DIGITS IN THE MANTISSA (48 FOR THE CYBER ),
     THEN DEC MAY ALSO BE USED;
 
 
 KEYWORDS:
 
     LU DECOMPOSITION,
     TRIANGULAR DECOMPOSITION,
     GAUSSIAN ELIMINATION.
 
 
 
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 2
 
 
 
 SUBSECTION: DEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DEC(A, N, AUX, P); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX; "INTEGER" "ARRAY" P;"CODE" 34300;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE MATRIX;
             EXIT:THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH ITS  UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:3];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS AN ESTIMATE  OF THE RELATIVE PRECISION OF
                     THE  MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION; SEE
                     METHOD AND PERFORMANCE;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS  1   IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX OF  ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N THEN THE PROCESS IS BROKEN OFF BECAUSE
                     THE  SELECTED  PIVOT  IS  TOO  SMALL  RELATIVE TO
                     THE MAXIMUM OF THE EUCLIDEAN NORMS OF THE ROWS OF
                     THE GIVEN MATRIX;
     P:      <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" P[1:N];
             EXIT:THE PIVOTAL INDICES.
 
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 3
 
 
 
 PROCEDURES USED:
 
     MATMAT = CP34013,
     MATTAM = CP34015,
     ICHROW = CP34032.
 
 
 REQUIRED CENTRAL MEMORY:
 
     A REAL ARRAY OF ORDER N IS DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN DEC IS TRIANGULAR DECOMPOSITION WITH STABILIZING
     ROW INTERCHANGES, ALSO CALLED "PARTIAL PIVOTING"; SEE ALSO [3,P.19]
     AND [5,P.201].
 
 
 EXAMPLE OF USE: SEE DECSOL (SECTION 3.1.1.1.1.1.3).
 
 
 
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 4
 
 
 
 SUBSECTION: GSSELM   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSELM(A, N, AUX, RI, CI); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX; "INTEGER" "ARRAY" RI, CI;"CODE" 34231;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT:THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH ITS UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:7];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION; SEE
                     METHOD AND PERFORMANCE;
             AUX[4]: A  VALUE  WHICH  IS USED  FOR CONTROLLING PIVOTING;
                     USUALLY, AUX[4] = 8 WILL GIVE GOOD RESULTS; SEE
                     METHOD AND PERFORMANCE;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N THEN THE PROCESS HAS BEEN BROKEN OFF,
                     BECAUSE THE SELECTED PIVOT IS TOO SMALL RELATIVE TO
                     THE MAXIMUM OF THE MODULI OF ELEMENTS OF THE GIVEN
                     MATRIX;
             AUX[5]: THE  MODULUS  OF  AN  ELEMENT  WHICH  IS OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX WHICH HAD BEEN GIVEN
                     IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (I. E. THE MODULUS OF
                     AN ELEMENT  WHICH IS OF MAXIMUM ABSOLUTE VALUE  FOR
                     THE MATRICES OCCURRING DURING ELIMINATION);
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             EXIT: THE PIVOTAL ROW-INDICES;
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             EXIT: THE PIVOTAL COLUMN-INDICES;
 
 
1SECTION: 3.1.1.1.1.1.1       (DECEMBER 1979)                     PAGE 5
 
 
 
 PROCEDURES USED:
 
     ROWCST      = CP31132,
     ELMROW      = CP34024,
     MAXELMROW   = CP34025,
     ICHCOL      = CP34031,
     ICHROW      = CP34032,
     ABSMAXMAT   = CP31069.
 
 REQUIRED CENTRAL MEMORY: NO EXTRA ARRAYS ARE DECLARED.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 METHOD AND PERFORMANCE:
     THE PROCESS OF GAUSSIAN ELIMINATION IS PERFORMED IN AT MOST N STEPS
     , WHERE N DENOTES THE ORDER OF THE MATRIX; PARTIAL PIVOTING WILL BE
     USED AS LONG AS THE CALCULATED UPPER BOUND FOR THE GROWTH ([2],
     [1]), IS LESS THAN A CRITICAL VALUE THAT EQUALS AUX[4] * N TIMES
     THE MODULUS OF AN ELEMENT WHICH IS OF MAXIMUM ABSOLUTE VALUE FOR
     THE GIVEN MATRIX;
     IN THE PARTIAL PIVOTING STRATEGY, THAT ELEMENT IS CHOSEN AS
     PIVOT IN THE K-TH STEP, WHOSE ABSOLUTE VALUE IS MAXIMAL
     FOR THE K-TH COLUMN OF THE LOWER-TRIANGULAR MATRIX L; HOWEVER, IF
     THE UPPER BOUND FOR THE GROWTH EXCEEDS THIS CRITICAL VALUE IN THE
     K-TH STEP, THEN A PIVOT IS SELECTED IN THE J-TH STEP (J = K,..., N)
     , IN SUCH A WAY, THAT ITS ABSOLUTE VALUE IS MAXIMAL FOR THE
     REMAINING SUBMATRIX OF ORDER N - K + 1 (COMPLETE PIVOTING);
     SINCE  IN PRACTICE,  IF WE CHOOSE  AUX[4] PROPERLY, THE UPPER BOUND
     FOR THE GROWTH RARELY EXCEEDS  THIS CRITICAL VALUE  ([2], [4]),  WE
     WILL  USUALLY  TAKE  ADVANTAGE OF THE GREATER SPEED OF PARTIAL
     PIVOTING (ORDER N - K + 1 IN THE K-TH STEP), WHILE IN A FEW
     DOUBTFUL CASES NUMERICAL DIFFICULTIES WILL BE RECOGNIZED AND THE
     PROCESS WILL SWITCH TO COMPLETE PIVOTING (ORDER
     (N - K + 1) ** 2 IN THE K-TH STEP);
     USING GSSELM,THE UPPER BOUND FOR THE RELATIVE ERROR IN THE SOLUTION
     OF A LINEAR SYSTEM ([4], [5]), WILL BE AT MOST AUX[4] * N TIMES THE
     UPPER BOUND USING GAUSSIAN ELIMINATION WITH COMPLETE PIVOTING ONLY;
     USUALLY, HOWEVER, THIS WILL BE A CRUDE OVERESTIMATE;
     THE CHOICE AUX[4] < 1 / N WILL RESULT IN COMPLETE PIVOTING ONLY
     , WHILE  PARTIAL PIVOTING WILL BE USED IN EVERY STEP IF WE CHOOSE
     AUX[4] > (2 ** (N - 1)) / N; USUALLY, AUX[4] = 8 WILL GIVE
     GOOD RESULTS ([2], [1]);
     THE PROCESS WILL ALSO SWITCH TO COMPLETE PIVOTING IF THE MODULUS OF
     THE PIVOT OBTAINED WITH PARTIAL PIVOTING IS LESS THAN A CERTAIN
     TOLERANCE, WHICH EQUALS THE GIVEN RELATIVE TOLERANCE AUX[2] TIMES
     THE MODULUS OF AN ELEMENT WHICH IS OF MAXIMUM ABSOLUTE VALUE FOR
     THE GIVEN MATRIX; IF ALL ELEMENTS IN THE REMAINING SUBMATRIX ARE
     SMALLER IN ABSOLUTE VALUE THAN THIS TOLERANCE THEN THE PROCESS IS
     BROKEN OFF AND THE PREVIOUS STEPNUMBER IS DELIVERED IN AUX[3];
     IN  CONTRAST  WITH  THE  METHOD  USED  IN  DEC  (THIS SECTION),  NO
     EQUILIBRATING IS DONE  IN THIS PIVOTING STRATEGY;  THE USER HIMSELF
     HAS TO TAKE CARE FOR A REASONABLE SCALING OF THE MATRIX ELEMENTS.
 
 
 EXAMPLE OF USE: SEE GSSSOL (SECTION 3.1.1.1.1.1.3).
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 6
 
 
 
 SUBSECTION: ONENRMINV.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS
     "REAL" "PROCEDURE" ONENRMINV(A, N); "VALUE" N;
     "INTEGER" N; "ARRAY" A; "CODE" 34240;
 
     ONENRMINV:= THE  1-NORM  OF THE CALCULATED  INVERSE  OF THE MATRIX,
             WHOSE TRIANGULARLY DECOMPOSED FORM IS GIVEN IN ARRAY A;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:
             THE TRIANGULARLY DECOMPOSED FORM OF A MATRIX,  AS DELIVERED
             BY  GSSELM  OR  DEC  (THIS SECTION);
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER  OF  THE MATRIX,  WHOSE  TRIANGULARLY  DECOMPOSED
             FORM HAS BEEN GIVEN IN ARRAY A.
 
 
 PROCEDURES USED:
 
     MATVEC  = CP34011.
 
 
 REQUIRED CENTRAL MEMORY:
 
     ONE REAL ARRAY OF ORDER N IS DECLARED.
 
 
 RUNNING TIME:   PROPORTIONAL TO N ** 3.
 
 
 METHOD AND PERFORMANCE:
 
     THE INVERSE OF THE MATRIX  WHOSE  TRIANGULARLY DECOMPOSED FORM,  AS
     DELIVERED BY GSSELM OR DEC,HAS BEEN GIVEN IN ARRAY A, IS CALCULATED
     WITH FORWARD AND BACK SUBSTITUTION ([3],[4],[5]);ONLY THE 1-NORM OF
     THIS INVERSE IS DELIVERED BY  ONENRMINV;  THE ELEMENTS  OF ARRAY  A
     REMAIN UNALTERED.
 
 
 EXAMPLE OF USE: SEE GSSSOLERB (SECTION 3.1.1.1.1.1.3).
 
 
 
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 7
 
 
 
 SUBSECTION: ERBELM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" ERBELM(N, AUX, NRMINV); "VALUE" N, NRMINV;
     "INTEGER" N; "REAL" NRMINV; "ARRAY" AUX; "CODE" 34241;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE LINEAR SYSTEM IN CONSIDERATION;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:11];
             ENTRY:
             AUX[0]: THE MACHINE PRECISION;
             AUX[5]: THE MODULUS  OF  AN ELEMENT,  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX OF THE LINEAR SYSTEM;
                     THIS VALUE IS DELIVERED  BY GSSELM  IN AUX[5] (THIS
                     SECTION);
             AUX[6]: AN  UPPER BOUND  FOR  THE  RELATIVE  ERROR  IN  THE
                     ELEMENTS OF THE MATRIX OF THE LINEAR SYSTEM;
             AUX[7]: AN  UPPER BOUND  FOR  THE  GROWTH  DURING  GAUSSIAN
                     ELIMINATION;  THIS VALUE IS DELIVERED IN  AUX[7] BY
                     GSSELM (THIS SECTION);
             EXIT:
             AUX[9]: THE VALUE OF NRMINV;
             AUX[11]: A ROUGH UPPER BOUND  FOR THE RELATIVE ERROR IN THE
                     SOLUTION   OF  A  LINEAR  SYSTEM    WHEN   GAUSSIAN
                     ELIMINATION  IS USED  FOR  THE CALCULATION  OF THIS
                     SOLUTION; IF NO USE CAN BE MADE OF THE FORMULA  FOR
                     THE  ERROR BOUND  (SEE:  METHOD  AND  PERFORMANCE),
                     BECAUSE OF A VERY BAD CONDITION OF THE MATRIX, THEN
                     AUX[11]:= -1;
     NRMINV: <ARITHMETIC EXPRESSION>;
             THE 1-NORM  OF  THE INVERSE  OF THE MATRIX  OF  THE  LINEAR
             SYSTEM MUST BE GIVEN IN NRMINV; THIS VALUE MAY BE OBTAINED
             BY ONENRMINV (THIS SECTION).
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 8
 
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY: NO EXTRA ARAYS ARE DECLARED.
 
 
 METHOD AND PERFORMANCE:
 
     WHEN CALLED AFTER GSSELM, ERBELM WILL CALCULATE A ROUGH UPPER BOUND
     FOR THE RELATIVE ERROR IN THE SOLUTION OF THE LINEAR SYSTEM,  WHOSE
     MATRIX HAS BEEN DECOMPOSED INTO TRIANGULAR FORM BY GSSELM (THIS
     SECTION), BY  ([3], [4], [5]):
             NORM(DX) / NORM(X) <= P / (1 - P),
     WHERE : P = Q * NORM(C) / (1 - Q * NORM(C)),
             Q = G * (.75 * N ** 3 + 4.5 * N ** 2) * EPS + EPSA,
             C IS THE CALCULATED INVERSE OF THE MATRIX,
             G   THE  UPPER  BOUND  FOR   THE  GROWTH   DURING  GAUSSIAN
             ELIMINATION, AS DELIVERED BY GSSELM (THIS SECTION),
             N THE ORDER OF THE MATRIX,
             EPSA  AN UPPER BOUND  FOR  THE RELATIVE ERROR IN THE MATRIX
             ELEMENTS,
             EPS THE MACHINE PRECISION AND
             NORM(.) DENOTES THE 1-NORM.
 
     THIS PROCEDURE IS USED IN E.G. GSSERB (THIS SECTION) AND GSSINVERB
     (SECTION 3.1.1.1.1.1.4)
 
 
 EXAMPLE OF USE: SEE GSSSOLERB (SECTION 3.1.1.1.1.1.3).
 
 
 
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                     PAGE 9
 
 
 
 SUBSECTION: GSSERB    .
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSERB(A, N, AUX, RI, CI); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX; "INTEGER""ARRAY" RI, CI; "CODE" 34242;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE MATRIX TO BE DECOMPOSED;
             EXIT: THE CALCULATED LOWER-TRIANGULAR MATRIX AND UNIT UPPER
             TRIANGULAR MATRIX,WITH ITS UNIT DIAGONAL OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:11];
             ENTRY:(SEE ALSO GSSELM IN THIS SECTION);
             AUX[0]: THE MACHINE PRECISION;
             AUX[2]: A RELATIVE TOLERANCE;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING;
             AUX[6]: AN UPPER BOUND  FOR  THE RELATIVE PRECISION  OF THE
                     MATRIX ELEMENTS;
             EXIT:
             AUX[1]: IF  R IS THE NUMBER OF ELIMINATION STEPS PERFORMED,
                     AUX[1] EQUALS 1 IF THE DETERMINANT OF THE PRINCIPAL
                     SUBMATRIX OF ORDER R IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT,  WHICH  IS OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX WHICH HAS BEEN GIVEN
                     IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH;
             AUX[9]: IF AUX[3] = N, THEN AUX[9] WILL EQUAL THE 1-NORM OF
                     THE INVERSE MATRIX, ELSE AUX[9] WILL BE UNDEFINED;
             AUX[11]: IF AUX[3] = N, THEN THE VALUE OF AUX[11] WILL BE A
                     ROUGH  UPPER BOUND  FOR  THE RELATIVE ERROR  IN THE
                     SOLUTION OF LINEAR SYSTEMS  WITH A MATRIX  AS GIVEN
                     IN ARRAY A, ELSE AUX[11] WILL BE UNDEFINED;  IF  NO
                     USE CAN BE MADE OF THE FORMULA FOR  THE ERROR BOUND
                     AS GIVEN ABOVE (SUBSECTION  ERBELM),  BECAUSE OF  A
                     VERY BAD CONDITION OF THE MATRIX, THEN AUX[11]:=-1;
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             EXIT: THE PIVOTAL ROW-INDICES.
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             EXIT: THE PIVOTAL COLUMN-INDICES.
 
 PROCEDURES USED:
 
     GSSELM      = CP34231,
     ONENRMINV   = CP34240,
     ERBELM      = CP34241.
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                    PAGE 10
 
 
 
 REQUIRED CENTRAL MEMORY: NO EXTRA ARRAYS ARE DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 METHOD AND PERFORMANCE:
 
     GSSERB  USES  GSSELM  (THIS  SECTION)  TO  PERFORM  THE  TRIANGULAR
     DECOMPOSITION  OF THE MATRIX  GIVEN  IN  ARRAY  A  AND  ERBELM  AND
     ONENRMINV  (THIS  SECTION) TO  CALCULATE  AN  UPPER BOUND  FOR  THE
     RELATIVE ERROR IN THE SOLUTION OF LINEAR SYSTEMS  WITH A MATRIX  AS
     GIVEN IN ARRAY  A; IF  AUX[3] < N,  THEN  THE EFFECT OF  GSSERB  IS
     MERELY THAT OF GSSELM.
 
 EXAMPLE OF USE: SEE GSSSOLERB (SECTION 3.1.1.1.1.1.3).
 
 
 
 SUBSECTION: GSSNRI   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSNRI(A, N, AUX, RI, CI); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX; "INTEGER""ARRAY" RI, CI; "CODE" 34252;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE MATRIX TO BE DECOMPOSED;
             EXIT: THE CALCULATED LOWER-TRIANGULAR MATRIX AND UNIT UPPER
             TRIANGULAR MATRIX,WITH ITS DIAGONAL OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:9];
             ENTRY:(SEE ALSO GSSELM IN THIS SECTION);
             AUX[2]: A RELATIVE TOLERANCE;
             AUX[4]: A VALUE USED FOR CONTROLLING PIVOTING;
             EXIT:
             AUX[1]: IF R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED,
                     THEN AUX[1]  EQUALS  1  IF THE DETERMINANT  OF  THE
                     PRINCIPAL SUBMATRIX OF ORDER  R  IS POSITIVE,  ELSE
                     AUX[1] = -1;
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: THE  MODULUS  OF  AN  ELEMENT,  WHICH IS OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX WHICH HAD BEEN GIVEN
                     IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH;
             AUX[9]: IF AUX[3] = N, THEN AUX[9] WIL EQUAL  THE 1-NORM OF
                     THE INVERSE MATRIX, ELSE AUX[9] WILL BE UNDEFINED;
1SECTION: 3.1.1.1.1.1.1       (FEBRUARY 1979)                    PAGE 11
 
 
 
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             EXIT: THE PIVOTAL ROW INDICES.
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             EXIT:THE PIVOTAL COLUMN INDICES.
 
 
 PROCEDURES USED:
 
     GSSELM      = CP34231,
     ONENRMINV   = CP34240.
 
 
 REQUIRED CENTRAL MEMORY: NO EXTRA ARRAYS ARE DECLARED.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 METHOD AND PERFORMANCE:
 
     GSSNRI  USES  GSSELM  (THIS  SECTION)  TO  PERFORM  THE  TRIANGULAR
     DECOMPOSITION OF THE MATRIX GIVEN IN ARRAY  A  AND  ONENRMINV (THIS
     SECTION)  TO  CALCULATE  THE  1-NORM  OF  THE  INVERSE  MATRIX;  IF
     AUX[3] < N,  THEN THE EFFECT OF  GSSNRI  IS  MERELY THAT OF  GSSELM
     (THIS SECTION).
 
 
 EXAMPLE OF USE: SEE GSSITISOLERB (SECTION 3.1.1.1.1.1.5).
 
 
 
 REFERENCES:
 
     [1] BUS, J. C. P.
         LINEAR SYSTEMS  WITH CALCULATION OF ERROR BOUNDS  AND ITERATIVE
         REFINEMENT (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, LR 3. 4. 19 (1972).
     [2] BUSINGER, P. A.
         MONITORING THE NUMERICAL STABILITY OF GAUSSIAN ELIMINATION.
         NUMER. MATH. 16, 360-361 (1971).
     [3] DEKKER, T. J.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
         MATHEMATICAL CENTRE, AMSTERDAM, TRACT 22 (1968).
     [4] WILKINSON, J. H.
         ROUNDING ERRORS IN ALGEBRAIC PROCESSES.
         LONDON (1963).
     [5] WILKINSON, J. H.
         THE ALGEBRAIC EIGENVALUE PROBLEM.
         OXFORD (1965).
 
 
1SECTION: 3.1.1.1.1.1.1       (MAY 1974)                         PAGE 12
 
 
 
 SOURCE TEXT(S):
0"CODE" 34300;
     "PROCEDURE" DEC(A, N, AUX, P); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX; "INTEGER" "ARRAY" P;
     "BEGIN" "INTEGER" I, K, K1, PK, D;
         "REAL" R, S, EPS;
         "ARRAY" V[1:N];
         R:= -1;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" S:= SQRT(MATTAM(1,N,I,I,A,A));
             "IF" S > R "THEN" R:= S; V[I]:= 1/S
         "END";
         EPS:= AUX[2] * R; D:= 1;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" R:= - 1; K1:= K - 1;
             "FOR" I:= K "STEP" 1 "UNTIL" N "DO"
             "BEGIN" A[I,K]:= A[I,K] - MATMAT(1, K1, I, K, A, A);
                 S:= ABS(A[I,K]) * V[I]; "IF" S > R "THEN"
                 "BEGIN" R:= S; PK:= I "END"
             "END" LOWER;
             P[K]:= PK; V[PK]:= V[K]; S:= A[PK,K];
             "IF" ABS(S) < EPS "THEN" "GOTO" END;
             "IF" S < 0 "THEN" D:= -D; "IF" PK ^= K "THEN"
             "BEGIN" D:= - D; ICHROW(1, N, K, PK, A) "END";
             "FOR" I:= K + 1 "STEP" 1 "UNTIL" N "DO"
             A[K,I]:= (A[K,I] - MATMAT(1, K1, K, I, A, A)) / S
         "END" LU;
         K:= N + 1;
      END: AUX[1]:= D; AUX[3]:= K - 1
     "END" DEC;
         "EOP"
 
 "CODE" 34231;
     "PROCEDURE" GSSELM(A, N, AUX, RI, CI); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "INTEGER" "ARRAY" RI, CI;
     "BEGIN" "INTEGER" I, J, P, Q, R, R1, JPIV, RANK, SIGNDET;
         "REAL" CRIT, PIVOT, RGROW, MAX, AID, MAX1, EPS;
         "BOOLEAN" PARTIAL;
                                                               "COMMENT"
1SECTION: 3.1.1.1.1.1.1       (DECEMBER 1979)                    PAGE 13
                                                                 ;
 
 
         AUX[5]:= RGROW:= ABSMAXMAT(1, N, 1, N, I, J, A);
         CRIT:= N * RGROW * AUX[4]; EPS:= RGROW * AUX[2]; MAX:= 0;
         RANK:= N; SIGNDET:= 1; PARTIAL:= RGROW ^= 0;
         "FOR" Q:= 1 "STEP" 1 "UNTIL" N "DO" "IF" Q ^= J "THEN"
         "BEGIN" AID:= ABS(A[I,Q]);
             "IF" AID > MAX "THEN" MAX:= AID
         "END";
         RGROW:= RGROW + MAX;
         "FOR" R:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" R1:= R + 1; "IF" I ^= R "THEN"
             "BEGIN" SIGNDET:= - SIGNDET; ICHROW(1, N, R, I, A) "END";
             "IF" J ^= R "THEN"
             "BEGIN" SIGNDET:= - SIGNDET; ICHCOL(1, N, R, J, A) "END";
             RI[R]:= I; CI[R]:= J; PIVOT:= A[R,R];
             "IF" PIVOT < 0 "THEN" SIGNDET:= - SIGNDET;
             "IF" PARTIAL "THEN"
             "BEGIN" MAX:= MAX1:= 0; J:= R1;
                 ROWCST(R1, N, R, A, 1 / PIVOT);
                 "FOR" P:= R1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" ELMROW(R1, N, P, R, A, A, - A[P,R]);
                     AID:= ABS(A[P,R1]); "IF" MAX < AID "THEN"
                     "BEGIN" MAX:= AID; I:= P "END";
                  "END";
                 "FOR" Q:= R1 + 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" AID:= ABS(A[I,Q]);
                     "IF" MAX1 < AID "THEN" MAX1:= AID
                 "END";
                 AID:= RGROW; RGROW:= RGROW + MAX1;
                 "IF" RGROW > CRIT "OR" MAX < EPS "THEN"
                 "BEGIN" PARTIAL:= "FALSE"; RGROW:= AID;
                     MAX:= ABSMAXMAT(R1, N, R1, N, I, J, A)
                 "END"
             "END" PARTIAL PIVOTINGSTEP
             "ELSE"
             "BEGIN" "IF" MAX <= EPS "THEN"
                 "BEGIN" RANK:= R - 1;
                     "IF" PIVOT < 0 "THEN" SIGNDET:= - SIGNDET;"GOTO"OUT
                 "END";
                 MAX:= - 1;
                 ROWCST(R1, N, R, A, 1 / PIVOT);
                 "FOR" P:= R1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" JPIV:= MAXELMROW(R1, N, P, R, A, A, - A[P,R]);
                     AID:= ABS(A[P,JPIV]); "IF" MAX < AID "THEN"
                     "BEGIN" MAX:= AID; I:= P; J:= JPIV "END"
                 "END";
                 "IF" RGROW < MAX "THEN" RGROW:= MAX
             "END" COMPLETE PIVOTINGSTEP
         "END" ELIMINATIONSTEP;
     OUT: AUX[1]:= SIGNDET; AUX[3]:= RANK; AUX[7]:= RGROW
     "END" GSSELM
1SECTION: 3.1.1.1.1.1.1       (MAY 1974)                         PAGE 14
 
 
                                                                  ;
         "EOP"
 "CODE" 34240;
     "REAL" "PROCEDURE" ONENRMINV(A, N); "VALUE" N; "INTEGER" N;
     "ARRAY" A;
     "BEGIN" "INTEGER" I, J;
         "REAL" NORM, MAX, AID;
         "ARRAY" Y[1:N];
         NORM:= 0;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" Y[I]:= "IF" I < J
             "THEN" 0 "ELSE" "IF" I = J "THEN" 1 / A[I,I] "ELSE"
             - MATVEC(J, I - 1, I, A, Y) / A[I,I];
             MAX:= 0;
             "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
             "BEGIN" AID:= Y[I]:= Y[I] - MATVEC(I + 1, N, I, A, Y);
                 MAX:= MAX + ABS(AID)
             "END";
             "IF" NORM < MAX "THEN" NORM:= MAX
         "END";
         ONENRMINV:= NORM
     "END" ONENRMINV;
         "EOP"
 "CODE" 34241;
     "PROCEDURE" ERBELM(N, AUX, NRMINV); "VALUE" N, NRMINV;
     "INTEGER" N; "REAL" NRMINV;
     "ARRAY" AUX;
     "BEGIN" "REAL" AID, EPS;
         EPS:= AUX[0]; AID:= (1.06 * EPS * (.75 * N + 4.5) * N ** 2
         * AUX[7] + AUX[5] * AUX[6]) * NRMINV;
         AUX[11]:= "IF" 2 * AID >= (1 - EPS) "THEN" - 1 "ELSE"
         AID / (1 - 2 * AID); AUX[9]:= NRMINV
     "END" ERBELM;
         "EOP"
 "CODE" 34242;
     "PROCEDURE" GSSERB(A, N, AUX, RI, CI); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "INTEGER" "ARRAY" RI, CI;
     "BEGIN"
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" ERBELM(N, AUX, ONENRMINV(A, N))
     "END" GSSERB;
         "EOP"
 "CODE" 34252;
     "PROCEDURE" GSSNRI(A, N, AUX, RI, CI); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "INTEGER" "ARRAY" RI, CI;
     "BEGIN"
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" AUX[9]:= ONENRMINV(A, N)
     "END" GSSNRI;
         "EOP"
1SECTION: 3.1.1.1.1.1.2       (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR: J. C. P. BUS.
 
 
 CONTRIBUTOR: J.C.P. BUS AND P. A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730831.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION  CONTAINS  A  PROCEDURE FOR CALCULATING THE
     DETERMINANT OF A TRIANGULARLY DECOMPOSED MATRIX;
 
 
 KEYWORDS:
 
     DETERMINANT.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "REAL" "PROCEDURE" DETERM(A, N, SIGN); "VALUE" N, SIGN;
     "INTEGER" N, SIGN; "ARRAY" A;
     "CODE" 34303;
 
     DETERM: DELIVERS THE CALCULATED VALUE OF THE DETERMINANT OF THE
             MATRIX;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE DIAGONAL ELEMENTS OF THE
                     LOWER-TRIANGULAR MATRIX L, OBTAINED BY TRIANGULAR
                     DECOMPOSITION OF THE MATRIX, HAVE TO BE GIVEN IN
                     A[I,I], I= 1, ..., N;
     N:      <ARITHMETIC EXPRESSION>;
             THE  ORDER  OF  THE  MATRIX,  WHOSE  DETERMINANT  HAS TO BE
             CALCULATED;
     SIGN:   <ARITHMETIC EXPRESSION>;
             ENTRY:  IF THE DETERMINANT OF THE MATRIX  IS POSITIVE  THEN
                     THE VALUE OF SIGN SHOULD BE +1, ELSE -1; THIS VALUE
                     IS DELIVERED BY GSSELM OR DEC IN  AUX[1],  (SECTION
                     3.1.1.1.1.1.1).
 
 
 PROCEDURES USED: NONE.
1SECTION: 3.1.1.1.1.1.2       (MAY 1974)                          PAGE 2
 
 
 
 RUNNING TIME: PROPORTIONAL TO N.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     A LOWER-TRIANGULAR MATRIX L HAS TO BE
     GIVEN, SUCH THAT FOR SOME UNIT UPPER-TRIANGULAR MATRIX U THE
     PRODUCT LU EQUALS THE MATRIX (WITH PERMUTED ROWS AND COLUMNS);
     THE SIGN OF THE DETERMINANT ALSO HAS TO BE GIVEN; THESE DATA ARE
     DELIVERED IN THE MATRIX AND AUX[1] BY THE PROCEDURES GSSELM OR DEC
     (SECTION 3.1.1.1.1.1.1) AND THE PROCEDURES GSSERB, GSSNRI (SECTION
     3.1.1.1.1.1.1), DECSOL, GSSSOL, GSSSOLERB (SECTION 3.1.1.1.1.1.3),
     GSSITISOL AND GSSITISOLERB (SECTION 3.1.1.1.1.1.5), WHICH MAKE USE
     OF GSSELM OR DEC.
     THE  CALCULATION   OF  THE  DETERMINANT  IS  DONE  STRAIGHT  ON  BY
     CALCULATING   THE  PRODUCT   OF   THE  DIAGONAL  ELEMENTS   OF  THE
     LOWER-TRIANGULAR MATRIX GIVEN IN ARRAY A;  THE USER IS WARNED, THAT
     OVERFLOW MAY OCCUR IF THE ORDER OF THE MATRIX IS LARGE.
 
 
 EXAMPLE OF USE:
 
     THE DETERMINANT  OF THE FOURTH ORDER SEGMENT  OF THE HILBERT MATRIX
     MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J; "REAL" D; "INTEGER" "ARRAY" RI, CI[1:4];
         "ARRAY" A[1:4, 1:4], AUX[1:7];
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" A[I, J]:= 1 / (I + J - 1);
         AUX[2]:= "-14; AUX[4]:= 8;
         GSSELM(A, 4, AUX, RI, CI);
         D:= "IF" AUX[3] = 4 "THEN" DETERM(A, 4, AUX[1]) "ELSE" 0;
         OUTPUT(71, "(""("DETERMINANT =")"B+.15D"+3D")", D)
     "END"
 
     RESULT:
 
     DETERMINANT = +.165343915345370"-006
 
 
 SOURCE TEXT(S):
 "CODE" 34303;
     "REAL" "PROCEDURE" DETERM(A, N, SIGN); "VALUE" N, SIGN;
     "INTEGER" N, SIGN; "ARRAY" A;
     "BEGIN" "INTEGER" I; "REAL" DET;
         DET:= 1;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" DET:= A[I, I] * DET;
         DETERM:= SIGN * ABS(DET)
     "END" DETERM;
         "EOP"
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 1
 
 
 
 AUTHORS: J. C. P. BUS AND T. J. DEKKER.
 
 
 CONTRIBUTOR: J.C.P. BUS AND P. A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730915.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FIVE PROCEDURES:
     SOL SOLVES THE LINEAR SYSTEM WHOSE MATRIX HAS BEEN TRIANGULARLY
     DECOMPOSED BY DEC;
     DECSOL SOLVES A LINEAR SYSTEM WHOSE ORDER IS SMALL RELATIVE TO THE
     NUMBER OF BINARY DIGITS IN THE NUMBER REPRSENTATION;
     SOLELM SOLVES A LINEAR SYSTEM WHOSE MATRIX HAS BEEN TRIANGULARLY
     DECOMPOSED BY GSSELM OR GSSERB(SECTION 3.1.1.1.1.1.1.).
     GSSSOL SOLVES A LINEAR SYSTEM;
     GSSSOLERB  SOLVES  A  LINEAR  SYSTEM  AND  CALCULATES  A  ROUGH
     UPPERBOUND FOR THE RELATIVE ERROR IN THE CALCULATED SOLUTION;
 
     THE
     DIFFERENCE BETWEEN  DECSOL ON THE ONE SIDE AND GSSSOL AND GSSSOLERB
     ON  THE  OTHER  SIDE  LIES  IN  THE  METHOD  USED   FOR  TRIANGULAR
     DECOMPOSITION,  PARTICULARLY IN THE PIVOTING STRATEGY;  DECSOL USES
     DEC,  GSSSOL  AND  GSSSOLERB  USE  GSSELM TO PERFORM THE TRIANGULAR
     DECOMPOSITION (SECTION 3.1.1.1.1.1.1); SINCE, IN EXCEPTIONAL CASES,
     DEC  MAY YIELD USELESS RESULTS,  ONE IS ADVISED  TO USE  GSSSOL  OR
     GSSSOLERB; HOWEVER, IF THE ORDER OF THE LINEAR SYSTEM IS VERY SMALL
     RELATIVE  TO   THE  NUMBER   OF   BINARY  DIGITS   IN   THE  NUMBER
     REPRESENTATION, THEN DECSOL ALSO MAY BE USED.
 
 
 KEYWORDS:
 
     ALGEBRAIC EQUATIONS,
     LINEAR SYSTEMS.
 
 
 
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 2
 
 
 
 SUBSECTION: SOL .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" SOL(A, N, P, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, B; "INTEGER" "ARRAY" P;
     "CODE" 34051;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE TRIANGULARLY  DECOMPOSED FORM  OF THE MATRIX OF
                     THE  LINEAR  SYSTEM  AS  PRODUCED BY  DEC  (SECTION
                     3.1.1.1.1.1.1);
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     P:      <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" P[1:N];
             ENTRY:THE PIVOTAL INDICES, AS PRODUCED BY DEC.
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE SOLUTION OF THE LINEAR SYSTEM.
 
 
 PROCEDURES USED:
 
     MATVEC = CP34011.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 2.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     SOL SHOULD BE CALLED AFTER  DEC (SECTION 3.1.1.1.1.1.1)  AND SOLVES
     THE LINEAR SYSTEM WITH A MATRIX, WHOSE TRIANGULARLY DECOMPOSED FORM
     AS PRODUCED BY  DEC  IS GIVEN IN ARRAY  A, AND A RIGHT-HAND SIDE AS
     GIVEN IN ARRAY B; SOL LEAVES A AND P UNALTERED,  SO, AFTER ONE CALL
     OF DEC, SEVERAL CALLS OF SOL MAY FOLLOW FOR SOLVING SEVERAL SYSTEMS
     HAVING THE SAME MATRIX BUT DIFFERENT RIGHT-HAND SIDES.
 
 
 EXAMPLE OF USE: SEE DECSOL (THIS SECTION).
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 3
 
 
 
 SUBSECTION: DECSOL   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECSOL(A, N, AUX, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX, B;
     "CODE" 34301;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT: THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH ITS  UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:3];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  IS TERMINATED AND NO
                     SOLUTION WILL BE CALCULATED;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED SOLUTION OF THE
                     LINEAR SYSTEM IS OVERWRITTEN ON B,  ELSE  B REMAINS
                     UNALTERED.
 
 
 PROCEDURES USED:
 
     DEC = CP34300,
     SOL = CP34051.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: DECSOL DECLARES AN AUXILIARY ARRAY  OF TYPE
                             INTEGER AND ORDER N.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 LANGUAGE:   ALGOL 60.
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 4
 
 
 
 METHOD AND PERFORMANCE:
 
 
     DECSOL  USES  DEC  TO PERFORM  THE TRIANGULAR DECOMPOSITION  OF THE
     MATRIX  AND  SOL  TO CALCULATE  THE SOLUTION  WITH FORWARD AND BACK
     SUBSTITUTION;  SINCE  DECSOL  MAY YIELD USELESS RESULTS,  EVEN  FOR
     WELL-CONDITIONED MATRICES (SEE DEC, SECTION 3.1.1.1.1.1.1),  DECSOL
     SHOULD ONLY BE USED IF THE ORDER OF THE MATRIX IS SMALL RELATIVE TO
     THE NUMBER  OF  BINARY  DIGITS  IN  THE  NUMBER REPRESENTATION;  IF
     AUX[3] < N, THEN THE EFFECT OF DECSOL IS MERELY THAT OF DEC.
 
 
 EXAMPLE OF USE:
 
     LET A BE THE FOURTH ORDER SEGMENT OF THE HILBERT MATRIX AND B THE
     THIRD COLUMN OF A, THEN THE SOLUTION OF THE LINEAR SYSTEM
     AX = B IS GIVEN BY THE THIRD UNIT VECTOR AND MAY BE CALCULATED BY
     THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J;
         "ARRAY" A[1:4, 1:4], B[1:4], AUX[1:3];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(B[I]);
             "FOR" I:= 1 "STEP" 2 "UNTIL" 3 "DO" ITEM(AUX[I])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("/, "("SOLUTION:")"B+.15D"+3D,/,3(10B+.15D"+3D,/),
         "("SIGN(DET) = ")"+D,/,"("NUMBER OF ELIMINATIONSTEPS = ")"
         +D")");
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             A[I,J]:= 1 / (I + J - 1); B[I]:= A[I,3]
         "END";
         AUX[2]:= "-14;
         DECSOL(A, 4, AUX, B);
         OUTLIST(71, LAYOUT, LIST)
     "END"
 
     RESULTS:
 
     SOLUTION: +.000000000000000"+000
               +.000000000000000"+000
               +.100000000000000"+001
               +.000000000000000"+000
     SIGN(DET) = +1
     NUMBER OF ELIMINATIONSTEPS = +4
 
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 5
 
 
 SUBSECTION: SOLELM  .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" SOLELM(A, N, RI, CI, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, B; "INTEGER" "ARRAY" RI, CI;
     "CODE" 34061;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE TRIANGULARLY  DECOMPOSED FORM  OF THE MATRIX OF
                     THE LINEAR SYSTEM AS  PRODUCED BY  GSSELM  (SECTION
                     3.1.1.1.1.1.1);
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             ENTRY:THE PIVOTAL ROW INDICES,  AS PRODUCED BY  GSSELM;
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             ENTRY:THE PIVOTAL COLUMN INDICES, AS PRODUCED BY  GSSELM;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE SOLUTION OF THE LINEAR SYSTEM.
 
 
 PROCEDURES USED:
 
     SOL = CP34051.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 2.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     SOLELM   SHOULD  BE  CALLED  AFTER   GSSELM   OR   GSSERB  (SECTION
     3.1.1.1.1.1.1) AND SOLVES THE LINEAR SYSTEM WITH THE MATRIX,  WHOSE
     TRIANGULARLY  DECOMPOSED  FORM  AS PRODUCED BY  GSSELM  IS GIVEN IN
     ARRAY A, AND A RIGHT-HAND SIDE AS GIVEN IN ARRAY B;  SOLELM  LEAVES
     A,  RI AND CI  UNALTERED,  SO, AFTER ONE CALL OF GSSELM  OR GSSERB,
     SEVERAL CALLS OF  SOLELM  MAY FOLLOW  FOR  SOLVING  SEVERAL SYSTEMS
     HAVING THE SAME MATRIX  BUT DIFFERENT RIGHT-HAND SIDES.
 
 EXAMPLE OF USE: SEE GSSSOL OR GSSSOLERB (THIS SECTION).
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 6
 
 
 
 SUBSECTION: GSSSOL   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSSOL(A, N, AUX, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX, B;
     "CODE" 34232;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT: THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH ITS  UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:7];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  IS TERMINATED AND NO
                     SOLUTION WILL HAVE BEEN CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX GIVEN IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED SOLUTION OF THE
                     LINEAR SYSTEM IS OVERWRITTEN ON B,  ELSE  B REMAINS
                     UNALTERED.
 
 PROCEDURES USED:
 
     SOLELM  = CP34061,
     GSSELM  = CP34231.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: GSSSOL  DECLARES  TWO  AUXILIARY  ARRAYS OF
                             TYPE INTEGER AND ORDER N.
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 7
 
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     GSSSOL USES  GSSELM (SECTION 3.1.1.1.1.1.1) TO PERFORM A TRIANGULAR
     DECOMPOSITION OF THE MATRIX AND  SOLELM (THIS SECTION) TO CALCULATE
     THE SOLUTION  OF THE GIVEN LINEAR SYSTEM;  IF AUX[3] < N,  THEN THE
     EFFECT OF GSSSOL IS MERELY THAT OF GSSELM.
 
 
 EXAMPLE OF USE:
 
     LET A BE THE FOURTH ORDER SEGMENT OF THE HILBERT MATRIX AND B THE
     THIRD COLUMN OF A, THEN THE SOLUTION OF THE LINEAR SYSTEM
     AX = B IS GIVEN BY THE THIRD UNIT VECTOR AND MAY BE CALCULATED BY
     THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J;
         "ARRAY" A[1:4, 1:4], B[1:4], AUX[1:7];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(B[I]);
             "FOR" I:= 1 "STEP" 2 "UNTIL" 7 "DO" ITEM(AUX[I])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("/, "("SOLUTION:")"B+.15D"+3D,/,3(10B+.15D"+3D,/),
         "("SIGN(DET) = ")"+D,/,"("NUMBER OF ELIMINATIONSTEPS = ")"
         +D,/,"("MAX(ABS(A[I,J]))= ")"+.15D"+3D,/,
         "("UPPER BOUND GROWTH: ")"+.15D"+3D")");
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             A[I,J]:= 1 / (I + J - 1); B[I]:= A[I,3]
         "END";
         AUX[2]:= "-14; AUX[4]:= 8;
         GSSSOL(A, 4, AUX, B);
         OUTLIST(71, LAYOUT, LIST)
     "END"
 
     RESULTS:
 
     SOLUTION: +.888178419700120"-014
               -.497379915032070"-013
               +.100000000000010"+001
               +.000000000000000"+000
     SIGN(DET) = +1
     NUMBER OF ELIMINATIONSTEPS = +4
     MAX(ABS(A[I,J]))= +.100000000000000"+001
     UPPER BOUND GROWTH: +.159619047619050"+001
 
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 8
 
 
 
 SUBSECTION: GSSSOLERB.
 
 CALLING SEQUENCE:
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSSOLERB(A, N, AUX, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX, B;
     "CODE" 34243;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT: THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH ITS  UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:11];
             ENTRY:
             AUX[0]: THE MACHINE PRECISION;
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             AUX[6]: AN UPPER BOUND  FOR  THE RELATIVE PRECISION  OF THE
                     GIVEN MATRIX ELEMENTS;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  IS TERMINATED AND NO
                     SOLUTION OR ERROR BOUND WILL HAVE BEEN CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX GIVEN IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
             AUX[9]: IF AUX[3] = N, THEN AUX[9] WILL EQUAL THE 1-NORM OF
                     THE INVERSE MATRIX, ELSE AUX[9] WILL BE UNDEFINED;
             AUX[11]: IF AUX[3] = N THEN THE VALUE OF AUX[11]  WILL BE A
                     ROUGH  UPPER BOUND  FOR  THE RELATIVE ERROR  IN THE
                     CALCULATED  SOLUTION  OF  THE  GIVEN LINEAR SYSTEM,
                     ELSE  AUX[11]  WILL BE UNDEFINED;  IF NO USE CAN BE
                     MADE OF THE FORMULA FOR THE ERROR BOUND AS GIVEN IN
                     SECTION 3.1.1.1.1.1.1 (SUBSECTION ERBELM),  BECAUSE
                     OF  A  VERY  BAD  CONDITION  OF  THE  MATRIX,  THEN
                     AUX[11]:= -1;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED SOLUTION OF THE
                     LINEAR SYSTEM, ELSE  B REMAINS UNALTERED.
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                          PAGE 9
 
 
 
 PROCEDURES USED:
 
     SOLELM  = CP34061,
     GSSERB  = CP34242.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: GSSSOLERB  DECLARES TWO AUXILIARY ARRAYS OF
                             TYPE INTEGER AND ORDER N.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     GSSSOLERB  USES  GSSERB  (SECTION  3.1.1.1.1.1.1)  TO  PERFORM  THE
     TRIANGULAR DECOMPOSITION OF THE MATRIX  AND  TO CALCULATE  AN UPPER
     BOUND  FOR THE RELATIVE ERROR  IN  THE CALCULATED SOLUTION  OF  THE
     GIVEN LINEAR SYSTEM, AND  SOLELM  (THIS SECTION)  TO CALCULATE THIS
     SOLUTION;  IF AUX[3] < N,  THEN THE EFFECT OF  GSSSOLERB  IS MERELY
     THAT OF GSSELM (SECTION 3.1.1.1.1.1.1).
 
 EXAMPLE OF USE:
 
     LET A BE THE FOURTH ORDER SEGMENT OF THE HILBERT MATRIX AND B THE
     THIRD COLUMN OF A, THEN THE SOLUTION OF THE LINEAR SYSTEM
     AX = B IS GIVEN BY THE THIRD UNIT VECTOR AND THIS SOLUTION, AS
     WELL AS AN UPPER BOUND FOR THE RELATIVE ERROR IN THE CALCULATED ONE
     , MAY BE OBTAINED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J;
         "ARRAY" A[1:4, 1:4], B[1:4], AUX[0:11];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(B[I]);
             "FOR" I:= 1 "STEP" 2 "UNTIL" 11 "DO" ITEM(AUX[I])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("/, "("SOLUTION:")"B+.15D"+3D,/,3(10B+.15D"+3D,/),
         "("SIGN(DET) = ")"+D,/,"("NUMBER OF ELIMINATIONSTEPS = ")"
         +D,/,"("MAX(ABS(A[I,J]))= ")"+.15D"+3D,/,
         "("UPPER BOUND GROWTH: ")"+.15D"+3D,/,
         "("1-NORM OF THE INVERSE MATRIX:")"B+.15D"+3D,/,
         "("UPPER BOUND REL. ERR. IN THE CALC. SOL.")"
         B+.15D"+3D")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             A[I,J]:= 1 / (I + J - 1); B[I]:= A[I,3]
         "END";
         AUX[0]:= AUX[2]:= "-14; AUX[4]:= 8; AUX[6]:= "-14;
         GSSSOLERB(A, 4, AUX, B);
         OUTLIST(71, LAYOUT, LIST)
     "END"
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                         PAGE 10
 
 
 
     RESULTS:
 
     SOLUTION: +.888178419700120"-014
               -.497379915032070"-013
               +.100000000000010"+001
               +.000000000000000"+000
     SIGN(DET) = +1
     NUMBER OF ELIMINATIONSTEPS = +4
     MAX(ABS(A[I,J]))= +.100000000000000"+001
     UPPER BOUND GROWTH: +.159619047619050"+001
     1-NORM OF THE INVERSE MATRIX: +.136199999998790"+005
     UPPER BOUND REL. ERR. IN THE CALC. SOL. +.277896269157090"-007
 
 
 
 
 
 REFERENCES:
 
     [1] BUS, J. C. P.
         LINEAR SYSTEMS  WITH CALCULATION OF ERROR BOUNDS  AND ITERATIVE
         REFINEMENT (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, LR 3. 4. 19 (1972).
     [2] DEKKER, T. J.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
         MATHEMATICAL CENTRE, AMSTERDAM, TRACT 22 (1968).
 
 SOURCE TEXT(S):
 
 "CODE" 34051;
     "PROCEDURE" SOL(A, N, P, B); "VALUE" N; "INTEGER" N; "ARRAY" A, B;
     "INTEGER" "ARRAY" P;
     "BEGIN" "INTEGER" K, PK;
         "REAL" R;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" R:= B[K]; PK:= P[K];
             B[K]:= (B[PK] - MATVEC(1, K - 1, K, A, B)) / A[K,K];
             "IF" PK ^= K "THEN" B[PK]:= R
         "END";
         "FOR" K:= N "STEP" - 1 "UNTIL" 1 "DO"
         B[K]:= B[K] - MATVEC(K + 1, N, K, A, B)
     "END" SOL
1SECTION: 3.1.1.1.1.1.3       (MAY 1974)                         PAGE 11
 
 
                                                                  ;
         "EOP"
0"CODE" 34301;
     "PROCEDURE" DECSOL(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN" "INTEGER" "ARRAY" P[1:N];
         DEC(A, N, AUX, P);
         "IF" AUX[3] = N "THEN" SOL(A, N, P, B)
     "END" DECSOL;
         "EOP"
0"CODE" 34061;
     "PROCEDURE" SOLELM(A, N, RI, CI, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, B;
     "INTEGER" "ARRAY" RI, CI;
     "BEGIN" "INTEGER" R, CIR;
         "REAL" W;
         SOL(A, N, RI, B);
         "FOR" R:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" CIR:= CI[R]; "IF" CIR ^= R "THEN"
             "BEGIN" W:= B[R]; B[R]:= B[CIR]; B[CIR]:= W "END"
         "END"
     "END" SOLELM;
         "EOP"
 "CODE" 34232;
     "PROCEDURE" GSSSOL(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN" "INTEGER" "ARRAY" RI, CI[1:N];
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" SOLELM(A, N, RI, CI, B)
     "END" GSSSOL;
         "EOP"
0"CODE" 34243;
     "PROCEDURE" GSSSOLERB(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN" "INTEGER" "ARRAY" RI, CI[1:N];
         GSSERB(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" SOLELM(A, N, RI, CI, B)
     "END" GSSSOLERB;
         "EOP"
1SECTION: 3.1.1.1.1.1.4       (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHORS: J. C. P. BUS AND T. J. DEKKER.
 
 
 CONTRIBUTOR: J.C.P. BUS AND P.A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730920.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS  FIVE  PROCEDURES  FOR INVERSION OF MATRICES:
     INV CALCULATES THE INVERSE OF A MATRIX THAT HAS BEEN TRIANGULARLY
     DECOMPOSED BY DEC;
     DECINV CALCULATES THE INVERSE OF A MATRIX WHOSE ORDER IS SMALL
     RELATIVE  TO  THE  NUMBER  OF  BINARY  DIGITS  IN  THE  NUMBER
     REPRESENTATION;
     INV1 CALCULATES THE INVERSE OF A MATRIX THAT HAS BEEN TRIANGULARLY
     DECOMPOSED BY GSSELM OR GSSERB.THE 1-NORM OF THE INVERSE MATRIX
     MIGHT ALSO BE CALCULATED
     GSSINV CALCULATES THE INVERSE OF A MATRIX;
     GSSINVERB CALCULATES THE INVERSE OF A MATRIX AND ITS 1-NORM.
     A ROUGH UPPERBOUND FOR THE RELATIVE ERROR IN THE CALCULATED INVERSE
     MATRIX IS ALSO GIVEN;
 
     THE DIFFERENCE
     BETWEEN  DECINV  ON THE ONE SIDE AND  GSSINV  AND  GSSINVERB ON THE
     OTHER SIDE  LIES IN THE METHOD  USED  FOR TRIANGULAR DECOMPOSITION,
     PARTICULARLY IN THE PIVOTING STRATEGY;  DECINV USES DEC, GSSINV AND
     GSSINVERB  USE  GSSELM TO PERFORM THE TRIANGULAR DECOMPOSITION; THE
     USER  IS  ADVISED  TO  USE   GSSINV  OR   GSSINVERB   (SEE  SECTION
     3.1.1.1.1.1.1).
 
 
 KEYWORDS:
 
     MATRIX INVERSION.
 
 
 
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                          PAGE 2
 
 
 
 SUBSECTION: INV .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" INV(A, N, P); "VALUE" N;
     "INTEGER" N; "ARRAY" A; "INTEGER" "ARRAY" P;
     "CODE" 34053;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE TRIANGULARLY  DECOMPOSED FORM  OF THE MATRIX AS
                     PRODUCED BY  DEC  (SECTION 3.1.1.1.1.1.1);
             EXIT:   THE CALCULATED INVERSE MATRIX;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     P:      <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY P[1:N];
             ENTRY:THE PIVOTAL INDICES, AS PRODUCED BY DEC;
 
 
 PROCEDURES USED:
 
     MATMAT     = CP34013,
     ICHCOL     = CP34031,
     DUPCOLVEC  = CP31034.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: INV  DECLARES  AN AUXILIARY ARRAY  OF  TYPE
                             REAL AND ORDER N.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     INV  SHOULD  BE  CALLED  AFTER  DEC  (SECTION  3.1.1.1.1.1.1)   AND
     CALCULATES THE INVERSE OF THE MATRIX, WHOSE TRIANGULARLY DECOMPOSED
     FORM AS PRODUCED BY  DEC IS GIVEN IN ARRAY A; THE INVERSE MATRIX IS
     OVERWRITTEN ON A.
 
 
 EXAMPLE OF USE: SEE DECINV (THIS SECTION).
 
 
 
1SECTION: 3.1.1.1.1.1.4       (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION: DECINV   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECINV(A, N, AUX); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX;
     "CODE" 34302;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE MATRIX, WHOSE INVERSE HAS TO BE CALCULATED;
             EXIT:   IF  AUX[3] = N, THEN THE CALCULATED INVERSE MATRIX;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:3];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N, THEN  THE PROCESS  IS TERMINATED AND NO
                     INVERSE WILL HAVE BEEN CALCULATED.
 
 
 PROCEDURES USED:
 
     DEC = CP34300,
     INV = CP34053.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: DECINV DECLARES AN AUXILIARY ARRAY  OF TYPE
                             INTEGER AND ORDER N.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 LANGUAGE:   ALGOL 60.
 
 
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                          PAGE 4
 
 
 
 METHOD AND PERFORMANCE:
 
     DECINV  USES  DEC (SECTION 3.1.1.1.1.1.1) TO PERFORM THE TRIANGULAR
     DECOMPOSITION OF A MATRIX AND INV TO CALCULATE ITS INVERSE;  DECINV
     SHOULD ONLY BE USED IF THE ORDER OF THE MATRIX IS SMALL RELATIVE TO
     THE NUMBER OF BINARY DIGITS IN THE NUMBER REPRESENTATION (SEE DEC);
     IF AUX[3] < N, THEN THE EFFECT OF DECINV IS MERELY THAT OF DEC.
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM CALCULATES  THE INVERSE  OF  THE INPUT MATRIX
     AND PRINTS THE RESULTS:
 
     "BEGIN"
         "ARRAY" A[1:4, 1:4], AUX[1:3];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(A[I,J])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("4(4B,4(B+ZDB),/),/")");
 
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" INREAL(70, A[I,J])
         "END" IN LIST;
         AUX[2]:= "-14;
         OUTPUT(71,"("/,"("INPUT:")",///")");
         OUTLIST(71, LAYOUT, LIST);
         OUTPUT(71,"("/,"("CALCULATED INVERSE:")",/")");
         DECINV(A, 4, AUX);
         OUTLIST(71, LAYOUT, LIST);
         OUTPUT(71, "(""("AUX[1]=")"B+D,/,"("AUX[3]=")"B+D")",
         AUX[1], AUX[3])
     "END"
 
     INPUT:
 
      + 4  + 2  + 4  + 1
      +30  +20  +45  +12
      +20  +15  +36  +10
      +35  +28  +70  +20
 
 
     RESULTS:
 
     CALCULATED INVERSE:
       +4   -2   +4   -1
      -30  +20  -45  +12
      +20  -15  +36  -10
      -35  +28  -70  +20
 
     AUX[1]= +1
     AUX[3]= +4
 
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                          PAGE 5
 
 
 
 SUBSECTION: INV1  .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "REAL" "PROCEDURE" INV1(A, N, RI, CI, WITHNORM);
     "VALUE" N, WITHNORM; "INTEGER" N; "BOOLEAN" WITHNORM; "ARRAY" A;
     "INTEGER" "ARRAY" RI, CI;
     "CODE" 34235;
 
     INV1:   IF THE VALUE OF  WITHNORM  IS TRUE, THEN THE VALUE OF  INV1
             WILL EQUAL THE  1-NORM  OF THE CALCULATED  INVERSE  MATRIX,
             ELSE INV1:= 0;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE TRIANGULARLY  DECOMPOSED FORM  OF THE MATRIX AS
                     PRODUCED BY  GSSELM  (SECTION 3.1.1.1.1.1.1);
             EXIT:   THE CALCULATED INVERSE MATRIX;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             ENTRY:THE PIVOTAL ROW INDICES,  AS PRODUCED BY  GSSELM;
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             ENTRY:THE PIVOTAL COLUMN INDICES, AS PRODUCED BY  GSSELM;
     WITHNORM: <BOOLEAN EXPRESSION>;
             IF THE VALUE OF  WITHNORM  IS TRUE,  THEN THE 1-NORM OF THE
             INVERSE MATRIX  WILL  BE CALCULATED  AND  ASSIGNED TO INV1,
             ELSE INV1:= 0;
 
 PROCEDURES USED:
 
     ICHROW = CP34032,
     INV    = CP34053.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     INV1   SHOULD  BE  CALLED  AFTER   GSSELM   OR   GSSERB    (SECTION
     3.1.1.1.1.1.1),WHICH DELIVERS THE TRIANGULARLY DECOMPOSED FORM OF A
     MATRIX;  INV1  CALCULATES  THE INVERSE MATRIX  AND  ALSO ITS 1-NORM
     MIGHT BE CALCULATED; THE INVERSE MATRIX IS OVERWRITTEN ON A.
 
 EXAMPLE OF USE: SEE GSSINV AND GSSINVERB (THIS SECTION).
1SECTION: 3.1.1.1.1.1.4       (DECEMBER 1975)                     PAGE 6
 
 
 
 SUBSECTION: GSSINV   .
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSINV(A, N, AUX); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX;
     "CODE" 34236;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE MATRIX, WHOSE INVERSE HAS TO BE CALCULATED;
             EXIT:   IF  AUX[3] = N, THEN THE CALCULATED INVERSE MATRIX;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:9];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  IS TERMINATED AND NO
                     SOLUTION WILL BE CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX GIVEN IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
             AUX[9]: IF AUX[3] = N, THEN AUX[9] WILL EQUAL THE 1-NORM OF
                     THE CALCULATED INVERSE MATRIX, ELSE AUX[9]  WILL BE
                     UNDEFINED.
 
 PROCEDURES USED:
 
     INV1    = CP34235,
     GSSELM  = CP34231.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: GSSINV  DECLARES  TWO  AUXILIARY  ARRAYS OF
                             TYPE INTEGER AND ORDER N.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 LANGUAGE:   ALGOL 60.
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                          PAGE 7
 
 
 
 METHOD AND PERFORMANCE:
 
     GSSINV USES  GSSELM (SECTION 3.1.1.1.1.1.1) TO PERFORM A TRIANGULAR
     DECOMPOSITION OF THE MATRIX AND  INV1 (THIS  SECTION)  TO CALCULATE
     THE INVERSE MATRIX;  IF AUX[3] < N,  THEN THE EFFECT OF  GSSINV  IS
     MERELY THAT OF GSSELM.
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM CALCULATES  THE INVERSE  OF  THE INPUT MATRIX
     AND PRINTS THE RESULTS:
     "BEGIN" "ARRAY" A[1:4, 1:4], AUX[1:9];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(A[I,J])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("4(4B,4(B+ZDB),/),/")");
 
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" INREAL(70, A[I,J])
         "END" IN LIST;
         AUX[2]:= "-14; AUX[4]:= 8;
         OUTPUT(71,"("/,"("INPUT:")",///")");
         OUTLIST(71, LAYOUT, LIST);
         GSSINV(A, 4, AUX);
         OUTPUT(71,"("/,"("CALCULATED INVERSE:")",/")");
         OUTLIST(71, LAYOUT, LIST);
         OUTPUT(71, "("4B"("AUX ELEMENTS:")",/,2(4B+D,/),
         3(4B+.15D"+3D,/)")", AUX[1], AUX[3], AUX[5], AUX[7], AUX[9])
     "END"
 
     INPUT:
 
      + 4  + 2  + 4  + 1
      +30  +20  +45  +12
      +20  +15  +36  +10
      +35  +28  +70  +20
 
     RESULTS:
 
     CALCULATED INVERSE:
       +4   -2   +4   -1
      -30  +20  -45  +12
      +20  -15  +36  -10
      -35  +28  -70  +20
 
     AUX ELEMENTS:
     +1
     +4
     +.700000000000000"+002
     +.112528571428570"+003
     +.154999999999730"+003
1SECTION: 3.1.1.1.1.1.4       (DECEMBER 1975)                     PAGE 8
 
 
 
 SUBSECTION: GSSINVERB.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSINVERB(A, N, AUX); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX;
     "CODE" 34244;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N, 1:N];
             ENTRY:  THE MATRIX, WHOSE INVERSE HAS TO BE CALCULATED;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED INVERSE MATRIX;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:11];
             ENTRY:
             AUX[0]: THE MACHINE PRECISION;
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             AUX[6]: AN UPPER BOUND  FOR  THE RELATIVE PRECISION  OF THE
                     GIVEN MATRIX ELEMENTS;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  IS TERMINATED AND NO
                     SOLUTION WILL HAVE BEEN CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX GIVEN IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
             AUX[9]: IF AUX[3] = N, THEN AUX[9] WILL EQUAL THE 1-NORM OF
                     THE INVERSE MATRIX, ELSE AUX[9] WILL BE UNDEFINED;
             AUX[11]: IF AUX[3] = N THEN THE VALUE OF AUX[11]  WILL BE A
                     ROUGH  UPPER BOUND  FOR  THE RELATIVE ERROR  IN THE
                     CALCULATED  INVERSE MATRIX,  ELSE  AUX[11]  WILL BE
                     BE UNDEFINED;  IF NO USE CAN BE MADE OF THE FORMULA
                     FOR  THE  ERROR  BOUND    AS   GIVEN   IN   SECTION
                     3.1.1.1.1.1.1  (SUBSECTION  ERBELM),   BECAUSE OF A
                     VERY BAD CONDITION OF THE MATRIX, THEN AUX[11]:=-1.
 
 
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                          PAGE 9
 
 
 
 PROCEDURES USED:
     INV1    = CP34235,
     GSSELM  = CP34231,
     ERBELM  = CP34241.
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH: GSSINVERB  DECLARES TWO AUXILIARY ARRAYS OF
                             TYPE INTEGER AND ORDER N.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     GSSINVERB  USES  GSSELM  (SECTION  3.1.1.1.1.1.1)  TO  PERFORM  THE
     TRIANGULAR  DECOMPOSITION  OF THE MATRIX,  INV1  (THIS SECTION)  TO
     CALCULATE THE INVERSE MATRIX AND ITS  1-NORM  AND  ERBELM  (SECTION
     3.1.1.1.1.1.1) TO CALCULATE AN UPPER BOUND  FOR  THE RELATIVE ERROR
     IN  THE  CALCULATED  INVERSE;  IF  AUX[3] < N,  THEN  THE EFFECT OF
     GSSINVERB IS MERELY THAT OF GSSELM.
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM CALCULATES  THE INVERSE  OF  THE INPUT MATRIX
     WITH AN UPPER BOUND  FOR THE RELATIVE ERROR IN IT  AND  PRINTS  THE
     RESULTS:
 
     "BEGIN" "ARRAY" A[1:4, 1:4], AUX[0:11];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(A[I,J])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("4(4B,4(B+ZDB),/),/")");
 
         "BEGIN" "INTEGER" I, J;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO" INREAL(70, A[I,J])
         "END" IN LIST;
         AUX[0]:= AUX[2]:= AUX[6]:= "-14;
         OUTPUT(71,"("/,"("INPUT:")",///")");
         OUTLIST(71, LAYOUT, LIST);
         AUX[4]:= 8; GSSINVERB(A, 4, AUX);
         OUTPUT(71,"("/,"("CALCULATED INVERSE:")",/")");
         OUTLIST(71, LAYOUT, LIST);
         OUTPUT(71, "("4B"("AUX ELEMENTS:")",/,2(4B+D,/),
         4(4B+.15D"+3D,/)")", AUX[1], AUX[3], AUX[5], AUX[7], AUX[9],
         AUX[11])
     "END"
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                         PAGE 10
 
 
 
     INPUT:
 
      + 4  + 2  + 4  + 1
      +30  +20  +45  +12
      +20  +15  +36  +10
      +35  +28  +70  +20
 
 
     RESULTS:
 
     CALCULATED INVERSE:
       +4   -2   +4   -1
      -30  +20  -45  +12
      +20  -15  +36  -10
      -35  +28  -70  +20
 
     AUX ELEMENTS:
     +1
     +4
     +.700000000000000"+002
     +.112528571428570"+003
     +.154999999999730"+003
     +.222946341369190"-007
 
 
 
 
 REFERENCES:
 
     [1] BUS, J. C. P.
         LINEAR SYSTEMS  WITH CALCULATION OF ERROR BOUNDS  AND ITERATIVE
         REFINEMENT (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, LR 3. 4. 19 (1972).
     [2] DEKKER, T. J.
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
         MATHEMATICAL CENTRE, AMSTERDAM, TRACT 22 (1968).
 
 
 
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                         PAGE 11
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 34053;
     "PROCEDURE" INV(A, N, P); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "INTEGER" "ARRAY" P;
     "BEGIN" "INTEGER" J, K, K1;
         "REAL" R;
         "ARRAY" V[1:N];
         "FOR" K:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" K1:= K + 1;
             "FOR" J:= N "STEP" - 1 "UNTIL" K1 "DO"
             "BEGIN" A[J,K1]:= V[J];
                 V[J]:= - MATMAT(K1, N, K, J, A, A)
             "END";
             R:= A[K,K];
             "FOR" J:= N "STEP" - 1 "UNTIL" K1 "DO"
             "BEGIN" A[K,J]:= V[J];
                 V[J]:= - MATMAT(K1, N, J, K, A, A) / R
             "END";
             V[K]:= (1 - MATMAT(K1, N, K, K, A, A)) / R
         "END";
         DUPCOLVEC(1, N, 1, A, V);
         "FOR" K:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" K1:= P[K]; "IF" K1 ^= K "THEN"
             ICHCOL(1, N, K, K1, A)
         "END"
     "END" INV;
         "EOP"
0"CODE" 34302;
     "PROCEDURE" DECINV(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN" "INTEGER" "ARRAY" P[1:N];
         DEC(A, N, AUX, P); "IF" AUX[3] = N "THEN" INV(A, N, P)
     "END" DECINV
1SECTION: 3.1.1.1.1.1.4       (MAY 1974)                         PAGE 12
 
 
                                                                  ;
         "EOP"
 "CODE" 34235;
     "REAL" "PROCEDURE" INV1(A, N, RI, CI, WITHNORM);
     "VALUE" N, WITHNORM; "INTEGER" N; "BOOLEAN" WITHNORM;
     "ARRAY" A; "INTEGER" "ARRAY" RI, CI;
     "BEGIN" "INTEGER" L, K, K1;
         "REAL" AID, NRMINV;
         INV(A, N, RI); NRMINV:= 0; "IF" WITHNORM "THEN"
         "FOR" L:= 1 "STEP" 1 "UNTIL" N "DO"
         NRMINV:= NRMINV + ABS(A[L,N]);
         "FOR" K:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" "IF" WITHNORM "THEN"
             "BEGIN" AID:= 0;
                 "FOR" L:= 1 "STEP" 1 "UNTIL" N "DO"
                 AID:= AID + ABS(A[L,K]);
                 "IF" NRMINV < AID "THEN" NRMINV:= AID
             "END";
             K1:= CI[K]; "IF" K1 ^= K "THEN" ICHROW(1, N, K, K1, A)
         "END";
         INV1:= NRMINV
     "END" INV1;
         "EOP"
0"CODE" 34236;
     "PROCEDURE" GSSINV(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN" "INTEGER" "ARRAY" RI, CI[1:N];
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" AUX[9]:= INV1(A, N, RI, CI, "TRUE")
     "END" GSSINV;
         "EOP"
0"CODE" 34244;
     "PROCEDURE" GSSINVERB(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN" "INTEGER" "ARRAY" RI, CI[1:N];
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN"
         ERBELM(N, AUX, INV1(A, N, RI, CI, "TRUE"))
     "END" GSSINVERB;
         "EOP"
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 1
 
 
 
 AUTHOR: J. C. P. BUS.
 
 
 CONTRIBUTOR: J.C.P. BUS AND  P. A. BEENTJES.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731008.
 
 
 BRIEF DESCRIPTION:
 
     THIS   SECTION  CONTAINS   FOUR   PROCEDURES  FOR   CALCULATING  AN
     ITERATIVELY  IMPROVED  SOLUTION  OF  A SYSTEM  OF LINEAR EQUATIONS:
     ITISOL SOLVES A LINEAR SYSTEM WHOSE MATRIX HAS BEEN TRIANGULARLY
     DECOMPOSED BY GSSELM OR GSSERB. THIS SOLUTION THUS OBTAINED
     NUMERICALLY, IS IMPROVED ITERATIVELY;
     GSSITISOL SOLVES A LINEAR SYSTEM AND THIS SOLUTION THUS OBTAINED
     NUMERICALLY, IS IMPROVED ITERATIVELY;
     ITISOLERB SOLVES A LINEAR SYSTEM WHOSE MATRIX HAS BEEN TRIANGULARLY
     DECOMPOSED BY GSSNRI.THIS SOLUTION IS IMPROVED ITERATIVELY.MOREOVER
     A REALISTIC  UPPERBOUND FOR THE RELATIVE ERROR IN THE SOLUTION IS
     CALCULATED.
     GSSITISOLERB SOLVES A LINEAR SYSTEM.THIS SOLUTION IS IMPROVED
     ITERATIVELY AND A REALISTIC UPPERBOUND FOR THE RELATIVE ERROR IN
     THE SOLUTION IS CALCULATED;
 
 
 KEYWORDS:
 
     ALGEBRAIC EQUATIONS,
     LINEAR SYSTEMS,
     ITERATIVE REFINEMENT.
 
 
 
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 2
 
 
 
 SUBSECTION: ITISOL  .
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" ITISOL(A, LU, N, AUX, RI, CI, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, LU, AUX, B; "INTEGER" "ARRAY" RI, CI;
     "CODE" 34250;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE MATRIX OF THE LINEAR SYSTEM;
     LU:     <ARRAY IDENTIFIER>;
             "ARRAY" LU[1:N, 1:N];
             ENTRY:THE TRIANGULARLY DECOMPOSED FORM OF THE MATRIX GIVEN
             IN A, AS DELIVERED BY GSSELM  (SECTION 3.1.1.1.1.1.1);
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[10:13];
             ENTRY:
             AUX[10]: A RELATIVE TOLERANCE  FOR THE SOLUTION VECTOR;  IF
                     THE  1-NORM  OF THE VECTOR  OF CORRECTIONS  TO  THE
                     SOLUTION,  DIVIDED BY  THE 1-NORM OF THE CALCULATED
                     SOLUTION, IS SMALLER THAN AUX[10], THEN THE PROCESS
                     WILL STOP; THE USER SHOULD NOT CHOOSE  THE VALUE OF
                     AUX[10] SMALLER THAN THE RELATIVE PRECISION  OF THE
                     ELEMENTS OF THE MATRIX  AND THE RIGHT-HAND SIDE  OF
                     THE LINEAR SYSTEM;
             AUX[12]: THE MAXIMUM NUMBER  OF ITERATIONS  ALLOWED FOR THE
                     REFINEMENT  OF  THE  SOLUTION;  IF  THE  NUMBER  OF
                     ITERATIONS EXCEEDS THE VALUE OF  AUX[12],  THEN THE
                     PROCESS  WILL  BE BROKEN OFF;  USUALLY  AUX[12] = 5
                     WILL GIVE GOOD RESULTS;
             EXIT:
             AUX[11]: THE 1-NORM  OF  THE VECTOR  OF  CORRECTIONS TO THE
                     SOLUTION IN THE LAST ITERATION STEP, DIVIDED BY THE
                     1-NORM OF THE CALCULATED SOLUTION;
                     IF  AUX[11] > AUX[10],  THEN  THE PROCESS  HAS BEEN
                     BROKEN OFF,   BECAUSE  THE  NUMBER  OF  ITERATIONS
                     EXCEEDED THE VALUE GIVEN IN AUX[12];
             AUX[13]: THE 1-NORM OF THE RESIDUAL VECTOR  (SEE METHOD AND
                     PERFORMANCE;
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             ENTRY:THE PIVOTAL ROW-INDICES,  AS PRODUCED BY  GSSELM;
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             ENTRY:THE PIVOTAL COLUMN-INDICES, AS PRODUCED BY  GSSELM;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE CALCULATED  SOLUTION OF THE LINEAR SYSTEM.
 
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 3
 
 
 
 PROCEDURES USED:
 
     SOLELM      = CP34061,
     INIVEC      = CP31010,
     DUPVEC      = CP31030,
     LNGMATVEC   = CP34411.
 
 REQUIRED CENTRAL MEMORY:
 
     TWO REAL ARRAYS, BOTH OF ORDER N, ARE DECLARED.
 
 RUNNING TIME: THE NUMBER OF  ARITHMETICAL OPERATIONS  IN EACH ITERATION
               STEP IS PROPORTIONAL TO N ** 2.
 
 METHOD AND PERFORMANCE:
 
     ITISOL   SHOULD  BE  CALLED  AFTER   GSSELM   OR   GSSERB  (SECTION
     3.1.1.1.1.1.1) AND SOLVES THE LINEAR SYSTEM WITH A MATRIX  GIVEN
     IN  ARRAY  A, AND A RIGHT-HAND SIDE  GIVEN IN  ARRAY  B; ONCE A
     SOLUTION IS CALCULATED WITH  SOLELM  (SECTION 3.1.1.1.1.1.3),  THIS
     SOLUTION WILL BE REFINED ITERATIVELY  UNTIL THE CALCULATED RELATIVE
     CORRECTION  TO THIS SOLUTION  WILL BE LESS THAN  A PRESCRIBED VALUE
     (SEE AUX[10]);
     EACH ITERATION  OF THE REFINEMENT PROCESS CONSISTS OF THE FOLLOWING
     THREE STEPS (SEE [1], [2], [3]):
     1   CALCULATE, IN DOUBLE PRECISION, THE RESIDUAL VECTOR R,  DEFINED
         BY:             R = AX - B,
         WHERE   X  DENOTES  THE  SOLUTION,  OBTAINED  IN  THE  PREVIOUS
         ITERATION,  B  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM,  GIVEN
         IN B[1:N], AND A THE MATRIX GIVEN IN A[1:N, 1:N];
     2   CALCULATE THE SOLUTION C, SAY, OF THE LINEAR SYSTEM: AC = R,
         WITH THE AID OF THE TRIANGULARLY DECOMPOSED MATRIX  AS GIVEN IN
         LU[1:N, 1:N];
     3   CALCULATE THE NEW SOLUTION: XNEW = X - C;
     CONDITION OF THE MATRIX IS NOT TOO BAD,  THEN  THE PRECISION OF THE
     CALCULATED SOLUTION WILL BE OF THE ORDER OF THE PRECISION ASKED FOR
     IN  AUX[10];  HOWEVER,  IF THE CONDITION OF THE MATRIX IS VERY BAD,
     THEN  THIS PROCESS WILL POSSIBLY  NOT  CONVERGE OR,  IN EXCEPTIONAL
     CASES,  CONVERGE TO  A USELESS RESULT;  IF  THE USER  WANTS TO MAKE
     CERTAIN  ABOUT  THE PRECISION  OF  THE CALCULATED SOLUTION, THEN HE
     HAS TO USE  ITISOLERB  (THIS SECTION),  WHICH NEEDS THE CALCULATION
     (OF ORDER  N ** 3) OF THE INVERSE MATRIX  TO GET AN UPPER BOUND FOR
     THE CONDITION NUMBER  AND  WHICH  GIVES A REALISTIC UPPER BOUND FOR
     THE RELATIVE ERROR IN THE CALCULATED SOLUTION;
     ITISOL  LEAVES  A,  LU,  RI  AND CI UNALTERED, SO AFTER ONE CALL OF
     GSSELM SEVERAL CALLS OF ITISOL MAY FOLLOW TO CALCULATE THE SOLUTION
     OF SEVERAL LINEAR SYSTEMS WITH THE SAME MATRIX BUT DIFFERENT RIGHT-
     HAND SIDES.
 
 EXAMPLE OF USE: SEE GSSITISOL (THIS SECTION).
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 4
 
 
 
 SUBSECTION: GSSITISOL   .
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSITISOL(A, N, AUX, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX, B; "CODE" 34251;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT: THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPERTRIANGULAR  MATRIX  WITH  ITS  UNIT  DIAGONAL OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[1:13];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE FOR THE PROCESS OF TRIANGULAR
                     DECOMPOSITION;A REASONABLE CHOICE FOR THIS VALUE IS
                     AN ESTIMATE OF THE RELATIVE PRECISION OF THE MATRIX
                     ELEMENTS; HOWEVER,IT SHOULD NOT BE CHOSEN SMALLER
                     THANN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             AUX[10]: A RELATIVE TOLERANCE  FOR THE SOLUTION VECTOR;  IF
                     THE  1-NORM  OF THE VECTOR  OF CORRECTIONS  TO  THE
                     SOLUTION,  DIVIDED BY  THE 1-NORM OF THE CALCULATED
                     SOLUTION, IS SMALLER THAN AUX[10], THEN THE PROCESS
                     WILL STOP; THE USER SHOULD NOT CHOOSE  THE VALUE OF
                     AUX[10] SMALLER THAN THE RELATIVE PRECISION  OF THE
                     ELEMENTS OF THE MATRIX  AND THE RIGHT-HAND SIDE  OF
                     THE LINEAR SYSTEM;
             AUX[12]: THE MAXIMUM NUMBER  OF ITERATIONS  ALLOWED FOR THE
                     REFINEMENT  OF  THE  SOLUTION;  IF  THE  NUMBER  OF
                     ITERATIONS EXCEEDS THE VALUE OF  AUX[12],  THEN THE
                     PROCESS  WILL  BE BROKEN OFF;  USUALLY  AUX[12] = 5
                     WILL GIVE GOOD RESULTS;
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N THEN THE PROCESS HAS BEEN BROKEN OFF AND
                     NO SOLUTION WILL HAVE BEEN CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX WHICH HAD BEEN GIVEN
                     IN ARRAY A;
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 5
 
 
 
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
             AUX[11]: IF AUX[3] < N,  THEN  AUX[11]  WILL  BE UNDEFINED,
                     ELSE  AUX[11]  EQUALS  THE 1-NORM  OF THE VECTOR OF
                     CORRECTIONS  TO  THE  SOLUTION  IN  THE  LAST STEP,
                     DIVIDED BY THE 1-NORM OF THE CALCULATED SOLUTION;
                     IF  AUX[11] > AUX[10],  THEN  THE PROCESS  HAS BEEN
                     BROKEN OFF,   BECAUSE   THE  NUMBER  OF  ITERATIONS
                     EXCEEDED THE VALUE GIVEN IN AUX[12];
             AUX[13]: IF AUX[3] = N,  THEN  THE VALUE  OF  AUX[13]  WILL
                     EQUAL THE 1-NORM OF THE RESIDUAL VECTOR (SEE ITISOL
                     IN THIS SECTION), ELSE AUX[13] WILL BE UNDEFINED;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED SOLUTION OF THE
                     LINEAR SYSTEM IS OVERWRITTEN ON B,  ELSE  B REMAINS
                     UNALTERED.
 
 
 PROCEDURES USED:
 
     DUPMAT  = CP31035,
     GSSELM  = CP34231,
     ITISOL  = CP34250.
 
 
 REQUIRED CENTRAL MEMORY:
 
     THREE REAL ARRAYS, TWO OF ORDER N AND ONE OF ORDER N ** 2, ARE
     DECLARED. FURTHERMORE, TWO INTEGER ARRAYS OF ORDER N ARE USED.
 
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 
 METHOD AND PERFORMANCE:
 
     GSSITISOL   USES   GSSELM  (SECTION  3.1.1.1.1.1.1)  TO  PERFORM  A
     TRIANGULAR DECOMPOSITION OF THE MATRIX AND ITISOL (THIS SECTION) TO
     CALCULATE  AN  ITERATIVELY  REFINED  SOLUTION  OF  THE GIVEN LINEAR
     SYSTEM; IF AUX[3] < N, THEN THE EFFECT OF GSSITISOL  IS MERELY THAT
     OF  GSSELM;  IF THE CONDITION OF THE MATRIX IS VERY BAD,  THEN,  IN
     EXCEPTIONAL CASES,  THE CALCULATED SOLUTION  MAY  BE  USELESS  (SEE
     ITISOL, IN THIS SECTION).
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     LET A BE THE FOURTH ORDER SEGMENT OF THE HILBERT MATRIX,
     MULTIPLIED WITH 840 TO GET INTEGER ELEMENTS, AND B THE THIRD COLUMN
     OF A, THEN THE SOLUTION OF THE LINEAR SYSTEM AX = B IS GIVEN BY
     THE THIRD UNIT VECTOR AND MAY BE OBTAINED BY THE FOLLOWING
     PROGRAM:
 
     "BEGIN" "INTEGER" I, J;
         "ARRAY" A[1:4, 1:4], B[1:4], AUX[1:13];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(B[I]);
             "FOR" I:= 1 "STEP" 2 "UNTIL" 7 "DO" ITEM(AUX[I]);
             ITEM(AUX[11]); ITEM(AUX[13])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("*, "("SOLUTION:")"B+.15D"+3D,/,3(10B+.15D"+3D,/),
         "("SIGN(DET) = ")"+D,/,"("NUMBER OF ELIMINATIONSTEPS = ")"
         +D,/,"("MAX(ABS(A[I,J]))= ")"+.15D"+3D,/,
         "("UPPER BOUND GROWTH: ")"+.15D"+3D,/,
         "("NORM LAST CORRECTION VECTOR: ")"+.15D"+3D,/,
         "("NORM RESIDUAL VECTOR: ")"+.15D"+3D")");
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             A[I,J]:= 840 // (I + J - 1); B[I]:= A[I,3]
         "END";
         AUX[2]:= "-14; AUX[4]:= 8; AUX[10]:= "-14; AUX[12]:= 5;
         GSSITISOL(A, 4, AUX, B);
         OUTLIST(71, LAYOUT, LIST)
     "END"
 
     RESULTS:
 
     SOLUTION: +.000000000000000"+000
               +.000000000000000"+000
               +.100000000000000"+001
               +.000000000000000"+000
     SIGN(DET) = +1
     NUMBER OF ELIMINATIONSTEPS = +4
     MAX(ABS(A[I,J]))= +.840000000000000"+003
     UPPER BOUND GROWTH: +.134080000000000"+004
     NORM LAST CORRECTION VECTOR: +.000000000000000"+000
     NORM RESIDUAL VECTOR: +.000000000000000"+000
 
 
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 7
 
 
 
 SUBSECTION: ITISOLERB.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" ITISOLERB(A, LU, N, AUX, RI, CI, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, LU, AUX, B; "INTEGER" "ARRAY" RI, CI;
     "CODE" 34253;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"[1:N,1:N];
             ENTRY:THE  MATRIX  OF  THE  LINEAR  SYSTEM;
     LU:     <ARRAY IDENTIFIER>;
             "ARRAY" LU[1:N,1:N];
             ENTRY:THE TRIANGULARLY DECOMPOSED FORM OF THE MATRIX GIVEN
             IN A AS DELIVERED BY GSSNRI  (SECTION 3.1.1.1.1.1.1);
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:13];
             ENTRY:
             AUX[0]: THE MACHINE PRECISION;
             AUX[5]: THE  MODULUS  OF  AN  ELEMENT,  WHICH IS OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX OF THE LINEAR SYSTEM;
                     THIS  VALUE  IS  DELIVERED   BY   GSSNRI   (SECTION
                     3.1.1.1.1.1.1) IN AUX[5];
             AUX[6]: AN  UPPER  BOUND  FOR  THE  RELATIVE  ERROR  IN THE
                     ELEMENTS OF THE MATRIX OF THE LINEAR SYSTEM;
             AUX[7]: AN  UPPER  BOUND  FOR  THE GROWTH  DURING  GAUSSIAN
                     ELIMINATION; THIS VALUE IS DELIVERED BY  GSSNRI  IN
                     AUX[7];
             AUX[8]: AN  UPPER  BOUND  FOR  THE  RELATIVE  ERROR  IN THE
                     ELEMENTS  OF  THE  RIGHT-HAND  SIDE  OF  THE LINEAR
                     SYSTEM;
             AUX[9]: THE 1-NORM  OF  THE INVERSE MATRIX;  THIS  VALUE IS
                     DELIVERED BY GSSNRI IN AUX[9];
             AUX[10]: A RELATIVE TOLERANCE  FOR THE SOLUTION VECTOR;  IF
                     THE  1-NORM  OF THE VECTOR  OF CORRECTIONS  TO  THE
                     SOLUTION,  DIVIDED BY  THE 1-NORM OF THE CALCULATED
                     SOLUTION, IS SMALLER THAN AUX[10], THEN THE PROCESS
                     WILL STOP; THE USER SHOULD NOT CHOOSE  THE VALUE OF
                     AUX[10] SMALLER THAN THE RELATIVE PRECISION  OF THE
                     ELEMENTS OF THE MATRIX  AND THE RIGHT-HAND SIDE  OF
                     THE LINEAR SYSTEM, GIVEN IN AUX[6] AND AUX[8];
             AUX[12]: THE MAXIMUM NUMBER  OF ITERATIONS  ALLOWED FOR THE
                     REFINEMENT  OF  THE  SOLUTION;  IF  THE  NUMBER  OF
                     ITERATIONS EXCEEDS THE VALUE OF  AUX[12],  THEN THE
                     PROCESS  WILL  BE BROKEN OFF;  USUALLY  AUX[12] = 5
                     WILL GIVE GOOD RESULTS;
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 8
 
 
 
             EXIT:
             AUX[11]:A REALISTIC UPPERBOUND FOR THE RELATIVE ERROR IN
                     THE CALCULATED SOLUTION; HOWEVER, IF NO USE CAN BE
                     MADE OF THE ERROR-FORMULA, THEN AUX[11] := -1;
             AUX[13]:THE 1-NORM OF THE RESIDUAL VECTOR  (SEE METHOD AND
                     PERFORMANCE);
     RI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" RI[1:N];
             ENTRY:THE PIVOTAL ROW-INDICES,  AS PRODUCED BY  GSSNRI;
     CI:     <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" CI[1:N];
             EXIT:THE PIVOTAL COLUMN-INDICES, AS PRODUCED BY  GSSNRI;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE SOLUTION OF THE LINEAR SYSTEM.
 
 PROCEDURES USED:
 
     ITISOL  = CP34250.
 
 REQUIRED CENTRAL MEMORY:TWO REAL AARRYS, BOTH OF ORDER N, ARE DECLARED.
 
 RUNNING TIME: THE NUMBER OF  ARITHMETICAL OPERATIONS  IN EACH ITERATION
               STEP OF THE REFINEMENT PROCESS IS PROPORTIONAL TO N ** 2.
 
 METHOD AND PERFORMANCE:
 
     ITISOLERB  SHOULD BE CALLED  AFTER  GSSNRI (SECTION 3.1.1.1.1.1.1),
     WHICH DELIVERS  THE TRIANGULARLY DECOMPOSED FORM OF THE MATRIX  AND
     THE PROPER VALUES  FOR THE ODD ELEMENTS  OF  ARRAY  AUX;  ITISOLERB
     CALCULATES, WITH THE USE OF  ITISOL (THIS SECTION),  AN ITERATIVELY
     IMPROVED SOLUTION OF THE LINEAR SYSTEM  WITH A MATRIX  AS  GIVEN IN
     ARRAY A AND A RIGHT-HAND SIDE AS GIVEN IN  B;  MOREOVER,  ITISOLERB
     CALCULATES  A REALISTIC UPPER BOUND  FOR THE RELATIVE ERROR  IN THE
     CALCULATED  SOLUTION, BY (SEE [1], [2]):
         NORM(DX) / NORM(X) <= P / (1 - P),
     WHERE : P = ( NORM(R) / NORM(X) + DB / NORM(X) + DA )
         * NORM(C) / (1 - Q * NORM(C) )
         FOR Q SEE SECTION 3.1.1.1.1.1.1 (SUBSECTION ERBELM),
         R IS THE RESIDUAL VECTOR (SEE ITISOL IN THIS SECTION),
         X IS THE CALCULATED SOLUTION,
         DB IS THE UPPER BOUND FOR THE RELATIVE ERROR  IN THE RIGHT-HAND
         SIDE ELEMENTS,
         DA IS THE UPPER BOUND FOR THE RELATIVE ERROR IN THE MATRIX
         ELEMENTS, C IS THE CALCULATED INVERSE MATRIX,
         AND THE 1-NORM OF A VECTOR OR A MATRIX IS DENOTED BY: NORM(.)
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                     PAGE 9
 
 
 
     IF 1 - P < AUX[0], THEN THE VALUE -1 IS DELIVERED IN AUX[11];
     ITISOLERB  LEAVES A, LU, RI AND CI UNALTERED,  SO AFTER ONE CALL OF
     GSSNRI  SEVERAL CALLS OF  ITISOLERB  MAY FOLLOW,  TO CALCULATE  THE
     SOLUTION  OF  SEVERAL  LINEAR  SYSTEMS  WITH  THE SAME  MATRIX  BUT
     DIFFERENT RIGHT-HAND SIDES.
 
 EXAMPLE OF USE: SEE GSSITISOLERB (THIS SECTION).
 
 
 
 SUBSECTION: GSSITISOLERB.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" GSSITISOLERB(A, N, AUX, B); "VALUE" N;
     "INTEGER" N; "ARRAY" A, AUX, B; "CODE" 34254;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY:THE N-TH ORDER MATRIX;
             EXIT: THE  CALCULATED  LOWER-TRIANGULAR  MATRIX  AND  UNIT
             UPPER-TRIANGULAR  MATRIX WITH ITS  UNIT  DIAGONAL  OMITTED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[0:13];
             ENTRY:
             AUX[0]: THE MACHINE PRECISION;
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE  IS  AN ESTIMATE OF THE RELATIVE PRECISION OF
                     THE MATRIX ELEMENTS;  HOWEVER,  IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             AUX[4]: A VALUE WHICH IS USED FOR CONTROLLING PIVOTING (SEE
                     GSSELM, SECTION 3.1.1.1.1.1.1);
             AUX[6]: AN UPPER BOUND FOR THE RELATIVE ERROR IN THE MATRIX
                     ELEMENTS OF THE LINEAR SYSTEM;
             AUX[8]: AN  UPPER  BOUND  FOR  THE  RELATIVE  ERROR  IN THE
                     ELEMENTS OF THE RIGHT-HAND SIDE;
             AUX[10]: A RELATIVE TOLERANCE  FOR THE SOLUTION VECTOR;  IF
                     THE  1-NORM  OF THE VECTOR  OF CORRECTIONS  TO  THE
                     SOLUTION,  DIVIDED BY  THE 1-NORM OF THE CALCULATED
                     SOLUTION, IS SMALLER THAN AUX[10], THEN THE PROCESS
                     WILL STOP; THE USER SHOULD NOT CHOOSE  THE VALUE OF
                     AUX[10] SMALLER THAN THE RELATIVE PRECISION  OF THE
                     ELEMENTS OF THE MATRIX  AND THE RIGHT-HAND SIDE  OF
                     THE LINEAR SYSTEM (AUX[10] >= AUX[2]);
             AUX[12]: THE MAXIMUM NUMBER  OF ITERATIONS  ALLOWED FOR THE
                     REFINEMENT  OF  THE  SOLUTION;  IF  THE  NUMBER  OF
                     ITERATIONS EXCEEDS THE VALUE OF  AUX[12],  THEN THE
                     PROCESS  WILL  BE BROKEN OFF;  USUALLY  AUX[12] = 5
                     WILL GIVE GOOD RESULTS;
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                    PAGE 10
 
 
 
             EXIT:
             AUX[1]: IF  R  IS THE NUMBER OF ELIMINATION STEPS PERFORMED
                     (SEE  AUX[3]),   THEN   AUX[1]  EQUALS   1  IF  THE
                     DETERMINANT OF THE PRINCIPAL SUBMATRIX  OF ORDER  R
                     IS POSITIVE, ELSE AUX[1] = -1;
             AUX[3]: THE  NUMBER  OF  ELIMINATION  STEPS  PERFORMED;  IF
                     AUX[3] < N  THEN  THE PROCESS  HAS BEEN BROKEN OFF
                     AND NO SOLUTION WILL HAVE BEEN CALCULATED;
             AUX[5]: THE  MODULUS  OF  AN ELEMENT  WHICH  IS  OF MAXIMUM
                     ABSOLUTE VALUE FOR THE MATRIX WHICH HAD BEEN GIVEN
                     IN ARRAY A;
             AUX[7]: AN UPPER BOUND FOR THE GROWTH (SEE GSSELM,  SECTION
                     3.1.1.1.1.1.1);
             AUX[9]: IF AUX[3] = N THEN AUX[9] EQUALS THE 1-NORM  OF THE
                     CALCULATED  INVERSE  MATRIX,  ELSE  AUX[9]  WILL BE
                     UNDEFINED;
             AUX[11]: IF AUX[3] < N,  THEN  AUX[11]  WILL  BE UNDEFINED,
                     ELSE THE VALUE OF AUX[11]  EQUALS A REALISTIC UPPER
                     BOUND  FOR  THE RELATIVE ERROR  IN  THE  CALCULATED
                     SOLUTION;  HOWEVER,  IF NO USE  CAN BE MADE  OF THE
                     ERROR FORMULA (SEE ITISOLERB IN THIS SECTION), THEN
                     AUX[11]:= -1;
             AUX[13]: IF AUX[3] = N,  THEN  AUX[13] EQUALS THE 1-NORM OF
                     THE RESIDUAL VECTOR  (SEE  ITISOL IN THIS SECTION),
                     ELSE AUX[13] WILL BE UNDEFINED;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN THE CALCULATED SOLUTION OF THE
                     LINEAR SYSTEM IS OVERWRITTEN ON B,  ELSE  B REMAINS
                     UNALTERED.
 
 PROCEDURES USED:
 
     DUPMAT      = CP31035,
     GSSNRI      = CP34252,
     ITISOLERB   = CP34253.
 
 REQUIRED CENTRAL MEMORY:
 
     THREE REAL ARRAYS, TWO OF ORDER N AND ONE OF ORDER N ** 2 , ARE
     USED. FURTHERMORE, TWO INTEGER ARRAYS OF ORDER N ARE USED.
 
 RUNNING TIME: PROPORTIONAL TO N ** 3.
 
 METHOD AND PERFORMANCE:
 
     GSSITISOLERB USES  GSSNRI  (SECTION  3.1.1.1.1.1.1)  TO  PERFORM  A
     TRIANGULAR DECOMPOSITION OF THE MATRIX AND ITISOLERB (THIS SECTION)
     TO CALCULATE AN ITERATIVELY REFINED  SOLUTION  OF  THE GIVEN LINEAR
     SYSTEM  AND  A REALISTIC UPPER BOUND FOR THE RELATIVE ERROR IN THIS
     SOLUTION; IF AUX[3] < N, THEN THE EFFECT OF  GSSITISOLERB IS MERELY
     THAT OF GSSELM (SECTION 3.1.1.1.1.1.1).
1SECTION: 3.1.1.1.1.1.5       (FEBRUARY 1979)                    PAGE 11
 
 
 
 EXAMPLE OF USE:
 
     LET A BE THE FOURTH ORDER SEGMENT OF THE HILBERT MATRIX,
     MULTIPLIED WITH 840 TO GET INTEGER ELEMENTS, AND B THE THIRD COLUMN
     OF A, THEN THE SOLUTION OF THE LINEAR SYSTEM AX = B IS GIVEN BY
     THE THIRD UNIT VECTOR  AND  THIS SOLUTION,  AS WELL AS  A REALISTIC
     UPPER BOUND FOR THE RELATIVE ERROR IN IT,  MAY BE OBTAINED BY THE
     FOLLOWING PROGRAM:
 
     "BEGIN" "INTEGER" I, J;
         "ARRAY" A[1:4, 1:4], B[1:4], AUX[0:13];
         "PROCEDURE" LIST(ITEM); "PROCEDURE" ITEM;
         "BEGIN" "INTEGER" I;
             "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO" ITEM(B[I]);
             "FOR" I:= 1 "STEP" 2 "UNTIL" 13 "DO" ITEM(AUX[I])
         "END" LIST;
         "PROCEDURE" LAYOUT;
         FORMAT("("*, "("SOLUTION:")"B+.15D"+3D,/,3(10B+.15D"+3D,/),
         "("SIGN(DET) = ")"+D,/,"("NUMBER OF ELIMINATIONSTEPS = ")"
         +D,/,"("MAX(ABS(A[I,J]))= ")"+.15D"+3D,/,
         "("UPPER BOUND GROWTH: ")"+.15D"+3D,/,
         "("NORM CALCULATED INVERSE MATRIX: ")"+.15D"+3D,/,
         "("UPPER BOUND FOR THE RELATIVE ERROR: ")"+.15D"+3D,/,
         "("NORM RESIDUAL VECTOR: ")"+.15D"+3D")");
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             A[I,J]:= 840 // (I + J - 1); B[I]:= A[I,3]
         "END";
         AUX[0]:= AUX[2]:= "-14; AUX[4]:= 8; AUX[6]:= AUX[8]:= 0;
         AUX[10]:= "-14; AUX[12]:= 5;
         GSSITISOLERB(A, 4, AUX, B);
         OUTLIST(71, LAYOUT, LIST)
     "END"
 
     RESULTS:
 
     SOLUTION: +.000000000000000"+000
               +.000000000000000"+000
               +.100000000000000"+001
               +.000000000000000"+000
     SIGN(DET) = +1
     NUMBER OF ELIMINATIONSTEPS = +4
     MAX(ABS(A[I,J]))= +.840000000000000"+003
     UPPER BOUND GROWTH: +.134080000000000"+004
     NORM CALCULATED INVERSE MATRIX: +.162142857143540"+002
     UPPER BOUND FOR THE RELATIVE ERROR: +.000000000000000"+000
     NORM RESIDUAL VECTOR: +.000000000000000"+000
 
1SECTION: 3.1.1.1.1.1.5       (MAY 1974)                         PAGE 12
 
 
 
 REFERENCES:
 
     [1] BUS, J. C. P.
         LINEAR SYSTEMS  WITH CALCULATION  OF ERROR BOUNDS AND ITERATIVE
         REFINEMENT (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, LR 3.4.19, (1972).
     [2] DEKKER, T. J.
         NUMERICAL ALGEBRA (DUTCH).
         MATHEMATICAL CENTRE, AMSTERDAM, SYLLABUS 12, (1971).
     [3] WILKINSON, J. H.
         THE ALGEBRAIC EIGENVALUE PROBLEM.
         OXFORD (1965).
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 34250;
     "PROCEDURE" ITISOL(A, LU, N, AUX, RI, CI, B); "VALUE" N;
     "INTEGER" N;
     "ARRAY" A, LU, AUX, B; "INTEGER" "ARRAY" RI, CI;
     "BEGIN" "INTEGER" I, ITER, MAXITER;
         "REAL" MAXERX, ERX, NRMRES, NRMSOL, R, RR;
         "ARRAY" RES, SOL[1:N];
         MAXERX:= ERX:= AUX[10]; MAXITER:= AUX[12];
         INIVEC(1, N, SOL, 0); DUPVEC(1, N, 0, RES, B);
         "FOR" ITER:= 1, ITER + 1 "WHILE" ITER <= MAXITER &
         MAXERX < ERX "DO"
         "BEGIN" SOLELM(LU, N, RI, CI, RES); ERX:= NRMSOL:= NRMRES:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" R:= RES[I]; ERX:= ERX + ABS(R); RR:= SOL[I] + R;
                 SOL[I]:= RR; NRMSOL:= NRMSOL + ABS(RR)
             "END";
             ERX:= ERX / NRMSOL;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" LNGMATVEC(1, N, I, A, SOL, - B[I], 0, R, RR);
                 R:= - (R + RR); RES[I]:= R; NRMRES:= NRMRES + ABS(R)
             "END"
         "END" ITERATION;
         DUPVEC(1, N, 0, B, SOL);
         AUX[11]:= ERX; AUX[13]:= NRMRES
     "END" ITISOL
1SECTION: 3.1.1.1.1.1.5       (MAY 1974)                         PAGE 13
 
 
                                                                  ;
         "EOP"
0"CODE" 34251;
     "PROCEDURE" GSSITISOL(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN" "INTEGER" I, J;
         "ARRAY" AA[1:N,1:N];
         "INTEGER" "ARRAY" RI, CI[1:N];
         DUPMAT(1, N, 1, N, AA, A);
         GSSELM(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" ITISOL(AA, A, N, AUX, RI, CI, B)
     "END" GSSITISOL;
         "EOP"
 
 "CODE" 34253;
     "PROCEDURE" ITISOLERB(A, LU, N, AUX, RI, CI, B); "VALUE" N;
     "INTEGER" N;
     "ARRAY" A, LU, AUX, B; "INTEGER" "ARRAY" RI, CI;
     "BEGIN" "INTEGER" I;
         "REAL" NRMSOL, NRMINV, NRMB, ALFA, TOLA, EPS;
         EPS:= AUX[0];
         NRMINV:= AUX[9]; TOLA:= AUX[5] * AUX[6]; NRMB:= NRMSOL:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO" NRMB:= NRMB + ABS(B[I]);
         ITISOL(A, LU, N, AUX, RI, CI, B);
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         NRMSOL:= NRMSOL + ABS(B[I]);
         ALFA:= 1 - (1.06 * EPS * AUX[7] * (.75 * N + 4.5) * N ** 2
                + TOLA) * NRMINV;
         "IF" ALFA < EPS "THEN" AUX[11]:= - 1 "ELSE"
         "BEGIN" ALFA:= ((AUX[13] + AUX[8] * NRMB) / NRMSOL + TOLA) *
                        NRMINV / ALFA;
             AUX[11]:= "IF" 1 - ALFA < EPS "THEN" - 1 "ELSE"
                       ALFA / (1 - ALFA)
         "END"
     "END" ITISOLERB;
         "EOP"
0"CODE" 34254;
     "PROCEDURE" GSSITISOLERB(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN" "INTEGER" I, J;
         "ARRAY" AA[1:N,1:N];
         "INTEGER" "ARRAY" RI, CI[1:N];
         DUPMAT(1, N, 1, N, AA, A);
         GSSNRI(A, N, AUX, RI, CI);
         "IF" AUX[3] = N "THEN" ITISOLERB(AA, A, N, AUX, RI, CI, B)
     "END" GSSITISOLERB;
         "EOP"
1SECTION: 3.1.1.1.1.2.1       (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR: T.J. DEKKER.
 
 
 CONTRIBUTORS: S.P.N. VAN KAMPEN, J. KOK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 RECEIVED: 731015.
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES:
     A) CHLDEC2 CALCULATES THE CHOLESKY  DECOMPOSITION OF A POSITIVE
     DEFINITE SYMMETRIC MATRIX WH0SE UPPER TRIANGLE IS GIVEN IN A TWO-
     DIMENSIONAL ARRAY;
     B) CHLDEC1 CALCULATES THE CHOLESKY  DECOMPOSITION OF A POSITIVE
     DEFINITE SYMMETRIC MATRIX WHOSE UPPER TRIANGLE IS GIVEN COLUMNWISE
     IN A ONE-DIMENSIONAL ARRAY.
 
 KEYWORDS:
 
     LINEAR EQUATIONS,
     POSITIVE DEFINITE SYMMETRIC MATRIX,
     CHOLESKY DECOMPOSITION.
 
 
 SUBSECTION: CHLDEC2.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDEC2(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "CODE" 34310;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE UPPER  TRIANGLE OF THE  POSITIVE DEFINITE MATRIX
                    MUST BE GIVEN IN THE UPPER-TRIANGULAR PART OF A (THE
                    ELEMENTS A[I,J], I <= J);
             EXIT:  THE  CHOLESKY  DECOMPOSITION  OF   THE  MATRIX  IS
                    DELIVERED IN THE UPPER TRIANGLE OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS;
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
1SECTION: 3.1.1.1.1.2.1       (MAY 1974)                          PAGE 2
 
 
 
 PROCEDURES USED: TAMMAT = CP34014.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     CHLDEC2 PERFORMS THE CHOLESKY DECOMPOSITION OF A SYMMETRIC
     POSITIVE DEFINITE MATRIX.
     THE METHOD USED IS CHOLESKY'S SQUARE ROOT METHOD WITHOUT
     PIVOTING (SEE REF[1] AND [2]). IF THE GIVEN SYMMETRIC MATRIX IS
     POSITIVE DEFINITE, THE METHOD YIELDS AN UPPER-TRIANGULAR MATRIX U
     SUCH THAT U'U EQUALS THE GIVEN MATRIX.
     THE PROCESS IS TERMINATED AT STAGE K, IF THE K-TH DIAGONAL ELEMENT
     OF THE GIVEN MATRIX MINUS THE SUM OF THE SQUARED ELEMENTS OF THE
     K-TH COLUMN OF U IS LESS THAN A TOLERANCE (AUX[2]) TIMES THE
     MAXIMAL DIAGONAL ELEMENT OF THE GIVEN MATRIX. IN THIS CASE THE
     MATRIX, POSSIBLY MODIFIED BY ROUNDING ERRORS, IS NOT POSITIVE
     DEFINITE.
 
 
 REFERENCES:
 
     [1]. T.J. DEKKER.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
          MC TRACT 22, 1968, MATH. CENTR., AMSTERDAM.
 
     [2]. J.H. WILKINSON.
          THE ALGEBRAIC EIGENVALUE PROBLEM.
          CLARENDON PRESS, OXFORD, 1965.
 
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF CHLINV2, SECTION 3.1.1.1.1.2.4.
 
 
1SECTION: 3.1.1.1.1.2.1       (MAY 1974)                          PAGE 3
 
 
 
 SUBSECTION: CHLDEC1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDEC1(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "CODE" 34311;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1 : (N + 1) * N // 2];
             ENTRY: THE UPPER-TRIANGULAR PART OF THE  POSITIVE  DEFINITE
                    SYMMETRIC MATRIX MUST BE GIVEN COLUMNWISE IN ARRAY A
                    (THE (I,J)-TH ELEMENT OF THE MATRIX MUST BE GIVEN IN
                    A[(J - 1) * J // 2 + I] FOR 1 <= I <= J <= N);
             EXIT:  THE  CHOLESKY  DECOMPOSITION  OF  THE   MATRIX  IS
                    DELIVERED COLUMNWISE IN A.
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS;
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
 
 
 PROCEDURES USED: VECVEC = CP34010.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     CHLDEC1 PERFORMS THE CHOLESKY DECOMPOSITION OF A SYMMETRIC
     POSITIVE DEFINITE MATRIX, WHOSE UPPER TRIANGLE IS STORED IN A ONE-
     DIMENSIONAL ARRAY, BY CHOLESKY'S SQUARE ROOT METHOD WITHOUT
     PIVOTING.
     SEE ALSO METHOD AND PERFORMANCE OF CHLDEC2, (THIS SECTION).
 
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF CHLINV1, SECTION 3.1.1.1.1.2.4.
1SECTION: 3.1.1.1.1.2.1       (DECEMBER 1975)                     PAGE 4
 
 
 
 SOURCE TEXT(S) :
 
 "CODE" 34310;
     "PROCEDURE" CHLDEC2(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN" "INTEGER" K, J; "REAL" R, EPSNORM;
 
         R:= 0;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "IF" A[K,K] > R "THEN" R:= A[K,K];
         EPSNORM:= AUX[2] * R;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" R:= A[K,K] - TAMMAT(1, K - 1, K, K, A, A);
             "IF" R <= EPSNORM "THEN"
             "BEGIN" AUX[3]:= K - 1; "GOTO" END "END";
             A[K,K]:= R:= SQRT(R);
             "FOR" J:= K + 1 "STEP" 1 "UNTIL" N "DO"
             A[K,J]:= (A[K,J] - TAMMAT(1, K - 1, J, K, A, A)) / R
         "END";
         AUX[3]:= N;
     END:
     "END" CHLDEC2;
         "EOP"
 
 "CODE" 34311;
     "PROCEDURE" CHLDEC1(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN" "INTEGER" J, K, KK, KJ, LOW, UP; "REAL" R, EPSNORM;
 
         R:= 0; KK:= 0;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + K; "IF" A[KK] > R "THEN" R:= A[KK] "END";
         EPSNORM:= AUX[2] * R; KK:= 0;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + K; LOW:= KK - K + 1; UP:= KK - 1;
             R:= A[KK] - VECVEC(LOW, UP, 0, A, A);
             "IF" R <= EPSNORM "THEN"
             "BEGIN" AUX[3]:= K - 1; "GOTO" END "END";
             A[KK]:= R:= SQRT(R); KJ:= KK + K;
             "FOR" J:= K + 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" A[KJ]:= (A[KJ] -
                     VECVEC(LOW, UP, KJ - KK, A, A)) / R;
                 KJ:= KJ + J
             "END"
         "END";
         AUX[3]:= N;
     END:
     "END" CHLDEC1;
         "EOP"
1SECTION: 3.1.1.1.1.2.2       (FEBRUARY 1979)                     PAGE 1      
        
        
        
 CONTRIBUTORS: S.P.N. VAN KAMPEN, J. KOK.       
        
        
 INSTITUTE: MATHEMATICAL CENTRE.      
        
        
 RECEIVED: 731015.
        
        
 BRIEF DESCRIPTION: 
        
     THIS SECTION CONTAINS TWO PROCEDURES:      
     CHLDETERM2, FOR THE CALCULATION OF THE DETERMINANT OF A
     SYMMETRIC POSITIVE DEFINITE MATRIX WHOSE CHOLESKY MATRIX IS  GIVEN       
     IN THE UPPER TRIANGLE OF A TWO-DIMENSIONAL ARRAY;    
     CHLDETERM1, FOR THE CALCULATION OF THE DETERMINANT OF A
     SYMMETRIC POSITIVE DEFINITE MATRIX WHOSE CHOLESKY MATRIX IS  GIVEN       
     COLUMNWISE IN A ONE-DIMENSIONAL ARRAY.     
        
        
 KEYWORDS:
        
     DETERMINANT, 
     POSITIVE DEFINITE SYMMETRIC MATRIX,
     CHOLESKY DECOMPOSITION.
        
        
 SUBSECTION: CHLDETERM2.    
        
        
 CALLING SEQUENCE:
        
     THE HEADING OF THE PROCEDURE IS: 
     "REAL" "PROCEDURE" CHLDETERM2(A, N); "VALUE" N; "INTEGER" N;   
     "ARRAY" A; "CODE" 34312; 
        
     CHLDETERM2  := THE  DETERMINANT  OF THE  SYMMETRIC  POSITIVE   
     DEFINITE MATRIX OF WHICH THE CHOLESKY MATRIX IS STORED IN A;   
        
     THE MEANING OF THE FORMAL PARAMETERS IS:   
     A:      <ARRAY IDENTIFIER>;      
             "ARRAY" A[1:N,1:N];      
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE  CHOLESKY MATRIX
                    AS  PRODUCED BY CHLDEC2 (SECTION  3.1.1.1.1.2.1) OR       
                    CHLDECSOL2 (SECTION  3.1.1.1.1.2.3)  MUST  BE GIVEN       
                    IN THE UPPER TRIANGLE OF A; 
             EXIT:  THE CONTENTS OF A ARE NOT CHANGED;    
     N:      <ARITHMETIC EXPRESSION>; 
             THE ORDER OF THE MATRIX. 
1SECTION: 3.1.1.1.1.2.2       (FEBRUARY 1979)                     PAGE 2      
        
        
        
 PROCEDURES USED: NONE.     
        
        
 REQUIRED CENTRAL MEMORY: NO EXTRA ARRAYS ARE DECLARED.   
        
        
 RUNNING TIME: PROPORTIONAL TO N.     
        
        
 METHOD AND PERFORMANCE:    
        
     THE PROCEDURE CHLDETERM2  SHOULD BE CALLED AFTER A  SUCCESSFUL CALL      
     OF CHLDEC2 OR CHLDECSOL2, I.E. IF AUX[3] = N;
     CHLDETERM2  SHOULD  NOT  BE CALLED  IF OVERFLOW IS TO BE  EXPECTED.      
        
        
 EXAMPLE OF USE:  
        
     SEE EXAMPLE OF USE OF CHLDECINV2 (SECTION 3.1.1.1.1.2.4)       
        
        
 SUBSECTION: CHLDETERM1.    
        
        
 CALLING SEQUENCE:
        
     THE HEADING OF THE PROCEDURE IS: 
     "REAL" "PROCEDURE" CHLDETERM1(A, N); "VALUE" N; "INTEGER" N;   
     "ARRAY" A; "CODE" 34313; 
        
     CHLDETERM1  := THE  DETERMINANT  OF THE  SYMMETRIC  POSITIVE   
     DEFINITE MATRIX OF WHICH THE CHOLESKY MATRIX IS STORED IN A;   
        
     THE MEANING OF THE FORMAL PARAMETERS IS:   
     A:      <ARRAY IDENTIFIER>;      
             "ARRAY" A[1 : (N + 1) * N // 2];   
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE  CHOLESKY MATRIX
                    AS  PRODUCED BY CHLDEC1 (SECTION  3.1.1.1.1.2.1) OR       
                    CHLDECSOL1 (SECTION  3.1.1.1.1.2.3)  MUST  BE GIVEN       
                    COLUMNWISE IN ARRAY A;      
             EXIT:  THE CONTENTS OF A ARE NOT CHANGED;    
     N:      <ARITHMETIC EXPRESSION>; 
             THE ORDER OF THE MATRIX. 
1SECTION: 3.1.1.1.1.2.2       (FEBRUARY 1979)                     PAGE 3      
        
        
        
 PROCEDURES USED: NONE.     
        
        
 REQUIRED CENTRAL MEMORY: NO EXTRA ARRAYS ARE DECLARED.   
        
        
 RUNNING TIME: PROPORTIONAL TO N.     
        
        
 METHOD AND PERFORMANCE:    
        
     THE PROCEDURE CHLDETERM1  SHOULD BE CALLED AFTER A  SUCCESSFUL CALL      
     OF CHLDEC1 OR CHLDECSOL1, I.E. IF AUX[3] = N;
     CHLDETERM1  SHOULD  NOT  BE  CALLED  IF OVERFLOW IS TO BE EXPECTED.      
        
        
        
 EXAMPLE OF USE:  
        
     SEE EXAMPLE OF USE OF CHLDECINV1, SECTION 3.1.1.1.1.2.4.       
        
        
 SOURCE TEXT(S) : 
 
 "CODE" 34312;
     "REAL" "PROCEDURE" CHLDETERM2(A, N); "VALUE" N; "INTEGER" N;
     "ARRAY" A;
     "BEGIN" "INTEGER" K; "REAL" D;
         D:= 1;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO" D:= A[K,K] * D;
         CHLDETERM2:= D * D
     "END" CHLDETERM2;
         "EOP"
 
 "CODE" 34313;
     "REAL" "PROCEDURE" CHLDETERM1(A, N); "VALUE" N; "INTEGER" N;
     "ARRAY" A;
     "BEGIN" "INTEGER" K, KK; "REAL" D;
         D:= 1; KK:= 0;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + K; D:= A[KK] * D "END";
         CHLDETERM1:= D * D
     "END" CHLDETERM1;
         "EOP"
1SECTION: 3.1.1.1.1.2.3       (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR: T.J. DEKKER.
 
 
 CONTRIBUTORS: S.P.N. VAN KAMPEN, J. KOK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731015.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOUR PROCEDURES:
     A) CHLSOL2, FOR THE SOLUTION OF A SYSTEM OF LINEAR EQUATIONS IF THE
     COEFFICIENT MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE PROCEDURE
     CHLDEC2, SECTION 3.1.1.1.1.2.1., OR CHLDECSOL2;
     B) CHLSOL1, FOR THE SOLUTION OF A SYSTEM OF LINEAR EQUATIONS IF THE
     COEFFICIENT MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE PROCEDURE
     CHLDEC1, SECTION 3.1.1.1.1.2.1., OR CHLDECSOL1;
     C) CHLDECSOL2, FOR THE SOLUTION OF A SYSTEM OF LINEAR EQUATIONS BY
     CHOLESKY'S SQUARE ROOT METHOD;
     THE COEFFICIENT MATRIX HAS TO BE SYMMETRIC POSITIVE DEFINITE AND
     MUST BE GIVEN IN THE UPPER TRIANGLE OF A TWO-DIMENSIONAL ARRAY;
     D) CHLDECSOL1, FOR THE SOLUTION OF A SYSTEM OF LINEAR EQUATIONS BY
     CHOLESKY'S SQUARE ROOT METHOD;
     THE COEFFICIENT MATRIX HAS TO BE SYMMETRIC POSITIVE DEFINITE AND
     MUST BE GIVEN COLUMNWISE IN A ONE-DIMENSIONAL ARRAY.
 
 
 KEYWORDS:
 
     LINEAR EQUATIONS,
     POSITIVE DEFINITE SYMMETRIC MATRIX,
     CHOLESKY DECOMPOSITION.
 
 
1SECTION: 3.1.1.1.1.2.3       (MAY 1974)                          PAGE 2
 
 
 
 SUBSECTION: CHLSOL2.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLSOL2(A, N, B); "VALUE" N; "INTEGER" N; "ARRAY" A, B;
     "CODE" 34390;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE  CHOLESKY MATRIX
                    AS  PRODUCED BY CHLDEC2, SECTION  3.1.1.1.1.2.1., OR
                    CHLDECSOL2  (THIS  SECTION), MUST  BE  GIVEN IN  THE
                    UPPER TRIANGLE OF A;
             EXIT:  THE CONTENTS OF A ARE NOT CHANGED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY: THE  RIGHT HAND   SIDE  OF  THE   SYSTEM  OF  LINEAR
                    EQUATIONS;
             EXIT:  THE SOLUTION OF THE SYSTEM.
 
 PROCEDURES USED:
 
     MATVEC = CP34011,
     TAMVEC = CP34012.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLSOL2 CALCULATES THE SOLUTION OF A SYSTEM OF LINEAR
     EQUATIONS, PROVIDED THAT THE COEFFICIENT MATRIX HAS BEEN DECOMPOSED
     BY A SUCCESSFUL CALL OF CHLDEC2 OR CHLDECSOL2;
     THE SOLUTION IS OBTAINED BY CARRYING OUT THE FORWARD AND BACK
     SUBSTITUTION WITH THE CHOLESKY MATRIX AND THE RIGHT HAND SIDE.
     THE RIGHT HAND SIDE IS OVERWRITTEN BY THE SOLUTION BUT THE
     ELEMENTS OF THE CHOLESKY MATRIX ARE NOT CHANGED, THUS SEVERAL
     SYSTEMS OF LINEAR EQUATIONS WITH THE SAME COEFFICIENT MATRIX BUT
     DIFFERENT RIGHT HAND SIDES CAN BE SOLVED BY SUCCESSIVE CALLS OF
     CHLSOL2. SEE ALSO REF [1].
 
 REFERENCES:
 
     [1]. T.J. DEKKER.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
          MC TRACT 22, 1968, MATH. CENTR., AMSTERDAM.
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF CHLINV2, SECTION 3.1.1.1.1.2.4.
1SECTION: 3.1.1.1.1.2.3       (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION: CHLSOL1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLSOL1(A, N, B); "VALUE" N; "INTEGER" N; "ARRAY" A, B;
     "CODE" 34391;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1 : (N + 1) * N // 2];
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE  CHOLESKY MATRIX
                    AS  PRODUCED BY CHLDEC1, SECTION  3.1.1.1.1.2.1., OR
                    CHLDECSOL1 (THIS SECTION), MUST  BE GIVEN COLUMNWISE
                    IN ARRAY A;
             EXIT:  THE CONTENTS OF A ARE NOT CHANGED;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY: THE  RIGHT HAND   SIDE  OF  THE   SYSTEM  OF  LINEAR
                    EQUATIONS;
             EXIT:  THE SOLUTION OF THE SYSTEM.
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010,
     SEQVEC = CP34016.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLSOL1 CALCULATES THE SOLUTION OF A SYSTEM OF LINEAR
     EQUATIONS, PROVIDED THAT THE COEFFICIENT MATRIX HAS BEEN DECOMPOSED
     BY A SUCCESSFUL CALL OF CHLDEC1 OR CHLDECSOL1;
     SEVERAL SYSTEMS WITH THE SAME COEFFICIENT MATRIX BUT DIFFERENT
     RIGHT HAND SIDES CAN BE SOLVED BY SUCCESSIVE CALLS OF CHLSOL1.
     SEE ALSO METHOD AND PERFORMANCE OF CHLSOL2 (THIS SECTION).
 
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF CHLINV1, SECTION 3.1.1.1.1.2.4.
 
 
1SECTION: 3.1.1.1.1.2.3       (DECEMBER 1975)                     PAGE 4
 
 
 
 SUBSECTION: CHLDECSOL2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDECSOL2(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "CODE" 34392;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE UPPER  TRIANGLE OF THE  POSITIVE DEFINITE MATRIX
                    MUST BE GIVEN IN THE UPPER-TRIANGULAR PART OF A (THE
                    ELEMENTS A[I,J], I <= J);
             EXIT:  THE  CHOLESKY  DECOMPOSITION   OF  THE  MATRIX  IS
                    DELIVERED IN THE UPPER TRIANGLE OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS; (SEE METHOD
                    AND PERFORMANCE OF CHLDEC2, SECTION 3.1.1.1.1.2.1);
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY: THE  RIGHT HAND   SIDE  OF  THE   SYSTEM  OF  LINEAR
                    EQUATIONS;
             EXIT:  THE SOLUTION OF THE SYSTEM.
 
 PROCEDURES USED:
     CHLDEC2 = CP34310,
     CHLSOL2 = CP34390.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLDECSOL2 SOLVES A SYSTEM OF LINEAR EQUATIONS WITH
     A SYMMETRIC POSITIVE DEFINITE COEFFICIENT MATRIX BY CALLING
     CHLDEC2, SECTION 3.1.1.1.1.2.1., AND, IF THIS CALL WAS
     SUCCESSFUL, CHLSOL2 (THIS SECTION).
     SEE ALSO CHLDEC2, SECTION 3.1.1.1.1.2.1.
 
 EXAMPLE OF USE:
 
     SEE EXAMPLE OF USE OF CHLDECINV2, SECTION 3.1.1.1.1.2.4.
1SECTION: 3.1.1.1.1.2.3       (DECEMBER 1975)                     PAGE 5
 
 
 
 SUBSECTION: CHLDECSOL1.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDECSOL1(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "CODE" 34393;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1 : (N + 1) * N // 2];
             ENTRY: THE UPPER-TRIANGULAR PART OF THE  POSITIVE  DEFINITE
                    SYMMETRIC MATRIX MUST BE GIVEN COLUMNWISE IN ARRAY A
                    (THE (I,J)-TH ELEMENT OF THE MATRIX MUST BE GIVEN IN
                    A[(J - 1) * J // 2 + I] FOR 1 <= I <= J <= N);
             EXIT:  THE  CHOLESKY  DECOMPOSITION   OF  THE  MATRIX  IS
                    DELIVERED COLUMNWISE IN A.
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS;
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY: THE  RIGHT HAND   SIDE  OF  THE   SYSTEM  OF  LINEAR
                    EQUATIONS;
             EXIT:  THE SOLUTION OF THE SYSTEM.
 
 PROCEDURES USED:
 
     CHLDEC1 = CP34311,
     CHLSOL1 = CP34391.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE PROCEDURE CHLDECSOL1 SOLVES A SYSTEM OF LINEAR EQUATIONS WITH
     A SYMMETRIC POSITIVE DEFINITE COEFFICIENT MATRIX BY CALLING
     CHLDEC1, SECTION 3.1.1.1.1.2.1., AND, IF THIS CALL WAS
     SUCCESSFUL, CHLSOL1 (THIS SECTION).
     THE UPPER TRIANGLE OF THE COEFFICIENT MATRIX MUST BE STORED COLUMN-
     WISE IN A ONE-DIMENSIONAL ARRAY.
     SEE ALSO CHLDEC1, SECTION 3.1.1.1.1.2.1.
 
 EXAMPLE OF USE:
     SEE EXAMPLE OF USE OF CHLDECINV1, SECTION 3.1.1.1.1.2.4.
1SECTION: 3.1.1.1.1.2.3       (MAY 1974)                          PAGE 6
 
 
 
 SOURCE TEXT(S) :
 
 "CODE" 34390;
     "PROCEDURE" CHLSOL2(A, N, B); "VALUE" N; "INTEGER" N; "ARRAY" A, B;
     "BEGIN" "INTEGER" I;
 
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         B[I]:= (B[I] - TAMVEC(1, I - 1, I, A, B)) / A[I,I];
         "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
         B[I]:= (B[I] - MATVEC(I + 1, N, I, A, B)) / A[I,I]
     "END" CHLSOL2;
         "EOP"
 "CODE" 34391;
     "PROCEDURE" CHLSOL1(A, N, B); "VALUE" N; "INTEGER" N; "ARRAY" A, B;
     "BEGIN" "INTEGER" I, II;
 
         II:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" II:= II + I;
             B[I]:= (B[I] - VECVEC(1, I - 1, II - I, B, A)) / A[II]
         "END";
         "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" B[I]:= (B[I] -
                 SEQVEC(I + 1, N, II + I, 0, A, B)) / A[II];
             II:= II - I
         "END"
     "END" CHLSOL1;
         "EOP"
 "CODE" 34392;
     "PROCEDURE" CHLDECSOL2(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN"
 
         CHLDEC2(A, N, AUX);
         "IF" AUX[3] = N "THEN" CHLSOL2(A, N, B)
     "END" CHLDECSOL2;
         "EOP"
 "CODE" 34393;
     "PROCEDURE" CHLDECSOL1(A, N, AUX, B); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX, B;
     "BEGIN"
 
         CHLDEC1(A, N, AUX);
         "IF" AUX[3] = N "THEN" CHLSOL1(A, N, B)
     "END" CHLDECSOL1;
         "EOP"
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 1
 
 
 
 AUTHOR   : T.J. DEKKER.
 
 
 CONTRIBUTORS: S.P.N. VAN KAMPEN, J. KOK.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731015.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOUR PROCEDURES:
     A) CHLINV2, FOR THE INVERSION OF A SYMMETRIC POSITIVE DEFINITE
     MATRIX, IF THE MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE
     PROCEDURE CHLDEC2, SECTION 3.1.1.1.1.2.1., OR CHLDECSOL2,
     SECTION 3.1.1.1.1.2.3.;
     B) CHLINV1, FOR THE INVERSION OF A SYMMETRIC POSITIVE DEFINITE
     MATRIX, IF THE MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE
     PROCEDURE CHLDEC1, SECTION 3.1.1.1.1.2.1., OR CHLDECSOL1,
     SECTION 3.1.1.1.1.2.3.;
     C) CHLDECINV2, FOR THE INVERSION OF A MATRIX BY CHOLESKY'S SQUARE
     ROOT METHOD;
     THE COEFFICIENT MATRIX HAS TO BE SYMMETRIC POSITIVE DEFINITE AND
     MUST BE GIVEN IN THE UPPER TRIANGLE OF A TWO-DIMENSIONAL ARRAY;
     D) CHLDECINV1, FOR THE INVERSION OF A MATRIX BY CHOLESKY'S SQUARE
     ROOT METHOD;
     THE COEFFICIENT MATRIX HAS TO BE SYMMETRIC POSITIVE DEFINITE AND
     MUST BE GIVEN COLUMNWISE IN A ONE-DIMENSIONAL ARRAY.
 
 
 KEYWORDS:
 
     MATRIX INVERSION,
     POSITIVE DEFINITE SYMMETRIC MATRIX,
     CHOLESKY DECOMPOSITION.
 
 
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 2
 
 
 
 SUBSECTION: CHLINV2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLINV2(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 34400;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE  CHOLESKY MATRIX
                    AS PRODUCED  BY CHLDEC2, SECTION  3.1.1.1.1.2.1., OR
                    CHLDECSOL2,  SECTION  3.1.1.1.1.2.3., MUST  BE GIVEN
                    IN THE UPPER TRIANGLE OF A;
             EXIT:  THE  UPPER-TRIANGULAR PART  OF THE INVERSE MATRIX IS
                    DELIVERED IN THE UPPER TRIANGLE OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX.
 
 
 PROCEDURES USED:
 
     MATVEC    = CP34011,
     TAMVEC    = CP34012,
     DUPVECROW = CP31031.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: N.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLINV2 CALCULATES THE INVERSE OF A MATRIX, PROVIDED
     THAT THE MATRIX HAS BEEN DECOMPOSED BY A SUCCESSFUL CALL OF CHLDEC2
     OR CHLDECSOL2;
     THE INVERSE, X, OF U'U, WHERE U IS THE CHOLESKY MATRIX,
     IS OBTAINED FROM THE CONDITIONS THAT X BE SYMMETRIC AND UX BE
     A LOWER-TRIANGULAR MATRIX WHOSE MAIN DIAGONAL ELEMENTS ARE THE
     RECIPROCALS OF THE DIAGONAL ELEMENTS OF U. HEREWITH THE UPPER-
     TRIANGULAR ELEMENTS OF X ARE CALCULATED BY BACK SUBSTITUTION.
     THE UPPER TRIANGLE OF THE INVERSE MATRIX IS DELIVERED IN THE UPPER
     TRIANGLE OF THE GIVEN ARRAY. SEE ALSO REF[1].
 
 
 REFERENCES:
 
     [1]. T.J. DEKKER.
          ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1.
          MC TRACT 22, 1968, MATH. CENTR., AMSTERDAM.
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 3
 
 
 
 EXAMPLE OF USE:
 
     THE SYMMETRIC POSITIVE DEFINITE  COEFFICIENT MATRIX  (THE  PASCAL
     MATRIX OF ORDER 4) OF THE SYSTEM OF EQUATIONS
         X1 +     X2 +      X3 +      X4 =  2
         X1 + 2 * X2 +  3 * X3 +  4 * X4 =  4
         X1 + 3 * X2 +  6 * X3 + 10 * X4 =  8
         X1 + 4 * X2 + 10 * X3 + 20 * X4 = 16
     IS STORED IN THE TWO-DIMENSIONAL ARRAY PASCAL2.
     THE  INVERSE OF  THE COEFFICIENT MATRIX  AND THE  SOLUTION  OF  THE
     LINEAR SYSTEM ARE CALCULATED BY THE FOLLOWING PROGRAM:
 
     "BEGIN" "COMMENT" TEST CHLDEC2, CHLSOL2 AND CHLINV2;
         "INTEGER" I, J;
         "ARRAY" PASCAL2[1:4,1:4], B[1:4], AUX[2:3];
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL2[1,J]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL2[I,J]:= "IF" I = J "THEN" PASCAL2[I-1,J] * 2 "ELSE"
                            PASCAL2[I,J-1] + PASCAL2[I-1,J];
             B[J]:= 2 ** J
         "END";
         AUX[2]:= "-11;
         CHLDEC2(PASCAL2, 4, AUX);
         "IF" AUX[3] = 4 "THEN"
         "BEGIN" CHLSOL2(PASCAL2, 4, B); CHLINV2(PASCAL2, 4) "END"
         "ELSE" OUTPUT(61, "(""("MATRIX NOT POSITIVE DEFINITE")", /")");
         OUTPUT(61, "("4B")");
         OUTPUT(61, "(""("SOLUTION WITH CHLDEC2 AND CHLSOL2:")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61, "("4B+D.5D")", B[I]);
         OUTPUT(61, "("//, 4B")");
         OUTPUT(61, "(""("INVERSE MATRIX WITH CHLINV2:")", /, 4B")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "IF" J < I "THEN" OUTPUT(61, "("12B")") "ELSE"
             OUTPUT(61, "("+ZD.5D3B")", PASCAL2[I,J]);
             OUTPUT(61, "("/, 4B")")
         "END"
     "END"
 
     THIS PROGRAM DELIVERS:
 
     SOLUTION WITH CHLDEC2 AND CHLSOL2:
     +0.00000    +4.00000    -4.00000    +2.00000
 
     INVERSE MATRIX WITH CHLINV2:
      +4.00000    -6.00000    +4.00000    -1.00000
                 +14.00000   -11.00000    +3.00000
                             +10.00000    -3.00000
                                          +1.00000
 
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 4
 
 
 
 SUBSECTION: CHLINV1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLINV1(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 34401;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:(N + 1) * N // 2];
             ENTRY: THE  UPPER-TRIANGULAR PART OF THE CHOLESKY  MATRIX
                    AS PRODUCED  BY CHLDEC1, SECTION  3.1.1.1.1.2.1., OR
                    CHLDECSOL1,  SECTION  3.1.1.1.1.2.3., MUST  BE GIVEN
                    COLUMNWISE IN ARRAY A;
             EXIT:  THE  UPPER-TRIANGULAR  PART OF THE INVERSE MATRIX IS
                    DELIVERED COLUMNWISE IN ARRAY A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX.
 
 PROCEDURES USED:
 
     SEQVEC    = CP34016,
     SYMMATVEC = CP34018.
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: N.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE: ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLINV1 CALCULATES THE INVERSE OF A MATRIX, PROVIDED
     THAT THE MATRIX HAS BEEN DECOMPOSED BY A SUCCESSFUL CALL OF CHLDEC1
     OR CHLDECSOL1;
     THE UPPER TRIANGLE OF THE INVERSE MATRIX IS DELIVERED COLUMNWISE
     IN THE ONE-DIMENSIONAL ARRAY.
     SEE ALSO METHOD AND PERFORMANCE OF CHLINV2 (THIS SECTION).
 
 EXAMPLE OF USE:
 
     THE SYMMETRIC POSITIVE DEFINITE  COEFFICIENT MATRIX  (THE  PASCAL
     MATRIX OF ORDER 4) OF THE SYSTEM OF EQUATIONS
         X1 +     X2 +      X3 +      X4 =  2
         X1 + 2 * X2 +  3 * X3 +  4 * X4 =  4
         X1 + 3 * X2 +  6 * X3 + 10 * X4 =  8
         X1 + 4 * X2 + 10 * X3 + 20 * X4 = 16
     IS STORED IN THE ONE-DIMENSIONAL ARRAY PASCAL1.
     THE  INVERSE OF  THE  COEFFICIENT MATRIX  AND THE  SOLUTION OF  THE
     LINEAR SYSTEM ARE CALCULATED BY THE FOLLOWING PROGRAM:
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 5
 
 
 
     "BEGIN" "COMMENT" TEST CHLDEC1, CHLSOL1 AND CHLINV1;
         "INTEGER" I, J, JJ;
         "ARRAY" PASCAL1[1:(4 + 1) * 4 // 2], B[1:4], AUX[2:3];
 
 
         JJ:= 1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL1[JJ]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL1[JJ + I - 1]:= "IF" I = J "THEN"
             PASCAL1[JJ + I - 2] * 2 "ELSE"
             PASCAL1[JJ + I - 2] + PASCAL1[JJ + I - J];
             B[J]:= 2 ** J;
             JJ:= JJ + J
         "END";
 
         AUX[2]:= "-11;
         CHLDEC1(PASCAL1, 4, AUX);
         "IF" AUX[3] = 4 "THEN"
         "BEGIN" CHLSOL1(PASCAL1, 4, B); CHLINV1(PASCAL1, 4) "END"
         "ELSE" OUTPUT(61, "(""("MATRIX NOT POSITIVE DEFINITE")", /")");
 
         OUTPUT(61,"("4B")");
         OUTPUT(61, "(""("SOLUTION WITH CHLDEC1 AND CHLSOL1:")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61, "("4B+D.5D")", B[I]);
         OUTPUT(61, "("2/, 4B")");
         OUTPUT(61, "(""("INVERSE MATRIX WITH CHLINV1:")", /, 4B")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "IF" J < I "THEN" OUTPUT(61, "("12B")") "ELSE"
             OUTPUT(61, "("+ZD.5D3B")", PASCAL1[(J - 1) * J // 2 + I]);
             OUTPUT(61, "("/, 4B")")
         "END"
     "END"
 
     THIS PROGRAM DELIVERS:
 
     SOLUTION WITH CHLDEC1 AND CHLSOL1:
     +0.00000    +4.00000    -4.00000    +2.00000
 
     INVERSE MATRIX WITH CHLINV1:
      +4.00000    -6.00000    +4.00000    -1.00000
                 +14.00000   -11.00000    +3.00000
                             +10.00000    -3.00000
                                          +1.00000
 
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 6
 
 
 
 SUBSECTION: CHLDECINV2.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDECINV2(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "CODE" 34402;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:N,1:N];
             ENTRY: THE UPPER  TRIANGLE OF THE  POSITIVE DEFINITE MATRIX
                    MUST  BE  GIVEN  IN  THE  UPPER TRIANGLE  OF  A (THE
                    ELEMENTS A[I,J], I <= J);
             EXIT:  THE  UPPER-TRIANGULAR  PART OF THE INVERSE MATRIX IS
                    DELIVERED IN THE UPPER TRIANGLE OF A.
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS;
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
 
 
 PROCEDURES USED:
 
     CHLDEC2 = CP34310,
     CHLINV2 = CP34400.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLDECINV2 CALCULATES THE INVERSE OF A SYMMETRIC
     POSITIVE DEFINITE MATRIX BY CALLING CHLDEC2 AND, IF THIS CALL WAS
     SUCCESSFUL, CHLINV2.
     THE UPPER TRIANGLE OF THE INVERSE MATRIX IS DELIVERED IN THE UPPER
     TRIANGLE OF THE GIVEN ARRAY.
     SEE ALSO METHOD AND PERFORMANCE OF CHLINV2 (THIS SECTION) AND
     CHLDEC2, SECTION 3.1.1.1.1.2.1.
 
 
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 7
 
 
 
 EXAMPLE OF USE:
 
     THE SYMMETRIC POSITIVE DEFINITE  COEFFICIENT MATRIX  (THE  PASCAL
     MATRIX OF ORDER 4) OF THE SYSTEM OF EQUATIONS
 
         X1 +     X2 +      X3 +      X4 =  2
         X1 + 2 * X2 +  3 * X3 +  4 * X4 =  4
         X1 + 3 * X2 +  6 * X3 + 10 * X4 =  8
         X1 + 4 * X2 + 10 * X3 + 20 * X4 = 16
 
     IS STORED IN THE TWO-DIMENSIONAL ARRAY PASCAL2.
     THE DETERMINANT AND  THE INVERSE OF THE COEFFICIENT MATRIX  AND THE
     SOLUTION  OF THE  LINEAR SYSTEM ARE  CALCULATED  BY  THE  FOLLOWING
     PROGRAM:
 
     "BEGIN" "COMMENT" TEST CHLDECSOL2, CHLDETERM2 AND CHLDECINV2;
         "INTEGER" I, J;
         "ARRAY" PASCAL2[1:4,1:4], B[1:4], AUX[2:3];
         "REAL" DETERMINANT;
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL2[1,J]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL2[I,J]:= "IF" I = J "THEN" PASCAL2[I-1,J] * 2 "ELSE"
                            PASCAL2[I,J-1] + PASCAL2[I-1,J];
             B[J]:= 2 ** J
         "END";
         AUX[2]:= "-11;
         CHLDECSOL2(PASCAL2, 4, AUX, B);
         "IF" AUX[3] = 4 "THEN" DETERMINANT:= CHLDETERM2(PASCAL2, 4)
         "ELSE" OUTPUT(61, "(""("MATRIX NOT POSITIVE DEFINITE")", /")");
         OUTPUT(61, "("4B")");
         OUTPUT(61, "(""("SOLUTION WITH CHLDECSOL2:")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61, "("4B+D.5D")", B[I]);
         OUTPUT(61, "("//, 4B, "("DETERMINANT WITH CHLDETERM2: ")",
                    +D.5D, 2/, 4B")", DETERMINANT);
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL2[1,J]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL2[I,J]:= "IF" I = J "THEN" PASCAL2[I-1,J] * 2 "ELSE"
                            PASCAL2[I,J-1] + PASCAL2[I-1,J]
         "END";
         CHLDECINV2(PASCAL2, 4, AUX);
         OUTPUT(61, "(""("INVERSE MATRIX WITH CHLDECINV2:")", /, 4B")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "IF" J < I "THEN" OUTPUT(61, "("12B")") "ELSE"
             OUTPUT(61, "("+ZD.5D3B")", PASCAL2[I,J]);
             OUTPUT(61, "("/, 4B")")
         "END"
     "END"
 
1SECTION: 3.1.1.1.1.2.4       (DECEMBER 1975)                     PAGE 8
 
 
 
     THIS PROGRAM DELIVERS:
 
     SOLUTION WITH CHLDECSOL2:
     +0.00000    +4.00000    -4.00000    +2.00000
 
     DETERMINANT WITH CHLDETERM2: +1.00000
 
     INVERSE MATRIX WITH CHLDECINV2:
      +4.00000    -6.00000    +4.00000    -1.00000
                 +14.00000   -11.00000    +3.00000
                             +10.00000    -3.00000
                                          +1.00000
 
 
 SUBSECTION: CHLDECINV1.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" CHLDECINV1(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "CODE" 34403;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY" A[1:(N + 1) * N // 2];
              ENTRY: THE UPPER-TRIANGULAR PART OF THE SYMMETRIC POSITIVE
                    DEFINITE MATRIX  MUST BE GIVEN COLUMNWISE IN ARRAY A
                    (THE (I,J)-TH ELEMENT OF THE MATRIX MUST BE GIVEN IN
                    A[(J - 1) * J // 2 + I] FOR 1 <= I <= J <= N);
             EXIT:  THE  UPPER-TRIANGULAR  PART OF THE INVERSE MATRIX IS
                    DELIVERED COLUMNWISE IN ARRAY A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:3];
             ENTRY: AUX[2]: A  RELATIVE TOLERANCE  USED TO  CONTROL  THE
                    CALCULATION OF THE DIAGONAL ELEMENTS; (SEE METHOD
                    AND PERFORMANCE OF CHLDEC2, SECTION 3.1.1.1.1.2.1);
             NORMAL EXIT:   AUX[3]:= N;
             ABNORMAL EXIT: IF THE  DECOMPOSITION CANNOT BE  CARRIED OUT
                    BECAUSE  THE  MATRIX  IS (NUMERICALLY) NOT  POSITIVE
                    DEFINITE,  AUX[3]:= K - 1, WHERE K IS THE LAST STAGE
                    NUMBER.
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                          PAGE 9
 
 
 
 PROCEDURES USED:
 
     CHLDEC1 = CP34311,
     CHLINV1 = CP34401.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE PROCEDURE CHLDECINV1 CALCULATES THE INVERSE OF A SYMMETRIC
     POSITIVE DEFINITE MATRIX BY CALLING CHLDEC1 AND, IF THIS CALL WAS
     SUCCESSFUL, CHLINV1.
     THE UPPER TRIANGLE OF THE INVERSE MATRIX IS DELIVERED COLUMNWISE IN
     THE GIVEN ONE-DIMENSIONAL ARRAY.
     SEE ALSO METHOD AND PERFORMANCE OF CHLINV2, (THIS SECTION) AND
     CHLDEC1, SECTION 3.1.1.1.1.2.1.
 
 
 EXAMPLE OF USE:
 
     THE SYMMETRIC POSITIVE DEFINITE  COEFFICIENT MATRIX  (THE  PASCAL
     MATRIX OF ORDER 4) OF THE SYSTEM OF EQUATIONS
 
         X1 +     X2 +      X3 +      X4 =  2
         X1 + 2 * X2 +  3 * X3 +  4 * X4 =  4
         X1 + 3 * X2 +  6 * X3 + 10 * X4 =  8
         X1 + 4 * X2 + 10 * X3 + 20 * X4 = 16
 
     IS STORED IN THE ONE-DIMENSIONAL ARRAY PASCAL1.
     THE DETERMINANT AND  THE INVERSE OF THE COEFFICIENT MATRIX  AND THE
     SOLUTION  OF THE  LINEAR SYSTEM ARE  CALCULATED  BY  THE  FOLLOWING
     PROGRAM:
1SECTION: 3.1.1.1.1.2.4       (DECEMBER 1975)                    PAGE 10
 
 
 
     "BEGIN" "COMMENT" TEST CHLDECSOL1, CHLDETERM1 AND CHLDECINV1;
         "INTEGER" I, J, JJ;
         "ARRAY" PASCAL1[1:(4 + 1) * 4 // 2], B[1:4], AUX[2:3];
         "REAL" DETERMINANT;
 
         JJ:= 1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL1[JJ]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL1[JJ + I - 1]:= "IF" I = J "THEN"
             PASCAL1[JJ + I - 2] * 2 "ELSE"
             PASCAL1[JJ + I - 2] + PASCAL1[JJ + I - J];
             B[J]:= 2 ** J;
             JJ:= JJ + J
         "END";
 
         AUX[2]:= "-11;
         CHLDECSOL1(PASCAL1, 4, AUX, B);
         "IF" AUX[3] = 4 "THEN" DETERMINANT:= CHLDETERM1(PASCAL1, 4)
         "ELSE" OUTPUT(61, "(""("MATRIX NOT POSITIVE DEFINITE")", /")");
 
         OUTPUT(61, "("4B")");
         OUTPUT(61, "(""("SOLUTION WITH CHLDECSOL1:")", /")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61, "("4B+D.5D")", B[I]);
         OUTPUT(61, "("//, 4B, "("DETERMINANT WITH CHLDETERM1: ")",
                    +D.5D, 2/, 4B")", DETERMINANT);
 
         JJ:= 1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" PASCAL1[JJ]:= 1;
             "FOR" I:= 2 "STEP" 1 "UNTIL" J "DO"
             PASCAL1[JJ + I - 1]:= "IF" I = J "THEN"
             PASCAL1[JJ + I - 2] * 2 "ELSE"
             PASCAL1[JJ + I - 2] + PASCAL1[JJ + I - J];
             JJ:= JJ + J
         "END";
 
 
         CHLDECINV1(PASCAL1, 4, AUX);
 
         OUTPUT(61, "(""("INVERSE MATRIX WITH CHLDECINV1:")", /, 4B")");
         "FOR" I:= 1 "STEP" 1 "UNTIL" 4 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" 4 "DO"
             "IF" J < I "THEN" OUTPUT(61, "("12B")") "ELSE"
             OUTPUT(61, "("+ZD.5D3B")", PASCAL1[(J - 1) * J // 2 + I]);
             OUTPUT(61, "("/, 4B")")
         "END"
     "END"
 
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                         PAGE 11
 
 
 
     THIS PROGRAM DELIVERS:
 
     SOLUTION WITH CHLDECSOL1:
     +0.00000    +4.00000    -4.00000    +2.00000
 
     DETERMINANT WITH CHLDETERM1: +1.00000
 
     INVERSE MATRIX WITH CHLDECINV1:
      +4.00000    -6.00000    +4.00000    -1.00000
                 +14.00000   -11.00000    +3.00000
                             +10.00000    -3.00000
                                          +1.00000
 
0SOURCE TEXT(S) :
 
 "CODE" 34400;
     "PROCEDURE" CHLINV2(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "BEGIN" "REAL" R; "INTEGER" I, J, I1;
         "ARRAY" U[1:N];
 
         "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" R:= 1 / A[I,I]; I1:= I + 1;
             DUPVECROW(I1, N, I, U, A);
             "FOR" J:= N "STEP" - 1 "UNTIL" I1 "DO" A[I,J]:=
             - (TAMVEC(I1, J, J, A, U) + MATVEC(J + 1, N, J, A, U)) * R;
             A[I,I]:= (R - MATVEC(I1, N, I, A, U)) * R
         "END"
     "END" CHLINV2;
         "EOP"
 
 "CODE" 34401;
     "PROCEDURE" CHLINV1(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "BEGIN" "INTEGER" I, II, I1, J, IJ; "REAL" R;
         "ARRAY" U[1:N];
 
         II:= (N + 1) * N // 2;
         "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" R:= 1 / A[II]; I1:= I + 1; IJ:= II + I;
             "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" U[J]:= A[IJ]; IJ:= IJ + J "END";
             "FOR" J:= N "STEP" - 1 "UNTIL" I1 "DO"
             "BEGIN" IJ:= IJ - J; A[IJ]:= -SYMMATVEC(I1, N, J, A, U) * R
             "END";
             A[II]:= (R - SEQVEC(I1, N, II + I, 0, A, U)) * R;
             II:= II - I
         "END"
     "END" CHLINV1
1SECTION: 3.1.1.1.1.2.4       (MAY 1974)                         PAGE 12
 
 
                                                                  ;
         "EOP"
 "CODE" 34402;
     "PROCEDURE" CHLDECINV2(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN"
 
         CHLDEC2(A, N, AUX);
         "IF" AUX[3] = N "THEN" CHLINV2(A, N)
     "END" CHLDECINV2;
         "EOP"
 
 "CODE" 34403;
     "PROCEDURE" CHLDECINV1(A, N, AUX); "VALUE" N; "INTEGER" N;
     "ARRAY" A, AUX;
     "BEGIN"
 
         CHLDEC1(A, N, AUX);
         "IF" AUX[3] = N "THEN" CHLINV1(A, N)
     "END" CHLDECINV1;
         "EOP"
1SECTION : 3.1.1.1.1.3.1     ( DECEMBER 1978 )                    PAGE 1
 
 
 
 AUTHORS : J.R.BUNCH,L,KAUFMAN,B.N.PARLETT.
 
 
 CONTRIBUTOR : C.H.CONVENT.
 
 
 INSTITUTE : UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED : 770712.
 
 
 BRIEF DESCRIPTION :
 
     DECSYM2 CALCULATES THE LDL' DECOMPOSITION OF A SYMMETRIC MATRIX.
     THE MATRIX MAY BE INDEFINITE AND/OR SINGULAR;
 
 
 KEYWORDS :
 
     GENERAL SYMMETRIC MATRIX,
     LDL' DECOMPOSITION,
     BLOCK DIAGONAL PIVOTING;
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" DECSYM2(A,N,TOL,AUX,P,DETAUX);
     "VALUE" N;"INTEGER" N;"REAL" TOL;
     "ARRAY" A,DETAUX;"INTEGER" "ARRAY" AUX,P;
     "CODE" 34291;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A :     <ARRAY IDENTIFIER>;
            "ARRAY" A[1:N,1:N];
            ENTRY : THE SYMMETRIC COEFFICIENT MATRIX;
            EXIT  : THE ELEMENTS OF THE LDL' DECOMPOSITION OF A ARE
                    STORED IN THE UPPER TRIANGULAR PART OF A. HERE D
                    IS A BLOCK DIAGONAL MATRIX WITH BLOCKS OF ORDER 1
                    OR 2. FOR A BLOCK OF ORDER 2 WE ALWAYS HAVE
                    D[I,I+1]^=0 AND L[I+1,I]=0,SO THAT D AND L' FIT
                    IN THE UPPER TRIANGULAR PART OF A.
                    THE STRICTLY LOWER TRIANGULAR PART OF A IS LEFT
                    UNDISTURBED.
     N :     <ARITHMETIC EXPRESSION>;
            THE ORDER OF THE MATRIX;
1SECTION : 3.1.1.1.1.3.1     ( DECEMBER 1978 )                    PAGE 2
 
 
 
     TOL :  <ARITHMETIC EXPRESSION>;
           A RELATIVE TOLERANCE, USED TO CONTROL THE
           CALCULATION OF THE BLOCK DIAGONAL ELEMENTS;
     AUX :   <ARRAY IDENTIFIER>;
            "INTEGER" "ARRAY" AUX[2:5];
            EXIT :
            AUX[2] : IF THE MATRIX IS SYMMETRIC THEN 1, OTHER-
                     WISE 0;IN THE LAST CASE NO DECOMPOSITION
                     IS PERFORMED;
            AUX[3] : IF THE MATRIX IS SYMMETRIC THEN THE
                     NUMBER OF ITS POSITIVE EIGENVALUES,
                     OTHERWISE 0. IF AUX[3]=N THEN THE
                     MATRIX IS POSITIVE DEFINITE;
            AUX[4] : IF THE MATRIX IS SYMMETRIC THEN THE
                     NUMBER OF ITS NEGATIVE EIGENVALUES,
                     OTHERWISE 0. IF AUX[4]=N THEN THE
                     MATRIX IS NEGATIVE DEFINITE;
            AUX[5] : IF THE MATRIX IS SYMMETRIC THEN THE
                     NUMBER OF ITS ZERO EIGENVALUES, OTHERWISE
                     N; SO, IF AUX[5]=0 THEN THE MATRIX IS
                     SYMMETRIC AND NON-SINGULAR;
     P :     <ARRAY IDENTIFIER>;
            "INTEGER" "ARRAY" P[1:N];
            EXIT :
            A VECTOR RECORDING
            1) THE INTERCHANGES PERFORMED ON A DURING THE
               COMPUTATION OF THE DECOMPOSITION AND
            2) THE BLOCK STRUCTURE OF D.
            IF P[I]>0 AND P[I+1]=0 A 2*2 BLOCK HAS BEEN
            FOUND I.E. D[I,I+1]^=0 AND L[I+1,I]=0;
     DETAUX : <ARRAY IDENTIFIER>;
             "ARRAY" DETAUX[1:N];
             EXIT :
             IF P[I]>0 AND P[I+1]>0 THEN DETAUX[I] EQUALS
             THE EXIT-VALUE OF A[I,I].
             IF P[I]>0 AND P[I+1]=0 THEN DETAUX[I]=1 AND
             DETAUX[I+1] EQUALS THE VALUE OF THE DETERMINANT
             OF THE CORRESPONDING 2*2 DIAGONAL BLOCK AS
             DETERMINED BY DECSYM2;
 
 
 PROCEDURES USED :
 
     ELMROW=CP34030.
     ICHROW=CP34032.
     ICHROWCOL=CP34033.
1SECTION : 3.1.1.1.1.3.1     ( DECEMBER 1978 )                    PAGE 3
 
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO N**3.
 
 
 METHOD AND PERFORMANCE :
 
     THE PROCEDURE DECSYM2 COMPUTES THE LDL' DECOMPOSITION OF A
     SYMMETRIC MATRIX,ACCORDING TO A METHOD DUE TO BUNCH,KAUFMAN AND
     PARLETT (SEE [1],[2]). IT USES BLOCK DIAGONAL PIVOTING.
     THE BLOCK DIAGONAL MATRIX D IS DELIVERED IN THE BLOCK DIAGONAL
     OF A. IF P[I]>0 AND P[I+1]=0 A 2*2 BLOCK HAS BEEN FOUND AND
     FURTHERMORE : L[I+1,I]=0 WHEN D[I,I+1]^=0.
     THE STRICTLY UPPER TRIANGULAR PART OF L' IS DELIVERED IN THE
     STRICTLY UPPER TRIANGULAR PART OF A. FOR THE INERTIA PROBLEM
     IT IS IMPORTANT THAT DECSYM2 CAN ACCEPT SINGULAR MATRICES.
     NOTE, HOWEVER, THAT IN ORDER TO FIND THE NUMBER OF ZERO
     EIGENVALUES OF SINGULAR MATRICES, THE SINGULAR VALUE
     DECOMPOSITION MIGHT BE PREFERRED.
     BEFORE THE DECOMPOSITION IS PERFORMED A CHECK IS MADE TO SEE
     WHETHER THE MATRIX IS SYMMETRIC. IF THE MATRIX IS ASYMMETRIC
     THEN NO DECOMPOSITION IS PERFORMED;
 
 
 REFERENCES :
 
     1) J.R.BUNCH,L.KAUFMAN.
       SOME STABLE METHODS FOR CALCULATING INERTIA AND SOLVING
       SYMMETRIC LINEAR SYSTEMS.
       MATHEMATICS OF COMPUTATION 31,P 163-180,1977.
     2) J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
       DECOMPOSITION OF A SYMMETRIC MATRIX.
       NUMERISCHE MATHEMATIK 27,P 95-109,1976.
1SECTION : 3.1.1.1.1.3.1     ( DECEMBER 1978 )                    PAGE 4
 
 
 
 SOURCE TEXT :
 "CODE" 34291;
 "PROCEDURE" DECSYM2(A,N,TOL,AUX,P,DETAUX);
 "VALUE" N;"INTEGER" N;"REAL" TOL;
 "ARRAY" A,DETAUX;"INTEGER" "ARRAY" P,AUX;
 "BEGIN" "INTEGER" I,J,K,M,IP1,IP2,DUMMY;"BOOLEAN" ONEBYONE,SYM;
     "REAL" DET,S,T,ALPHA,LAMBDA,SIGMA,AII,AIP1,AIP1I;
     AUX[3]:=AUX[4]:=0;SYM:="TRUE";I:=0;
     "FOR" DUMMY:=0 "WHILE" SYM "AND" (I<N) "DO"
     "BEGIN" I:=I+1;J:=I;
       "FOR" M:=0 "WHILE" SYM "AND" (J<N) "DO"
       "BEGIN" J:=J+1;SYM:=SYM "AND" (A[I,J]=A[J,I]) "END";
     "END";
     "IF" SYM "THEN" AUX[2]:=1
         "ELSE" "BEGIN" AUX[2]:=0;"GOTO" ENDDEC "END";
     ALPHA:=(1+SQRT(17))/8;P[N]:=N;I:=1;
     "FOR" DUMMY:=0 "WHILE" I<N "DO"
     "BEGIN" IP1:=I+1;IP2:=I+2;AII:=ABS(A[I,I]);P[I]:=I;
       LAMBDA:=ABS(A[I,IP1]);J:=IP1;
       "FOR" M:=IP2 "STEP" 1 "UNTIL" N "DO"
       "IF" ABS(A[I,M])>LAMBDA "THEN"
       "BEGIN" J:=M;LAMBDA:=ABS(A[I,M]) "END";
       T:=ALPHA*LAMBDA;ONEBYONE:="TRUE";
       "IF" AII<T "THEN"
       "BEGIN" SIGMA:=LAMBDA;
          "FOR" M:=IP1 "STEP" 1 "UNTIL" J-1 "DO"
             "IF" ABS(A[M,J])>SIGMA "THEN" SIGMA:=ABS(A[M,J]);
          "FOR" M:=J+1 "STEP" 1 "UNTIL" N "DO"
             "IF" ABS(A[J,M])>SIGMA "THEN" SIGMA:=ABS(A[J,M]);
          "IF" SIGMA*AII<LAMBDA "THEN"
          "BEGIN" "IF" ALPHA*SIGMA<ABS(A[J,J]) "THEN"
             "BEGIN" ICHROW(J+1,N,I,J,A);ICHROWCOL(IP1,J-1,I,J,A);
                T:=A[I,I];A[I,I]:=A[J,J];A[J,J]:=T;P[I]:=J
             "END"
             "ELSE"
             "BEGIN" "IF" J>IP1 "THEN"
               "BEGIN" ICHROW(J+1,N,IP1,J,A);ICHROWCOL(IP2,J-1,IP1,J,A);
                   T:=A[I,I];A[I,I]:=A[J,J];A[J,J]:=T;
                   T:=A[I,J];A[I,J]:=A[I,IP1];A[I,IP1]:=T
                "END";
                DET:=A[I,I]*A[IP1,IP1]-A[I,IP1]**2;AIP1I:=A[I,IP1]/DET;
                AII:=A[I,I]/DET;AIP1:=A[IP1,IP1]/DET;P[I]:=J;P[IP1]:=0;
                DETAUX[I]:=1;DETAUX[IP1]:=DET;                 "COMMENT"
1SECTION : 3.1.1.1.1.3.1     ( DECEMBER 1978 )                    PAGE 5
                                                                  ;
 
 
                "FOR" J:=IP2 "STEP" 1 "UNTIL" N "DO"
                "BEGIN" S:=AIP1I*A[IP1,J]-AIP1*A[I,J];
                   T:=AIP1I*A[I,J]-AII*A[IP1,J];ELMROW(J,N,J,I,A,A,S);
                   ELMROW(J,N,J,IP1,A,A,T);A[I,J]:=S;A[IP1,J]:=T
                "END";
                AUX[3]:=AUX[3]+1;AUX[4]:=AUX[4]+1;I:=IP2;
                ONEBYONE:="FALSE"
             "END"
          "END"
       "END";
       "IF" ONEBYONE "THEN"
       "BEGIN" "IF" TOL<ABS(A[I,I]) "THEN"
          "BEGIN" AII:=A[I,I];DETAUX[I]:=A[I,I];
             "IF" AII>0 "THEN" AUX[3]:=AUX[3]+1 "ELSE" AUX[4]:=AUX[4]+1;
             "FOR" J:=IP1 "STEP" 1 "UNTIL" N "DO"
            "BEGIN" S:=-A[I,J]/AII;ELMROW(J,N,J,I,A,A,S);A[I,J]:=S "END"
          "END";I:=IP1
       "END"
     "END" WHILE I;
     "IF" I=N "THEN"
     "BEGIN" "IF" TOL<ABS(A[N,N]) "THEN"
       "BEGIN" "IF" A[N,N]>0 "THEN" AUX[3]:=AUX[3]+1
               "ELSE" AUX[4]:=AUX[4]+1
       "END";DETAUX[N]:=A[N,N]
     "END";
   ENDDEC:
     AUX[5]:=N-AUX[3]-AUX[4]
 "END" DECSYM2;
         "EOP"
1SECTION : 3.1.1.1.1.3.2     ( DECEMBER 1978 )                    PAGE 1
 
 
 
 AUTHORS : J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
 
 
 CONTRIBUTOR : C.H.CONVENT.
 
 
 INSTITUTE : UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED : 770712.
 
 
 BRIEF DESCRIPTION :
 
     DETERMSYM2 CALCULATES THE DETERMINANT OF A SYMMETRIC MATRIX.
     THE LDL' DECOMPOSITION OF THE MATRIX, AS PRODUCED BY DECSYM2,
     SHOULD BE AVAILABLE.
 
 
 KEYWORDS :
 
     GENERAL SYMMETRIC MATRIX,
     LDL' DECOMPOSITION,
     BLOCK DIAGONAL PIVOTING;
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "REAL" "PROCEDURE" DETERMSYM2(DETAUX,N,AUX);
     "VALUE" N;"INTEGER" N;
     "ARRAY" DETAUX;"INTEGER" "ARRAY" AUX;
     "CODE" 34294;
 
     DETERMSYM2 : DELIVERS THE CALCULATED VALUE OF THE DETERMINANT OF
                  THE MATRIX;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     DETAUX :    <ARRAY IDENTIFIER>;
                 "ARRAY" DETAUX[1:N];
                 ENTRY : THE ARRAY DETAUX AS PRODUCED BY DECSYM2;
     N      :    <ARITHMETIC EXPRESSION>;
                 THE ORDER OF THE ARRAY DETAUX
                     ( = THE ORDER OF THE MATRIX );
     AUX    :    <ARRAY IDENTIFIER>;
                 "INTEGER" "ARRAY" AUX[2:5];
                 ENTRY : THE ARRAY AUX AS PRODUCED BY DECSYM2;
 
 
 PROCEDURES USED : NONE.
 
1SECTION : 3.1.1.1.1.3.2     ( DECEMBER 1978 )                    PAGE 2
 
 
 
 RUNNING TIME : PROPORTIONAL TO N;
 
 
 
 METHOD AND PERFORMANCE :
 
     FIRST OF ALL DECSYM2 SHOULD BE CALLED TO PERFORM THE LDL'
     DECOMPOSITION OF THE SYMMETRIC MATRIX,ACCORDING TO A METHOD DUE
     TO BUNCH,KAUFMAN AND PARLETT (SEE [1],[2]).
     IF A 1*1 BLOCK HAS BEEN COMPUTED FOR D THEN DETAUX[I] CONTAINS
     THE VALUE OF D[I]. IF A 2*2 BLOCK HAS BEEN COMPUTED FOR D THEN
     DETAUX[I]=1 AND DETAUX[I+1] CONTAIN THE VALUE OF THE DETERMINANT
     OF THE CORRESPONDING 2*2 BLOCK.
     THE COMPUTATION OF THE DETERMINANT IS DONE BY CALCULATING THE
     PRODUCT OF THE ELEMENTS OF DETAUX.
 
 
 REFERENCES :
 
     1) J.R.BUNCH,L.KAUFMAN.
       SOME STABLE METHODS FOR CALCULATING INERTIA AND SOLVING
       SYMMETRIC LINEAR SYSTEMS.
       MATHEMATICS OF COMPUTATION 31,P 163-180,1977.
     2) J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
       DECOMPOSITION OF A SYMMETRIC MATRIX.
       NUMERISCHE MATHEMATIK 27,P 95-109,1976.
 
 
 
 
 EXAMPLE OF USE  :
 
 "BEGIN" "COMMENT" EXAMPLE OF USE OF THE PROCEDURE DETERMSYM2;
         "INTEGER" I,J;"REAL" TOL,DETERMINANT;
         "REAL" "ARRAY" A[1:5,1:5],DETAUX[1:5];
         "INTEGER" "ARRAY" AUX[2:5],P[1:5];
 
         A[1,1]:=A[1,2]:=-3;A[1,3]:=-18;A[1,4]:=-30;A[1,5]:=18;
         A[2,2]:=-1;A[2,3]:=-4;A[2,4]:=-48;A[2,5]:=8;
         A[3,3]:=-6;A[3,4]:=-274;A[3,5]:=6;
         A[4,4]:=119;A[4,5]:=19;
         A[5,5]:=216;
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         "FOR" J:=I+1 "STEP" 1 "UNTIL" 5 "DO" A[J,I]:=A[I,J];
                                                               "COMMENT"
1SECTION : 3.1.1.1.1.3.2     ( DECEMBER 1978 )                    PAGE 3
                                                                  ;
 
 
         OUTPUT(61,"(""("THE COEFFICIENT MATRIX :")",/")");
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         "BEGIN" "FOR" J:=1 "STEP" 1 "UNTIL" 5 "DO"
                 OUTPUT(61,"("-2ZD,4B")",A[I,J]);
                 OUTPUT(61,"("/")")
         "END";
         TOL:="-14;
         DECSYM2(A,5,TOL,AUX,P,DETAUX);
         "IF" AUX[2]=1 "THEN"
              OUTPUT(61,"("/,"("THE MATRIX IS SYMMETRIC")"")")
         "ELSE" OUTPUT(61,"("/,"("THE MATRIX IS ASYMMETRIC.THE ")",
                            "("RESULTS ARE MEANINGLESS")"")");
         DETERMINANT:=DETERMSYM2(DETAUX,5,AUX);
         OUTPUT(61,"("/,"("THE DETERMINANT OF THE MATRIX : ")",
                     3Z3D.2D")",DETERMINANT)
 "END"
 
 
 THIS DELIVERS AS RESULT :
 
 
     THE COEFFICIENT MATRIX :
      -3      -3     -18    -30     18
      -3      -1      -4    -48      8
     -18      -4      -6   -274      6
     -30     -48    -274    119     19
      18       8       6     19    216
 
     THE MATRIX IS SYMMETRIC.
     THE DETERMINANT OF THE MATRIX :    168.00
 
 
 SOURCE TEXT :
0"CODE" 34294;
 "REAL" "PROCEDURE" DETERMSYM2(DETAUX,N,AUX);
 "VALUE" N;"INTEGER" N;
 "ARRAY" DETAUX;"INTEGER" "ARRAY" AUX;
 "BEGIN" "INTEGER" I;"REAL" DET;
         "IF" AUX[5]>0 "THEN" DET:=0 "ELSE"
         "BEGIN" DET:=1;
                 "FOR" I:=1 "STEP" 1 "UNTIL" N "DO" DET:=DET*DETAUX[I]
         "END";
         DETERMSYM2:=DET
 "END" DETERMSYM2;
         "EOP"
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 1
 
 
 
 AUTHORS : J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
 
 
 CONTRIBUTOR : C.H.CONVENT.
 
 
 INSTITUTE : UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED : 770712.
 
 
 BRIEF DESCRIPTION :
 
 THIS SECTION CONTAINS TWO PROCEDURES :
 A) SOLSYM2 SOLVES A SYMMETRIC SYSTEM OF LINEAR EQUATIONS, ASSUMING
     THAT THE MATRIX HAS BEEN DECOMPOSED INTO LDL' FORM BY A CALL OF
     DECSYM2;
 B) DECSOLSYM2 CALCULATES THE LDL' DECOMPOSITION OF A SYMMETRIC
     MATRIX; MOREOVER, IF THIS MATRIX IS NON-SINGULAR, THEN IT SOLVES A
     CORRESPONDING SYSTEM OF LINEAR EQUATIONS;
 
 
 KEYWORDS :
 
     GENERAL SYMMETRIC MATRIX,
     LDL' DECOMPOSITION,
     BLOCK DIAGONAL PIVOTING;
 
 
 SUBSECTION : SOLSYM2.
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" SOLSYM2(A,N,B,P,DETAUX);
     "VALUE" N;"INTEGER" N;
     "ARRAY" A,B,DETAUX;"INTEGER" "ARRAY" P;
     "CODE" 34292;
 
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 2
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A :     <ARRAY IDENTIFIER>;
            "ARRAY" A[1:N,1:N];
            ENTRY : THE LDL' DECOMPOSITION OF A AS PRODUCED BY
                    DECSYM2;
     N :     <ARITHMETIC EXPRESSION>;
            THE ORDER OF THE MATRIX;
     B :     <ARRAY IDENTIFIER>;
            "ARRAY" B[1:N];
            ENTRY : THE RIGHT-HANDSIDE OF A SYSTEM OF LINEAR
                    EQUATIONS;
            EXIT  : THE CALCULATED SOLUTION VECTOR;
     P :     <ARRAY IDENTIFIER>;
            "INTEGER" "ARRAY" P[1:N];
            ENTRY : A VECTOR RECORDING THE INTERCHANGES PERFORMED ON
                    THE MATRIX BY THE PROCEDURE DECSYM2. P ALSO CONTAINS
                    INFORMATION ON THE BLOCKSTRUCTURE OF THE MATRIX AS
                    DECOMPOSED BY DECSYM2;
     DETAUX : <ARRAY IDENTIFIER>;
             "ARRAY" DETAUX[1:N];
             ENTRY : THE ARRAY DETAUX AS PRODUCED BY DECSYM2;
 
 
 PROCEDURES USED :
 
     MATVEC=CP34011.
     ELMVECROW=CP34026.
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO N**2.
 
 
 METHOD AND PERFORMANCE :
 
     THE PROCEDURE SOLSYM2 COMPUTES THE SOLUTION OF A SYMMETRIC
     SYSTEM OF LINEAR EQUATIONS,ASSUMING THAT THE MATRIX HAS BEEN
     DECOMPOSED INTO LDL' FORM BY A CALL OF DECSYM2. B IS OVERWRITTEN
     WITH THE SOLUTION VECTOR.
 
 
 REFERENCES :
 
     1) J.R.BUNCH,L.KAUFMAN.
       SOME STABLE METHODS FOR CALCULATING INERTIA AND SOLVING
       SYMMETRIC LINEAR SYSTEMS.
       MATHEMATICS OF COMPUTATION 31,P 163-180,1977.
     2) J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
       DECOMPOSITION OF A SYMMETRIC MATRIX.
       NUMERISCHE MATHEMATIK 27,P 95-109,1976.
 
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 3
 
 
 
 SUBSECTION : DECSOLSYM2.
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" DECSOLSYM2(A,N,B,TOL,AUX);
     "VALUE" N;"INTEGER" N;"REAL" TOL;
     "ARRAY" A,B;"INTEGER" "ARRAY" AUX;
     "CODE" 34293;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A :     <ARRAY IDENTIFIER>;
            "ARRAY" A[1:N,1:N];
            ENTRY : SEE DECSYM2;
            EXIT  : SEE DECSYM2;
     N :     <ARITHMETIC EXPRESSION>;
            THE ORDER OF THE MATRIX;
     B :     <ARRAY IDENTIFIER>;
            "ARRAY" B[1:N];
            ENTRY : SEE SOLSYM2;
            EXIT  : THE CALCULATED SOLUTION VECTOR,WHEN A WAS FOUND
                    TO BE NON-SINGULAR.
                    B IS LEFT UNDISTURBED OTHERWISE;
     TOL :   <ARITHMETIC EXPRESSION>;
            ENTRY : SEE DECSYM2;
     AUX :   <ARRAY IDENTIFIER>;
            "INTEGER" "ARRAY" AUX[2:5];
            EXIT  : SEE DECSYM2;
 
 PROCEDURES USED :
 
     DECSYM2=CP34291.
     SOLSYM2=CP34292.
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO N**3.
 
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 4
 
 
 
 METHOD AND PERFORMANCE :
 
     THE PROCEDURE DECSOLSYM2 COMPUTES THE SOLUTION OF A SYMMETRIC
     SYSTEM OF LINEAR EQUATIONS. IT DOES SO BY FIRST CALLING THE
     PROCEDURE DECSYM2 TO COMPUTE THE LDL' DECOMPOSITION OF THE
     SYMMETRIC MATRIX,ACCORDING TO A METHOD DUE TO BUNCH,KAUFMAN AND
     PARLETT (SEE [1],[2]).
     WHEN THE MATRIX IS FOUND TO BE NON-SINGULAR THE PROCEDURE SOLSYM2
     IS CALLED TO COMPUTE THE SOLUTION VECTOR,AND THE LATTER OVERWRITES
     B. WHEN THE MATRIX IS FOUND TO BE SINGULAR THE PROCEDURE SOLSYM2
     IS NOT CALLED AND B IS LEFT UNDISTURBED.
 
 
 REFERENCES :
 
     1) J.R.BUNCH,L.KAUFMAN.
       SOME STABLE METHODS FOR CALCULATING INERTIA AND SOLVING
       SYMMETRIC LINEAR SYSTEMS.
       MATHEMATICS OF COMPUTATION 31,P 163-180,1977.
     2) J.R.BUNCH,L.KAUFMAN,B.N.PARLETT.
       DECOMPOSITION OF A SYMMETRIC MATRIX.
       NUMERISCHE MATHEMATIK 27,P 95-109,1976.
 
 
 
 
 EXAMPLES OF USE :
 
 
 "BEGIN" "COMMENT" EXAMPLE OF USE OF THE PROCEDURE DECSOLSYM2;
         "INTEGER" I,J;"REAL" TOL;
         "REAL" "ARRAY" A[1:5,1:5],B[1:5];
         "INTEGER" "ARRAY" AUX[2:5];
 
         A[1,1]:=A[1,2]:=-3;A[1,3]:=-18;A[1,4]:=-30;A[1,5]:=18;
         A[2,2]:=-1;A[2,3]:=-4;A[2,4]:=-48;A[2,5]:=8;
         A[3,3]:=-6;A[3,4]:=-274;A[3,5]:=6;
         A[4,4]:=119;A[4,5]:=19;
         A[5,5]:=216;
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         "FOR" J:=I+1 "STEP" 1 "UNTIL" 5 "DO" A[J,I]:=A[I,J];
 
         OUTPUT(61,"(""("THE COEFFICIENTMATRIX :")",/")");
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         "BEGIN" "FOR" J:=1 "STEP" 1 "UNTIL" 5 "DO"
                 OUTPUT(61,"("-2ZD,4B")",A[I,J]);
                 OUTPUT(61,"("/")")
         "END";                                                "COMMENT"
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 5
                                                                  ;
 
 
         OUTPUT(61,"("/,"("THE RHS-VECTOR :")",/")");
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         "BEGIN" INREAL(70, B[I]);
                 OUTPUT(61,"("-Z3D,4B")",B[I])
         "END";
         TOL:="-14;
         DECSOLSYM2(A,5,B,TOL,AUX);
         OUTPUT(61,"("2/")");
         "IF" AUX[2]=1 "THEN"
              OUTPUT(61,"(""("THE MATRIX IS SYMMETRIC")",/")")
         "ELSE" OUTPUT(61,"(""("THE MATRIX IS ASYMMETRIC.THE ")",
                            "("RESULTS ARE MEANINGLESS")",/")");
         OUTPUT(61,"("/,"("INERTIA : <")",D,"(",")",D,"(",")",D,
                     "(">")",/")",AUX[3],AUX[4],AUX[5]);
         OUTPUT(61,"("/,"("THE COMPUTED SOLUTION :")",/")");
         "FOR" I:=1 "STEP" 1 "UNTIL" 5 "DO"
         OUTPUT(61,"("-D.5D,4B")",B[I])
 "END"
 
 
 INPUT:
 
     327     291   1290     275    1720
 
 THIS DELIVERS AS RESULT :
 
 
     THE COEFFICIENT MATRIX :
      -3      -3     -18    -30      18
      -3      -1      -4    -48       8
     -18      -4      -6   -274       6
     -30     -48    -274    119      19
      18       8       6     19     216
 
     THE RHS-VECTOR :
     327     291   1290     275    1720
 
     THE MATRIX IS SYMMETRIC.
     INERTIA : <3,2,0>
 
     THE COMPUTED SOLUTION :
     -7.00000   -2.00000   -1.00000    -4.00000     9.00000
1SECTION : 3.1.1.1.1.3.3     ( DECEMBER 1978 )                    PAGE 6
 
 
 
 SOURCE TEXT(S) :
 
 "CODE" 34292;
 "PROCEDURE" SOLSYM2(A,N,B,P,DETAUX);
 "VALUE" N;"INTEGER" N;
 "ARRAY" A,B,DETAUX;"INTEGER" "ARRAY" P;
 "BEGIN" "INTEGER" I,II,J,K,IP1,PI,PII,DUMMY;
     "REAL" DET,TEMP,SAVE;
     I:=1;
     "FOR" DUMMY:=0 "WHILE" I<N "DO"
     "BEGIN" IP1:=I+1;PI:=P[I];SAVE:=B[PI];
       "IF" P[IP1]>0 "THEN"
       "BEGIN" B[PI]:=B[I];B[I]:=SAVE/A[I,I];
           ELMVECROW(IP1,N,I,B,A,SAVE);I:=IP1
       "END"
       "ELSE"
       "BEGIN" TEMP:=B[I];B[PI]:=B[IP1];DET:=DETAUX[IP1];
           B[I]:=(TEMP*A[IP1,IP1]-SAVE*A[I,IP1])/DET;
           B[IP1]:=(SAVE*A[I,I]-TEMP*A[I,IP1])/DET;
           ELMVECROW(I+2,N,I,B,A,TEMP);ELMVECROW(I+2,N,IP1,B,A,SAVE);
           I:=I+2
       "END"
     "END" WHILE I;
     "IF" I=N "THEN" "BEGIN" B[I]:=B[I]/A[I,I];I:=N-1 "END"
       "ELSE" I:=N-2;
     "FOR" DUMMY:=0 "WHILE" I>0 "DO"
     "BEGIN" "IF" P[I]=0 "THEN" II:=I-1 "ELSE" II:=I;
       "FOR" K:=II "STEP" 1 "UNTIL" I "DO"
       "BEGIN" SAVE:=B[K];SAVE:=SAVE+MATVEC(I+1,N,K,A,B);
          B[K]:=SAVE
       "END";
       PII:=P[II];B[I]:=B[PII];B[PII]:=SAVE;I:=II-1
     "END" WHILE I
 "END" SOLSYM2;
         "EOP"
 
 
 "CODE" 34293;
 "PROCEDURE" DECSOLSYM2(A,N,B,TOL,AUX);
 "VALUE" N;"INTEGER" N;"REAL" TOL;
 "ARRAY" A,B;"INTEGER" "ARRAY" AUX;
 "BEGIN" "REAL" "ARRAY" DETAUX[1:N];"INTEGER" "ARRAY" P[1:N];
         DECSYM2(A,N,TOL,AUX,P,DETAUX);
         "IF" AUX[5]=0 "THEN" SOLSYM2(A,N,B,P,DETAUX)
 "END" DECSOLSYM2;
         "EOP"
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 1
 
 
 
 AUTHOR      :    T.J. DEKKER.
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    731015.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS TWO PROCEDURES :
     A) LSQORTDEC, FOR THE HOUSEHOLDER TRIANGULARIZATION WITH COLUMN
     INTERCHANGES OF THE COEFFICIENT MATRIX OF A LINEAR LEAST SQUARES
     PROBLEM;
     B) LSQDGLINV, FOR THE CALCULATION OF THE DIAGONAL ELEMENTS OF THE
     INVERSE OF M'M, WHERE M IS THE COEFFICIENT MATRIX OF A LINEAR
     LEAST SQUARES PROBLEM.
 
 
 KEY WORDS   :
 
     LINEAR LEAST SQUARES PROBLEM,
     HOUSEHOLDER TRIANGULARIZATION.
 
 
 SUBSECTION :    LSQORTDEC.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS :
 
     "PROCEDURE" LSQORTDEC(A, N, M, AUX, AID, CI); "VALUE" N, M;
     "INTEGER" N, M; "INTEGER""ARRAY" CI; "ARRAY" A, AUX, AID;
     "CODE" 34134;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
 
         A   :   <ARRAY IDENTIFIER>;
                 "ARRAY" A[1 : N,1 : M];
                 ENTRY  :THE COEFFICIENT MATRIX OF THE
                 LINEAR LEAST SQUARES PROBLEM;
                 EXIT   : IN THE UPPER TRIANGLE OF A (THE ELEMENTS
                 A[I,J] WITH I < J) THE SUPERDIAGONAL
                 ELEMENTS OF THE UPPER-TRIANGULAR MATRIX, PRODUCED BY
                 THE HOUSEHOLDER TRANSFORMATION; IN THE OTHER PART OF
                 THE COLUMNS OF A THE SIGNIFICANT ELEMENTS OF THE
                 GENERATING VECTORS OF THE HOUSEHOLDER MATRICES USED
                 FOR THE HOUSEHOLDER TRIANGULARIZATION;
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 2
 
 
 
         N    :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF ROWS OF THE MATRIX;
         M    :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF COLUMNS OF THE MATRIX (N >= M);
         AUX  :  <ARRAY IDENTIFIER>;
                 "ARRAY" AUX[2 : 5];
                 ENTRY  : AUX[2] CONTAINS A RELATIVE TOLERANCE USED FOR
                 CALCULATING THE DIAGONAL ELEMENTS OF THE
                 UPPER-TRIANGULAR MATRIX;
                 EXIT  :
                 AUX[3] DELIVERS THE NUMBER OF THE DIAGONAL ELEMENTS OF
                 THE UPPER-TRIANGULAR MATRIX WHICH HAVE BEEN FOUND NOT
                 NEGLIGIBLE;
                 NORMAL EXIT AUX[3] = M;
                 AUX[5] := THE MAXIMUM OF THE EUCLIDEAN NORMS OF THE
                 COLUMNS OF THE GIVEN MATRIX;
         AID :   <ARRAY IDENTIFIER>;
                 "ARRAY" AID[1 : M];
                 NORMAL EXIT (AUX[3] = M) : AID CONTAINS THE DIAGONAL
                 ELEMENTS OF THE UPPER-TRIANGULAR MATRIX PRODUCED BY THE
                 HOUSEHOLDER TRIANGULARIZATION;
         CI :    <ARRAY IDENTIFIER>;
                 "INTEGER""ARRAY" CI[1 : M];
                 EXIT : CI CONTAINS THE PIVOTAL INDICES OF THE
                 INTERCHANGES OF THE COLUMNS OF THE GIVEN MATRIX.
 
 
 PROCEDURES USED :
 
     TAMMAT = CP34014,
     ELMCOL = CP34023,
     ICHCOL = CP34031.
 
 
 REQUIRED CENTRAL MEMORY :
 
     EXECUTION FIELD LENGTH :  AN ARRAY OF M ELEMENTS IS DECLARED.
 
 
 RUNNING TIME:
 
     (C1 * M + C2) * M * (N - M / 3);
     THE CONSTANTS C1 AND C2 DEPEND ON THE
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 3
 
 
 
 METHOD AND PERFORMANCE :
 
     THE PROCEDURE LSQORTDEC IS A MODIFICATION OF THE PROCEDURE LSQDEC
     DUE TO   T.J. DEKKER (SEE REF [1], WHERE A DERIVATION IS GIVEN OF
     A SET OF PROCEDURES BY
     P. BUSINGER AND G.H. GOLUB, SEE REF [2]). THE METHOD IS
     HOUSEHOLDER TRIANGULARIZATION WITH COLUMN INTERCHANGES.
     LET M DENOTE THE GIVEN MATRIX. LSQORTDEC PRODUCES AN N-TH ORDER
     ORTHOGONAL MATRIX Q AND AN N * M UPPER-TRIANGULAR MATRIX R SUCH
     THAT R EQUALS QM WITH PERMUTED COLUMNS, Q IS THE PRODUCT OF
     AT MOST M HOUSEHOLDER MATRICES WHICH ARE REPRESENTED BY THEIR
     GENERATING VECTORS. M IS REDUCED TO R IN AT MOST M STAGES : AT
     THE K-TH STAGE THE K-TH COLUMN OF THE (ALREADY MODIFIED) MATRIX IS
     INTERCHANGED WITH THE COLUMN OF MAXIMUM EUCLIDEAN NORM (THE
     PIVOTAL COLUMN); THEN THE MATRIX IS MULTIPLIED WITH A HOUSEHOLDER
     MATRIX SUCH, THAT THE SUBDIAGONAL ELEMENTS OF THE K-TH COLUMN
     BECOME ZERO, WHILE THE FIRST   K - 1   COLUMNS REMAIN UNCHANGED.
     THE PROCESS TERMINATES PREMATURELY, IF AT SOME STAGE THE
     EUCLIDEAN NORM OF THE PIVOTAL COLUMN IS LESS THAN SOME TOLERANCE,
     VIZ. A GIVEN TOLERANCE (AUX[2]) TIMES THE MAXIMUM OF THE
     EUCLIDEAN NORMS OF THE COLUMNS OF THE GIVEN MATRIX.
     LSQORTDEC DELIVERS THE SIGNIFICANT ELEMENTS OF THE GENERATING
     VECTOR OF THE K-TH HOUSEHOLDER MATRIX (THE FIRST   K - 1
     ELEMENTS OF THIS VECTOR BEING ZERO) IN THE LOWER TRIANGLE PART OF
     THE K-TH COLUMN OF THE ARRAY A (A[I,K] FOR I >= K).
     OF THE RESULTING UPPER-TRIANGULAR MATRIX THE
     DIAGONAL ELEMENTS ARE DELIVERED SEPARATELY IN AN ARRAY AID, AND THE
     REMAINING ELEMENTS IN THE SUPER-TRIANGULAR PART OF THE ARRAY A.
     FOR THE SOLUTION OF LEAST SQUARES PROBLEMS, ONLY CALLS WITH
       N >= M   ARE USEFUL.
 
 
 REFERENCES  :
 
     [1] DEKKER, T.J. :
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MC TRACT 22, 1968, MATHEMATISCH CENTRUM, AMSTERDAM.
     [2] BUSINGER, P. AND G.H. GOLUB :
         LINEAR LEAST SQUARES SOLUTION BY HOUSEHOLDER TRANSFORMATIONS,
         NUM. MATH. 7 (1965), PP. 269 - 276.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLE OF USE OF LSQSOL.
 
 
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 4
 
 
 
 SUBSECTION  :    LSQDGLINV.
 
 
 CALLING SEQUENCE  :
 
     THE HEADING OF THE PROCEDURE IS :
 
     "PROCEDURE" LSQDGLINV(A, M, AID, CI, DIAG); "VALUE" M; "INTEGER" M;
     "INTEGER""ARRAY" CI; "ARRAY" A, AID, DIAG;
     "CODE" 34132;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
 
         A, M, AID, CI :
                 SEE 'CALLING SEQUENCE' OF LSQORTDEC (THIS SECTION);
                 THE CONTENTS OF A, AID AND CI SHOULD BE PRODUCED BY A
                 SUCCESSFUL CALL OF LSQORTDEC   (AUX[3] = M)  .
         DIAG :  <ARRAY IDENTIFIER>; "ARRAY" DIAG[1 : M];
                 EXIT : THE DIAGONAL ELEMENTS OF THE INVERSE OF M'M
                 WHERE M IS THE MATRIX OF THE LINEAR LEAST SQUARES
                 PROBLEM.
 
 
 PROCEDURES USED :
     VECVEC = CP34010,
     TAMVEC = CP34012.
 
 
 RUNNING TIME :
     (C3 * M + C4) * M * M;
     THE CONSTANTS C3 AND C4 DEPEND ON THE ARITHMETIC
     OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     LSQDGLINV SHOULD BE CALLED AFTER A SUCCESSFUL CALL OF LSQORTDEC,
     I.E. IF AUX[3] = M. LSQDGLINV CALCULATES THE DIAGONAL ELEMENTS
     OF THE INVERSE OF M'M, WHERE M IS THE MATRIX OF A LINEAR
     LEAST SQUARES PROBLEM.
     THESE VALUES CAN BE USED FOR THE COMPUTATION OF THE STANDARD
     DEVIATIONS OF LEAST SQUARES SOLUTIONS.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLE OF USE OF LSQSOL.
 
 
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S) :
 
 "CODE" 34134;
     "PROCEDURE" LSQORTDEC(A, N, M, AUX, AID, CI); "VALUE" N, M;
     "INTEGER" N, M; "ARRAY" A, AUX, AID; "INTEGER" "ARRAY" CI;
     "BEGIN" "INTEGER" J, K, KPIV;
         "REAL" BETA, SIGMA, NORM, W, EPS, AKK, AIDK;
         "ARRAY" SUM[1:M];
 
         NORM:= 0; AUX[3]:= M;
         "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" W:= SUM[K]:= TAMMAT(1, N, K, K, A, A);
             "IF" W > NORM "THEN" NORM:= W
         "END";
         W:= AUX[5]:= SQRT(NORM); EPS:= AUX[2] * W;
         "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" SIGMA:= SUM[K]; KPIV:= K;
             "FOR" J:= K + 1 "STEP" 1 "UNTIL" M "DO"
             "IF" SUM[J] > SIGMA "THEN"
             "BEGIN" SIGMA:= SUM[J]; KPIV:= J "END";
             "IF" KPIV ^= K "THEN"
             "BEGIN" SUM[KPIV]:= SUM[K]; ICHCOL(1, N, K, KPIV, A) "END";
             CI[K]:= KPIV; AKK:= A[K,K];
             SIGMA:= TAMMAT(K, N, K, K, A, A); W:= SQRT(SIGMA);
             AIDK:= AID[K]:= "IF" AKK < 0 "THEN" W "ELSE" - W;
             "IF" W < EPS "THEN"
             "BEGIN" AUX[3]:= K - 1; "GO TO" ENDDEC "END";
             BETA:= 1 / (SIGMA - AKK * AIDK); A[K,K]:= AKK - AIDK;
             "FOR" J:= K + 1 "STEP" 1 "UNTIL" M "DO"
             "BEGIN" ELMCOL(K, N, J, K, A, A, - BETA * TAMMAT(K, N,
                 K, J, A, A)); SUM[J]:= SUM[J] - A[K,J] ** 2
             "END"
         "END" FOR K;
     ENDDEC:
     "END" LSQORTDEC
1SECTION : 3.1.1.2.1.1         (MAY 1974)                         PAGE 6
 
 
                                                                   ;
         "EOP"
 "CODE" 34132;
     "PROCEDURE" LSQDGLINV(A, M, AID, CI, DIAG); "VALUE" M; "INTEGER" M;
     "ARRAY" A, AID, DIAG; "INTEGER" "ARRAY" CI;
     "BEGIN" "INTEGER" J, K, CIK;
         "REAL" W;
 
         "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" DIAG[K]:= 1 / AID[K];
             "FOR" J:= K + 1 "STEP" 1 "UNTIL" M "DO"
             DIAG[J]:= - TAMVEC(K, J - 1, J, A, DIAG) / AID[J];
             DIAG[K]:= VECVEC(K, M, 0, DIAG, DIAG)
         "END";
         "FOR" K:= M "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" CIK:= CI[K]; "IF" CIK ^= K "THEN"
             "BEGIN" W:= DIAG[K]; DIAG[K]:= DIAG[CIK]; DIAG[CIK]:= W
             "END"
         "END"
     "END" LSQDGLINV;
         "EOP"
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 1
 
 
 
 AUTHOR      :    T.J. DEKKER.
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    731015.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS TWO PROCEDURES :
     A) LSQSOL, FOR THE SOLUTION OF A LINEAR LEAST SQUARES PROBLEM IF
     THE COEFFICIENT MATRIX HAS BEEN DECOMPOSED BY LSQORTDEC
     (SECTION 3.1.1.2.1.1.);
     B) LSQORTDECSOL, FOR THE SOLUTION OF A LINEAR LEAST SQUARES PROBLEM
     BY HOUSEHOLDER TRIANGULARIZATION WITH COLUMN INTERCHANGES AND FOR
     THE CALCULATION OF THE DIAGONAL OF THE INVERSE OF M'M, WHERE
     M IS THE COEFFICIENT MATRIX.
 
 
 KEY WORDS   :
 
     LINEAR LEAST SQUARES PROBLEM,
     HOUSEHOLDER TRIANGULARIZATION.
 
 
 SUBSECTION :    LSQSOL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS :
 
     "PROCEDURE" LSQSOL(A, N, M, AID, CI, B); "VALUE" N, M;
     "INTEGER" N, M; "INTEGER""ARRAY" CI; "ARRAY" A, AID, B;
     "CODE" 34131;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
         A, N, M, AID, CI : SEE 'CALLING SEQUENCE' OF LSQORTDEC
                 (SECTION 3.1.1.2.1.1.); THE CONTENTS OF THE ARRAYS
                 A, AID AND CI SHOULD BE PRODUCED BY A SUCCESSFUL CALL
                 OF LSQORTDEC, I.E. IF AUX[3] = M;
         B :     <ARRAY IDENTIFIER>;
                 "ARRAY" B[1 : N];
                 ENTRY : B CONTAINS THE RIGHT HAND SIDE OF A LINEAR
                 LEAST SQUARES PROBLEM;
                 EXIT : B[1 : M] CONTAINS THE SOLUTION OF THE PROBLEM;
                 B[M + 1 : N] CONTAINS A VECTOR WITH EUCLIDEAN
                 LENGTH EQUAL TO THE EUCLIDEAN LENGTH OF THE RESIDUAL
                 VECTOR.
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 2
 
 
 
 PROCEDURES USED :
 
     MATVEC    = CP34011,
     TAMVEC    = CP34012,
     ELMVECCOL = CP34021.
 
 
 RUNNING TIME:
 
     (C5 * M + C6) * N;
     THE CONSTANTS C5 AND C6 DEPEND UPON THE ELEMENTARY
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     LSQSOL SHOULD BE CALLED AFTER A SUCCESSFUL CALL OF LSQORTDEC
     (SECTION 3.1.1.2.1.1.), I.E. IF AUX[3] = M. LSQSOL YIELDS
     THE LEAST SQUARES SOLUTION OF THE OVERDETERMINED SYSTEM WITH THE
     DECOMPOSED COEFFICIENT MATRIX IN ARRAY A AND THE RIGHT HAND SIDE IN
     ARRAY B.
     FIRST THE ORTHOGONAL TRANSFORMATION WITH THE HOUSEHOLDER MATRICES
     IS PERFORMED ON THE RIGHT HAND SIDE. NEXT THE SYSTEM OF THE FIRST M
     EQUATIONS AND WITH AN UPPER-TRIANGULAR COEFFICIENT MATRIX IS SOLVED
     BY BACK SUBSTITUTION, YIELDING A SOLUTION WITH M PERMUTED
     COMPONENTS DUE TO THE COLUMN INTERCHANGES OF THE TRIANGULARIZATION.
     FINALLY THE ORDER OF THE M COMPONENTS IS RESTORED. SEE ALSO METHOD
     AND PERFORMANCE OF LSQORTDEC (SECTION 3.1.1.2.1.1.).
     THE LEAST SQUARES SOLUTIONS OF SEVERAL OVERDETERMINED SYSTEMS WITH
     THE SAME COEFFICIENT MATRIX CAN BE OBTAINED BY SUCCESSIVE CALLS OF
     LSQSOL WITH DIFFERENT RIGHT HAND SIDES.
 
 
 EXAMPLE OF USE :
 
     THE NEXT PROGRAM SOLVES THE SYSTEM
 
         - 2 * X1   +   X2  =  0
           -   X1   +   X2  =  1
               X1   +   X2  =  2
           2 * X1   +   X2  =  2
               X1 + 2 * X2  =  3
 
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 3
 
 
 
     "BEGIN""COMMENT" 730912, TEST LSQORTDEC, LSQSOL, LSQDGLINV;
        "ARRAY" A, C[1 : 5,1 : 2], B, X[1 : 5], DIAG, AID[1 : 2],
        AUX[2 : 5];
        "INTEGER""ARRAY" PIV[1 : 2];
        "INTEGER" I, J;
        "REAL" H;
 
        "REAL""PROCEDURE" SUM(I, A, B, X); "VALUE" A, B;
        "INTEGER" I, A, B; "REAL" X;
        "BEGIN""REAL" S; S:= 0; "FOR" I:= A "STEP" 1 "UNTIL" B "DO"
           S:= S + X; SUM:= S
        "END" SUM;
 
        AUX[2]:= "-12; I:= J:= 1;
        "FOR" H:= - 2, - 1, 1, 2, 1, 1, 1, 1, 1, 2 "DO"
        "BEGIN" A[I,J]:= C[I,J]:= H; "IF" I < 5 "THEN" I:= I + 1 "ELSE"
           "BEGIN" I:= 1; J:= J + 1 "END"
        "END";
        "FOR" H:= 0, 1, 2, 2, 3 "DO"
        "BEGIN" B[I]:= X[I]:= H; I:= I + 1 "END";
 
        LSQORTDEC(A, 5, 2, AUX, AID, PIV);
        "IF" AUX[3] = 2 "THEN"
        "BEGIN" LSQSOL(A, 5, 2, AID, PIV, X);
           LSQDGLINV(A, 2, AID, PIV, DIAG);
           OUTPUT(61, "("/, "("AUX[2, 3, 5] = ")" +.4D"+DD5B, 3ZD5B,
              +.4D"+DD/, "("LSQ SOLUTION  :")", 2(2B+.8D"+DD), /
              "("RESIDUE (DELIVERED) :")" +.8D"+DD/,
              "("RESIDUE (CHECKED)   :")" +.8D"+DD/,
              "("DIAGONAL OF INVERSE M'M  :")", 2(2B+.8D"+DD)")",
              AUX[2], AUX[3], AUX[5], X[1], X[2],
              SQRT(VECVEC(3, 5, 0, X, X)),
              SQRT(SUM(I, 1, 5, (B[I] - C[I,1] * X[1] - C[I,2] * X[2])
               ** 2)), DIAG[1], DIAG[2])
        "END"
     "END"
 
     DELIVERS  :
 
     AUX[2, 3, 5] = +.1000"-11        2     +.3317"+01
     LSQ SOLUTION  :  +.50000000"+00  +.12500000"+01
     RESIDUE (DELIVERED) :+.50000000"+00
     RESIDUE (CHECKED)   :+.50000000"+00
     DIAGONAL OF INVERSE M'M  :  +.95238095"-01  +.13095238"+00
 
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 4
 
 
 
 SUBSECTION  :    LSQORTDECSOL.
 
 CALLING SEQUENCE  :
 
     THE HEADING OF THE PROCEDURE IS :
 
     "PROCEDURE" LSQORTDECSOL(A, N, M, AUX, DIAG, B); "VALUE" N, M;
     "INTEGER" N, M; "ARRAY" A, AUX, DIAG, B;
     "CODE" 34135;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
 
         A   :   <ARRAY IDENTIFIER>;
                 "ARRAY" A[1 : N,1 : M];
                 ENTRY  : A CONTAINS THE COEFFICIENT MATRIX OF THE
                 LINEAR LEAST SQUARES PROBLEM;
                 EXIT   : IN THE UPPER TRIANGLE OF A (THE ELEMENTS
                 A[I,J] WITH I < J) THE SUPERDIAGONAL
                 ELEMENTS OF THE UPPER-TRIANGULAR MATRIX, PRODUCED BY
                 THE HOUSEHOLDER TRANSFORMATION; IN THE OTHER PART OF
                 THE COLUMNS OF A THE SIGNIFICANT ELEMENTS OF THE
                 GENERATING VECTORS OF THE HOUSEHOLDER MATRICES USED
                 FOR THE HOUSEHOLDER TRIANGULARIZATION;
         N    :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF ROWS OF THE MATRIX;
         M    :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF COLUMNS OF THE MATRIX (N >= M);
         AUX  :  <ARRAY IDENTIFIER>;
                 "ARRAY" AUX[2 : 5];
                 ENTRY  : AUX[2] CONTAINS A RELATIVE TOLERANCE USED FOR
                 CALCULATING THE DIAGONAL ELEMENTS OF THE
                 UPPER-TRIANGULAR MATRIX;
                 EXIT  :
                 AUX[3] DELIVERS THE NUMBER OF THE DIAGONAL ELEMENTS OF
                 THE UPPER-TRIANGULAR MATRIX WHICH ARE FOUND NOT
                 NEGLIGIBLE; NORMAL EXIT AUX[3] = M;
                 AUX[5] := THE MAXIMUM OF THE EUCLIDEAN NORMS OF THE
                 COLUMNS OF THE GIVEN MATRIX;
         DIAG :  <ARRAY IDENTIFIER>;
                 "ARRAY" DIAG[1 : M];
                 EXIT : THE DIAGONAL ELEMENTS OF THE INVERSE OF M'M
                 WHERE M IS THE MATRIX OF THE LINEAR LEAST SQUARES
                 PROBLEM;
         B :     <ARRAY IDENTIFIER>;
                 "ARRAY" B[1 : N];
                 ENTRY : B CONTAINS THE RIGHT HAND SIDE OF A LINEAR
                 LEAST SQUARES PROBLEM;
                 EXIT : B[1 : M] CONTAINS THE SOLUTION OF THE PROBLEM;
                 B[M + 1 : N] CONTAINS A VECTOR WITH EUCLIDEAN LENGTH
                 EQUAL TO THE EUCLIDEAN LENGTH OF THE RESIDUAL VECTOR.
 
 PROCEDURES USED :
     LSQORTDEC = CP34134,
     LSQDGLINV = CP34132,
     LSQSOL    = CP34131.
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 5
 
 
 
 REQUIRED CENTRAL MEMORY :
 
     EXECUTION FIELD LENGTH : AN INTEGER ARRAY AND A REAL ARRAY,
     BOTH OF M ELEMENTS, ARE DECLARED.
 
 RUNNING TIME :    ROUGHLY PROPORTIONAL TO N * (M ** 2).
 
 LANGUAGE    :   ALGOL 60.
 
 METHOD AND PERFORMANCE :
 
     LSQORTDECSOL SOLVES AN OVERDETERMINED SYSTEM OF N LINEAR EQUATIONS
     IN M UNKNOWNS BY CALLING LSQORTDEC AND, IF THIS CALL WAS SUCCESSFUL
     LSQDGLINV AND LSQSOL. LSQORTDECSOL DELIVERS THE LEAST SQUARES
     SOLUTION AND THE DIAGONAL OF THE INVERSE OF M'M, WHERE M IS
     THE COEFFICIENT MATRIX OF THE SYSTEM. SEE SECTION 3.1.1.2.1.1.,
     AND LSQSOL (THIS SECTION).
 
 EXAMPLE OF USE :
 
     THE PROGRAM
 
     "BEGIN""COMMENT" 730914, TEST LSQORTDECSOL;
        "ARRAY" A, C[1 : 5,1 : 2], B, X[1 : 5], DIAG[1 : 2],
        AUX[2 : 5];
        "INTEGER" I, J;
        "REAL" H;
        "REAL""PROCEDURE" SUM(I, A, B, X); "VALUE" A, B;
        "INTEGER" I, A, B; "REAL" X;
        "BEGIN""REAL" S; S:= 0; "FOR" I:= A "STEP" 1 "UNTIL" B "DO"
           S:= S + X; SUM:= S
        "END" SUM;
        AUX[2]:= "-12; I:= J:= 1;
        "FOR" H:= - 2, - 1, 1, 2, 1, 1, 1, 1, 1, 2 "DO"
        "BEGIN" A[I,J]:= C[I,J]:= H; "IF" I < 5 "THEN" I:= I + 1 "ELSE"
           "BEGIN" I:= 1; J:= J + 1 "END"
        "END";
        "FOR" H:= 0, 1, 2, 2, 3 "DO"
        "BEGIN" B[I]:= X[I]:= H; I:= I + 1 "END";
        LSQORTDECSOL(A, 5, 2, AUX, DIAG, X);
        "IF" AUX[3] = 2 "THEN"
        OUTPUT(61, "("/, "("AUX[2, 3, 5] = ")" +.4D"+DD5B, 3ZD5B,
              +.4D"+DD/, "("LSQ SOLUTION  :")", 2(2B+.8D"+DD), /
              "("RESIDUE (DELIVERED) :")" +.8D"+DD/,
              "("RESIDUE (CHECKED)   :")" +.8D"+DD/,
              "("DIAGONAL OF INVERSE M'M  :")", 2(2B+.8D"+DD)")",
              AUX[2], AUX[3], AUX[5], X[1], X[2],
              SQRT(VECVEC(3, 5, 0, X, X)),
              SQRT(SUM(I, 1, 5, (B[I] - C[I,1] * X[1] - C[I,2] * X[2])
               ** 2)), DIAG[1], DIAG[2])
     "END"
1SECTION : 3.1.1.2.1.2         (MAY 1974)                         PAGE 6
 
 
 
     WHICH SOLVES THE PROBLEM OF THE EXAMPLE OF USE OF LSQSOL,
     DELIVERS  :
 
     AUX[2, 3, 5] = +.1000"-11        2     +.3317"+01
     LSQ SOLUTION  :  +.50000000"+00  +.12500000"+01
     RESIDUE (DELIVERED) :+.50000000"+00
     RESIDUE (CHECKED)   :+.50000000"+00
     DIAGONAL OF INVERSE M'M  :  +.95238095"-01  +.13095238"+00
 
 
 SOURCE TEXT(S)  :
0"CODE" 34131;
     "PROCEDURE" LSQSOL(A, N, M, AID, CI, B); "VALUE" N, M;
     "INTEGER" N, M; "ARRAY" A, AID, B; "INTEGER" "ARRAY" CI;
     "BEGIN" "INTEGER" K, CIK;
         "REAL" W;
 
         "FOR" K:= 1 "STEP" 1 "UNTIL" M "DO" ELMVECCOL(K, N, K, B, A,
         TAMVEC(K, N, K, A, B) / (AID[K] * A[K,K]));
         "FOR" K:= M "STEP" - 1 "UNTIL" 1 "DO" B[K]:= (B[K] - MATVEC
         (K + 1, M, K, A, B)) / AID[K];
         "FOR" K:= M "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" CIK:= CI[K]; "IF" CIK ^= K "THEN"
             "BEGIN" W:= B[K]; B[K]:= B[CIK]; B[CIK]:= W "END"
         "END"
     "END" LSQSOL;
         "EOP"
0"CODE" 34135;
     "PROCEDURE" LSQORTDECSOL(A, N, M, AUX, DIAG, B); "VALUE" N, M;
     "INTEGER" N, M; "ARRAY" A, AUX, DIAG, B;
     "BEGIN" "ARRAY" AID[1:M];
         "INTEGER" "ARRAY" CI[1:M];
 
         LSQORTDEC(A, N, M, AUX, AID, CI);
         "IF" AUX[3] = M "THEN"
         "BEGIN" LSQDGLINV(A, M, AID, CI, DIAG);
             LSQSOL(A, N, M, AID, CI, B)
         "END"
     "END" LSQORTDECSOL;
         "EOP"
1SECTION : 3.1.1.2.1.3        (OCTOBER 1974)                      PAGE 1
 
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    740617.
 
 
 BRIEF DESCRIPTION    :
 
     THIS SECTION CONTAINS ONE PROCEDURE,
     LSQINV, FOR THE CALCULATION OF THE INVERSE OF THE MATRIX  S'S,
     WHERE  S  IS THE COEFFICIENT MATRIX OF A LINEAR LEAST SQUARES
     PROBLEM.
 
 
 KEYWORDS   :
 
     INVERSE MATRIX,
     LINEAR LEAST SQUARES PROBLEM.
 
 
 CALLING SEQUENCE    :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" LSQINV(A, M, AID, C); "VALUE" M; "INTEGER" M;
     "ARRAY" A, AID; "INTEGER""ARRAY" C;
     "CODE" 34136;
 
     THE MEANING OF THE FORMAL PARAMETERS IS   :
 
         A   :   <ARRAY IDENTIFIER>;
                 "ARRAY" A[1 : M, 1 : M];
                 ENTRY :  IN THE UPPER TRIANGLE OF A (THE ELEMENTS
                 A[I,J] WITH  1 <= I < J <= M) THE SUPERDIAGONAL
                 ELEMENTS SHOULD BE GIVEN OF THE UPPERTRIANGULAR MATRIX
                 THAT IS PRODUCED BY THE HOUSEHOLDER TRIANGULARIZATION
                 IN A CALL OF THE PROCEDURE  LSQORTDEC  (SECTION
                 3.1.1.2.1.1.) WITH A NORMAL EXIT (AUX[3] = M).
                 SEE ALSO THE MEANING OF THE PARAMETER  AID;
                 EXIT :  THE UPPER TRIANGLE OF THE (SYMMETRIC) INVERSE
                 MATRIX IS DELIVERED IN THE UPPERTRIANGULAR ELEMENTS OF
                 THE ARRAY A (A[I,J] FOR  1 <= I <= J <= M);
         M   :   <ARITHMETIC EXPRESSION>;
                 NUMBER OF COLUMNS OF THE MATRIX OF THE LINEAR LEAST
                 SQUARES PROBLEM;
         AID :   <ARRAY IDENTIFIER>;
                 "ARRAY" AID[1 : M];
                 ENTRY :  AID CONTAINS THE DIAGONAL ELEMENTS OF THE
                 UPPERTRIANGULAR MATRIX THAT IS PRODUCED BY LSQORTDEC;
         C   :   <ARRAY IDENTIFIER>;
                 "INTEGER""ARRAY" C[1 : M];
                 ENTRY :  C CONTAINS THE PIVOTAL INDICES AS PRODUCED BY
                 A CALL OF LSQORTDEC.
 
 
1SECTION : 3.1.1.2.1.3        (OCTOBER 1974)                      PAGE 2
 
 
 
 PROCEDURES USED    :
 
     CHLINV2   = CP34400,
     ICHCOL    = CP34031,
     ICHROW    = CP34032,
     ICHROWCOL = CP34033.
 
 
 REQUIRED CENTRAL MEMORY    :
 
     EXECUTION FIELD LENGTH :  A REAL ARRAY OF M ELEMENTS IS
     DECLARED (IN THE CALL OF CHLINV2).
 
 
 RUNNING TIME    :  PROPORTIONAL TO M CUBED.
 
 
 LANGUAGE    :  ALGOL 60.
 
 
 METHOD AND PERFORMANCE  :
 
     LSQINV  SHOULD  BE CALLED  AFTER  A SUCCESSFUL  CALL  OF  LSQORTDEC
     (SECTION  3.1.1.2.1.1.).  LSQINV CAN BE USED FOR THE CALCULATION OF
     THE COVARIANCE MATRIX OF A LINEAR LEAST SQUARES PROBLEM.
     LET  S  BE THE MATRIX  OF THE LEAST SQUARES  SYSTEM  WITH  PERMUTED
     COLUMNS  AND  Q * R  THE  HOUSEHOLDER DECOMPOSITION OF  S. THEN THE
     INVERSE  OF   S'S  ALSO IS  THE INVERSE  OF  R'R.  SINCE  R  IS THE
     CHOLESKY MATRIX OF  R'R,  THE INVERSE MATRIX IS COMPUTED  IN A CALL
     OF  CHLINV2  (SECTION 3.1.1.1.1.2.4.).  AFTERWARDS  THE  COVARIANCE
     MATRIX IS OBTAINED BY INTERCHANGES  OF THE COLUMNS AND ROWS  OF THE
     INVERSE MATRIX.
 
 
 EXAMPLE OF USE  :
 
     THE FOLLOWING PROGRAM COMPUTES THE INVERSE  T  OF  S'S, WHERE  S IS
     THE COEFFICIENT  MATRIX  OF THE SYSTEM  IN THE EXAMPLE  OF  USE  OF
     LSQORTDEC AND  LSQDGLINV (SECTION 3.1.1.2.1.1.). THE DIAGONAL OF  S
     CAN BE COMPARED WITH THE RESULT OF  LSQDGLINV. TO CHECK THE ANSWERS
     S' * (S * T)  IS PRINTED.
 
1SECTION : 3.1.1.2.1.3        (OCTOBER 1974)                      PAGE 3
 
 
 
     "BEGIN""COMMENT" JKOK, 740530, EXAMPLE OF USE OF  LSQORTDEC AND
         LSQINV;
 
         "ARRAY" A, C[1 : 5, 1 : 2], AID[1 : 2], T[1 : 2, 1 : 2],
         AUX[2 : 5];
         "INTEGER""ARRAY" PIV[1 : 2];
         "INTEGER" I, J; "REAL" H;
 
         AUX[2]:= "-12; I:= J:= 1;
         "FOR" H:= - 2, - 1, 1, 2, 1, 1, 1, 1, 1, 2 "DO"
         "BEGIN" A[I,J]:= C[I,J]:= H; "IF" I < 5 "THEN" I:= I + 1 "ELSE"
             "BEGIN" I:= 1; J:= J + 1 "END"
         "END";
 
         LSQORTDEC(A, 5, 2, AUX, AID, PIV); "IF" AUX[3] = 2 "THEN"
         "BEGIN" LSQINV(A, 2, AID, PIV);
             T[1,1]:= A[1,1]; T[2,2]:= A[2,2]; T[2,1]:= T[1,2]:= A[1,2];
             "FOR" J:= 1, 2 "DO""FOR" I:= 1 "STEP" 1 "UNTIL" 5 "DO"
             A[I,J]:= MATMAT(1, 2, I, J, C, T);
             OUTPUT(61, "("/4B, "(" AUX[2, 3, 5] = ")",
                 -.4D"+DD5B, 3ZD5B, +.4D"+DD/,
                 2(/4B, 30S, /, 2(/4B, 2(2B+.8D"+DD)), /) ")",
                 AUX[2], AUX[3], AUX[5],
                 "(" INVERSE :")", T,
                 "(" CHECK : S' * (S * T) :")",
                  TAMMAT(1, 5, 1, 1, C, A),
                  TAMMAT(1, 5, 1, 2, C, A),
                  TAMMAT(1, 5, 2, 1, C, A),
                  TAMMAT(1, 5, 2, 2, C, A) )
         "END"
     "END"
 
     OUTPUT  :
 
      AUX[2, 3, 5] =  .1000"-11        2     +.3317"+01
 
      INVERSE :
 
       +.95238095"-01  -.23809524"-01
       -.23809524"-01  +.13095238"+00
 
      CHECK : S' * (S * T) :
 
       +.10000000"+01  +.17763568"-14
       +.00000000"+00  +.10000000"+01
1SECTION : 3.1.1.2.1.3        (OCTOBER 1974)                      PAGE 4
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 34136;
     "PROCEDURE" LSQINV(A, M, AID, C); "VALUE" M; "INTEGER" M;
     "ARRAY" A, AID; "INTEGER""ARRAY" C;
     "BEGIN""INTEGER" I, CI;
        "REAL" W;
 
        "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO" A[I,I]:= AID[I];
        CHLINV2(A, M);
        "FOR" I:= M "STEP" - 1 "UNTIL" 1 "DO"
        "BEGIN" CI:= C[I]; "IF" CI ^= I "THEN"
           "BEGIN" ICHCOL(1, I - 1, I, CI, A); ICHROWCOL(I + 1, CI - 1,
              I, CI, A); ICHROW(CI + 1, M, I, CI, A);
              W:= A[I,I]; A[I,I]:= A[CI,CI]; A[CI,CI]:= W
           "END"
        "END"
     "END" LSQINV;
         "EOP"
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 1
 
 
 
 AUTHORS: A.BJOERCK AND G.H.GOLUB.
 
 
 CONTRIBUTOR: J.KOOPMAN.
 
 
 INSTITUTE: UNIVERSITY OF AMSTERDAM.
 
 
 RECEIVED: 780701 .
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES FOR SOLVING A LINEAR LEAST
     SQUARES PROBLEM SUBJECT TO LINEAR CONSTRAINTS:
     LSQDECOMP , FOR THE QR-DECOMPOSITION OF A LEAST SQUARES MATRIX,
                 WHERE  THIS MATRIX ALSO CONTAINS THE COEFFICIENTS OF
                 THE LINEAR CONSTRAINTS (LINEAR EQUATIONS);
     LSQREFSOL , FOR THE SOLUTION OF THIS LEAST SQUARES PROBLEM, IF
                 THE MATRIX HAS BEEN DECOMPOSED BY LSQDECOMP.
 
 
 KEYWORDS:
 
     LEAST SQUARES,
     LINEAR CONSTRAINTS,
     HOUSEHOLDER TRIANGULARIZATION,
     ITERATIVE REFINEMENT.
 
 
 SUBSECTION: LSQDECOMP.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LSQDECOMP(A, N, M, N1, AUX, AID, CI);
     "VALUE"N,M,N1;"INTEGER"N,M,N1;"ARRAY" A,AUX,AID;
     "INTEGER""ARRAY" CI;
     "CODE" 34137;
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 2
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
 
     A     :<ARRAY IDENTIFIER>;
            "ARRAY" A[1:N,1:M];
            ENTRY: THE ORIGINAL LEAST SQUARES MATRIX, WHERE THE FIRST
                   N1 ROWS SHOULD FORM THE CONSTRAINT MATRIX (I.E. THE
                   FIRST N1 EQUATIONS ARE TO BE STRICTLY SATISFIED);
            EXIT : IN THE UPPER TRIANGLE OF A (THE ELEMENTS A[I,J] WITH
                   I<J) THE SUPERDIAGONAL PART OF THE UPPER TRIANGULAR
                   MATRIX, PRODUCED BY HOUSEHOLDER TRANSFORMATIONS; IN
                   THE OTHER PART OF THE COLUMNS OF A THE SIGNIFICANT
                   ELEMENTS OF THE GENERATING VECTORS OF THE HOUSEHOLDER
                   MATRICES USED FOR THE TRIANGULARIZATION;
     N     :<ARITHMETIC EXPRESSION>;
            NUMBER OF ROWS OF THE MATRIX;
     M     :<ARITHMETIC EXPRESSION>;
            NUMBER OF COLUMNS OF THE MATRIX;
     N1    :<ARITHMETIC EXPRESSION>;
            NUMBER OF LINEAR CONSTRAINTS, I.E. THE FIRST N1 ROWS OF A
            SET UP A SYSTEM OF N1 LINEAR EQUATIONS THAT MUST BE
            STRICTLY SATISFIED (OF COURSE, IF THERE ARE NO CON-
            STRAINTS, N1 MUST BE CHOSEN ZERO);
     AUX   :<ARRAY IDENTIFIER>;
            "ARRAY" AUX[2:7];
            ENTRY: AUX[2] CONTAINS A RELATIVE TOLERANCE FOR CALCULATING
                   THE DIAGONAL ELEMENTS OF THE UPPER TRIANGULAR MATRIX;
            EXIT:  AUX[3] CONTAINS THE NUMBER OF DIAGONAL ELEMENTS WHICH
                   ARE NOT NEGLIGIBLE, NORMAL EXIT AUX[3]=M;
     AID   :<ARRAY IDENTIFIER>;
            "ARRAY" AID[1:M];
            NORMAL EXIT (AUX[3]=M): THE DIAGONAL ELEMENTS OF THE UPPER
            TRIANGULAR MATRIX PRODUCED BY THE HOUSEHOLDER TRANSFORMATION
     CI    :<ARRAY IDENTIFIER>;
            "INTEGER""ARRAY" CI[1:M];
            EXIT: THE PIVOTAL INDICES OF THE INTERCHANGES OF THE COLUMNS
            OF THE GIVEN MATRIX;
 
 
 PROCEDURES USED:
 
     MATMAT = CP34013.
     TAMMAT = CP34014.
     ELMCOL = CP34023.
     ICHCOL = CP34031.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO N*M**2-M**3/3.
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 3
 
 
 
 METHOD AND PERFORMANCE:
 
     LET A DENOTE THE GIVEN MATRIX. LSQDECOMP PRODUCES AN N-TH ORDER
     ORTHOGONAL MATRIX Q AND AN N*M UPPER TRIANGULAR MATRIX R SUCH THAT
     R EQUALS QA WITH PERMUTED COLUMNS.
     THE ORTHOGONAL MATRIX Q IS FORMED AS A PRODUCT OF AT MOST M TRANS-
     FORMATIONS OF THE FORM (I-BETA U U'). THESE HOUSEHOLDER MATRICES
     REDUCE A TO THE MATRIX R: AT THE K-TH STAGE THE K-TH COLUMN OF THE
     (ALREADY MODIFIED) MATRIX IS INTERCHANGED WITH THE COLUMN OF
     MAXIMUM EUCLIDEAN NORM.THESE INTERCHANGES ARE RECORDED IN THE ARRAY
     CI. PREMATURE TERMINATION OCCURS IF AT SOME STAGE THE EUCLIDEAN
     NORM OF THE PIVOTAL COLUMN IS LESS THAN SOME TOLERANCE (AUX[2])
     TIMES THE MAXIMUM OF THE EUCLIDEAN NORMS OF THE COLUMNS OF THE
     MATRIX.
     LSQDECOMP DELIVERS THE UPPER TRIANGULAR MATRIX, WHERE THE DIAGONAL
     ELEMENTS ARE STORED IN THE ARRAY AID AND THE OFF-DIAGONAL ELEMENTS
     IN THE UPPER TRIANGULAR PART OF A. THE SIGNIFICANT ELEMENTS OF THE
     GENERATING VECTORS OF THE HOUSEHOLDER TRANSFORMATIONS ARE STORED
     IN THE COLUMNS OF A, I.E. ON AND BELOW THE LEADING DIAGONAL OF
     A. IT SHOULD BE NOTED THAT FOR THE SOLUTION OF LEAST SQUARES
     PROBLEMS, ONLY CALLS WITH N>=M ARE USEFUL.
 
 
 REFERENCES:
 
     A.BJOERCK AND G.H.GOLUB:
     ITERATIVE REFINEMENT OF LEAST SQUARES SOLUTIONS BY HOUSEHOLDER
     TRANSFORMATION,  BIT 7 (1967), PP. 322-337
 
 
 SUBSECTION: LSQREFSOL.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" LSQREFSOL(A, QR, N, M, N1, AUX,AID,CI,B,LDX,X,RES);
     "VALUE"N,M,N1;"INTEGER"N,M,N1;"INTEGER""ARRAY"CI;"REAL" LDX;
     "ARRAY"A,QR,AUX,AID,B,X,RES;
     "CODE" 34138;
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 4
 
 
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A     :<ARRAY IDENTIFIER>;
            "ARRAY" A[1:N,1:M];
            THE ORIGINAL LEAST SQUARES MATRIX, WHERE THE FIRST N1
            ROWS SET UP A SYSTEM OF LINEAR EQUATIONS THAT MUST BE
            STRICTLY SATISFIED;
     QR    :<ARRAY IDENTIFIER>;
            "ARRAY" QR[1:N,1:M];
            THE QR-DECOMPOSITION OF THE ORIGINAL LEAST SQUARES
            MATRIX AS DELIVERED BY A SUCCESSFUL CALL OF LSQDECOMP;
     N     :<ARITHMETIC EXPRESSION>;
            NUMBER OF ROWS OF THE MATRICES A AND QR;
     M     :<ARITHMETIC EXPRESSION>;
            NUMBER OF COLUMNS OF THE MATRICES A AND QR;
     N1    :<ARITHMETIC EXPRESSION>;
            NUMBER OF LINEAR CONSTRAINTS;
     AUX   :<ARRAY IDENTIFIER>;
            "ARRAY" AUX[2:7];
            ENTRY: AUX[2] CONTAINS A RELATIVE TOLERANCE AS A
                   CRITERION TO STOP ITERATIVE REFINING: IF THE
                   EUCLIDEAN NORM OF THE CORRECTION IS SMALLER
                   THAN AUX[2] TIMES THE CURRENT APPROXIMATION OF
                   THE SOLUTION, THE ITERATIVE REFINING IS STOPPED;
                   AUX[6]: MAXIMUM NUMBER OF ITERATIONS ALLOWED
                   (USUALLY AUX[6]=5 WILL BE SUFFICIENT);
            EXIT : AUX[7]: THE NUMBER OF ITERATIONS PERFORMED;
    AID    :<ARRAY IDENTIFIER>;
            "ARRAY" AID[1:M];
            THE DIAGONAL ELEMENTS OF THE UPPER TRIANGULAR MATRIX
            AS DELIVERED BY A SUCCESSFUL CALL OF LSQDECOMP;
     CI    :<ARRAY IDENTIFIER>;
            "INTEGER""ARRAY" CI[1:M];
            THE PIVOTAL INDICES AS PRODUCED BY LSQDECOMP;
     B     :<ARRAY IDENTIFIER>;
            "ARRAY" B[1:N];
            THE RIGHT-HAND SIDE OF THE LEAST SQUARES PROBLEM;
            FIRST N1 ELEMENTS FORM THE RIGHT HAND SIDES OF THE
            CONSTRAINTS;
     LDX   :<REAL VARIABLE>;
            THE EUCLIDEAN NORM OF THE LAST CORRECTION OF THE
            SOLUTION;
     X     :<ARRAY IDENTIFIER>;
            "ARRAY" X[1:M];
            EXIT: THE SOLUTION VECTOR;
     RES   :<ARRAY IDENTIFIER>;
            "ARRAY" RES[1:N];
            EXIT: THE RESIDUAL VECTOR CORRESPONDING TO THE SOLUTION;
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 5
 
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010.
     MATVEC = CP34011.
     TAMVEC = CP34012.
     ELMVECCOL = CP34021.
     ICHCOL = CP34031.
     LNG SUB = CP31106.
     LNGMATVEC = CP34411.
     LNGTAMVEC = CP34412.
 
 
 RUNNING TIME:
 
     ROUGHLY PROPORTIONAL TO C1*M*N-C2*M**2, WHERE C1 AND C2
     ARE CONSTANTS.
 
 
 METHOD AND PERFORMANCE:
 
     LSQREFSOL SHOULD BE CALLED AFTER A SUCCESSFUL CALL OF LSQDECOMP
     (I.E. AUX[3]=M). LSQREFSOL YIELDS THE LEAST SQUARES SOLUTION OF
     THE OVERDETERMINED SYSTEM WITH THE DECOMPOSED COEFFICIENT MATRIX
     IN THE ARRAY A AND THE RIGHT-HAND SIDE IN ARRAY B. THE ORIGINAL
     LEAST SQUARES MATRIX ALSO CONTAINS THE LINEAR CONSTRAINTS (THE
     FIRST N1 ROWS OF THIS MATRIX SET UP A SYSTEM THAT MUST BE STRICT-
     LY SATISFIED). FIRST, THE ORTHOGONAL TRANSFORMATION WITH THE
     HOUSEHOLDER MATRICES IS PERFORMED ON THE RIGHT-HAND SIDE. NEXT
     THE SYSTEM IS SOLVED BY MEANS OF A BACK SUBSTITUTION. IN THIS
     WAY THE FIRST APPROXIMATION OF THE SOLUTION (WITH PERMUTED
     COLUMNS) IS OBTAINED.
     AFTER THIS AN ITERATIVE PROCESS REFINES THE APPROXIMATION
     UNTIL THE EUCLIDEAN NORM OF THE CORRECTION VECTOR IS NEGLIGIBLY
     SMALL COMPARED TO THE APPROXIMATION OR UNTIL THE MAXIMUM NUMBER
     OF ITERATIONS IS REACHED. FOR A MORE DETAILED DESCRIPTION OF
     THE ITERATIVE IMPROVEMENT, SEE REF[1].
     AFTER THE ITERATIVE PROCESS AN APPROXIMATION TO THE SOLUTION IS
     FOUND. HOWEVER, THE ORDER OF THE COMPONENTS POSSIBLY IS NOT
     CORRECT. THEREFORE THIS ORDER IS RESTORED AT THE END OF THE
     PROCEDURE (SEE ALSO METHOD AND PERFORMANCE OF LSQDECOMP).
     THE LEAST SQUARES SOLUTIONS OF SEVERAL OVERDETERMINED SYSTEMS
     WITH THE SAME CONSTRAINTS AND COEFFICIENT MATRIX CAN BE SOLVED
     BY SUCCESSIVE CALLS OF LSQREFSOL WITH DIFFERENT RIGHT-HAND
     SIDES.
 
 
 REFERENCES:
 
     [1] A.BJOERCK AND G.H.GOLUB:
     ITERATIVE REFINEMENT OF LEAST SQUARES SOLUTIONS BY HOUSEHOLDER
     TRANSFORMATION, BIT 7 (1967), PP. 322-337.
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     THE FOLLOWING PROGRAM SOLVES THE PROBLEM:
 
     MINIMIZE  //B - A*X//
 
     UNDER    X1 + 1000*X2 + 5*X3 = 2016 ,WHERE
     A IS THE MATRIX
 
 
      1    0    8
      0    3    2
      1    2    "-5
      0    0    0
 
     AND THE VECTOR B = (25, 12, 5.00003, 1)' , X = (X1, X2, X3)' ;
 
 
 "BEGIN" "INTEGER" N,M,N1,I,J;
         N := 5; M := 3; N1 := 1;
         "BEGIN""INTEGER""ARRAY" CI[1:M];
             "ARRAY" AUX[2:7],QR,A[1:N,1:M],B,RES[1:N],AID,X[1:M];
             "REAL" LDX;
             A[1,1] := 1; A[1,2] := 1000; A[1,3] := 5;
             A[2,1] := 1; A[2,2] := 0; A[2,3] := 8;
             A[3,1] := 0; A[3,2] := 3; A[3,3] := 2;
             A[4,1] := 1; A[4,2] := 2; A[4,3] := "-5;
             A[5,1]:=A[5,2]:=A[5,3]:=0;
             B[1] := 2016; B[2] :=25; B[3] :=12; B[4] := 5.00003;
             B[5] := 1;  AUX[2] := "-14; AUX[6] := 5;
             "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
             "FOR" J:=1 "STEP" 1 "UNTIL" M "DO" QR[I,J] := A[I,J];
 
             LSQDECOMP(QR,N,M,N1,AUX,AID,CI);
             LSQREFSOL(A,QR,N,M,N1,AUX,AID,CI,B,LDX,X,RES);
 
 OUTPUT(61,"(""("THE SOLUTION VECTOR: ")",//")");
 "FOR" I:=1 "STEP" 1 "UNTIL" M "DO" OUTPUT(61,"("/")",X[I]);
 OUTPUT(61,"("//,"("THE RESIDUAL VECTOR: ")",//")");
 "FOR" J:=N1+1 "STEP" 1 "UNTIL" N "DO" OUTPUT(61,"("/")",RES[J]);
 OUTPUT(61,"("///,"("NUMBER OF ITERATIONS: ")",D,//,
        "("NORM LAST CORRECTION OF X: ")",N")",AUX[7],LDX)
        "END"
 "END"
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 7
 
 
 
 DELIVERS:
 
 
 THE SOLUTION VECTOR:
 
 +1.0000000000000"+000
 +2.0000000000000"+000
 +3.0000000000000"+000
 
 
 THE RESIDUAL VECTOR:
 
 -5.2734444477081"-016
 +2.1280091641666"-015
 +5.3479806840033"-016
 +1.0000000000000"+000
 
 NUMBER OF ITERATIONS: 2
 
 NORM LAST CORRECTION OF X:  +2.1657844626990"-015
 
 
 
 SOURCE TEXT(S):
0"CODE" 34137;
 "PROCEDURE" LSQDECOMP( A, N ,M ,N1 ,AUX ,AID ,CI );
 "VALUE" N , M ,N1;"INTEGER" N,M,N1;"ARRAY" A,AUX, AID;
 "INTEGER""ARRAY" CI;
 "BEGIN""INTEGER"J,K,KPIV,NR,S;"BOOLEAN" FSUM;
     "REAL" BETA,SIGMA,NORM,AIDK,AKK,W,EPS;
     "ARRAY" SUM[1:M];
 
     NORM:=0 ; AUX[3]:=M;NR:=N1;FSUM:="TRUE";
     "FOR" K:=1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" "IF" K=N1+1 "THEN" "BEGIN" FSUM:="TRUE"; NR:=N "END";
         "IF" FSUM "THEN"
         "FOR" J:=K "STEP" 1 "UNTIL" M "DO"
         "BEGIN" W:=SUM[J]:= TAMMAT(K ,NR ,J ,J ,A ,A);
                 "IF" W>NORM "THEN" NORM:=W
         "END"; FSUM:="FALSE";EPS:=AUX[2]*SQRT(NORM);
         SIGMA:=SUM[K]; KPIV:=K;
         "FOR" J:=K+1 "STEP" 1 "UNTIL" M "DO"
         "IF" SUM[J]>SIGMA "THEN"
         "BEGIN" SIGMA:=SUM[J]; KPIV:=J "END";
                                                               "COMMENT"
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 8
                                                                  ;
 
 
         "IF" KPIV^=K "THEN"
         "BEGIN" SUM[KPIV]:=SUM[K]; ICHCOL( 1 ,N ,K ,KPIV ,A) "END";
         CI[K]:=KPIV; AKK:=A[K,K];
         SIGMA:=TAMMAT(K ,NR ,K ,K ,A ,A); W:=SQRT(SIGMA);
         AIDK:=AID[K]:="IF" AKK<0 "THEN" W "ELSE" -W;
         "IF" W<EPS "THEN"
         "BEGIN" AUX[3]:=K-1;"GOTO" ENDDEC "END";
         BETA:= 1/(SIGMA-AKK*AIDK); A[K,K]:=AKK-AIDK;
         "FOR" J:=K+1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" ELMCOL(K ,NR ,J ,K ,A ,A ,-BETA*TAMMAT(K ,NR ,
         K ,J ,A ,A)); SUM[J]:=SUM[J]-A[K,J]**2
         "END";
         "IF" K=N1 "THEN"
         "FOR" J:=N1+1 "STEP" 1 "UNTIL" N "DO"
         "FOR" S:=1 "STEP" 1 "UNTIL" M "DO"
         "BEGIN" NR:="IF" S>N1 "THEN" N1 "ELSE" S-1;
         W:=A[J,S]-MATMAT(1 ,NR , J ,S ,A ,A);
         A[J,S]:="IF" S>N1 "THEN" W "ELSE" W/AID[S]
         "END"
     "END" FOR K;
   ENDDEC:
 "END" LSQDECOMP;
         "EOP"
 "CODE" 34138;
 "PROCEDURE" LSQREFSOL(A, QR, N, M, N1, AUX, AID, CI, B,LDX,X,RES);
 "VALUE"N,M,N1;"INTEGER"N,M,N1;"INTEGER""ARRAY"CI;"REAL"LDX;
 "ARRAY"QR,A,AID,AUX,X,RES,B;
 "BEGIN""INTEGER"I,J,K,S;
        "REAL"C1,NEXVE,NDX,NDR,D,DD,OP,OPL,CORRNORM;
        "ARRAY"F[1:N],G[1:M];
        "PROCEDURE" HOUSEHOLDER(P, Q, R, E);
        "VALUE" P,Q,R,E;"INTEGER" P,Q,R,E;
        "BEGIN" "FOR" S:=P "STEP" Q "UNTIL" R "DO"
                ELMVECCOL(S, E, S, F, QR,TAMVEC(S, E, S,QR, F)/(QR[S,S]*
                AID[S]))
        "END";
        "FOR" J:=1 "STEP" 1 "UNTIL" M "DO"
        "BEGIN" S:=CI[J];"IF" S^=J"THEN" ICHCOL(1,N,J,S,A) "END";
        "FOR"J:=1"STEP"1"UNTIL"M"DO"X[J]:=G[J]:=0;
        "FOR"I:=1"STEP"1"UNTIL"N"DO"
        "BEGIN"RES[I]:=0;F[I]:=B[I]"END";
                                                               "COMMENT"
1SECTION : 3.1.1.2.1.4       (DECEMBER 1978)                      PAGE 9
                                                                  ;
 
 
        "FOR"K:=0,1,K+1
           "WHILE" (CORRNORM>AUX[2]*NEXVE & K<=AUX[6])
        "DO"
        "BEGIN"NDX:=NDR:=0;
           "IF"K^=0"THEN"
           "BEGIN""FOR"I:=1"STEP"1"UNTIL"N"DO"RES[I]:=RES[I]+F[I];
                  "FOR"S:=1"STEP"1"UNTIL"M"DO"
                  "BEGIN" X[S]:=X[S]+G[S];
                         LNGTAMVEC(1,N,S,A,RES,0,0,D,DD);
                         G[S]:=(-D-TAMVEC(1,S-1,S,QR,G))/AID[S]
                  "END";
                  "FOR"I:=1"STEP"1"UNTIL"N"DO"
                  "BEGIN" LNGMATVEC(1, M, I, A, X,
                          "IF" I>N1 "THEN" RES[I] "ELSE" 0, 0, D, DD);
                         LNG SUB(B[I],0,D,DD,OP,OPL);
                         F[I]:=OP
                  "END"
           "END";
           NEXVE:=SQRT(VECVEC(1,M,0,X,X)+VECVEC(1,N,0,RES,RES));
           HOUSEHOLDER(1, 1, N1, N1);
           "FOR" I:=N1+1 "STEP" 1 "UNTIL" N "DO"
           F[I]:=F[I]-MATVEC(1,N1, I, QR, F);
           HOUSEHOLDER(N1+1, 1, M, N);
           "FOR" I:=1 "STEP" 1 "UNTIL" M "DO"
           "BEGIN" C1:=F[I];F[I]:=G[I];
               G[I]:="IF" I>N1 "THEN" C1-G[I] "ELSE" C1
           "END";
           "FOR"S:=M"STEP"-1"UNTIL"1"DO"
           "BEGIN"G[S]:=(G[S]-MATVEC(S+1,M,S,QR,G))/AID[S];
                  NDX:=NDX+G[S]**2
           "END";
           HOUSEHOLDER(M, -1, N1+1, N);
           "FOR" S:=1 "STEP" 1 "UNTIL" N1 "DO"
           F[S]:=F[S]-TAMVEC(N1+1, N, S, QR, F);
           HOUSEHOLDER(N1, -1, 1, N1);
           AUX[7]:=K;
           "FOR"I:=1"STEP"1"UNTIL"N"DO"NDR:=NDR+F[I]**2;
           CORRNORM:=SQRT(NDX+NDR)
        "END"FOR K;
        LDX:=SQRT(NDX);
        "FOR" S:=M "STEP" -1 "UNTIL" 1 "DO"
        "BEGIN" J:=CI[S];"IF" J^=S "THEN"
           "BEGIN" C1:=X[J];X[J]:=X[S];X[S]:=C1;ICHCOL(1,N,J,S,A)"END"
        "END"
 "END" LSQREFSOL;
         "EOP"
1SECTION : 3.1.1.3.1.1         (FEBRUARY 1979)                    PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 RECEIVED : 731217
 
 BRIEF DESCRIPTION :
 
     THIS  SECTION  CONTAINS  2  PROCEDURES   FOR  THE  SOLUTION  OF  AN
     OVERDETERMINED SYSTEM OF LINEAR EQUATIONS:
     SOLSVDOVR  SOLVES AN OVERDETERMINED SYSTEM OF LINEAR EQUATIONS ,
     MULTIPLYING THE  RIGHT-HAND SIDE BY THE PSEUDO-INVERSE OF THE GIVEN
     MATRIX; THE SINGULAR VALUES DECOMPOSITION SHOULD BE AVAILABLE.
     SOLOVR CALCULATES THE SINGULAR VALUES DECOMPOSITION AND SOLVES AN
     OVERDETERMINED SYSTEM OF LINEAR EQUATIONS.
 
 KEYWORDS :
     BEST LEAST-SQUARES SOLUTION
     SINGULAR VALUES
     PSEUDO-INVERSE
 
 
 SUBSECTION : SOLSVDOVR
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" SOLSVDOVR(U, VAL, V, M, N, X, EM);
     "VALUE" M,N; "INTEGER" M,N; "ARRAY" U, VAL, V, X, EM; "CODE" 34280;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     U:  <ARRAY IDENTIFIER>;
         "ARRAY" U[1:M,1:N];
         ENTRY:THE MATRIX U IN THE SINGULAR VALUES DECOMPOSITION U*S*V'.
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         ENTRY:THE SINGULAR VALUES.
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         ENTRY:THE MATRIX V IN THE SINGULAR VALUES DECOMPOSITION.
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF UNKNOWNS.
     M:  <ARITHMETIC EXPRESSION>;
         THE LENGTH OF THE RIGHT-HAND SIDE VECTOR, N SHOULD SATISFY
         N <= M.
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[1:M];
         ENTRY: THE RIGHT-HAND SIDE VECTOR;
         EXIT: THE SOLUTION VECTOR IN X[1:N].
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[6:6];
         ENTRY: EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE.
1SECTION : 3.1.1.3.1.1         (FEBRUARY 1979)                    PAGE 2
 
 
 
 PROCEDURES USED :
     MATVEC = CP34011
     TAMVEC = CP34012
 
 REQUIRED CENTRAL MEMORY : AN AUXILIARY ARRAY OF N REALS IS DECLARED.
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (M + N) * N
 
 METHOD AND PERFORMANCE :
 
     THE SOLUTION IS FOUND IN THREE STEPS :
     1.  U' * X = X1 IS CALCULATED,
     2.  VAL+ * X1 = X2  IS CALCULATED,  HERE VAL+  DENOTES THE DIAGONAL
         MATRIX OBTAINED FROM VAL BY SETTING VAL+[I,I] = 1/VAL[I]  IF
         VAL[I] GREATER THAN OR EQUAL TO EM[6], AND 0 OTHERWISE,
     3.  THE SOLUTION V * X2 IS CALCULATED.
 
 
 SUBSECTION : SOLOVR
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" SOLOVR(A, M, N, X, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, X, EM; "CODE" 34281;
 
     SOLOVR:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E. ZERO IF ALL
         SINGULAR VALUES ARE CALCULATED.
 
     THE MEANING OF THE FORMAL PAREMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE MATRIX OF THE SYSTEM;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N <= M;
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[1:M];
         ENTRY: THE RIGHT-HAND SIDE VECTOR;
         EXIT: THE SOLUTION VECTOR IN X[1:N];
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
         ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION OF THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED IN
                    THE SINGULAR VALUES DECOMPOSITION;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT:EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS  PERFORMED IN THE SINGULAR
                    VALUES DECOMPOSITION;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                    SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
1SECTION : 3.1.1.3.1.1         (FEBRUARY 1979)                    PAGE 3
 
 
 
 PROCEDURES USED :
 
     QRISNGVALDEC = CP34273
     SOLSVDOVR    = CP34280
 
 REQUIRED CENTRAL MEMORY :
 
     AUXILIARY ARRAYS ARE DECLARED TO A TOTAL OF (N + 2) * N REALS
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (M + N) * N * N
 
 METHOD AND PERFORMANCE :
 
     THE SOLUTION IS FOUND IN TWO STEPS :
     1.  THE SINGULAR VALUES DECOMPOSITION IS CALCULATED BY MEANS OF THE
         PROCEDURE QRISNGVALDEC (SECTION 3.5.1.2);
     2.  THE SOLUTION IS CALCULATED BY MEANS OF THE PROCEDURE SOLSVDOVR,
         (THIS SECTION);
 
 
 REFERENCES :
         WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL. 2 (CONTRIBUTION I-10)
         LINEAR ALGEBRA
         HEIDELBERG (1971)
 
 EXAMPLE OF USE :
 
     FIRST A PROGRAM IS GIVEN, AND THEN THE RESULTS OF THIS PROGRAM :
 
     "BEGIN" "ARRAY" A[1:8,1:5], B[1:8], EM[0:7];
         "INTEGER" I;
         A[1,1]:=22; A[1,2]:= A[2,3]:=10; A[1,3]:= A[7,1]:= A[8,5]:=2;
         A[1,4]:= A[3,5]:=3; A[1,5]:= A[2,2]:=7; A[2,1]:=14; A[2,5]:=8;
         A[2,4]:= A[8,3]:=0; A[3,1]:= A[3,3]:= A[6,5]:=-1; A[3,2]:=13;
         A[3,4]:=-11; A[4,1]:=-3; A[4,2]:= A[4,4]:= A[5,4]:= A[8,4]:=-2;
         A[4,3]:=13; A[4,5]:= A[5,5]:= A[8,1]:=4; A[5,1]:= A[6,1]:=9;
         A[5,2]:=8; A[5,3]:= A[6,2]:= A[7,5]:=1; A[6,3]:=-7;
         A[6,4]:= A[7,4]:= A[8,2]:=5; A[7,2]:=-6; A[7,3]:=6;
         B[1]:=-1; B[2]:=2; B[3]:= B[7]:=1; B[4]:=4; B[5]:= B[8]:=0;
         B[6]:=-3; EM[0]:="-14; EM[2]:="-12; EM[4]:=80; EM[6]:="-10;
         I:= SOLOVR(A, 8, 5, B, EM);
         OUTPUT(61, "("4B, "("NUMBER SINGULAR VALUES NOT FOUND : ")",
         3ZD,/, 4B, "("NORM : ")", N,/, 4B, "("MAX NEGL SUBD ELEM : ")",
         N,/, 4B, "("NUMBER ITERATIONS : ")", 3ZD, /, 4B, "("RANK : ")",
         3ZD, /")", I, EM[1], EM[3], EM[5], EM[7]);
         OUTPUT(61, "("/, 4B, "("SOLUTION VECTOR")",/,/, 5(4B, N, /)")",
         B[1], B[2], B[3], B[4], B[5])
     "END"
1SECTION : 3.1.1.3.1.1         (FEBRUARY 1979)                    PAGE 4
 
 
 
      NUMBER SINGULAR VALUES NOT FOUND :    0
      NORM : +4.4000000000000"+001
      MAX NEGL SUBD ELEM : +4.3977072741076"-014
      NUMBER ITERATIONS :    6
      RANK :    3
 
      SOLUTION VECTOR
 
      -8.3333333333334"-002
      +1.0989227456287"-015
      +2.5000000000000"-001
      -8.3333333333332"-002
      +8.3333333333334"-002
         "EOP"
 
 SOURCE TEXT(S):
0"CODE" 34280;
 "PROCEDURE" SOLSVDOVR(U, VAL, V, M, N, X, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V, X, EM;
 "BEGIN" "INTEGER" I;
     "REAL" MIN;
     "ARRAY" X1[1:N];
     MIN:= EM[6];
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     X1[I]:= "IF" VAL[I] <= MIN "THEN" 0 "ELSE" TAMVEC(1, M, I, U, X) /
     VAL[I];
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     X[I]:= MATVEC(1, N, I, V, X1)
 "END" SOLSVDOVR;
         "EOP"
0"CODE" 34281;
 "INTEGER" "PROCEDURE" SOLOVR(A, M, N, X, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, X, EM;
 "BEGIN" "INTEGER" I;
     "ARRAY" VAL[1:N], V[1:N,1:N];
 
     SOLOVR:= I:= QRISNGVALDEC(A, M, N, VAL, V, EM);
     "IF" I = 0 "THEN" SOLSVDOVR(A, VAL, V, M, N, X, EM)
 "END" SOLOVR;
         "EOP"
1SECTION 3.1.1.3.1.2           (DECEMBER 1975)                    PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 
 RECEIVED : 731217
 
 
 BRIEF DESCRIPTION :
 
     THIS  SECTION  CONTAINS  2  PROCEDURES   FOR THE  SOLUTION  OF AN
     UNDERDETERMINED SYSTEM OF LINEAR EQUATIONS:
     SOLUND  EXPECTS  AS INPUT  THE MATRIX  OF THE SYSTEM  OF EQUATIONS,
     CALCULATES  THE  SINGULAR  VALUES  DECOMPOSITION  BY  MEANS  OF THE
     PROCEDURE  QRISNGVALDEC, AND SOLVES THE  SYSTEM  BY  MEANS  OF  THE
     PROCEDURE SOLSVDUND.
     SOLSVDUND  ASSUMES THAT THE MATRIX IS
     ALREADY DECOMPOSED AND SOLVES THE SYSTEM OF  EQUATIONS, MULTIPLYING
     THE RIGHT-HAND SIDE BY THE PSEUDO-INVERSE OF THE GIVEN MATRIX.
 
 KEYWORDS :
 
     BEST LEAST-SQUARES SOLUTION
     SINGULAR VALUES
     PSEUDO-INVERSE
1SECTION 3.1.1.3.1.2           (DECEMBER 1975)                    PAGE 2
 
 
 
 SUBSECTION : SOLSVDUND
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" SOLSVDUND(U, VAL, V, M, N, X, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V, X, EM;
     "CODE" 34282;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     U:  <ARRAY IDENTIFIER>;
         "ARRAY" U[1:M,1:N];
         ENTRY:THE MATRIX U IN THE SINGULAR VALUES DECOMPOSITION V*S*U'.
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         ENTRY:THE SINGULAR VALUES;
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         ENTRY:THE MATRIX V IN THE SINGULAR VALUES DECOMPOSITION.
     N:  <ARITHMETIC EXPRESSION>;
         THE LENGTH OF THE RIGHT-HAND SIDE VECTOR;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF UNKNOWNS, N SHOULD SATISFY N <= M;
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[1:M];
         ENTRY: THE RIGHT-HAND SIDE VECTOR IN X[1:N];
         EXIT: THE SOLUTION VECTOR IN X[1:M];
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[6:6];
         ENTRY: EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE.
 
 
 PROCEDURES USED :
 
     MATVEC = CP34011
     TAMVEC = CP34012
 
 
 REQUIRED CENTRAL MEMORY : AN AUXILIARY ARRAY OF N REALS IS DECLARED
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (M + N) * N
 
 
 METHOD AND PERFORMANCE :
 
     THE SOLUTION IS FOUND IN THREE STEPS :
     1.  V' * X = X1 IS CALCULATED,
     2.  VAL+ * X1 = X2 IS CALCULATED,  HERE  VAL+  DENOTES THE DIAGONAL
         MATRIX OBTAINED FROM VAL  BY SETTING  VAL+[I,I] = 1/VAL[I]  IF
         VAL[I] GREATER THAN OR EQUAL TO EM[6], AND 0 OTHERWISE,
     3.  THE SOLUTION U * X2 IS CALCULATED.
 
 LANGUAGE : ALGOL 60
1SECTION 3.1.1.3.1.2           (DECEMBER 1975)                    PAGE 3
 
 
 
 SUBSECTION : SOLUND
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" SOLUND(A, M, N, X, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, X, EM;
     "CODE" 34283;
 
     SOLUND:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E. ZERO IF ALL
         SINGULAR VALUES ARE CALCULATED.
 
     THE MEANING OF THE FORMAL PAREMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE TRANSPOSE OF THE MATRIX;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N <= M;
     X:  <ARRAY IDENTIFIER>;
         "ARRAY" X[1:M];
         ENTRY: THE RIGHT-HAND SIDE VECTOR IN X[1:N];
         EXIT: THE SOLUTION VECTOR.
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
         ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION FOR THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED IN
                    THE SINGULAR VALUES DECOMPOSITION;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS PERFORMED  IN THE SINGULAR
                    VALUES DECOMPOSITION;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                    SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
 PROCEDURES USED :
 
     QRISNGVALDEC = CP34273
     SOLSVDUND    = CP34282
 
 REQUIRED CENTRAL MEMORY :
 
     AUXILIARY ARRAYS ARE DECLARED TO A TOTAL OF (N + 1) * N REALS
 
 
 METHOD AND PERFORMANCE :
 
     THE SOLUTION IS FOUND IN TWO STEPS :
     1.  THE SINGULAR VALUES DECOMPOSITION IS CALCULATED BY MEANS OF THE
         PROCEDURE QRISNGVALDEC;
     2.  THE SOLUTION IS CALCULATED BY MEANS OF THE PROCEDURE SOLSVDUND.
1SECTION 3.1.1.3.1.2           (MAY 1974)                         PAGE 4
 
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (M + N) * N * N
 
 LANGUAGE : ALGOL-60
 
 REFERENCES :
 
         WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL. 2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
 
 EXAMPLE OF USE :
 
     FIRST WE GIVE A PROGRAM, AND THAN THE RESULTS OF THIS PROGRAM :
 
     "BEGIN" "ARRAY" A[1:8,1:5], B[1:8], EM[0:7];
         "INTEGER" I;
         A[1,1]:=22; A[1,2]:= A[2,3]:=10; A[1,3]:= A[7,1]:= A[8,5]:=2;
         A[1,4]:= A[3,5]:=3; A[1,5]:= A[2,2]:=7; A[2,1]:=14; A[2,5]:=8;
         A[2,4]:= A[8,3]:=0; A[3,1]:= A[3,3]:= A[6,5]:=-1; A[3,2]:=13;
         A[3,4]:=-11; A[4,1]:=-3; A[4,2]:= A[4,4]:= A[5,4]:= A[8,4]:=-2;
         A[4,3]:=13; A[4,5]:= A[5,5]:= A[8,1]:=4; A[5,1]:= A[6,1]:=9;
         A[5,2]:=8; A[5,3]:= A[6,2]:= A[7,5]:=1; A[6,3]:=-7;
         A[6,4]:= A[7,4]:= A[8,2]:=5; A[7,2]:=-6; A[7,3]:=6;
         B[1]:=-1; B[2]:=2; B[3]:=1; B[4]:=4; B[5]:=0;
         EM[0]:="-14; EM[2]:="-12; EM[4]:=80; EM[6]:="-10;
         I:= SOLUND(A, 8, 5, B, EM);
         OUTPUT(61, "("4B, "("NUMBER SINGULAR VALUES NOT FOUND : ")",
         3ZD,/, 4B, "("NORM : ")",N, /, 4B, "("MAX NEGL SUBD ELEM : ")",
         N,/, 4B, "("NUMBER ITERATIONS : ")", 3ZD, /, 4B, "("RANK : ")",
         3ZD, /")", I, EM[1], EM[3], EM[5], EM[7]);
         OUTPUT(61, "("/, 4B, "("SOLUTION VECTOR")", /,/, 8(4B, N,/)")",
         B[1], B[2], B[3], B[4], B[5], B[6], B[7], B[8])
     "END"
 
      NUMBER SINGULAR VALUES NOT FOUND :    0
      NORM : +4.4000000000000"+001
      MAX NEGL SUBD ELEM : +4.3977072741076"-014
      NUMBER ITERATIONS :    6
      RANK :    3
 
      SOLUTION VECTOR
 
      +1.6410256410255"-002
      +1.4807692307694"-002
      -4.8397435897438"-002
      +1.0000000000002"-002
      -6.7948717948740"-003
      +1.1602564102565"-002
      +2.9999999999996"-002
      -8.3974358974328"-003
1SECTION 3.1.1.3.1.2           (MAY 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S):
0"CODE" 34282;
 "PROCEDURE" SOLSVDUND(U, VAL, V, M, N, X, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V, X, EM;
 "BEGIN" "INTEGER" I;
     "REAL" MIN;
     "ARRAY" X1[1:N];
 
 
     MIN:= EM[6];
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     X1[I]:= "IF" VAL[I] <= MIN "THEN" 0 "ELSE" TAMVEC(1, N, I, V, X) /
     VAL[I];
     "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
     X[I]:= MATVEC(1, N, I, U, X1)
 "END" SOLSVDUND;
         "EOP"
0"CODE" 34283;
 "INTEGER" "PROCEDURE" SOLUND(A, M, N, X, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, X, EM;
 "BEGIN" "INTEGER" I;
     "ARRAY" VAL[1:N], V[1:N,1:N];
 
 
     SOLUND:= I:= QRISNGVALDEC(A, M, N, VAL, V, EM);
     "IF" I = 0 "THEN" SOLSVDUND(A, VAL, V, M, N, X, EM)
 "END" SOLUND;
         "EOP"
1SECTION 3.1.1.3.1.3           (DECEMBER 1975)                    PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 
 RECEIVED : 731217
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS 2 PROCEDURES  FOR THE
     CALCULATION OF THE HOMOGENEOUS EQUATIONS  A * X = 0 AND X' * A = 0,
     WHERE  A  DENOTES A MATRIX,  AND  X  A VECTOR:
     HOMSOLSVD  ASSUMES THAT THE SINGULAR VALUES DECOMPOSITION OF A HAS
     BEEN GIVEN.
     HOMSOL  FIRST   CALCULATES   THE  SINGULAR  VALUES
     DECOMPOSITION BY MEANS OF THE PROCEDURE QRISNGVALDEC.
 
 KEYWORDS :
 
     HOMOGENEOUS SOLUTION
     SINGULAR VALUES
 
 
 SUBSECTION : HOMSOLSVD
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" HOMSOLSVD(U, VAL, V, M, N);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V;
     "CODE" 34284;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     U:  <ARRAY IDENTIFIER>;
         "ARRAY" U[1:M,1:N];
         ENTRY:
             THE MATRIX U IN THE SINGULAR VALUES DECOMPOSITION A=U*S*V'.
         EXIT: THE COLUMNS OF U THAT CORRESPOND TO THE ELEMENTS
         OF VAL WITH  A VALUE  SMALLER THAN  SOME SMALL CONSTANT  MAY BE
         SEEN AS THE SOLUTIONS OF X' * A = 0;
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         ENTRY:THE SINGULAR VALUES;
         EXIT :THE  ARRAY  WILL  BE  ORDERED  IN  SUCH  A  WAY  THAT
         VAL[I] < VAL[J] IF J < I;
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         ENTRY:THE  MATRIX  V  IN  THE  SINGULAR  VALUES  DECOMPOSITION;
         EXIT:THE COLUMNS OF V THAT CORRESPOND TO THE ELEMENTS OF VAL
         THAT  ARE  SMALLER  THAN SOME SMALL CONSTANT MAY BE SEEN AS THE
         SOLUTIONS OF THE EQUATION A * X = 0;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF U;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF U;
1SECTION 3.1.1.3.1.3           (DECEMBER 1975)                    PAGE 2
 
 
 
 PROCEDURES USED :
 
     ICHCOL = CP34031
 
 
 RUNNING TIME : PROPORTIONAL TO N ' 2
 
 
 METHOD AND PERFORMANCE :
 
     THE PROCEDURE DOES NOTHING MORE  THAN A SIMPLE  SORTING  PROCESS ON
     THE ELEMENTS OF  THE ARRAY VAL,  AT THE SAME TIME  THE COLUMNS OF U
     AND V ARE INTERCHANGED, ACCORDING TO  THE INTERCHANGING OF THE
     ELEMENTS  VAL.
 
 
 LANGUAGE : ALGOL 60
 
 
 SUBSECTION : HOMSOL
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" HOMSOL(A, M, N, V, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, V, EM;
     "CODE" 34285;
 
     HOMSOL:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E. ZERO IF ALL
         SINGULAR VALUES ARE CALCULATED.
 
     THE MEANING OF THE FORMAL PAREMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE MATRIX;
         EXIT:  THE COLUMNS OF A THAT  CORRESPOND TO THE ELEMENTS OF
             VAL THAT ARE SMALLER THAN SOME SMALL CONSTANT,  MAY BE SEEN
             AS THE SOLUTIONS OF THE EQUATION X' * A = 0.
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A.
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A.
1SECTION 3.1.1.3.1.3           (DECEMBER 1975)                    PAGE 3
 
 
 
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         EXIT:  THE COLUMNS OF  V  THAT CORRESPOND TO ELEMENTS OF VAL
             SMALLER  THAN  SOME  SMALL  CONSTANT  MAY  BE  SEEN  AS THE
             SOLUTIONS OF THE EQUATION A * X = 0.
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
         ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION FOR THE SINGULAR VALUES;
             EM[4]:  THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED IN
                 THE SINGULAR VALUES DECOMPOSITION.
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
         EXIT: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]:  THE NUMBER  OF ITERATIONS PERFORMED IN THE SINGULAR
                 VALUES DECOMPOSITION;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                 SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6].
 
 
 PROCEDURES USED :
 
     QRISNGVALDEC = CP34273
     HOMSOLSVD    = CP34284
 
 
 METHOD AND PERFORMANCE :
 
     THE SOLUTION IS FOUND IN TWO STEPS :
     1.  THE SINGULAR VALUES DECOMPOSITION IS CALCULATED BY MEANS OF THE
         PROCEDURE QRISNGVALDEC;
     2.  THE  SINGULAR  VALUES  ARE  ORDERED  BY MEANS OF  THE PROCEDURE
         HOMSOLSVD (PROVIDED THAT ALL SINGULAR VALUES HAVE BEEN FOUND).
 
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (M + N) * N * N
 
 
 LANGUAGE : ALGOL 60
 
 
 REFERENCES :
 
         WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL. 2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
1SECTION 3.1.1.3.1.3           (NOVEMBER 1976)                    PAGE 4
 
 
 
 EXAMPLE OF USE :
 
     FIRST WE GIVE A PROGRAM, AND THAN THE RESULTS OF THIS PROGRAM :
 
     "BEGIN" "ARRAY" A[1:8,1:5], V[1:5,1:5], EM[0:7];
         "INTEGER" I, J;
         A[1,1]:=22; A[1,2]:= A[2,3]:=10; A[1,3]:= A[7,1]:= A[8,5]:=2;
         A[1,4]:= A[3,5]:=3; A[1,5]:= A[2,2]:=7; A[2,1]:=14; A[2,5]:=8;
         A[2,4]:= A[8,3]:=0; A[3,1]:= A[3,3]:= A[6,5]:=-1; A[3,2]:=13;
         A[3,4]:=-11; A[4,1]:=-3; A[4,2]:= A[4,4]:= A[5,4]:= A[8,4]:=-2;
         A[4,3]:=13; A[4,5]:= A[5,5]:= A[8,1]:=4; A[5,1]:= A[6,1]:=9;
         A[5,2]:=8; A[5,3]:= A[6,2]:= A[7,5]:=1; A[6,3]:=-7;
         A[6,4]:= A[7,4]:= A[8,2]:=5; A[7,2]:=-6; A[7,3]:=6;
         EM[0]:="-14; EM[2]:="-12; EM[4]:=80; EM[6]:="-10;
         I:= HOMSOL(A, 8, 5, V, EM);
         OUTPUT(61, "("4B, "("NUMBER SINGULAR VALUES NOT FOUND : ")",
         3ZD,/, 4B, "("NORM : ")", N,/, 4B, "("MAX NEGL SUBD ELEM : ")",
         N,/, 4B, "("NUMBER ITERATIONS : ")", 3ZD, /, 4B, "("RANK : ")",
         3ZD, /")", I, EM[1], EM[3], EM[5], EM[7]);
         "FOR" J:= EM[7] + 1 "STEP" 1 "UNTIL" 5 "DO"
         OUTPUT(61, "("/, 4B, "("COLUMN NUMBER : ")", D, 5(/ ,4B, 2(N)),
         3(/, 4B, N), /")", J, A[1,J], V[1,J], A[2,J], V[2,J], A[3,J],
         V[3,J], A[4,J], V[4,J], A[5,J], V[5,J], A[6,J], A[7,J], A[8,J])
     "END"
 
      NUMBER SINGULAR VALUES NOT FOUND :    0
      NORM : +4.4000000000000"+001
      MAX NEGL SUBD ELEM : +4.3977072741076"-014
      NUMBER ITERATIONS :    6
      RANK :    3
 
      COLUMN NUMBER : 4
      +3.4708599800002"-001  -4.1909548511171"-001
      -6.0723369623011"-001  +4.4050912303713"-001
      +1.2207461910546"-001  -5.2004549247434"-002
      +6.1882574433898"-001  +6.7605914021670"-001
      -4.6344371870996"-003  +4.1297730284731"-001
      +3.3409859838125"-001
      -3.3528410857408"-002
      -1.3547246422274"-002
 
      COLUMN NUMBER : 5
      -2.5533109413182"-001  +0.0000000000000"+000
      -1.7359809248754"-001  -4.1854806384909"-001
      -2.2081225414163"-001  -3.4879005320758"-001
      +4.1165471593410"-002  -2.4415303724531"-001
      +9.2044247057656"-001  +8.0221712237742"-001
      -2.8895953996492"-002
      +6.1327596621994"-002
      -4.9058079025100"-002
1SECTION 3.1.1.3.1.3           (MAY 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S):
 
 "CODE" 34284;
 "PROCEDURE" HOMSOLSVD(U, VAL, V, M, N);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V;
 "BEGIN" "INTEGER" I, J;
     "REAL" X;
 
     "FOR" I:= N "STEP" - 1 "UNTIL" 2 "DO"
     "FOR" J:= I - 1 "STEP" - 1 "UNTIL" 1 "DO"
     "IF" VAL[I] > VAL[J] "THEN"
     "BEGIN" X:= VAL[I]; VAL[I]:= VAL[J]; VAL[J]:= X;
         ICHCOL(1, M, I, J, U); ICHCOL(1, N, I, J, V)
     "END"
 "END" HOMSOLSVD;
         "EOP"
0"CODE" 34285;
 "INTEGER" "PROCEDURE" HOMSOL(A, M, N, V, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, V, EM;
 "BEGIN" "INTEGER" I;
     "ARRAY" VAL[1:N];
 
     HOMSOL:= I:= QRISNGVALDEC(A, M, N, VAL, V, EM);
     "IF" I = 0 "THEN" HOMSOLSVD(A, VAL, V, M, N)
 "END" HOMSOL;
         "EOP"
1SECTION 3.1.1.3.1.4           (DECEMBER 1979)                    PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 
 RECEIVED : 731217
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS TWO PROCEDURES  FOR THE
     CALCULATION OF THE PSEUDO-INVERSE OF A MATRIX:
     PSDINVSVD  ASSUMES  THAT  THE  MATRIX  IS  GIVEN AS SINGULAR VALUES
     DECOMPOSITION.
     PSDINV  FIRST CALCULATES THIS DECOMPOSITION.
 
 
 KEYWORDS :
 
     PSEUDO-INVERSE
     SINGULAR VALUES
 
 
 SUBSECTION : PSDINVSVD
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" PSDINVSVD(U, VAL, V, M, N, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V, EM; "CODE" 34286;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     U:  <ARRAY IDENTIFIER>;
         "ARRAY" U[1:M,1:N];
         ENTRY:  THE  MATRIX  U  IN THE  SINGULAR  VALUES  DECOMPOSITION
             U * S * V';
         EXIT: THE TRANSPOSE OF THE PSEUDO-INVERSE.
     VAL: <ARRAY IDENTIFIER>;
         "ARRAY" VAL[1:N];
         THE SINGULAR VALUES.
     V:  <ARRAY IDENTIFIER>;
         "ARRAY" V[1:N,1:N];
         THE MATRIX V IN THE SINGULAR VALUES DECOMPOSITION U * S * V'.
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF U.
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF V.
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[6:6];
         ENTRY: EM[6]:THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE.
1SECTION 3.1.1.3.1.4           (DECEMBER 1979)                    PAGE 2
 
 
 
 PROCEDURES USED :
 
     MATVEC = CP34011
 
 REQUIRED CENTRAL MEMORY : AN AUXILIARY ARRAY OF N REALS IS DECLARED
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO M * N * N
 
 
 METHOD AND PERFORMANCE :
 
     THE PSEUDO-INVERSE IS CALCULATED IN TWO STEPS :
     1.  THE MATRIX X = VAL+ * U' IS CALCULATED,  WHERE VAL+ DENOTES THE
         DIAGONAL MATRIX OBTAINED FROM VAL BY PUTTING
         VAL+[I,I] = 1/VAL[I] IF VAL[I] GREATER THAN OR EQUAL TO EM[6],
         AND VAL+[I,I] = 0 OTHERWISE.
     2.  THE PSEUDO INVERSE (V * X) IS CALCULATED.
 
 
 SUBSECTION : PSDINV
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
     "INTEGER" "PROCEDURE" PSDINV(A, M, N, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, EM; "CODE" 34287;
 
     PSDINV:= THE NUMBER OF SINGULAR VALUES NOT FOUND,  I.E. ZERO IF ALL
         SINGULAR VALUES ARE CALCULATED.
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A   <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY : THE GIVEN MATRIX;
         EXIT : THE TRANSPOSE OF THE PSEUDO-INVERSE;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N<= M;
     EM: <ARRAY IDENTIFIER>;
         "ARRAY" EM[0:7];
      ENTRY: EM[0]: THE MACHINE PRECISION;
             EM[2]: THE RELATIVE PRECISION FOR THE SINGULAR VALUES;
             EM[4]: THE MAXIMAL NUMBER OF ITERATIONS TO BE PERFORMED;
             EM[6]: THE MINIMAL NON-NEGLECTABLE SINGULAR VALUE;
       EXIT: EM[1]: THE INFINITY NORM OF THE MATRIX;
             EM[3]: THE MAXIMAL NEGLECTED SUPERDIAGONAL ELEMENT;
             EM[5]: THE NUMBER OF ITERATIONS  PERFORMED IN THE SINGULAR
                    VALUES DECOMPOSITION;
             EM[7]: THE NUMERICAL RANK OF THE MATRIX, I.E. THE NUMBER OF
                    SINGULAR VALUES GREATER THAN OR EQUAL TO EM[6];
1SECTION 3.1.1.3.1.4           (DECEMBER 1979)                    PAGE 3
 
 
 
 PROCEDURES USED :
 
     QRISNGVALDEC = CP34273
     PSDINVSVD    = CP34286
 
 
 REQUIRED CENTRAL MEMORY :
 
     AUXILIARY ARRAYS ARE DECLARED TO A TOTAL OF (N + 1) * N REALS
 
 RUNNING TIME : ROUGHLY PROPORTIONAL TO (2M + N) * N * N
 
 METHOD AND PERFORMANCE :
 
     FIRST THE SINGULAR VALUES DECOMPOSITION IS CALCULATED, AND THEN THE
     PSEUDO-INVERSE IS CALCULATED BY PSDINVSVD.
 
 
 
 
 
 REFERENCES :
         WILKINSON, J.H. AND C.REINSCH
         HANDBOOK OF AUTOMATIC COMPUTATION, VOL.2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
1SECTION 3.1.1.3.1.4           (DECEMBER 1979)                    PAGE 4
 
 
 
 EXAMPLE OF USE :
 
     FIRST WE GIVE A PROGRAM, AND THEN THE RESULTS OF THIS PROGRAM :
 
     "BEGIN" "ARRAY" A[1:8,1:5], EM[0:7];
         "INTEGER" I, J;
 
         A[1,1]:=22; A[1,2]:= A[2,3]:=10; A[1,3]:= A[7,1]:= A[8,5]:=2;
         A[1,4]:= A[3,5]:=3; A[1,5]:= A[2,2]:=7; A[2,1]:=14; A[2,5]:=8;
         A[2,4]:= A[8,3]:=0; A[3,1]:= A[3,3]:= A[6,5]:=-1; A[3,2]:=13;
         A[3,4]:=-11; A[4,1]:=-3; A[4,2]:= A[4,4]:= A[5,4]:= A[8,4]:=-2;
         A[4,3]:=13; A[4,5]:= A[5,5]:= A[8,1]:=4; A[5,1]:= A[6,1]:=9;
         A[5,2]:=8; A[5,3]:= A[6,2]:= A[7,5]:=1; A[6,3]:=-7;
         A[6,4]:= A[7,4]:= A[8,2]:=5; A[7,2]:=-6; A[7,3]:=6;
         EM[0]:="-14; EM[2]:="-12; EM[4]:=80; EM[6]:="-10;
         I:= PSDINV(A, 8, 5, EM);
         OUTPUT(61, "("4B, "("NUMBER SINGULAR VALUES NOT FOUND : ")",
         3ZD,/, 4B, "("NORM : ")", N,/, 4B, "("MAX NEGL SUBD ELEM : ")",
         N,/, 4B, "("NUMBER ITERATIONS : ")", 3ZD, /, 4B, "("RANK : ")",
         3ZD, /")", I, EM[1], EM[3], EM[5], EM[7]);
         OUTPUT(61, "("/, 4B, "("TRANSPOSE OF PSEUDO-INVERSE")", /,
         4B, "("FIRST THREE COLUMNS")", /, /, 8(4B, 3(N), /), /, /,
         4B, "("LAST TWO COLUMNS")", /, /, 8(15B, 2(N), /)")",
         A[1,1], A[1,2], A[1,3], A[2,1], A[2,2], A[2,3], A[3,1], A[3,2],
         A[3,3], A[4,1], A[4,2], A[4,3], A[5,1], A[5,2], A[5,3], A[6,1],
         A[6,2], A[6,3], A[7,1], A[7,2], A[7,3], A[8,1], A[8,2], A[8,3],
         A[1,4], A[1,5], A[2,4], A[2,5], A[3,4], A[3,5], A[4,4], A[4,5],
         A[5,4], A[5,5], A[6,4], A[6,5], A[7,4], A[7,5], A[8,4], A[8,5])
     "END"
 
      NUMBER SINGULAR VALUES NOT FOUND :    0
      NORM : +4.4000000000000"+001
      MAX NEGL SUBD ELEM : +4.3977072741076"-014
      NUMBER ITERATIONS :    6
      RANK :    3
 
      TRANSPOSE OF PSEUDO-INVERSE
      FIRST THREE COLUMNS
 
     +2.1129807692308"-002  +4.6153846153850"-003  -2.1073717948727"-003
     +9.3108974358974"-003  +2.2115384615376"-003  +2.0528846153848"-002
     -1.1097756410256"-002  +2.7403846153848"-002  -3.8862179487199"-003
     -7.9166666666667"-003  -5.0000000000007"-003  +3.3750000000001"-002
     +5.5128205128205"-003  +9.8076923076935"-003  -8.9743589743826"-004
     +1.4318910256410"-002  -2.5961538461548"-003  -2.0136217948716"-002
     +4.8958333333335"-003  -1.4999999999998"-002  +1.5312499999996"-002
     +1.5064102564102"-003  +7.4038461538447"-003  -1.6987179487147"-003
1SECTION 3.1.1.3.1.4           (DECEMBER 1979)                    PAGE 5
 
 
 
      LAST TWO COLUMNS
 
                 +7.6041666666662"-003  +3.8060897435894"-003
                 -2.0833333333295"-004  +1.0016025641026"-002
                 -2.7604166666667"-002  +4.2067307692303"-003
                 -5.4166666666662"-003  +1.0416666666667"-002
                 -5.0000000000005"-003  +3.2051282051275"-003
                 +1.2812500000000"-002  -6.2099358974354"-003
                 +1.2395833333332"-002  +2.6041666666656"-003
                 -4.9999999999993"-003  +1.6025641025649"-003
         "EOP"
 
 SOURCE TEXT(S):
0"CODE" 34286;
 "PROCEDURE" PSDINVSVD(U, VAL, V, M, N, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" U, VAL, V, EM;
 "BEGIN" "INTEGER" I, J;
     "REAL" MIN, VALI;
     "ARRAY" X[1:N];
     MIN:= EM[6];
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     "IF" VAL[I] > MIN "THEN"
     "BEGIN" VALI:= 1 / VAL[I];
         "FOR" J:= 1 "STEP" 1 "UNTIL" M "DO" U[J,I]:= U[J,I] * VALI
     "END"
     "ELSE" "FOR" J:= 1 "STEP" 1 "UNTIL" M "DO" U[J,I]:= 0;
     "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
     "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" X[J]:= U[I,J];
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         U[I,J]:= MATVEC(1, N, J, V, X)
     "END"
 "END" PSDINVSVD;
         "EOP"
0"CODE" 34287;
 "INTEGER" "PROCEDURE" PSDINV(A, M, N, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, EM;
 "BEGIN" "INTEGER" I;
     "ARRAY" VAL[1:N], V[1:N,1:N];
 
     PSDINV:= I:= QRISNGVALDEC(A, M, N, VAL, V, EM);
     "IF" I = 0 "THEN" PSDINVSVD(A, VAL, V, M, N, EM)
 "END" PSDINV;
         "EOP"
1SECTION 3.1.2.1.1.1.1.1      (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR         :    T.J. DEKKER.
 
 
 REVISOR        :    J. KOK.
 
 
 INSTITUTE      :    MATHEMATICAL CENTRE.
 
 
 RECEIVED       :    730903.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS THE PROCEDURE DECBND
     FOR THE DECOMPOSITION OF A BAND MATRIX BY GAUSSIAN ELIMINATION
     WITH STABILIZING ROW INTERCHANGES (PARTIAL PIVOTING).
 
 
 KEY WORDS      :
 
     LINEAR EQUATIONS,
     PARTIAL PIVOTING,
     GAUSSIAN ELIMINATION,
     BAND MATRIX.
 
 
 CALLING SEQUENCE      :
 
     THE HEADING OF THE PROCEDURE IS    :
 
     "PROCEDURE" DECBND(A, N, LW, RW, AUX, M, P); "VALUE" N, LW, RW;
     "INTEGER" N, LW, RW; "INTEGER""ARRAY" P; "ARRAY" A, M, AUX;
     "CODE" 34320;
 
     THE MEANING OF THE FORMAL PARAMETERS IS    :
 
         A    :  <ARRAY IDENTIFIER>;
                 "ARRAY" A[1 : (LW + RW) * (N - 1) + N];
                 ENTRY  : A CONTAINS ROWWISE THE BAND ELEMENTS OF THE
                  BAND MATRIX IN SUCH A WAY THAT THE (I,J)-TH ELEMENT OF
                  THE MATRIX IS GIVEN IN A[( LW + RW ) * (I - 1) + J],
                  I=1,...,N AND J=MAX(1,I-LW),...,MIN(N,I+RW).
                  THE  VALUES  OF  THE  REMAINING  ELEMENTS  OF  A  ARE
                  IRRELEVANT.
                 EXIT   : THE BAND ELEMENTS OF THE GAUSSIAN ELIMINATED
                  MATRIX, WHICH IS AN UPPERTRIANGULAR BAND MATRIX WITH
                  (LW + RW) CODIAGONALS, ARE ROWWISE DELIVERED IN A  AS
                  FOLLOWS: THE (I,J)-TH ELEMENT OF U IS
                  A [ ( LW + RW ) * (I - J) + J ],I=1,...,N AND
                  J=I,...,MIN(N,I + LW + RW).
         N    :  <ARITHMETIC EXPRESSION>;
                 ORDER OF THE BAND MATRIX;
         LW   :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF  LEFT CODIAGONALS OF A;
1SECTION 3.1.2.1.1.1.1.1      (JUNE 1974)                         PAGE 2
 
 
 
         RW   :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF RIGHT CODIAGONALS OF A;
         AUX  :  <ARRAY IDENTIFIER>;
                 "ARRAY" AUX[1 : 5];
                 ENTRY  :AUX[2] = EPS IS A RELATIVE TOLERANCE TO CONTROL
                   THE ELIMINATION; THE PROCESS IS DISCONTINUED IF
                   (EPS > PIVOT[I] / EUCLIDEAN NORM OF I-TH ROW)
                   IN THE I-TH ELIMINATION STEP;
                 NORMAL EXIT  :
                   AUX[1] = SIGN OF THE DETERMINANT OF THE MATRIX
                   (+1 OR -1);
                   AUX[3] = N;
                   AUX[5] = MINIMUM ABSOLUTE VALUE OF
                   PIVOT[I] / EUCLIDEAN NORM OF THE I-TH ROW;
                 ABNORMAL EXIT : IF THE ELIMINATION CANNOT BE CARRIED
                   OUT, I.E. IF TEMP (THE QUANTITY
                   ABS(PIVOT[I] / EUCLIDEAN NORM OF THE I-TH ROW))
                   IS TOO SMALL IN THE I-TH ELIMINATION STEP :
                   AUX[3] = I - 1,
                   AUX[5] = TEMP;
         M  :    <ARRAY IDENTIFIER>;
                 "ARRAY" M[1 : LW * (N - 2) + 1];
                 EXIT :  THE GAUSSIAN MULTIPLIERS OF ALL ELIMINATIONS
                  IN SUCH A WAY THAT THE I-TH MULTIPLIER OF THE J-TH
                  STEP  IS  M [ LW * (J - 1) + I - J ].
         P  :    <ARRAY IDENTIFIER>;
                 "INTEGER""ARRAY" P[1 : N];
                 EXIT :  THE PIVOTAL INDICES.
 
 
 PROCEDURES USED    :
 
     VECVEC = CP34010,
     ELMVEC = CP34020,
     ICHVEC = CP34030.
 
 
 REQUIRED CENTRAL MEMORY    :
 
     EXECUTION FIELD LENGTH  : A REAL ARRAY OF N ELEMENTS IS DECLARED.
 
 
 RUNNING TIME   :
 
     (C1 * LW + C2) * (LW + RW + 1) * N;
     THE CONSTANTS C1 AND C2 DEPEND UPON THE
     ARITHMETIC OF THE COMPUTER.
 
 
1SECTION 3.1.2.1.1.1.1.1      (JUNE 1974)                         PAGE 3
 
 
 
 LANGUAGE       :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     DECBND PERFORMS THE DECOMPOSITION OF A MATRIX WHOSE NON-ZERO
     ELEMENTS ARE IN BAND FORM, AND WHOSE BAND ELEMENTS ARE STORED
     ROWWISE IN A ONE-DIMENSIONAL ARRAY.
     THE METHOD USED IS GAUSSIAN ELIMINATION WITH STABILIZING ROW
     INTERCHANGES (PARTIAL PIVOTING).
     THE GAUSSIAN ELIMINATION IS PERFORMED IN N STEPS. IN THE K-TH
     STEP, K = 1, ... , N, A PIVOT IS SELECTED IN THE K-TH COLUMN OF
     THE REMAINING SUBMATRIX OF ORDER N - K + 1 (THIS COLUMN
     CONTAINS AT MOST LW + 1 NON-ZERO ELEMENTS); THEN THE PIVOTAL
     ROW IS INTERCHANGED WITH THE K-TH ROW; SUBSEQUENTLY THE K-TH
     UNKNOWN IS ELIMINATED IN THE LAST N - K ROWS (ONLY THE FIRST
     LW OF THESE LAST ROWS ARE INVOLVED HERE).
     THE PIVOT IS SELECTED IN SUCH A WAY THAT ITS ABSOLUTE
     VALUE DIVIDED BY THE EUCLIDEAN NORM OF THE CORRESPONDING ROW OF
     THE MATRIX IS MAXIMAL. THUS, THE MATRIX IS EQUILIBRATED IN THIS
     PIVOTING STRATEGY SUCH, THAT THE ROWS EFFECTIVELY OBTAIN UNIT
     EUCLIDEAN NORM.
     THE PROCEDURE DELIVERS THE BAND ELEMENTS OF THE ELIMINATED MATRIX
     (WHICH IS AN UPPER TRIANGULAR MATRIX WITH LW + RW
     SUPERDIAGONALS) AND THE GAUSSIAN MULTIPLIERS FOR EACH ELIMINATION
     .
     THE ELIMINATION CANNOT BE CARRIED OUT IF THE ABSOLUTE VALUE OF THE
     PIVOT IS LESS THAN A GIVEN RELATIVE TOLERANCE (AUX[2]) TIMES THE
     EUCLIDEAN NORM OF THE CORRESPONDING ROW OF THE MATRIX. THEN THE
     PREVIOUS STEP NUMBER OF THE ELIMINATION IS DELIVERED (IN AUX[3],
     WHICH ELSE TAKES THE VALUE N).  SEE ALSO REF [1], SECTION 212.
 
 
 REFERENCE      :
 
     [1] DEKKER, T.J. :
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MC TRACT 22, 1968, MATHEMATISCH CENTRUM, AMSTERDAM.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLE OF USE OF SOLBND.
 
 
1SECTION 3.1.2.1.1.1.1.1      (JUNE 1974)                         PAGE 4
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34320;
 "PROCEDURE" DECBND(A, N, LW, RW, AUX, M, P); "VALUE" N, LW, RW;
 "INTEGER" N, LW, RW; "INTEGER" "ARRAY" P; "ARRAY" A, M, AUX;
 "BEGIN" "INTEGER" I, J, K, KK, KK1, PK, MK, IK, LW1, F, Q, W, W1,
         W2, NRW, IW, SDET;
         "REAL" R, S, EPS, MIN;
         "ARRAY" V[1:N];
 
         F:= LW; W1:= LW + RW; W:= W1 + 1; W2:= W - 2; IW:= 0; SDET:= 1;
         NRW:= N - RW; LW1:= LW + 1; Q:= LW - 1;
         "FOR" I:= 2 "STEP" 1 "UNTIL" LW "DO"
         "BEGIN" Q:= Q - 1; IW:= IW + W1;
             "FOR" J:= IW - Q "STEP" 1 "UNTIL" IW "DO" A[J]:= 0
         "END";
         IW:= - W2; Q:= - LW;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" IW:= IW + W; "IF" I <= LW1 "THEN" IW:= IW - 1;
             Q:= Q + W; "IF" I > NRW "THEN" Q:= Q - 1;
             V[I]:= SQRT(VECVEC(IW, Q, 0, A, A))
         "END";
         EPS:= AUX[2]; MIN:= 1; KK:= - W1; MK:= - LW;
         "IF" F > NRW "THEN" W2:= W2 + NRW - F;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN""IF" F < N "THEN" F:= F + 1; IK:= KK:= KK + W;
             MK:= MK + LW; S:= ABS(A[KK]) / V[K]; PK:= K; KK1:= KK + 1;
             "FOR" I:= K + 1 "STEP" 1 "UNTIL" F "DO"
             "BEGIN" IK:= IK + W1; M[MK + I - K]:= R:= A[IK]; A[IK]:= 0;
                 R:= ABS(R) / V[I]; "IF" R > S "THEN"
                 "BEGIN" S:= R; PK:= I "END"
             "END";
             "IF" S < MIN "THEN" MIN:= S; "IF" S < EPS "THEN"
             "BEGIN" AUX[3]:= K - 1; AUX[5]:= S; "GO TO" END "END";
             "IF" K + W2 >= N "THEN" W2:= W2 - 1;
             P[K]:= PK; "IF" PK ^= K "THEN"
             "BEGIN" V[PK]:= V[K];
                 PK:= PK - K; ICHVEC(KK1, KK1 + W2, PK * W1, A);
                 SDET:= - SDET; R:= M[MK + PK]; M[MK + PK]:= A[KK];
                 A[KK]:= R
             "END""ELSE" R:= A[KK]; "IF" R < 0 "THEN" SDET:= - SDET;
             IW:= KK1; LW1:= F - K + MK;
             "FOR" I:= MK + 1 "STEP" 1 "UNTIL" LW1 "DO"
             "BEGIN" M[I]:= S:= M[I] / R; IW:= IW + W1;
                 ELMVEC(IW, IW + W2, KK1 - IW, A, A, - S)
             "END"
         "END";
         AUX[3]:= N; AUX[5]:= MIN;
     END: AUX[1]:= SDET
     "END" DECBND;
         "EOP"
1SECTION 3.1.2.1.1.1.1.2      (JUNE 1974)                         PAGE 1
 
 
 
 CONTRIBUTOR    :    J. KOK.
 
 
 INSTITUTE      :    MATHEMATICAL CENTRE.
 
 
 RECEIVED       :    730903.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS THE PROCEDURE DETERMBND
     FOR THE CALCULATION OF THE DETERMINANT OF A BAND MATRIX.
 
 
 KEY WORDS  :
 
     DETERMINANT,
     BAND MATRIX.
 
 
 CALLING SEQUENCE       :
 
     THE HEADING OF THE PROCEDURE IS    :
 
     "REAL""PROCEDURE" DETERMBND(A, N, LW, RW, SGNDET); "VALUE" N, LW,
     RW, SGNDET; "INTEGER" N, LW, RW, SGNDET; "ARRAY" A;
     "CODE" 34321;
 
     DETERMBND DELIVERS THE DETERMINANT OF THE MATRIX.
 
     THE MEANING OF THE FORMAL PARAMETERS IS    :
 
     A, N, LW, RW   :    SEE 'CALLING SEQUENCE' OF DECBND
                 (SECTION 3.1.2.1.1.1.1.1.);
                 ENTRY : THE CONTENTS OF A ARE AS PRODUCED BY DECBND OR
                 DECSOLBND (SECTION 3.1.2.1.1.1.1.3.);
     SGNDET  :   <ARITHMETIC EXPRESSION>;
                 ENTRY : THE SIGN OF THE DETERMINANT AS DELIVERED IN
                 AUX[1] BY DECBND, IF THE ELIMINATION BY DECBND WAS
                 SUCCESSFUL.
 
 
1SECTION 3.1.2.1.1.1.1.2      (DECEMBER 1975)                     PAGE 2
 
 
 
 PROCEDURES USED    :    NONE.
 
 
 RUNNING TIME   :    PROPORTIONAL TO N.
 
 
 LANGUAGE       :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     DETERMBND CAN BE CALLED AFTER DECBND OR DECSOLBND ONLY IF THE
     GAUSSIAN ELIMINATION WAS SUCCESSFUL, I.E. IF AUX[3] = N.
     THE FUNCTION VALUE OF DETERMBND IS
     THE DETERMINANT OF THE GAUSSIAN ELIMINATED UPPER TRIANGULAR
     MATRIX PROVIDED WITH THE CORRECT SIGN THAT IS DELIVERED BY
     DECBND OR DECSOLBND IN AUX[1].
     DETERMBND SHOULD NOT BE CALLED WHEN OVERFLOW CAN BE EXPECTED.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLES OF USE OF SOLBND AND DECSOLBND.
 
 
 
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34321;
 "REAL""PROCEDURE" DETERMBND(A, N, LW, RW, SGNDET);
 "VALUE" N, LW, RW, SGNDET; "INTEGER" N, LW, RW, SGNDET; "ARRAY" A;
 "BEGIN""INTEGER" I, L; "REAL" P;
         L:= 1; P:= 1; LW:= LW + RW + 1;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" P:= A[L] * P; L:= L + LW "END";
         DETERMBND:= ABS(P) * SGNDET
     "END" DETERMBND;
         "EOP"
1SECTION 3.1.2.1.1.1.1.3      (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR         :    T.J. DEKKER.
 
 
 REVISOR        :    J. KOK.
 
 
 INSTITUTE      :    MATHEMATICAL CENTRE.
 
 
 RECEIVED       :    730903.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS TWO PROCEDURES.
     A) SOLBND, FOR THE SOLUTION OF ONE OR MORE SYSTEMS
     OF LINEAR EQUATIONS WITH THE SAME COEFFICIENT MATRIX, IF THIS
     MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE PROCEDURE DECBND
     (SECTION 3.1.2.1.1.1.1.1.).
     B) DECSOLBND, FOR THE SOLUTION OF ONE SYSTEM OF
     LINEAR EQUATIONS BY GAUSSIAN ELIMINATION WITH STABILIZING ROW
     INTERCHANGES (PARTIAL PIVOTING) IF THE COEFFICIENT MATRIX IS IN
     BAND FORM AND IS STORED ROWWISE IN A ONE-DIMENSIONAL ARRAY.
 
 
 KEY WORDS     :
 
     LINEAR EQUATIONS,
     PARTIAL PIVOTING,
     GAUSSIAN ELIMINATION,
     BAND MATRIX.
 
 
 SUBSECTION     :    SOLBND.
 
 
 CALLING SEQUENCE      :
 
     THE HEADING OF THE PROCEDURE IS    :
 
     "PROCEDURE" SOLBND(A, N, LW, RW, M, P, B); "VALUE" N, LW, RW;
     "INTEGER" N, LW, RW; "INTEGER""ARRAY" P; "ARRAY" A, M, B;
     "CODE" 34071;
 
     THE MEANING OF THE FORMAL PARAMETERS IS    :
 
         A, N, LW, RW, M, P :  SEE 'CALLING SEQUENCE' OF DECBND,
                 ENTRY : THE CONTENTS OF THE ARRAYS A, M, P ARE AS
                 PRODUCED BY DECBND;
         B  :    <ARRAY IDENTIFIER>;
                 "ARRAY" B[1 : N];
                 ENTRY : THE RIGHT HAND SIDE OF THE SYSTEM OF LINEAR
                 EQUATIONS;
                 EXIT  :  THE SOLUTION OF THE SYSTEM.
 
 
1SECTION 3.1.2.1.1.1.1.3      (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED :
     VECVEC = CP34010,
     ELMVEC = CP34020.
 
 RUNNING TIME   :
     (C3 * LW + C4 * RW + C5) * N;
     THE CONSTANTS C3, C4 AND C5 DEPEND UPON THE
     ARITHMETIC OF THE COMPUTER.
 
 LANGUAGE       :    ALGOL 60.
 
 METHOD AND PERFORMANCE :
 
     SOLBND CALCULATES THE SOLUTION OF A SYSTEM OF LINEAR EQUATIONS,
     PROVIDED THAT THE MATRIX WAS DECOMPOSED BY A SUCCESSFUL CALL OF
     DECBND (SECTION 3.1.2.1.1.1.1.1.).
     THE SOLUTION OF THE LINEAR SYSTEM IS OBTAINED BY CARRYING OUT THE
     ELIMINATIONS, FOR
     WHICH THE GAUSSIAN MULTIPLIERS ARE SAVED, ON THE RIGHT HAND SIDE,
     AND BY SOLVING THE NEW SYSTEM WITH THE UPPER TRIANGULAR BAND MATRIX
     , AS PRODUCED BY DECBND, BY BACK SUBSTITUTION. THE SOLUTIONS OF
     SEVERAL SYSTEMS WITH THE SAME COEFFICIENT MATRIX CAN BE OBTAINED BY
     SUCCESSIVE CALLS OF SOLBND.
 
 EXAMPLE OF USE :
 
     THE FOLLOWING PROGRAM SOLVES THE SYSTEM OF SIMULTANEOUS EQUATIONS
 
         2 * X1   -   X2                             = 1
         -   X1 + 2 * X2   -   X3                    = 0
                  -   X2 + 2 * X3   -   X4           = 0
                           -   X3 + 2 * X4   -   X5  = 0
                                    -   X4 + 2 * X5  = 1
 
     "BEGIN""COMMENT" 730822, TEST DECBND, SOLBND AND DETERMBND;
        "INTEGER" I; "INTEGER""ARRAY" ROWIND[1 : 5];
        "ARRAY" BAND[1 : 13], MULT[1 : 4], RIGHT, AUX[1 : 5];
        "FOR" I:= 1 "STEP" 1 "UNTIL" 13 "DO"
        BAND[I]:= "IF" (I + 1) // 3 * 3 < I "THEN" 2 "ELSE" - 1;
        RIGHT[1]:= RIGHT[5]:= 1;
        "FOR" I:= 2, 3, 4 "DO" RIGHT[I]:= 0; AUX[2]:= "- 12;
        DECBND(BAND, 5, 1, 1, AUX, MULT, ROWIND);
        "IF" AUX[3] = 5 "THEN"
        "BEGIN" SOLBND(BAND, 5, 1, 1, MULT, ROWIND, RIGHT);
           OUTPUT(61, "("5(+2Z.4D2B), /"("DETERMINANT IS  ")" +.8D"+DD
           ")", RIGHT, DETERMBND(BAND, 5, 1, 1, AUX[1]))
        "END"
     "END"
 
     DELIVERS   :
      +1.0000   +1.0000   +1.0000   +1.0000   +1.0000
     DETERMINANT IS  +.60000000"+01
1SECTION 3.1.2.1.1.1.1.3      (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION      :    DECSOLBND.
 
 
 CALLING SEQUENCE         :
 
     THE HEADING OF THE PROCEDURE IS    :
 
     "PROCEDURE" DECSOLBND(A, N, LW, RW, AUX, B); "VALUE" N, LW, RW;
     "INTEGER" N, LW, RW; "ARRAY" A, AUX, B;
     "CODE" 34322;
 
     THE MEANING OF THE FORMAL PARAMETERS IS    :
 
         A, N, LW, RW, AUX  : SEE DECBND (SECTION : 3.1.2.1.1.1.1.1);
         B                  : SEE SOLBND (THIS SECTION).
 
 
 PROCEDURES USED    :
 
     VECVEC = CP34010,
     ELMVEC = CP34020,
     ICHVEC = CP34030.
 
 
 REQUIRED CENTRAL MEMORY    :
 
     EXECUTION FIELD LENGTH :  A REAL ARRAY OF N ELEMENTS AND A REAL
     ARRAY OF LW + 1 ELEMENTS ARE DECLARED.
 
 
 RUNNING TIME   :
 
     (C1 * LW + C6) * (LW + RW + 1) * N;
     THE CONSTANTS C1 AND C6 DEPEND UPON THE
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE       :    ALGOL 60.
 
 
1SECTION 3.1.2.1.1.1.1.3      (JUNE 1974)                         PAGE 4
 
 
 
 METHOD AND PERFORMANCE :
 
     DECSOLBND PERFORMS GAUSSIAN ELIMINATION IN THE SAME WAY AS DECBND
     , MEANWHILE ALSO CARRYING OUT THE ELIMINATION WITH THE GIVEN
     RIGHT HAND SIDE. THE SOLUTION OF THE ELIMINATED SYSTEM IS OBTAINED
     BY BACK SUBSTITUTION.
 
 
 EXAMPLE OF USE :
 
     THE PROGRAM
 
     "BEGIN""COMMENT" 730822, TEST DECSOLBND AND DETERMBND;
        "INTEGER" I;
        "ARRAY" BAND[1 : 13], RIGHT, AUX[1 : 5];
 
        "FOR" I:= 1 "STEP" 1 "UNTIL" 13 "DO"
        BAND[I]:= "IF" (I + 1) // 3 * 3 < I "THEN" 2 "ELSE" - 1;
        RIGHT[1]:= RIGHT[5]:= 1;
        "FOR" I:= 2, 3, 4 "DO" RIGHT[I]:= 0; AUX[2]:= "- 12;
        DECSOLBND(BAND, 5, 1, 1, AUX, RIGHT);
        "IF" AUX[3] = 5 "THEN"
        "BEGIN"
           OUTPUT(61, "("5(+2Z.4D2B), /"("DETERMINANT IS  ")" +.8D"+DD
           ")", RIGHT, DETERMBND(BAND, 5, 1, 1, AUX[1]))
        "END"
     "END"
 
     WHICH SOLVES THE SAME PROBLEM AS THE PROGRAM IN THE EXAMPLE OF USE
     OF SOLBND, DELIVERS   :
 
      +1.0000   +1.0000   +1.0000   +1.0000   +1.0000
     DETERMINANT IS  +.60000000"+01
 
1SECTION 3.1.2.1.1.1.1.3      (JUNE 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34071;
 "PROCEDURE" SOLBND(A, N, LW, RW, M, P, B); "VALUE" N, LW, RW;
 "INTEGER" N, LW, RW; "INTEGER" "ARRAY" P; "ARRAY" A, B, M;
 "BEGIN" "INTEGER" F, I, K, KK, W, W1, W2, SHIFT;
         "REAL" S;
 
         F:= LW; SHIFT:= - LW; W1:= LW - 1;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN""IF" F < N "THEN" F:= F + 1; SHIFT:= SHIFT + W1;
             I:=P[K]; S:= B[I]; "IF" I ^= K "THEN"
             "BEGIN" B[I]:= B[K]; B[K]:= S "END";
             ELMVEC(K + 1, F, SHIFT, B, M, - S)
         "END";
         W1:= LW + RW; W:= W1 + 1; KK:= (N + 1) * W - W1; W2:= - 1;
         SHIFT:= N * W1;
         "FOR" K:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" KK:= KK - W; SHIFT:= SHIFT - W1;
             "IF" W2 < W1 "THEN" W2:= W2 + 1;
             B[K]:= (B[K] - VECVEC(K + 1, K + W2, SHIFT, B, A)) / A[KK]
         "END"
     "END" SOLBND;
         "EOP"
 
0"CODE" 34322;
 "PROCEDURE" DECSOLBND(A, N, LW, RW, AUX, B); "VALUE" N, LW, RW;
 "INTEGER" N, LW, RW; "ARRAY" A, B, AUX;
 "BEGIN""INTEGER" I, J, K, KK, KK1, PK, IK, LW1, F, Q, W, W1, W2,IW,
         NRW, SHIFT, SDET;
         "REAL" R, S, EPS, MIN; "ARRAY" M[0:LW], V[1:N];
 
         F:= LW; SDET:= 1; W1:= LW + RW; W:= W1 + 1; W2:= W - 2; IW:= 0;
         NRW:= N - RW; LW1:= LW + 1; Q:= LW - 1;
         "FOR" I:= 2 "STEP" 1 "UNTIL" LW "DO"
         "BEGIN" Q:= Q - 1; IW:= IW + W1;
             "FOR" J:= IW - Q "STEP" 1 "UNTIL" IW "DO" A[J]:= 0
         "END";
                                                               "COMMENT"
1SECTION 3.1.2.1.1.1.1.3      (JUNE 1974)                         PAGE 6
                                                                  ;
 
 
         IW:= - W2; Q:= - LW;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" IW:= IW + W; "IF" I <= LW1 "THEN" IW:= IW - 1;
             Q:= Q + W; "IF" I > NRW "THEN" Q:= Q - 1;
             V[I]:= SQRT(VECVEC(IW, Q, 0, A, A))
         "END";
         EPS:= AUX[2]; MIN:= 1; KK:= - W1;
         "IF" F > NRW "THEN" W2:= W2 + NRW - F;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN""IF" F < N "THEN" F:= F + 1; IK:= KK:= KK + W;
             S:= ABS(A[KK]) / V[K]; PK:= K; KK1:= KK + 1;
             "FOR" I:= K + 1 "STEP" 1 "UNTIL" F "DO"
             "BEGIN" IK:= IK + W1; M[I - K]:= R:= A[IK]; A[IK]:= 0;
                 R:= ABS(R) / V[I]; "IF" R > S "THEN"
                 "BEGIN" S:= R; PK:= I "END"
             "END";
             "IF" S < MIN "THEN" MIN:= S; "IF" S < EPS "THEN"
             "BEGIN" AUX[3]:= K - 1; AUX[5]:= S; "GO TO" END "END";
             "IF" K + W2 >= N "THEN" W2:= W2 - 1; "IF" PK ^= K "THEN"
             "BEGIN" V[PK]:= V[K];
                 PK:= PK - K; ICHVEC(KK1, KK1 + W2, PK * W1, A);
                 SDET:= - SDET; R:= B[K]; B[K]:= B[PK + K];
                 B[PK + K]:= R; R:= M[PK]; M[PK]:= A[KK]; A[KK]:= R
             "END"
             "ELSE" R:= A[KK]; IW:= KK1; LW1:= F - K;
             "IF" R < 0 "THEN" SDET:= - SDET;
             "FOR" I:= 1 "STEP" 1 "UNTIL" LW1 "DO"
             "BEGIN" M[I]:= S:= M[I] / R; IW:= IW + W1;
                 ELMVEC(IW, IW + W2, KK1 - IW, A, A, - S);
                 B[K + I]:= B[K + I] - B[K] * S
             "END"
         "END";
         AUX[3]:= N; AUX[5]:= MIN;
         KK:= (N + 1) * W - W1; W2:= - 1; SHIFT:= N * W1;
         "FOR" K:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" KK:= KK - W; SHIFT:= SHIFT - W1;
             "IF" W2 < W1 "THEN" W2:= W2 + 1;
             B[K]:= (B[K] - VECVEC(K + 1, K + W2, SHIFT, B, A)) / A[KK]
         "END";
     END: AUX[1]:= SDET
     "END" DECSOLBND;
         "EOP"
1SECTION 3.1.2.1.1.1.2.1      (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR: W. HOFFMANN.
 
 
 CONTRIBUTOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731210.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO  PREPARATORY  PROCEDURES  FOR THE
     SOLUTION  OF  SYSTEMS  OF  LINEAR  ALGEBRAIC  EQUATIONS  WITH A
     TRIDIAGONAL  MATRIX;
     DECTRI  PERFORMS  A  TRIANGULAR  DECOMPOSITION  OF  A  TRIDIAGONAL
     MATRIX.
     DECTRIPIV  PERFORMS A TRIANGULAR DECOMPOSITION OF A TRIDIAGONAL
     MATRIX, USING PARTIAL PIVOTING TO STABILIZE THE PROCESS.
 
 
 KEYWORDS:
 
     LU DECOMPOSITION,
     TRIANGULAR DECOMPOSITION,
     TRIDIAGONAL MATRIX.
 
 
 
 SUBSECTION: DECTRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECTRI(SUB, DIAG, SUPER, N, AUX);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX;
     "CODE" 34423;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1: N - 1];
             ENTRY:  THE  SUBDIAGONAL   OF  THE  GIVEN  MATRIX  T,  SAY;
                     T[I + 1, I]  SHOULD   BE  GIVEN  IN  SUB[I], I = 1,
                     ..., N - 1;
             EXIT:   SUPPOSE L DENOTES THE LOWER-BIDIAGONAL MATRIX, SUCH
                     THAT  LU = T,  FOR SOME UPPER-BIDIAGONAL MATRIX  U,
                     WITH UNIT DIAGONAL ELEMENTS, THEN L[I + 1, I]  WILL
                     BE DELIVERED IN SUB[I], I = 1, ..., AUX[3] - 1;
1SECTION 3.1.2.1.1.1.2.1      (JUNE 1974)                         PAGE 2
 
 
 
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF T;
             EXIT:   L[I, I] WILL BE DELIVERED IN  DIAG[I],  I = 1, ...,
                     AUX[3];
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY:  THE SUPERDIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN
                     IN SUPER[I], I = 1, ..., N - 1;
             EXIT:   U[I, I + 1]  WILL BE DELIVERED IN  SUPER[I], I = 1,
                     ..., AUX[3] - 1;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY :
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX,  ELSE  AUX[5]  IS SET  EQUAL TO
                     THE  VALUE  OF  THAT  ELEMENT   WHICH   CAUSES  THE
                     BREAKDOWN OF THE DECOMPOSITION.
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN DECTRI YIELDS A LOWER-BIDIAGONAL MATRIX L  AND A
     UNIT UPPER-BIDIAGONAL MATRIX U, SUCH THAT THE PRODUCT LU EQUALS THE
     GIVEN TRIDIAGONAL MATRIX;  THE PROCESS  IS TERMINATED  IN THE  K-TH
     STEP, IF THE MODULUS OF THE K-TH DIAGONAL ELEMENT IS SMALLER THAN A
     CERTAIN SMALL VALUE,  WHICH IS GIVEN BY  AUX[2]  MULTIPLIED BY  THE
     1-NORM OF THE K-TH ROW; IN THIS CASE AUX[3] WILL BE GIVEN THE VALUE
     K - 1  AND  AUX[5]  WILL BE GIVEN  THE VALUE  OF  THE K-TH DIAGONAL
     ELEMENT.
 
 
 EXAMPLE OF USE: SEE DECSOLTRI (SECTION 3.1.2.1.1.1.2.3).
1SECTION 3.1.2.1.1.1.2.1      (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION: DECTRIPIV.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECTRIPIV(SUB, DIAG, SUPER, N, AID, AUX, PIV);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AID, AUX;
     "BOOLEAN" "ARRAY" PIV;
     "CODE" 34426;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1: N - 1];
             ENTRY:  THE  SUBDIAGONAL   OF  THE  GIVEN  MATRIX  T,  SAY;
                     T[I+1,I] SHOULD BE GIVEN IN SUB[I],I > 1,...,N - 2
             EXIT:   LET  T'  DENOTE THE MATRIX  T  WITH  PERMUTED ROWS;
                     SUPPOSE L DENOTES THE LOWER-BIDIAGONAL MATRIX, SUCH
                     THAT LU = T', FOR SOME UNIT UPPER-TRIANGULAR MATRIX
                     U, THEN  L[I + 1, I]  WILL BE DELIVERED IN  SUB[I],
                     I = 1, ..., AUX[3] - 1;   NOTE  THAT   U   HAS  TWO
                     CODIAGONALS, BECAUSE OF THE PARTIAL PIVOTING DURING
                     THE DECOMPOSITION;
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF T;
             EXIT:   L[I,I] WILL BE DELIVERED IN DIAG[I],I=1,...,AUX[3];
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY:  THE SUPERDIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN
                     IN SUPER[I], I = 1, ..., N - 1;
             EXIT:   U[I, I + 1]  WILL BE DELIVERED IN  SUPER[I], I = 1,
                     ..., AUX[3] - 1;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AID:    <ARRAY IDENTIFIER>;
             "ARRAY" AID[1: N - 2];
             EXIT:U[I,I+2] WILL BE DELIVERED IN AID[I],I=1,...,AUX[3]-2;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX,  ELSE  AUX[5]  IS SET  EQUAL TO
                     THE  VALUE  OF  THAT  ELEMENT   WHICH   CAUSES  THE
                     BREAKDOWN OF THE DECOMPOSITION.
     PIV:    <ARRAY IDENTIFIER>;
             "BOOLEAN""ARRAY" PIV[1 : N - 1];
             THE VALUE OF PIV[I] WILL BE TRUE IF THE I-TH AND (I + 1)-TH
             ROW ARE INTERCHANGED, I = 1, ..., MIN(AUX[3], N - 1),  ELSE
             PIV[I] WILL BE FALSE.
1SECTION 3.1.2.1.1.1.2.1      (JUNE 1974)                         PAGE 4
 
 
 
 PROCEDURES USED: NONE.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN DECTRIPIV YIELDS A LOWER-BIDIAGONAL MATRIX L AND
     A UNIT UPPER-TRIANGULAR MATRIX  U  WITH TWO CODIAGONALS,  SUCH THAT
     THE PRODUCT  LU  EQUALS THE GIVEN TRIDIAGONAL MATRIX  WITH PERMUTED
     ROWS; PARTIAL PIVOTING IS USED DURING THE TRIANGULAR DECOMPOSITION,
     I.E. THAT ELEMENT OF THE K-TH COLUMN OF L IS CHOSEN AS PIVOT IN THE
     K-TH STEP, WHOSE MODULUS DIVIDED BY THE 1-NORM OF THE CORRESPONDING
     ROW OF THE GIVEN MATRIX IS MAXIMAL;  THE PROCESS  IS TERMINATED  IN
     THE K-TH STEP,  IF THE MODULUS OF  THE K-TH  PIVOT ELEMENT  IS LESS
     THAN A CERTAIN SMALL VALUE, WHICH IS GIVEN BY AUX[2]  MULTIPLIED BY
     THE 1-NORM OF THE  CORRESPONDING ROW;  IN THIS CASE  AUX[3] WILL BE
     GIVEN THE VALUE  K - 1, AND  AUX[5]  WILL BE GIVEN THE VALUE OF THE
     K-TH PIVOT ELEMENT.
 
 EXAMPLE OF USE: SEE SOLTRIPIV (SECTION 3.1.2.1.1.1.2.3).
 
 
 
 SOURCE TEXTS:
0"CODE" 34423;
   "PROCEDURE" DECTRI(SUB, DIAG, SUPER, N, AUX);
   "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX;
   "BEGIN" "INTEGER" I, N1;
      "REAL" D, R, S, U, NORM, NORM1, TOL;
      TOL:= AUX[2]; D:= DIAG[1]; R:= SUPER[1];
      NORM:= NORM1:= ABS(D) + ABS(R);
      "IF" ABS(D) <= NORM1 * TOL "THEN"
      "BEGIN" AUX[3]:= 0; AUX[5]:= D; "GOTO" EXIT "END";
      U:= SUPER[1]:= R / D; S:= SUB[1]; N1:= N - 1;
      "FOR" I:= 2 "STEP" 1 "UNTIL" N1 "DO"
      "BEGIN" D:= DIAG[I]; R:= SUPER[I];
         NORM1:= ABS(S) + ABS(D) + ABS(R);
         D:= DIAG[I]:= D - U * S;
         "IF" ABS(D) <= NORM1 * TOL "THEN"
         "BEGIN" AUX[3]:= I - 1; AUX[5]:= D; "GOTO" EXIT "END";
         U:= SUPER[I]:= R / D; S:= SUB[I];
         "IF" NORM1 > NORM "THEN" NORM:= NORM1
      "END";
      D:= DIAG[N]; NORM1:= ABS(D) + ABS(S);
      D:= DIAG[N]:= D - U * S;
      "IF" ABS(D) <= NORM1 * TOL "THEN"
      "BEGIN" AUX[3]:= N1; AUX[5]:= D; "GOTO" EXIT "END";
      "IF" NORM1 > NORM "THEN" NORM:= NORM1;
      AUX[3]:= N; AUX[5]:= NORM;
  EXIT:
  "END" DECTRI
1SECTION 3.1.2.1.1.1.2.1      (JUNE 1974)                         PAGE 5
 
 
                                                                   ;
         "EOP"
0"CODE" 34426;
   "PROCEDURE" DECTRIPIV(SUB, DIAG, SUPER, N, AID, AUX, PIV);
   "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AID, AUX;
   "BOOLEAN" "ARRAY" PIV;
   "BEGIN" "INTEGER" I, I1, N1, N2;
      "REAL" D, R, S, U, T, Q, V, W, NORM, NORM1, NORM2, TOL;
      TOL:= AUX[2]; D:= DIAG[1]; R:= SUPER[1];
      NORM:= NORM2:= ABS(D) + ABS(R); N2:= N - 2;
      "FOR" I:= 1 "STEP" 1 "UNTIL" N2 "DO"
      "BEGIN" I1:= I + 1; S:= SUB[I]; T:= DIAG[I1]; Q:= SUPER[I1];
         NORM1:= NORM2; NORM2:= ABS(S) + ABS(T) + ABS(Q);
         "IF" NORM2 > NORM "THEN" NORM:= NORM2;
         "IF" ABS(D) * NORM2 < ABS(S) * NORM1 "THEN"
         "BEGIN" "IF" ABS(S) <= TOL * NORM2 "THEN"
            "BEGIN" AUX[3]:= I - 1; AUX[5]:= S; "GOTO" EXIT "END";
            DIAG[I]:= S; U:= SUPER[I]:= T / S;
            V:= AID[I]:= Q / S; SUB[I]:= D;
            W:= SUPER[I1]:= -V * D; D:= DIAG[I1]:= R - U * D;
            R:= W; NORM2:= NORM1; PIV[I]:= "TRUE"
         "END" "ELSE"
         "BEGIN" "IF" ABS(D) <= TOL * NORM1 "THEN"
            "BEGIN" AUX[3]:= I - 1; AUX[5]:= D; "GOTO" EXIT "END";
            U:= SUPER[I]:= R / D; D:= DIAG[I1]:= T - U * S;
            AID[I]:= 0; PIV[I]:= "FALSE"; R:= Q
         "END"
      "END";
      N1:= N - 1; S:= SUB[N1]; T:= DIAG[N]; NORM1:= NORM2;
      NORM2:= ABS(S) + ABS(T); "IF" NORM2 > NORM "THEN" NORM:= NORM2;
      "IF" ABS(D) * NORM2 < ABS(S) * NORM1 "THEN"
      "BEGIN" "IF" ABS(S) <= TOL * NORM2 "THEN"
         "BEGIN" AUX[3]:= N2; AUX[5]:= S; "GOTO" EXIT "END";
         DIAG[N1]:= S; U:= SUPER[N1]:= T / S; SUB[N1]:= D;
         D:= DIAG[N]:= R - U * D; NORM2:= NORM1; PIV[N1]:= "TRUE"
      "END" "ELSE"
      "BEGIN" "IF" ABS(D) <= TOL * NORM1 "THEN"
         "BEGIN" AUX[3]:= N2; AUX[5]:= D; "GOTO" EXIT "END";
         U:= SUPER[N1]:= R / D; D:= DIAG[N]:= T - U * S;
         PIV[N1]:= "FALSE"
      "END";
      "IF" ABS(D) <= TOL * NORM2 "THEN"
      "BEGIN" AUX[3]:= N1; AUX[5]:= D; "GOTO" EXIT "END";
      AUX[3]:= N; AUX[5]:= NORM;
  EXIT:
  "END" DECTRIPIV;
         "EOP"
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR: W. HOFFMANN.
 
 
 CONTRIBUTOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731210.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS FOUR PROCEDURES
     FOR SOLVING A SYSTEM OF LINEAR EQUATIONS  WITH A
     TRIDIAGONAL MATRIX;
     SOLTRI CALCULATES A SOLUTION BY FORWARD AND BACK SUBSTITUTION IF
     THE TRIANGULAR DECOMPOSED FORM AS DELIVERED BY DECTRI IS GIVEN.
     DECSOLTRI  PERFORMS  THE TRIANGULAR DECOMPOSITION OF THE GIVEN
     MATRIX ( NOT USING ANY PIVOTING STRATEGY DURING THE PROCESS ) AND
     CALCULATES THE SOLUTION BY FORWARD AND BACK SUBSTITUTION.
     SOLTRIPIV CALCULATES A SOLUTION BY FORWARD AND BACK SUBTITUTION,IF
     THE TRIANGULAR DECOMPOSED FORM AS DELIVERED BY DECTRIPIV IS GIVEN.
     DECSOLTRIPIV PERFORMS THE TRIANGULAR DECOMPOSITION OF THE GIVEN
     MATRIX ( USING PARTIAL PIVOTING ) AND CALCULATES THE SOLUTION BY
     FORWARD AND BACK SUBSTITUTION.
 
 
 KEYWORDS:
 
     ALGEBRAIC EQUATIONS,
     LINEAR SYSTEMS,
     TRIDIAGONAL MATRIX,
     FORWARD AND BACK SUBSTITUTION.
 
 
 
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 2
 
 
 
 SUBSECTION: SOLTRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" SOLTRI(SUB, DIAG, SUPER, N, B);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, B;
     "CODE" 34424;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1, N - 1];
             ENTRY  :  THE   SUBDIAGONAL  OF  THE
             LOWER-BIDIAGONAL MATRIX,  AS DELIVERED BY  DECTRI  (SECTION
             3.1.2.1.1.1.2.1);
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1:N];
             ENTRY :  THE DIAGONAL OF THE LOWER-
             BIDIAGONAL MATRIX, AS DELIVERED BY DECTRI;
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY : THE SUPERDIAGONAL OF THE
             UPPER-BIDIAGONAL MATRIX AS DELIVERED BY DECTRI;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE CALCULATED SOLUTION OF THE LINEAR SYSTEM.
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     SOLTRI   CALCULATES   THE  SOLUTION  OF  A  LINEAR  SYSTEM  WITH  A
     TRIDIAGONAL  MATRIX,   WITH  FORWARD  AND  BACK  SUBSTITUTION;  THE
     TRIANGULARLY DECOMPOSED FORM OF THE MATRIX,  AS PRODUCED BY  DECTRI
     (SECTION  3.1.2.1.1.1.2.1),  SHOULD BE GIVEN;  ONE CALL  OF  DECTRI
     FOLLOWED BY SEVERAL CALLS OF  SOLTRI  MAY BE USED  TO SOLVE SEVERAL
     LINEAR SYSTEMS  HAVING  THE SAME TRIDIAGONAL MATRIX,  BUT DIFFERENT
     RIGHT-HAND SIDES.
 
 
 EXAMPLE OF USE: SEE DECSOLTRI (THIS SECTION).
 
 
 
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION: DECSOLTRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECSOLTRI(SUB, DIAG, SUPER, N, AUX, B);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX, B;
     "CODE" 34425;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1: N - 1];
             ENTRY:  THE  SUBDIAGONAL   OF  THE  GIVEN  MATRIX  T,  SAY;
                     T[I + 1, I]  SHOULD   BE  GIVEN  IN  SUB[I], I = 1,
                     ..., N - 1;
             EXIT:   SUPPOSE L DENOTES THE LOWER-BIDIAGONAL MATRIX, SUCH
                     THAT  LU = T,  FOR SOME UPPER-BIDIAGONAL MATRIX  U,
                     WITH UNIT DIAGONAL ELEMENTS, THEN L[I + 1, I]  WILL
                     BE DELIVERED IN SUB[I], I = 1, ..., AUX[3] - 1;
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF T;
             EXIT:   L[I, I] WILL BE DELIVERED IN  DIAG[I],  I = 1, ...,
                     AUX[3];
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY:  THE SUPERDIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN
                     IN SUPER[I], I = 1, ..., N - 1;
             EXIT:   U[I, I + 1]  WILL BE DELIVERED IN  SUPER[I], I = 1,
                     ..., AUX[3] - 1;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY :
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT :
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX  (SEE  SECTION  3.1.2.1.1.1.2.1,
                     SUBSECTION DECTRI);
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF AUX[3] = N,  THEN  THE  SOLUTION  OF  THE LINEAR
                     SYSTEM  IS  OVERWRITTEN  ON  B,  ELSE   B   REMAINS
                     UNALTERED.
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 4
 
 
 
 PROCEDURES USED:
 
     DECTRI = CP34423,
     SOLTRI = CP34424.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     DECSOLTRI  CALCULATES  THE  SOLUTION  OF  A  LINEAR  SYSTEM  WITH A
     TRIDIAGONAL MATRIX; THE TRIANGULAR DECOMPOSITION IS DONE BY CALLING
     DECTRI    (SECTION  3.1.2.1.1.1.2.1)   AND  THE  FORWARD  AND  BACK
     SUBSTITUTION BY CALLING SOLTRI (THIS SECTION);  IF AUX[3] < N, THEN
     THE EFFECT OF DECSOLTRI IS MERELY THAT OF DECTRI.
 
 
 EXAMPLE OF USE:
 
     LET  T  BE A TRIDIAGONAL MATRIX  WITH SUBDIAGONAL AND SUPERDIAGONAL
     ELEMENTS I * 2 AND I RESPECTIVELY (I = 1, ..., N - 1), AND DIAGONAL
     ELEMENTS I + 10 (I = 1, ..., N); LET  B  BE THE SECOND COLUMN OF T;
     THEN  THE SOLUTION  OF THE LINEAR SYSTEM   TX = B   IS GIVEN BY THE
     SECOND UNIT VECTOR;  BY THE FOLLOWING PROGRAM  WE  MAY  SOLVE  THIS
     SYSTEM AND PRINT THE ERROR IN THE CALCULATED SOLUTION.
 
     "BEGIN"
         "INTEGER" I;
         "ARRAY" D, SUB, SUPER, B[1:30], AUX[2:5];
         "FOR" I:= 1 "STEP" 1 "UNTIL" 30 "DO"
         "BEGIN" SUB[I]:= I * 2; SUPER[I]:= I; D[I]:= I + 10;
             B[I]:= 0
         "END"; B[1]:= 1; B[2]:= 12; B[3]:= 4;
         AUX[2]:= "-14;
         DECSOLTRI(SUB, D, SUPER, 30, AUX, B);
         OUTPUT(71, "("/,"("AUX[3] AND AUX[5]:")",2(/,N)")",
         AUX[3], AUX[5]);
         B[2]:= B[2] - 1;
         OUTPUT(71, "("//"("ERROR IN THE SOLUTION: ")", N")",
         SQRT(VECVEC(1, 30, 0, B, B)))
     "END"
 
     RESULTS:
 
     AUX[3] AND AUX[5]:
     +3.0000000000000"+001
     +1.2400000000000"+002
 
     ERROR IN THE SOLUTION: +0.0000000000000"+000
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 5
 
 
 
 SUBSECTION: SOLTRIPIV.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" SOLTRIPIV(SUB, DIAG, SUPER, N, AID, PIV, B);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AID, B;
     "BOOLEAN" "ARRAY" PIV;
     "CODE" 34427;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1, N - 1];
             ENTRY : THE SUBDIAGONAL OF THE
             LOWER-BIDIAGONAL MATRIX, AS DELIVERED BY DECTRIPIV (SECTION
             3.1.2.1.1.1.2.1);
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1:N];
             ENTRY: THE DIAGONAL OF THE LOWER-
             BIDIAGONAL MATRIX, AS DELIVERED BY DECTRIPIV;
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY : THE FIRST CODIAGONAL OF
             THE UPPER-TRIANGULAR MATRIX AS DELIVERED BY DECTRIPIV;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AID:    <ARRAY IDENTIFIER>;
             "ARRAY" AID[1: N - 2];
             ENTRY:  THE SECOND CODIAGONAL OF
             THE UPPER-TRIANGULAR MATRIX AS DELIVERED BY DECTRIPIV;
     PIV:    <ARRAY IDENTIFIER>;
             "BOOLEAN""ARRAY" PIV[1: N-1];
             ENTRY:  THE PIVOT-
             INFORMATION AS DELIVERED BY DECTRIPIV;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE CALCULATED SOLUTION OF THE LINEAR SYSTEM.
 
 
 PROCEDURES USED: NONE.
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     SOLTRIPIV  CALCULATES  THE SOLUTION  OF  A  LINEAR  SYSTEM  WITH  A
     TRIDIAGONAL  MATRIX,   WITH  FORWARD  AND  BACK  SUBSTITUTION;  THE
     TRIANGULARLY DECOMPOSED FORM OF THE MATRIX,AS PRODUCED BY DECTRIPIV
     (SECTION 3.1.2.1.1.1.2.1), SHOULD BE GIVEN;  ONE CALL OF  DECTRIPIV
     FOLLOWED BY SEVERAL CALLS OF SOLTRIPIV MAY BE USED TO SOLVE SEVERAL
     LINEAR SYSTEMS  HAVING  THE SAME TRIDIAGONAL MATRIX,  BUT DIFFERENT
     RIGHT-HAND SIDES.
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 6
 
 
 
 EXAMPLE OF USE:
 
     LET  T  BE THE MATRIX  AS GIVEN IN THE EXAMPLE OF USE OF  DECSOLTRI
     (THIS SECTION)  AND LET B1 AND B2 BE THE SECOND AND THIRD COLUMN OF
     T, THEN  THE SOLUTIONS OF THE LINEAR SYSTEMS  TX = B1  AND  TX = B2
     ARE GIVEN BY THE SECOND AND THIRD UNIT VECTOR  RESPECTIVELY; IN THE
     FOLLOWING PROGRAM  THESE SYSTEMS  ARE SOLVED  AND THE ERRORS IN THE
     CALCULATED SOLUTIONS ARE PRINTED.
 
     "BEGIN"
         "INTEGER" I;
         "ARRAY" D, SUB, SUPER, AID, B1, B2[1:30], AUX[2:5];
         "BOOLEAN" "ARRAY" PIV[1:29];
         "FOR" I:= 1 "STEP" 1 "UNTIL" 30 "DO"
         "BEGIN" SUB[I]:= I * 2; SUPER[I]:= I; D[I]:= I + 10;
             B1[I]:= B2[I]:= 0
         "END"; B1[1]:= 1; B1[2]:= 12; B1[3]:= 4;
         B2[2]:= 2; B2[3]:= 13; B2[4]:= 6;
         AUX[2]:= "-14;
         DECTRIPIV(SUB, D, SUPER, 30, AID, AUX, PIV);
         SOLTRIPIV(SUB, D, SUPER, 30, AID, PIV, B1);
         SOLTRIPIV(SUB, D, SUPER, 30, AID, PIV, B2);
         OUTPUT(71, "("/,"("AUX[3] AND AUX[5]:")",2(/,N)")",
         AUX[3], AUX[5]);
         B1[2]:= B1[2] - 1; B2[3]:= B2[3] - 1;
      OUTPUT(71, "("//"("ERROR IN B1: ")",N,/,"("ERROR IN B2: ")",N")",
         SQRT(VECVEC(1, 30, 0, B1, B1)), SQRT(VECVEC(1, 30, 0, B2, B2)))
     "END"
 
     RESULTS:
 
     AUX[3] AND AUX[5]:
     +3.0000000000000"+001
     +1.2400000000000"+002
 
     ERROR IN B1: +0.0000000000000"+000
     ERROR IN B2: +0.0000000000000"+000
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 7
 
 
 
 SUBSECTION: DECSOLTRIPIV.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECSOLTRIPIV(SUB, DIAG, SUPER, N, AUX, B);
     "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX, B;
     "CODE" 34428;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     SUB:    <ARRAY IDENTIFIER>;
             "ARRAY" SUB[1: N - 1];
             ENTRY:  THE  SUBDIAGONAL   OF  THE  GIVEN  MATRIX  T,  SAY;
                     T[I + 1, I]  SHOULD   BE  GIVEN  IN  SUB[I], I = 1,
                     ..., N - 1;
             EXIT:   THE ELEMENTS OF SUB WILL BE OVERWRITTEN;
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF T;
             EXIT:   THE ELEMENTS OF DIAG WILL BE OVERWRITTEN;
     SUPER:  <ARRAY IDENTIFIER>;
             "ARRAY" SUPER[1: N - 1];
             ENTRY:  THE SUPERDIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN
                     IN SUPER[I], I = 1, ..., N - 1;
             EXIT:   THE ELEMENTS OF SUPER WILL BE OVERWRITTEN;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX  (SEE SECTION  3.1.2.1.1.1.2.1.,
                     SUBSECTION DECTRIPIV);
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1 : N];
             ENTRY:  THE RIGHT-HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF  AUX[3] = N,  THEN  THE SOLUTION  OF  THE LINEAR
                     SYSTEM WILL BE OVERWRITTEN ON B, ELSE B WILL REMAIN
                     UNALTERED.
1SECTION 3.1.2.1.1.1.2.3      (DECEMBER 1975)                     PAGE 8
 
 
 
 PROCEDURES USED: NONE.
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: ONE  AUXILIARY ARRAY  OF  TYPE BOOLEAN  AND
                             ORDER N IS DECLARED IN DECSOLTRIPIV;
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     ONE CALL OF  DECSOLTRIPIV  IS EQUIVALENT WITH CALLING CONSECUTIVELY
     DECTRIPIV  (SECTION 3.1.2.1.1.1.2.1) AND  SOLTRIPIV (THIS SECTION);
     HOWEVER, DECSOLTRIPIV DOES NOT MAKE USE OF DECTRIPIV AND SOLTRIPIV,
     TO SAVE MEMORY SPACE AND TIME; THIS IS ONLY  TRUE  IN THE CASE THAT
     LINEAR SYSTEMS WITH  DIFFERENT MATRICES HAVE TO BE SOLVED; IF
     AUX[3] < N THEN
     DECSOLTRIPIV  IS TERMINATED PREMATURELY (SEE  DECTRIPIV  IN SECTION
     3.1.2.1.1.1.2.1).
 
 
 EXAMPLE OF USE:
 
     THE SAME LINEAR SYSTEM AS GIVEN IN THE EXAMPLE OF USE OF  DECSOLTRI
     MAY BE SOLVED WITH DECSOLTRIPIV BY THE FOLLOWING PROGRAM:
 
     "BEGIN"
         "INTEGER" I;
         "ARRAY" D, SUB, SUPER, B[1:30], AUX[2:5];
         "FOR" I:= 1 "STEP" 1 "UNTIL" 30 "DO"
         "BEGIN" SUB[I]:= I * 2; SUPER[I]:= I; D[I]:= I + 10;
             B[I]:= 0
         "END"; B[1]:= 1; B[2]:= 12; B[3]:= 4;
         AUX[2]:= "-14;
         DECSOLTRIPIV(SUB, D, SUPER, 30, AUX, B);
         OUTPUT(71, "("/,"("AUX[3] AND AUX[5]:")",2(/,N)")",
         AUX[3], AUX[5]);
         B[2]:= B[2] - 1;
         OUTPUT(71, "("//"("ERROR IN THE SOLUTION: ")", N")",
         SQRT(VECVEC(1, 30, 0, B, B)))
     "END"
 
     RESULTS:
 
     AUX[3] AND AUX[5]:
     +3.0000000000000"+001
     +1.2400000000000"+002
 
     ERROR IN THE SOLUTION: +0.0000000000000"+000
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                         PAGE 9
 
 
 
 SOURCE TEXTS:
0"CODE" 34424;
   "PROCEDURE" SOLTRI(SUB, DIAG, SUPER, N, B);
   "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, B;
   "BEGIN" "INTEGER" I;
      "REAL" R;
      R:= B[1]:= B[1] / DIAG[1];
      "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
      R:= B[I]:= (B[I] - SUB[I - 1] * R) / DIAG[I];
      "FOR" I:= N - 1 "STEP" -1 "UNTIL" 1 "DO"
      R:= B[I] := B[I] - SUPER[I] * R
   "END" SOLTRI;
         "EOP"
0"CODE" 34425;
  "PROCEDURE" DECSOLTRI(SUB, DIAG, SUPER, N, AUX, B);
  "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX, B;
  "BEGIN"
          DECTRI(SUB, DIAG, SUPER, N, AUX); "IF" AUX[3]= N "THEN"
          SOLTRI(SUB, DIAG, SUPER, N, B)
  "END" DECSOLTRI;
         "EOP"
 
0"CODE" 34427;
   "PROCEDURE" SOLTRIPIV(SUB, DIAG, SUPER, N, AID, PIV, B);
   "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AID, B;
   "BOOLEAN" "ARRAY" PIV;
   "BEGIN" "INTEGER" I, N1;
      "REAL" BI, BI1, R, S, T;
      N1:= N - 1;
      "FOR" I:= 1 "STEP" 1 "UNTIL" N1 "DO"
      "BEGIN" "IF" PIV[I] "THEN"
         "BEGIN" BI:= B[I+1]; BI1:= B[I] "END"
         "ELSE"
         "BEGIN" BI:= B[I]; BI1:= B[I+1] "END";
         R:= B[I]:= BI / DIAG[I];
         B[I+1]:= BI1 - SUB[I] * R
      "END";
      R:= B[N]:= B[N] / DIAG[N];
      T:= B[N1]:= B[N1] - SUPER[N1] * R;
      "FOR" I:= N - 2 "STEP" -1 "UNTIL" 1 "DO"
      "BEGIN" S:= R; R:= T; T:= B[I]:= B[I] - SUPER[I] * R -
         ("IF" PIV[I] "THEN" AID[I] * S "ELSE" 0)
      "END"
  "END" SOLTRIPIV
 
1SECTION 3.1.2.1.1.1.2.3      (JUNE 1974)                        PAGE 10
 
                                                                  ;
         "EOP"
0"CODE" 34428;
   "PROCEDURE" DECSOLTRIPIV(SUB, DIAG, SUPER, N, AUX, B);
   "VALUE" N; "INTEGER" N; "ARRAY" SUB, DIAG, SUPER, AUX, B;
   "BEGIN" "INTEGER" I, I1, N1, N2;
      "REAL" D, R, S, U, T, Q, V, W, NORM, NORM1, NORM2, TOL,
      BI, BI1, BI2;
      "BOOLEAN" "ARRAY" PIV[1:N];
      TOL:= AUX[2]; D:= DIAG[1]; R:= SUPER[1]; BI:= B[1];
      NORM:= NORM2:= ABS(D) + ABS(R); N2:= N - 2;
      "FOR" I:= 1 "STEP" 1 "UNTIL" N2 "DO"
      "BEGIN" I1:= I + 1; S:= SUB[I]; T:= DIAG[I1]; Q:= SUPER[I1];
         BI1:= B[I1];
         NORM1:= NORM2; NORM2:= ABS(S) + ABS(T) + ABS(Q);
         "IF" NORM2 > NORM "THEN" NORM:= NORM2;
         "IF" ABS(D) * NORM2 < ABS(S) * NORM1 "THEN"
         "BEGIN" "IF" ABS(S) <= TOL * NORM2 "THEN"
            "BEGIN" AUX[3]:= I - 1; AUX[5]:= S; "GOTO" EXIT "END";
            U:= SUPER[I]:= T / S; BI1:= B[I]:= BI1 / S;
            BI:= BI - BI1 * D; V:= SUB[I]:= Q / S;
            W:= SUPER[I1]:= -V * D; D:= DIAG[I1]:= R - U * D;
            R:= W; NORM2:= NORM1; PIV[I]:= "TRUE"
         "END" "ELSE"
         "BEGIN" "IF" ABS(D) <= TOL * NORM1 "THEN"
            "BEGIN" AUX[3]:= I - 1; AUX[5]:= D; "GOTO" EXIT "END";
            U:= SUPER[I]:= R / D; BI:= B[I]:= BI / D;
            BI:= BI1 - BI * S; D:= DIAG[I1]:= T - U * S;
            PIV[I]:= "FALSE"; R:= Q
         "END"
      "END";
      N1:= N - 1; S:= SUB[N1]; T:= DIAG[N]; NORM1:= NORM2; BI1:= B[N];
      NORM2:= ABS(S) + ABS(T); "IF" NORM2 > NORM "THEN" NORM:= NORM2;
      "IF" ABS(D) * NORM2 < ABS(S) * NORM1 "THEN"
      "BEGIN" "IF" ABS(S) <= TOL * NORM2 "THEN"
         "BEGIN" AUX[3]:= N2; AUX[5]:= S; "GOTO" EXIT "END";
         U:= SUPER[N1]:= T / S; BI1:= B[N1]:= BI1 / S;
         BI:= BI - BI1 * D; D:= R - U * D; NORM2:= NORM1
      "END" "ELSE"
      "BEGIN" "IF" ABS(D) <= TOL * NORM1 "THEN"
         "BEGIN" AUX[3]:= N2; AUX[5]:= D; "GOTO" EXIT "END";
         U:= SUPER[N1]:= R / D; BI:= B[N1]:= BI / D;
         BI:= BI1 - BI * S; D:= T - U * S
      "END";
      "IF" ABS(D) <= TOL * NORM2 "THEN"
      "BEGIN" AUX[3]:= N1; AUX[5]:= D; "GOTO" EXIT "END";
      AUX[3]:= N; AUX[5]:= NORM;
      BI1:= B[N]:= BI / D; BI:= B[N1]:= B[N1] - SUPER[N1] * BI1;
      "FOR" I:= N - 2 "STEP" -1 "UNTIL" 1 "DO"
      "BEGIN" BI2:= BI1; BI1:= BI;
          BI:= B[I]:= B[I] - SUPER[I] * BI1 -
          ("IF" PIV[I] "THEN" SUB[I] * BI2 "ELSE" 0)
      "END";
  EXIT:
  "END" DECSOLTRIPIV;
         "EOP"
1SECTION 3.1.2.1.1.2.1.1      (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR      :    T.J. DEKKER.
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    731001.
 
 
 BRIEF DESCRIPTION  :
     THIS SECTION CONTAINS THE PROCEDURE CHLDECBND
     FOR THE CHOLESKY DECOMPOSITION OF A SYMMETRIC POSITIVE DEFINITE
     BAND MATRIX.
 
 KEYWORDS   :
     LINEAR EQUATIONS,
     CHOLESKY DECOMPOSITION,
     SYMMETRIC POSITIVE DEFINITE MATRIX,
     BAND MATRIX.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" CHLDECBND(A, N, W, AUX); "VALUE" N, W; "INTEGER" N, W;
     "ARRAY" A, AUX;
     "CODE" 34330;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
         A    :  <ARRAY IDENTIFIER>;
                 "ARRAY" A[1 : W * (N - 1) + N];
                 ENTRY  : A CONTAINS COLUMNWISE (I.E. THE (I,J)-TH
                 ELEMENT OF THE MATRIX IS A[(J-1)*W+I], J=1,..,N,
                 I=MAX(1,J-W),..,J) THE UPPER-TRIANGULAR BAND
                 ELEMENTS OF THE SYMMETRIC BAND MATRIX;
                 EXIT   : THE BAND ELEMENTS OF THE CHOLESKY
                 MATRIX, WHICH IS AN UPPER-TRIANGULAR BAND MATRIX WITH
                 W SUPERDIAGONALS, ARE DELIVERED COLUMNWISE IN A;
         N    :  <ARITHMETIC EXPRESSION>;
                 ORDER OF THE BAND MATRIX;
         W    :  <ARITHMETIC EXPRESSION>;
                 NUMBER OF  SUPERDIAGONALS OF THE MATRIX;
         AUX  :  <ARRAY IDENTIFIER>;
                 "ARRAY" AUX[2 : 3];
                 ENTRY  : AUX[2] IS A RELATIVE TOLERANCE TO CONTROL THE
                  CALCULATION OF THE DIAGONAL ELEMENTS OF THE
                  CHOLESKY MATRIX (SEE METHOD AND PERFORMANCE);
                 NORMAL EXIT  :
                  AUX[3] = N;
                 ABNORMAL EXIT :
                  AUX[3] = K - 1, WHERE K IS THE INDEX OF THE DIAGONAL
                  ELEMENT OF THE CHOLESKY MATRIX THAT CANNOT BE
                  CALCULATED.
1SECTION 3.1.2.1.1.2.1.1      (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED :
 
     VECVEC = CP34010.
 
 
 RUNNING TIME :
 
     (C1 * W + C2) * W * N;
     THE CONSTANTS C1 AND C2 DEPEND UPON THE
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     CHLDECBND PERFORMS THE CHOLESKY DECOMPOSITION OF A SYMMETRIC
     POSITIVE DEFINITE MATRIX, WHOSE NON-ZERO ELEMENTS ARE IN BAND FORM,
     AND WHOSE UPPER-TRIANGULAR BAND ELEMENTS ARE STORED COLUMNWISE IN
     IONAL ARRAY.
     THE METHOD USED IS CHOLESKY'S SQUARE ROOT METHOD. IF THE GIVEN
     MATRIX IS POSITIVE DEFINITE, THEN THIS METHOD YIELDS AN UPPER-
     TRIANGULAR BAND MATRIX, THE CHOLESKY MATRIX. THE NUMBER OF
     NON-ZERO SUPERDIAGONALS OF THE GIVEN MATRIX AND ITS CHOLESKY
     MATRIX ARE EQUAL. THE PROCESS IS COMPLETED IN N STAGES, AT EACH
     STAGE PRODUCING A ROW OF THE CHOLESKY MATRIX. HOWEVER, THE
     PROCESS IS DISCONTINUED IF AT SOME STAGE, SAY K, THE K-TH DIAGONAL
     ELEMENT OF THE GIVEN MATRIX MINUS THE SUM OF SQUARES OF THE
     SUPERDIAGONAL ELEMENTS OF THE K-TH COLUMN OF THE CHOLESKY MATRIX
     (THE SQUARE ROOT OF THIS QUANTITY BEING THE K-TH DIAGONAL ELEMENT
     OF THE CHOLESKY MATRIX) IS EITHER NEGATIVE OR LESS THAN A GIVEN
     RELATIVE TOLERANCE (AUX[2]) TIMES THE MAXIMAL DIAGONAL ELEMENT
     THE GIVEN MATRIX. IN THIS CASE THE GIVEN MATRIX, POSSIBLY MODIFIED
     BY ROUNDING ERRORS, IS NOT POSITIVE DEFINITE. THIS IS INDICATED IN
     AUX[3], BY WHICH THE VALUE K - 1 IS DELIVERED. IF THE
     DECOMPOSITION IS CARRIED OUT FULLY, AUX[3] BECOMES N.
     THE PROCEDURE DELIVERS THE BAND ELEMENTS OF THE CHOLESKY MATRIX.
     SEE ALSO REF [1], SECTION 222.
 
 
 REFERENCE   :
 
     [1] DEKKER, T.J. :
         ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 1,
         MC TRACT 22, 1968, MATHEMATISCH CENTRUM, AMSTERDAM.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLE OF USE OF CHLSOLBND.
1SECTION 3.1.2.1.1.2.1.1      (JUNE 1974)                         PAGE 3
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34330;
 "PROCEDURE" CHLDECBND(A, N, W, AUX); "VALUE" N, W; "INTEGER" N, W;
 "ARRAY" A, AUX;
 "BEGIN" "INTEGER" J, K, JMAX, KK, KJ, W1, START;
         "REAL" R, EPS, MAX;
         MAX:= 0; KK:= - W; W1:= W + 1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + W1; "IF" A[KK] > MAX "THEN" MAX:= A[KK]"END";
         JMAX:= W; W1:= W + 1; KK:= - W; EPS:= AUX[2] * MAX;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN""IF" K + W > N "THEN" JMAX:= JMAX - 1; KK:= KK + W1;
             START:= KK - K + 1;
             R:= A[KK] - VECVEC("IF" K <= W1 "THEN" START "ELSE" KK - W,
             KK - 1, 0, A, A); "IF" R <= EPS "THEN"
             "BEGIN" AUX[3]:= K - 1; "GO TO" END "END";
             A[KK]:= R:= SQRT(R); KJ:= KK;
             "FOR" J:= 1 "STEP" 1 "UNTIL" JMAX "DO"
             "BEGIN" KJ:= KJ + W;
                 A[KJ]:= (A[KJ] - VECVEC("IF" K + J <= W1 "THEN" START
                 "ELSE" KK - W + J, KK - 1, KJ - KK, A, A)) / R
             "END"
         "END";
         AUX[3]:= N;
     END:
     "END" CHLDECBND;
         "EOP"
1SECTION 3.1.2.1.1.2.1.2      (JUNE 1974)                         PAGE 1
 
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    731001.
 
 
 BRIEF DESCRIPTION  :
 
     THIS SECTION CONTAINS ONE PROCEDURE,
     CHLDETERMBND, FOR THE CALCULATION OF THE DETERMINANT OF A SYMMETRIC
     POSITIVE DEFINITE BAND MATRIX.
 
 
 KEY WORDS  :
 
     DETERMINANT,
     SYMMETRIC POSITIVE DEFINITE MATRIX,
     BAND MATRIX.
 
 
 CALLING SEQUENCE  :
 
     THE HEADING OF THE PROCEDURE IS :
 
     "REAL""PROCEDURE" CHLDETERMBND(A, N, W); "VALUE" N, W;
     "INTEGER" N, W; "ARRAY" A;
     "CODE" 34331;
 
     CHLDETERMBND DELIVERS THE DETERMINANT OF THE SYMMETRIC POSITIVE
     DEFINITE BAND MATRIX WHOSE CHOLESKY MATRIX IS STORED IN A.
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
 
     A, N, W :   SEE 'CALLING SEQUENCE' OF CHLDECBND
                 (SECTION 3.1.2.1.1.2.1.1.);
                 THE CONTENTS OF A ARE AS PRODUCED BY CHLDECBND OR
                 CHLDECSOLBND (SECTION 3.1.2.1.1.2.1.3.).
 
 
 PROCEDURES USED :    NONE.
 
 
 RUNNING TIME :    PROPORTIONAL TO N.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
1SECTION 3.1.2.1.1.2.1.2      (JUNE 1974)                         PAGE 2
 
 
 
 METHOD AND PERFORMANCE :
 
     CHLDETERMBND CAN BE CALLED AFTER CHLDECBND OR CHLDECSOLBND ONLY IF
     THE CHOLESKY DECOMPOSITION WAS SUCCESSFUL, I.E. IF
     AUX[3] = N.
     THE FUNCTION VALUE OF CHLDETERMBND IS THE SQUARE OF THE DETERMINANT
     OF THE CHOLESKY MATRIX.
     CHLDETERMBND SHOULD NOT BE CALLED WHEN OVERFLOW CAN BE EXPECTED.
 
 
 EXAMPLE OF USE :
 
     SEE EXAMPLES OF USE OF CHLSOLBND AND CHLDECSOLBND.
 
 
 
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34331;
 "REAL""PROCEDURE" CHLDETERMBND(A, N, W); "VALUE" N, W; "INTEGER" N,W;
 "ARRAY" A;
 "BEGIN""INTEGER" J, KK, W1; "REAL" P;
         W1:= W + 1; KK:= - W; P:= 1;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + W1; P:= A[KK] * P "END";
         CHLDETERMBND:= P * P
     "END" CHLDETERMBND;
         "EOP"
1SECTION 3.1.2.1.1.2.1.3      (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR      :    T.J. DEKKER.
 
 
 CONTRIBUTOR :    J. KOK.
 
 
 INSTITUTE   :    MATHEMATICAL CENTRE.
 
 
 RECEIVED    :    731001.
 
 BRIEF DESCRIPTION  :
     THIS SECTION CONTAINS TWO PROCEDURES.
     A) CHLSOLBND, FOR THE SOLUTION OF ONE OR MORE SYSTEMS OF LINEAR
     EQUATIONS WITH THE SAME COEFFICIENT MATRIX, WHICH IS SYMMETRIC,
     POSITIVE DEFINITE AND IN BANDFORM, PROVIDED THAT THIS
     MATRIX HAS BEEN DECOMPOSED BY A CALL OF THE PROCEDURE CHLDECBND
     (SECTION 3.1.2.1.1.2.1.1.).
     B) CHLDECSOLBND, FOR THE SOLUTION OF ONE SYSTEM OF LINEAR
     EQUATIONS BY CHOLESKY'S SQUARE ROOT METHOD, PROVIDED THAT THE
     SYMMETRIC POSITIVE DEFINITE COEFFICIENT MATRIX IS IN BAND FORM
     AND IS STORED COLUMNWISE IN A ONE-DIMENSIONAL ARRAY.
 
 
 KEYWORDS  :
     LINEAR EQUATIONS,
     CHOLESKY DECOMPOSITION,
     SYMMETRIC POSITIVE DEFINITE MATRIX,
     BAND MATRIX.
 
 
 SUBSECTION :    CHLSOLBND.
 
 CALLING SEQUENCE  :
 
 
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" CHLSOLBND(A, N, W, B); "VALUE" N, W; "INTEGER" N, W;
     "ARRAY" A, B;
     "CODE" 34332;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
         A, N, W :   SEE 'CALLING SEQUENCE' OF CHLDECBND,
                 THE CONTENTS OF THE ARRAY A ARE AS PRODUCED BY
                 CHLDECBND;
         B  :    <ARRAY IDENTIFIER>;
                 "ARRAY" B[1 : N];
                 ENTRY : THE RIGHT HAND SIDE OF THE SYSTEM OF LINEAR
                 EQUATIONS;
                 EXIT  :  THE SOLUTION OF THE SYSTEM.
 
 PROCEDURES USED :
 
     VECVEC = CP34010,
     SCAPRD1= CP34017.
 
 
1SECTION 3.1.2.1.1.2.1.3      (JUNE 1974)                         PAGE 2
 
 
 
 RUNNING TIME:
 
     (C3 * W + C4) * N;
     THE CONSTANTS C3 AND C4 DEPEND UPON THE
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
     THE PROCEDURE CHLSOLBND CALCULATES THE SOLUTION OF A SYSTEM OF
     LINEAR EQUATIONS, PROVIDED THAT THE COEFFICIENT MATRIX WAS
     DECOMPOSED BY A SUCCESSFUL CALL OF CHLDECBND (SECTION
     3.1.2.1.1.2.1.1.).
     THE SOLUTION OF THE LINEAR SYSTEM IS OBTAINED BY CARRYING OUT THE
     FORWARD AND BACK SUBSTITUTION WITH THE CHOLESKY MATRIX AND THE
     RIGHT HAND SIDE. THE LATTER IS OVERWRITTEN BY THE SOLUTION.
     THE SOLUTIONS OF SEVERAL SYSTEMS WITH THE SAME COEFFICIENT MATRIX
     CAN BE OBTAINED BY SUCCESSIVE CALLS OF CHLSOLBND.
 
 
 EXAMPLE OF USE :
 
     THE FOLLOWING PROGRAM SOLVES THE SYSTEM OF SIMULTANEOUS EQUATIONS
 
         2 * X1   -   X2                             = 1
         -   X1 + 2 * X2   -   X3                    = 0
                  -   X2 + 2 * X3   -   X4           = 0
                           -   X3 + 2 * X4   -   X5  = 0
                                    -   X4 + 2 * X5  = 1
 
     "BEGIN""COMMENT" 730829, TEST CHLDECBND, CHLSOLBND AND
        CHLDETERMBND;
        "INTEGER" I;
        "ARRAY" SYMBAND[1 : 9], RIGHT[1 : 5], AUX[2 : 3];
        "FOR" I:= 1 "STEP" 1 "UNTIL" 9 "DO"
        SYMBAND[I]:= "IF" I // 2 * 2 < I "THEN" 2 "ELSE" - 1;
        RIGHT[1]:= RIGHT[5]:= 1;
        "FOR" I:= 2, 3, 4 "DO" RIGHT[I]:= 0; AUX[2]:= "- 12;
        CHLDECBND(SYMBAND, 5, 1, AUX);
        "IF" AUX[3] = 5 "THEN"
        "BEGIN" CHLSOLBND(SYMBAND, 5, 1, RIGHT);
           OUTPUT(61, "("5(+2Z.4D2B), /"("DETERMINANT IS  ")" +.8D"+DD
           ")", RIGHT, CHLDETERMBND(SYMBAND, 5, 1))
        "END"
     "END".
 
     THIS PROGRAM DELIVERS:
      +1.0000   +1.0000   +1.0000   +1.0000   +1.0000
     DETERMINANT IS  +.60000000"+01
1SECTION 3.1.2.1.1.2.1.3      (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION :    CHLDECSOLBND.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE IS :
 
 
     "PROCEDURE" CHLDECSOLBND(A, N, W, AUX, B); "VALUE" N, W;
     "INTEGER" N, W; "ARRAY" A, AUX, B;
     "CODE" 34333;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
 
         A, N, W, AUX    : SEE CHLDECBND;
         B               : SEE CHLSOLBND.
 
 
 PROCEDURES USED :
 
     CHLDECBND = CP34330,
     CHLSOLBND = CP34332.
 
 
 RUNNING TIME:
 
     (C1 * W + C5) * W * N;
     THE CONSTANTS C1 AND C5 DEPEND UPON THE ELEMENTARY
     ARITHMETIC OF THE COMPUTER.
 
 
 LANGUAGE    :    ALGOL 60.
 
 
 METHOD AND PERFORMANCE :
 
     CHLDECSOLBND SOLVES A SYSTEM OF LINEAR EQUATIONS BY CALLING
     CHLDECBND AND, PROVIDED THAT THE CHOLESKY DECOMPOSITION WAS
     SUCCESSFUL, CHLSOLBND. THE COEFFICIENT MATRIX OF THIS SYSTEM HAS TO
     BE A SYMMETRIC POSITIVE DEFINITE BAND MATRIX WHOSE UPPER-TRIANGULAR
     BAND ELEMENTS ARE STORED COLUMNWISE IN IONAL ARRAY.
 
 
 EXAMPLE OF USE :
 
     THE PROGRAM
 
     "BEGIN""COMMENT" 730829, TEST CHLDECSOLBND AND CHLDETERMBND;
        "INTEGER" I;
        "ARRAY" SYMBAND[1 : 9], RIGHT[1 : 5], AUX[2 : 3];
1SECTION 3.1.2.1.1.2.1.3      (JUNE 1974)                         PAGE 3
 
 
 
        "FOR" I:= 1 "STEP" 1 "UNTIL" 9 "DO"
        SYMBAND[I]:= "IF" I // 2 * 2 < I "THEN" 2 "ELSE" - 1;
        RIGHT[1]:= RIGHT[5]:= 1;
        "FOR" I:= 2, 3, 4 "DO" RIGHT[I]:= 0; AUX[2]:= "- 12;
        CHLDECSOLBND(SYMBAND, 5, 1, AUX, RIGHT);
        "IF" AUX[3] = 5 "THEN"
        "BEGIN"
           OUTPUT(61, "("5(+2Z.4D2B), /"("DETERMINANT IS  ")" +.8D"+DD
           ")", RIGHT, CHLDETERMBND(SYMBAND, 5, 1))
        "END"
     "END"
 
     WHICH SOLVES THE SAME PROBLEM AS THE PROGRAM IN THE EXAMPLE  OF USE
     OF CHLSOLBND, DELIVERS:
 
      +1.0000   +1.0000   +1.0000   +1.0000   +1.0000
     DETERMINANT IS  +.60000000"+01
         "EOP"
 
 SOURCE TEXT(S) :
0"CODE" 34332;
 "PROCEDURE" CHLSOLBND(A, N, W, B); "VALUE" N, W; "INTEGER" N, W;
 "ARRAY" A, B;
 "BEGIN" "INTEGER" I, K, IMAX, KK, W1;
         KK:= - W; W1:= W + 1;
         "FOR" K:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" KK:= KK + W1;
             B[K]:= (B[K] - VECVEC("IF" K <= W1 "THEN" 1 "ELSE" K - W,
             K - 1, KK - K, B, A)) / A[KK]
         "END";
         IMAX:= - 1;
         "FOR" K:= N "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN""IF" IMAX < W "THEN" IMAX:= IMAX + 1;
             B[K]:= (B[K] - SCAPRD1(KK + W, W, K + 1, 1, IMAX, A, B)) /
             A[KK]; KK:= KK - W1
         "END"
     "END" CHLSOLBND;
         "EOP"
0"CODE" 34333;
 "PROCEDURE" CHLDECSOLBND(A, N, W, AUX, B); "VALUE" N, W;
 "INTEGER" N, W; "ARRAY" A, AUX, B;
 "BEGIN"
         CHLDECBND(A, N, W, AUX);
         "IF" AUX[3] = N "THEN" CHLSOLBND(A, N, W, B)
     "END" CHLDECSOLBND;
         "EOP"
1SECTION 3.1.2.1.1.2.2.1      (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR: W. HOFFMANN.
 
 CONTRIBUTOR: J. C. P. BUS.
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 RECEIVED: 731215.
 
 BRIEF DESCRIPTION:
     THIS  SECTION  CONTAINS  A  PROCEDURE,  DECSYMTRI,   TO  PERFORM  A
     TRIANGULAR DECOMPOSITION OF A SYMMETRIC TRIDIAGONAL MATRIX.
 
 KEYWORDS:
 
     LU DECOMPOSITION,
     TRIANGULAR DECOMPOSITION,
     SYMMETRIC TRIDIAGONAL MATRIX.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECSYMTRI(DIAG, CO, N, AUX);
     "VALUE" N; "INTEGER" N; "ARRAY" DIAG, CO, AUX;
     "CODE" 34420;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF THE GIVEN MATRIX T, SAY;
             EXIT:   SUPPOSE U DENOTES THE UNIT UPPER-BIDIAGONAL MATRIX,
                     SUCH THAT  U'DU = T   FOR SOME  DIAGONAL MATRIX  D,
                     WHERE U' DENOTES THE TRANSPOSED MATRIX; THEN D[I,I]
                     WILL BE DELIVERED IN DIAG[I], I = 1, ..., AUX[3];
     CO:     <ARRAY IDENTIFIER>;
             "ARRAY" CO[1: N - 1];
             ENTRY:  THE CODIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN IN
                     CO[I], I = 1, ..., N - 1;
             EXIT:   U[I, I + 1] WILL BE DELIVERED IN CO[I], I = 1, ...,
                     AUX[3] - 1;
     N:      <ARITHMETICAL EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX,  ELSE  AUX[5]  IS SET  EQUAL TO
                     THE  VALUE  OF  THAT  ELEMENT   WHICH   CAUSES  THE
                     BREAKDOWN OF THE DECOMPOSITION.
1SECTION 3.1.2.1.1.2.2.1      (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED: NONE.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
 
     THE METHOD USED IN DECSYMTRI  YIELDS A UNIT UPPER-BIDIAGONAL MATRIX
     U AND A DIAGONAL MATRIX  D, SUCH THAT THE PRODUCT  U'DU  EQUALS THE
     GIVEN  SYMMETRIC TRIDIAGONAL MATRIX;  THE PROCESS  IS TERMINATED IN
     THE K-TH STEP  IF  THE MODULUS  OF  THE  K-TH  DIAGONAL ELEMENT  IS
     SMALLER THAN  A CERTAIN  SMALL  VALUE,  WHICH  IS GIVEN  BY  AUX[2]
     MULTIPLIED BY THE 1-NORM OF THE K-TH ROW;  IN THIS CASE AUX[3] WILL
     BE GIVEN THE VALUE  K - 1  AND  AUX[5]  WILL BE GIVEN  THE VALUE OF
     THE K-TH DIAGONAL ELEMENT.
 
 
 EXAMPLE OF USE: SEE DECSOLSYMTRI (SECTION 3.1.2.1.1.2.2.3).
 
 
 SOURCE TEXT:
0"CODE" 34420;
       "PROCEDURE" DECSYMTRI(DIAG, CO, N, AUX); "VALUE" N; "INTEGER" N;
       "ARRAY" DIAG, CO, AUX;
       "BEGIN"  "INTEGER" I, N1;
          "REAL" D, R, S, U, TOL, NORM, NORMR;
          TOL:= AUX[2]; D:= DIAG[1]; R:= CO[1];
          NORM:= NORMR:= ABS(D) + ABS(R);
          "IF" ABS(D) <= NORMR * TOL "THEN"
          "BEGIN" AUX[3]:= 0; AUX[5]:= D; "GOTO" EXIT "END";
          U:= CO[1]:= R / D; N1:= N - 1;
          "FOR" I:= 2 "STEP" 1 "UNTIL" N1 "DO"
          "BEGIN" S:= R; R:= CO[I]; D:= DIAG[I];
             NORMR:= ABS(S) + ABS(D) + ABS(R);
             D:= DIAG[I]:= D - U * S;
             "IF" ABS(D) <= NORMR * TOL "THEN"
             "BEGIN" AUX[3]:= I - 1; AUX[5]:= D; "GOTO" EXIT "END";
             U:= CO[I]:= R / D; "IF" NORMR > NORM "THEN" NORM:= NORMR
          "END";
          D:= DIAG[N]; NORMR:= ABS(D) + ABS(R);
          D:= DIAG[N]:= D - U * R;
          "IF" ABS(D) <= NORMR * TOL "THEN"
          "BEGIN" AUX[3]:= N1; AUX[5]:= D; "GOTO" EXIT "END";
          "IF" NORMR > NORM "THEN" NORM:= NORMR;
          AUX[3]:= N; AUX[5]:= NORM;
       EXIT:
       "END" DECSYMTRI;
         "EOP"
1SECTION 3.1.2.1.1.2.2.3      (FEBRUARY 1979)                     PAGE 1
 
 
 
 AUTHOR: W. HOFFMANN.
 
 
 CONTRIBUTOR: J. C. P. BUS.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731215.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION CONTAINS TWO PROCEDURES
     FOR  SOLVING  A  SYSTEM  OF  LINEAR  EQUATIONS   WITH  A  SYMMETRIC
     TRIDIAGONAL  MATRIX;
     SOLSYMTRI  CALCULATES  A  SOLUTION   IF  THE
     TRIANGULARLY DECOMPOSED FORM,  AS DELIVERED BY  DECSYMTRI  (SECTION
     3.1.2.1.1.2.2.1),  IS GIVEN;
     DECSOLSYMTRI  PERFORMS THE TRIANGULAR
     DECOMPOSITION  AS WELL AS  THE  FORWARD  AND  BACK SUBSTITUTION  TO
     CALCULATE THE SOLUTION  OF THE GIVEN LINEAR SYSTEM.
 
 
 KEYWORDS:
 
     ALGEBRAIC EQUATIONS,
     LINEAR SYSTEMS,
     SYMMETRIC TRIDIAGONAL MATRIX,
     FORWARD AND BACK SUBSTITUTION.
 
 
 
1SECTION 3.1.2.1.1.2.2.3      (FEBRUARY 1979)                     PAGE 2
 
 
 
 SUBSECTION: SOLSYMTRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" SOLSYMTRI(DIAG, CO, N, B);
     "VALUE" N; "INTEGER" N; "ARRAY" DIAG, CO, B; "CODE" 34421;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1:N];
             ENTRY:  THE  DIAGONAL  MATRIX,  AS
             DELIVERED BY DECSYMTRI (SECTION 3.1.2.1.1.2.2.1);
     CO:     <ARRAY IDENTIFIER>;
             "ARRAY" CO[1: N - 1];
             ENTRY:  THE CODIAGONAL OF THE UNIT
             UPPER-BIDIAGONAL MATRIX AS DELIVERED BY DECSYMTRI;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   THE CALCULATED SOLUTION OF THE LINEAR SYSTEM.
 
 
 PROCEDURES USED: NONE.
 
 
 METHOD AND PERFORMANCE:
 
     SOLSYMTRI  CALCULATES  THE  SOLUTION  OF  A  LINEAR  SYSTEM  WITH A
     SYMMETRIC TRIDIAGONAL MATRIX, WITH FORWARD  AND  BACK SUBSTITUTION;
     THE TRIANGULARLY  DECOMPOSED  FORM  OF  THE MATRIX,  AS PRODUCED BY
     DECSYMTRI (SECTION  3.1.2.1.1.2.2.1), SHOULD BE GIVEN;  ONE CALL OF
     DECSYMTRI FOLLOWED BY SEVERAL CALLS OF  SOLSYMTRI  MAY BE  USED  TO
     SOLVE SEVERAL LINEAR SYSTEMS  HAVING THE SAME SYMMETRIC TRIDIAGONAL
     MATRIX, BUT DIFFERENT RIGHT HAND SIDES.
 
 
 EXAMPLE OF USE: SEE DECSOLSYMTRI (THIS SECTION).
 
 
 
1SECTION 3.1.2.1.1.2.2.3      (FEBRUARY 1979)                     PAGE 3
 
 
 
 SUBSECTION: DECSOLSYMTRI.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" DECSOLSYMTRI(DIAG, CO, N, AUX, B);
     "VALUE" N; "INTEGER" N; "ARRAY" DIAG, CO, AUX, B; "CODE" 34422;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     DIAG:   <ARRAY IDENTIFIER>;
             "ARRAY" DIAG[1: N];
             ENTRY:  THE DIAGONAL OF THE GIVEN MATRIX T, SAY;
             EXIT:   SUPPOSE U DENOTES THE UNIT UPPER-BIDIAGONAL MATRIX,
                     SUCH THAT  U'DU = T   FOR SOME  DIAGONAL MATRIX  D,
                     WHERE U' DENOTES THE TRANSPOSED MATRIX; THEN D[I,I]
                     WILL BE DELIVERED IN DIAG[I], I = 1, ..., AUX[3];
     CO:     <ARRAY IDENTIFIER>;
             "ARRAY" CO[1: N - 1];
             ENTRY:  THE CODIAGONAL OF T; T[I, I + 1] SHOULD BE GIVEN IN
                     CO[I], I = 1, ..., N - 1;
             EXIT:   U[I, I + 1] WILL BE DELIVERED IN CO[I], I = 1, ...,
                     AUX[3] - 1;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
     AUX:    <ARRAY IDENTIFIER>;
             "ARRAY" AUX[2:5];
             ENTRY:
             AUX[2]: A RELATIVE TOLERANCE;  A REASONABLE CHOICE FOR THIS
                     VALUE IS AN ESTIMATE OF  THE RELATIVE PRECISION  OF
                     THE  MATRIX ELEMENTS,  HOWEVER, IT  SHOULD  NOT  BE
                     CHOSEN SMALLER THAN THE MACHINE PRECISION;
             EXIT:
             AUX[3]: THE NUMBER OF ELIMINATION STEPS PERFORMED;
             AUX[5]: IF AUX[3] = N, THEN AUX[5] WILL EQUAL THE INFINITY-
                     NORM OF THE MATRIX,  ELSE  AUX[5]  IS SET  EQUAL TO
                     THE  VALUE  OF  THAT  ELEMENT   WHICH   CAUSES  THE
                     BREAKDOWN OF THE DECOMPOSITION;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             ENTRY:  THE RIGHT HAND SIDE OF THE LINEAR SYSTEM;
             EXIT:   IF  AUX[3] = N  THEN  THE  SOLUTION  OF  THE LINEAR
                     SYSTEM  IS  OVERWRITTEN  ON   B,  ELSE   B  REMAINS
                     UNALTERED.
 
 
1SECTION 3.1.2.1.1.2.2.3      (FEBRUARY 1979)                     PAGE 4
 
 
 
 PROCEDURES USED:
 
     DECSYMTRI = CP34420,
     SOLSYMTRI = CP34421.
 
 
 METHOD AND PERFORMANCE:
 
     DECSOLSYMTRI  CALCULATES  THE SOLUTION  OF  A LINEAR SYSTEM  WITH A
     SYMMETRIC TRIDIAGONAL MATRIX;  THE TRIANGULAR DECOMPOSITION IS DONE
     BY CALLING DECSYMTRI (SECTION 3.1.2.1.1.2.2.1)  AND THE FORWARD AND
     BACK SUBSTITUTION BY CALLING SOLSYMTRI (THIS SECTION); IF AUX[3]<N,
     THEN THE EFFECT OF DECSOLSYMTRI IS MERELY THAT OF DECSYMTRI.
 
 
 EXAMPLE OF USE:
 
     LET T BE A SYMMETRIC TRIDIAGONAL MATRIX OF ORDER 100  WITH DIAGONAL
     ELEMENTS I (I = 1, ..., 100) AND CODIAGONAL ELEMENTS I * 2  (I = 1,
     ..., 99); LET THE RIGHT HAND SIDE  B  BE GIVEN BY THE SECOND COLUMN
     OF T; THEN THE SOLUTION OF THE LINEAR SYSTEM TX = B IS GIVEN BY THE
     SECOND UNIT VECTOR;  BY  THE FOLLOWING PROGRAM  WE  MAY SOLVE  THIS
     SYSTEM AND PRINT THE ERROR IN THE CALCULATED SOLUTION.
 
     "BEGIN"
         "INTEGER" I; "ARRAY" D, CO, B[1:100], AUX[2:5];
         "FOR" I:= 1 "STEP" 1 "UNTIL" 100 "DO"
         "BEGIN" D[I]:= I; CO[I]:= I * 2; B[I]:= 0 "END";
         B[1]:= B[2]:= 2; B[3]:= 4;
         AUX[2]:= "-14;
         DECSOLSYMTRI(D, CO, 100, AUX, B);
         B[2]:= B[2] - 1;
         OUTPUT(71, "("/,"("    AUX[3] AND AUX[5]:")",2(/4B,N)")",
         AUX[3], AUX[5]);
         OUTPUT(71, "("//,"("    ERROR IN THE SOLUTION:")",N,/")",
         SQRT(VECVEC(1, 100, 0, B, B)))
     "END"
 
     RESULTS:
 
     AUX[3] AND AUX[5]:
     +1.0000000000000"+002
     +4.9300000000000"+002
 
     ERROR IN THE SOLUTION:+0.0000000000000"+000
1SECTION 3.1.2.1.1.2.2.3      (JUNE 1974)                         PAGE 5
 
 
 
 SOURCE TEXTS:
0"CODE" 34421;
       "PROCEDURE" SOLSYMTRI(DIAG, CO, N, B); "VALUE" N; "INTEGER" N;
       "ARRAY" DIAG, CO, B;
       "BEGIN" "INTEGER" I;
          "REAL" R, S;
          R:= B[1]; B[1]:= R / DIAG[1];
          "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO"
          "BEGIN" R:= B[I] - CO[I-1] * R; B[I]:= R / DIAG[I] "END";
          S:= B[N];
          "FOR" I:= N - 1 "STEP" -1 "UNTIL" 1 "DO"
          S:= B[I]:= B[I] - CO[I] * S
       "END" SOLSYMTRI;
         "EOP"
 
0"CODE" 34422;
       "PROCEDURE" DECSOLSYMTRI(DIAG, CO, N, AUX, B); "VALUE" N;
       "INTEGER" N; "ARRAY" DIAG, CO, AUX, B;
       "BEGIN"
               DECSYMTRI(DIAG, CO, N, AUX); "IF" AUX[3] = N "THEN"
               SOLSYMTRI(DIAG, CO, N, B)
       "END" DECSOLSYMTRI;
         "EOP"
1SECTION 3.1.2.2.1            (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR: P.W.HEMKER.
 
 
 INSTITUTE: MATHEMATICAL CENTRE.
 
 
 RECEIVED: 730615.
 
 
 BRIEF DESCRIPTION:
 
     CONJ GRAD  SOLVES A  LINEAR  SYSTEM OF  EQUATIONS BY THE  METHOD OF
     CONJUGATE GRADIENTS. THE SYSTEM  HAS TO BE  SYMMETRIC AND  POSITIVE
     DEFINITE.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" CONJ GRAD (MATVEC, X, R, L, N, GO ON, ITERATE, NORM2);
     "VALUE" L, N; "BOOLEAN" GO ON; "INTEGER" L, N, ITERATE;
     "REAL" NORM2; "ARRAY" X, R; "PROCEDURE" MATVEC;
     "CODE" 34220;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     MATVEC: <PROCEDURE IDENTIFIER>;
             THE HEADING OF THIS PROCEDURE READS:
             "PROCEDURE" MATVEC( P, Q); "ARRAY" P, Q;
             THIS PROCEDURE DEFINES THE MATRIX A (THE COEFFICIENT MATRIX
             OF THE SYSTEM) AS FOLLOWS :
             AT EACH CALL MATVEC DELIVERS IN Q THE MATRIX-VECTOR PRODUCT
             AP; P AND Q ARE ONE - DIMENSIONAL ARRAYS:
             "ARRAY" P,Q[L:N];
     X:      <ARRAY IDENTIFIER>;
             "ARRAY" X[L:N];
             ENTRY: AN INITIAL APPROXIMATION TO THE SOLUTION X;
             EXIT:  THE SOLUTION;
     R:      <ARRAY IDENTIFIER>;
             "ARRAY" R[L:N];
             ENTRY: THE RIGHT-HAND SIDE OF THE SYSTEM;
             EXIT:  THE RESIDUE B - AX, COMPUTED RECURSIVELY;
     L,N:    <ARITHMETIC EXPRESSION>;
             L AND N ARE RESPECTIVELY THE  LOWER AND  UPPER BOUND OF THE
             ARRAYS  X,R,P,Q;
     GO ON:  <BOOLEAN EXPRESSION>;
             GO ON INDICATES THE CONTINUATION OF THE PROCESS.
             THIS EXPRESSION MAY DEPEND ON THE JENSEN PARAMETERS ITERATE
             AND NORM2. WITH THIS BOOLEAN EXPRESSION THE USER CONTROLS
             THE  CONTINUATION OF THE  PROCESS. IF  GO ON:= "FALSE"  THE
             ITERATION PROCESS IS STOPPED.
     ITERATE:<IDENTIFIER>;
             DELIVERS THE NUMBER OF ITERATION STEPS ALREADY PERFORMED;
     NORM2:  <IDENTIFIER>;
             DELIVERS THE SQUARED EUCLIDEAN NORM OF THE RESIDUE,COMPUTED
             RECURSIVELY
1SECTION 3.1.2.2.1            (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED:
 
     VECVEC = CP34010 ,
     ELMVEC = CP34020 .
 
 
 REQUIRED CENTRAL MEMORY:
 
     EXECUTION FIELD LENGTH: 7 + 2 * ( N - L + 1 ).
 
 
 RUNNING TIME:
 
     THE  RUNNING TIME IS PROPORTIONAL TO THE  NUMBER OF ITERATION STEPS
     PERFORMED. EACH  ITERATION STEP  REQUIRES  ONE  EVALUATION  OF  THE
     PROCEDURE MATVEC, THE  EVALUATION OF TWO SCALAR - VECTOR - PRODUCTS
     AND ONE VECTOR - VECTOR - PRODUCT.
 
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE REF[1].
 
 
 REFERENCES:
 
     [1].J.K.REID.
         ON THE METHOD OF  CONJUGATE GRADIENTS FOR THE SOLUTION OF LARGE
         SPARSE SYSTEMS OF LINEAR EQUATIONS.
         IN:LARGE SPARSE SETS OF LINEAR EQUATIONS (J.K.REID ED)1971.
 
 
1SECTION 3.1.2.2.1            (DECEMBER 1979)                     PAGE 3
 
 
 
 EXAMPLE OF USE:
 
     "BEGIN"
         "ARRAY" X,B[0:12];
         "INTEGER" IT,I;
         "REAL" NO;
         "PROCEDURE" A(X,B);
         "ARRAY" X,B;
         "BEGIN" B[0]:=2*X[0]-X[1];
             "FOR" I:=1 "STEP" 1 "UNTIL" 11 "DO"
             B[I]:=-X[I-1]+2*X[I]-X[I+1];
             B[12]:=2*X[12]-X[11]
         "END" A;
         "FOR" I:=0 "STEP" 1 "UNTIL" 12 "DO" X[I]:=B[I]:=0;
         B[0]:=1;B[12]:=4;
         CONJ GRAD(A,X,B,0,12,IT<20 "AND" NO>"-10,IT,NO);
         OUTPUT(61,"(""("IT= ")",B3D5B,"("NO= ")",N,//,10B,
         "("X")",20B,"("R")",//")",IT,NO);
         "FOR" I:=0 "STEP" 1 "UNTIL" 12 "DO"
         OUTPUT(61,"("N,5B,N,/")",X[I],B[I])
     "END"
 
     DELIVERS:
     IT= 013     NO= +3.3424581859911"-027
 
                X                    R
 
     +1.2142857142857"+000     -7.1054273576010"-015
     +1.4285714285715"+000     +1.5151278924296"-014
     +1.6428571428572"+000     -1.3184703260130"-014
     +1.8571428571429"+000     +1.6718441615946"-014
     +2.0714285714286"+000     -1.5514524667596"-014
     +2.2857142857144"+000     +2.2130179956186"-014
     +2.5000000000001"+000     -2.2524167805437"-014
     +2.7142857142858"+000     +2.0834049529361"-014
     +2.9285714285715"+000     -1.8674557504802"-014
     +3.1428571428572"+000     +1.9163204503355"-014
     +3.3571428571429"+000     -1.2366043539824"-014
     +3.5714285714286"+000     +8.2548347242718"-015
     +3.7857142857143"+000     +4.4408920985006"-016  .
1SECTION 3.1.2.2.1            (JUNE 1974)                         PAGE 4
 
 
 
 SOURCE TEXT(S):
0"CODE" 34220;
     "PROCEDURE" CONJ GRAD( MATVEC, X, R, L, N, GO ON, ITERATE, NORM2);
     "VALUE" L, N; "PROCEDURE" MATVEC; "ARRAY" X, R; "BOOLEAN" GO ON;
     "INTEGER" L, N, ITERATE; "REAL" NORM2;
     "BEGIN" "ARRAY" P, AP[ L: N];
         "INTEGER" I;
         "REAL"  A, B, PRR, RRP;
         "FOR" ITERATE:= 0, ITERATE + 1 "WHILE" GO ON "DO"
         "BEGIN" "IF" ITERATE = 0 "THEN"
             "BEGIN" MATVEC( X, P);
                 "FOR" I:= L "STEP" 1 "UNTIL" N "DO"
                 P[ I]:= R[ I]:= R[ I] - P[ I];
                 PRR:= VECVEC( L, N, 0, R, R)
             "END" "ELSE"
             "BEGIN" B:= RRP / PRR; PRR:= RRP;
                 "FOR" I:= L "STEP" 1 "UNTIL" N "DO"
                 P[ I]:= R[ I] + B * P[ I]
             "END";
             MATVEC( P, AP);
             A:= PRR / VECVEC( L, N, 0, P, AP);
             ELMVEC( L, N, 0, X, P, A);
             ELMVEC( L, N, 0, R, AP, -A);
             NORM2:= RRP:= VECVEC( L, N, 0, R, R)
         "END"
     "END" CONJ GRAD;
         "EOP"
1SECTION:3.2.1.1.1            (JUNE 1974)                         PAGE 1
 
 
 
 AUTHORS  :      T.J.DEKKER AND W.HOFFMANN.
 
 
 CONTRIBUTORS: W.HOFFMANN, J.G.VERWER.
 
 
 INSTITUTE:    MATHEMATICAL CENTRE.
 
 
 RECEIVED:     731022.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION  CONTAINS TWO PROCEDURES.
     A) EQILBR  EQUILIBRATES A MATRIX BY MEANS OF A DIAGONAL  SIMILARITY
     TRANSFORMATION,
     B) BAKLBR  PERFORMS  THE  CORRESPONDING  BACK TRANSFORMATION ON THE
     COLUMNS OF A MATRIX AND SHOULD BE CALLED AFTER EQILBR.
 
 KEYWORDS:
 
     SIMILARITY TRANSFORMATION,
     EQUILIBRATION.
 
 
 SUBSECTION: EQILBR.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" EQILBR(A, N, EM, D, INT); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM, D; "INTEGER" "ARRAY" INT;
     "CODE" 34173;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE MATRIX TO BE EQUILIBRATED;
             EXIT:   THE EQUILIBRATED MATRIX;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY"EM[0:0];
             ENTRY:  EM[0], THE MACHINE PRECISION;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY"D[1:N];
             EXIT:   THE  MAIN  DIAGONAL  OF  THE TRANSFORMING  DIAGONAL
                     MATRIX;
     INT:    <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" INT[1:N];
             EXIT:   INFORMATION DEFINING THE POSSIBLE INTERCHANGING  OF
                     SOME ROWS AND THE CORRESPONDING COLUMNS;
 
 
1SECTION:3.2.1.1.1            (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED:
     TAMMAT          =      CP34014,
     MATTAM          =      CP34015,
     ICHCOL          =      CP34031,
     ICHROW          =      CP34032.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 LANGUAGE:   ALGOL 60.
 
 
 
 METHOD AND PERFORMANCE:
     THE    MATRIX  IS EQUILIBRATED  BY  MEANS  OF OSBORNE'S  DIAGONAL
     SIMILARITY    TRANSFORMATION    POSSIBLY   WITH   INTERCHANGES [2].
     THE TRANSFORMING DIAGONAL MATRIX AND THE  EQUILIBRATED  MATRIX  ARE
     CALCULATED ITERATIVELY:
     IN EACH STEP A CERTAIN COLUMN OF  THE  MATRIX IS MULTIPLIED BY, AND
     THE CORRESPONDING ROW DIVIDED BY, A FACTOR WHICH IS CHOSEN IN  SUCH
     A WAY THAT THE  CONSIDERED  COLUMN AND ROW OBTAIN  ROUGHLY THE SAME
     EUCLIDEAN  NORM (IN  FACT, THE  FACTOR  IS  ROUNDED  TO THE NEAREST
     INTEGRAL  POWER  OF  2, IN  ORDER TO PREVENT ROUNDING  ERRORS); THE
     COLUMNS AND ROWS ARE HANDLED IN CYCLIC ORDER. IF  THE  MATRIX  DOES
     NOT CONTAIN COLUMNS OR ROWS  WHOSE  OFF-DIAGONAL  ELEMENTS ARE 0 OR
     NEARLY 0, THEN THE PROCESS (WITH UNROUNDED FACTORS) CONVERGES,  AND
     IN  PRACTICE  A  FEW  STEPS  ARE  NEEDED  TO  OBTAIN  A  REASONABLY
     EQUILIBRATED MATRIX [2].
     IF ALL OFF-DIAGONAL  ELEMENTS OF SOME CONSIDERED COLUMN (ROW) ARE 0
     OR NEARLY 0, THEN THIS  COLUMN (ROW) IS INTERCHANGED WITH THE FIRST
     NONZERO COLUMN (LAST NONZERO ROW)  OF THE  MATRIX, AND, IN ORDER TO
     HAVE A SIMILARITY TRANSFORMATION, THE CORRESPONDING  ROWS (COLUMNS)
     ARE ALSO INTERCHANGED;  THEN  FOR THE  FURTHER  EQUILIBRATION,  THE
     SUBMATRIX IS CONSIDERED WHICH DOES NOT  CONTAIN  SUCH  ZERO COLUMNS
     AND ROWS AND THE CORRESPONDING ROWS AND COLUMNS. THE  EQUILIBRATION
     PROCESS IS CONTINUED UNTIL, IN A WHOLE CYCLE NO FACTOR > 2 OR < 0.5
     AND NO ZERO COLUMN OR ROW IS FOUND, OR UNTIL  (N + 1) * N ** 2 ROWS
     AND COLUMNS HAVE BEEN CONSIDERED.
 
 
1SECTION:3.2.1.1.1            (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION: BAKLBR.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" BAKLBR(N, N1, N2, D, INT, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" D, VEC; "INTEGER" "ARRAY" INT;
     "CODE" 34174;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE LENGTH OF THE VECTORS TO BE TRANSFORMED;
     N1, N2: <ARITHMETIC EXPRESSION>;
             THE  SERIAL   NUMBERS  OF  THE  FIRST AND LAST VECTOR TO BE
             TRANSFORMED;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY"VEC[1:N,N1:N2];
             ENTRY:  THE   N2 - N1 + 1   VECTORS   OF   LENGTH N  TO  BE
                     TRANSFORMED;
             EXIT:   THE N2 - N1 + 1 VECTORS OF LENGTH N RESULTING  FROM
                     THE BACK TRANSFORMATION;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY"D[1:N];
             ENTRY:  THE MAIN DIAGONAL  OF  THE  TRANSFORMING   DIAGONAL
                     MATRIX OF ORDER N, AS PRODUCED BY EQILBR;
     INT:    <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" INT[1:N];
             ENTRY:  INFORMATION DEFINING THE POSSIBLE INTERCHANGING  OF
                     SOME ROWS AND COLUMNS, AS PRODUCED BY EQILBR.
 
 PROCEDURES USED:
     ICHROW          =      CP34032.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO (N2 - N1 + 1) * N.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     THE  BACK  TRANSFORMATION, WHICH  CORRESPONDS  WITH  THE   DIAGONAL
     SIMILARITY   TRANSFORMATION  AS  PERFORMED  BY  EQILBR,  TRANSFORMS
     A  VECTOR X INTO  A  VECTOR  DX  AND  PERFORMS  THE   CORRESPONDING
     INTERCHANGES. THE MATRIX D IS THE DIAGONAL MATRIX OF  THE  DIAGONAL
     SIMILARITY TRANSFORMATION.
 
 REFERENCES:
     [1]      DEKKER, T. J. AND HOFFMANN, W.
              ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
              MATHEMATICAL CENTRE TRACTS 23,
              MATHEMATISCH CENTRUM, AMSTERDAM, 1968;
     [2]      OSBORNE, E. E, ON PRECONDITIONING OF MATRICES,
              J. ACM 7(1960) 338-354.
 
 EXAMPLES OF USE:
     EXAMPLES OF USE OF EQILBR AND BAKLBR CAN BE FOUND IN THE PROCEDURES
     FOR  CALCULATING  EIGENVALUES  AND  EIGENVECTORS  AS  DESCRIBED  IN
     SECTION 3.3.1.2.2.
1SECTION:3.2.1.1.1            (JUNE 1974)                         PAGE 4
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34173;
     "COMMENT" MCA 2405;
     "PROCEDURE" EQILBR(A, N, EM, D, INT); "VALUE" N; "INTEGER" N;
      "ARRAY" A, EM, D; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, IM, I1, P, Q, J, T, COUNT, EXPONENT, NI;
         "REAL" C, R, EPS, OMEGA, FACTOR;
 
         "PROCEDURE" MOVE(K); "VALUE" K; "INTEGER" K;
         "BEGIN" "REAL" DI;
             NI:= Q - P; T:= T + 1; "IF" K ^= I "THEN"
             "BEGIN" ICHCOL(1, N, K, I, A); ICHROW(1, N, K, I, A);
                 DI:= D[I]; D[I]:= D[K]; D[K]:= DI
             "END"
         "END" MOVE;
 
         FACTOR:= 1 / (2 * LN(2)); "COMMENT" MORE GENERALLY: LN(BASE);
         EPS:= EM[0]; OMEGA:= 1 / EPS; T:= P:= 1; Q:= NI:= I:= N;
         COUNT:= (N + 1) * N // 2;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" D[J]:= 1; INT[J]:= 0 "END";
         "FOR" I:= "IF" I < Q "THEN" I + 1 "ELSE" P
         "WHILE" COUNT > 0 "AND" NI > 0 "DO"
         "BEGIN" COUNT:= COUNT - 1; IM:= I - 1; I1:= I + 1;
             C:= SQRT(TAMMAT(P, IM, I, I, A, A) +
             TAMMAT(I1, Q, I, I, A, A));
             R:= SQRT(MATTAM(P, IM, I, I, A, A) +
             MATTAM(I1, Q, I, I, A, A));
             "IF" C * OMEGA <= R * EPS "THEN"
             "BEGIN" INT[T]:= I; MOVE(P); P:= P + 1 "END"
             "ELSE" "IF" R * OMEGA <= C * EPS "THEN"
             "BEGIN" INT[T]:= -I; MOVE(Q); Q:= Q - 1 "END"
             "ELSE"
             "BEGIN" EXPONENT:= LN(R / C) * FACTOR;
                 "IF" ABS(EXPONENT) > 1 "THEN"
                 "BEGIN" NI:= Q - P; C:= 2 ** EXPONENT; R:= 1 / C;
                     D[I]:= D[I] * C;
                     "FOR" J:= 1 "STEP" 1 "UNTIL" IM,
                     I1 "STEP" 1 "UNTIL" N "DO"
                     "BEGIN" A[J,I]:= A[J,I] * C;
                         A[I,J]:= A[I,J] * R
                     "END"
                 "END" "ELSE" NI:= NI - 1
             "END"
         "END"
     "END" EQILBR
1SECTION:3.2.1.1.1            (JUNE 1974)                         PAGE 5
 
                                                                   ;
         "EOP"
0"CODE" 34174;
     "COMMENT" MCA 2406;
     "PROCEDURE" BAKLBR(N, N1, N2, D, INT, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" D, VEC; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, J, K, P, Q; "REAL" DI;
 
         P:= 1; Q:= N;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" DI:= D[I]; "IF" DI ^= 1 "THEN"
             "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO" VEC[I,J]:=
             VEC[I,J] * DI; K:= INT[I];
             "IF" K > 0 "THEN" P:= P + 1 "ELSE"
             "IF" K < 0 "THEN" Q:= Q - 1
         "END";
         "FOR" I:= P - 1 + N - Q "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" K:= INT[I]; "IF" K > 0 "THEN"
             "BEGIN" P:= P - 1; "IF" K ^= P "THEN"
                 ICHROW(N1, N2, K, P, VEC)
             "END" "ELSE"
             "BEGIN" Q:= Q + 1; "IF" -K ^= Q "THEN"
                 ICHROW(N1, N2, -K, Q, VEC)
             "END"
         "END"
     "END" BAKLBR;
         "EOP"
1SECTION:3.2.1.1.2            (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731008.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES EQILBRCOM AND BAKLBRCOM.
     EQILBRCOM EQUILIBRATES A GIVEN MATRIX.
     BAKLBRCOM TRANSFORMS THE EIGENVECTORS OF THE EQUILIBRATED MATRIX
     INTO THE EIGENVECTORS OF THE ORIGINAL MATRIX.
 
 
 KEYWORDS :
 
     COMPLEX MATRIX,
     EIGENVECTORS,
     EQUILIBRATION.
 
 
 SUBSECTION: EQILBRCOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" EQILBRCOM(A1, A2, N, EM, D, INT); "VALUE" N;
     "INTEGER" N; "ARRAY" A1, A2, EM, D; "INTEGER" "ARRAY" INT;
     "CODE" 34361;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A1,A2::    <ARRAY IDENTIFIER>;
                "ARRAY" A1,A2[1:N,1:N];
                ENTRY:
                THE REAL PART AND IMAGINARY PART OF THE MATRIX TO  BE
                EQUILIBRATED  MUST BE GIVEN IN THE ARRAYS A1 AND A2,
                RESPECTIVELY;
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE EQUILIBRATED
                MATRIX ARE DELIVERED IN THE ARRAYS A1 AND A2,
                RESPECTIVELY;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY"EM[0:7];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[6]: THE MAXIMUM ALLOWED NUMBER OF ITERATIONS;
                EXIT:
                EM[7]: THE NUMBER OF ITERATIONS PERFORMED;
1SECTION:3.2.1.1.2            (JUNE 1974)                         PAGE 2
 
 
 
     D:         <ARRAY IDENTIFIER>:
                "ARRAY" D[1:N];
                EXIT:
                THE SCALING FACTORS OF THE DIAGONAL SIMILARITY
                TRANSFORMATION;
     INT:       <ARRAY IDENTIFIER>;
                "INTEGER""ARRAY" INT[1:N];
                EXIT:
                INFORMATION CONCERNING THE POSSIBLE INTERCHANGING OF
                SOME ROWS AND CORRESPONDING COLUMNS.
 
 
 PROCEDURES USED:
 
     ICHCOL = CP34031,
     ICHROW = CP34332,
     TAMMAT = CP34014,
     MATTAM = CP34015.
 
 
 RUNNING TIME: PROPORTIONAL TO N * NUMBER OF ITERATIONS.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE BAKLBRCOM.
 
 
 SUBSECTION: BAKLBRCOM.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" BAKLBRCOM(N, N1, N2, D, INT, VR, VI);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2; "ARRAY" D, VR, VI;
     "INTEGER" "ARRAY" INT;
     "CODE" 34362;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE MATRIX OF WHICH THE EIGENVECTORS ARE
                CALCULATED;
     N1,N2:     <ARITHMETIC EXPRESSION>;
                THE EIGENVECTORS CORRESPONDING TO THE EIGENVALUES WITH
                INDICES N1,...,N2 ARE TO BE TRANSFORMED;
     D:         <ARRAY IDENTIFIER>:
                "ARRAY" D[1:N];
                ENTRY: THE SCALING FACTORS OF THE DIAGONAL SIMILARITY
                TRANSFORMATION AS DELIVERED BY EQILBRCOM;
     INT:       <ARRAY IDENTIFIER>;
                "INTEGER""ARRAY" INT[1:N];
                ENTRY: INFORMATION DEFINING THE INTERCHANGING OF SOME
                ROWS AND COLUMNS, AS DELIVERED BY EQILBRCOM;
1SECTION:3.2.1.1.2            (DECEMBER 1975)                     PAGE 3
 
 
 
     VR,VI:     <ARRAY IDENTIFIER>;
                "ARRAY" VR,VI[1:N,N1:N2];
                ENTRY:
                THE BACK TRANSFORMATION IS PERFORMED ON THE EIGENVECTORS
                WITH THE REAL PARTS GIVEN IN ARRAY VR AND THE IMAGINARY
                PARTS GIVEN IN ARRAY VI;
                EXIT:
                THE REAL PARTS AND IMAGINARY PARTS OF THE RESULTING
                EIGENVECTORS ARE DELIVERED IN THE COLUMNS OF THE ARRAYS
                VR AND VI, RESPECTIVELY.
 
 
 PROCEDURES USED: BAKLBR = CP34174.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N * (N2-N1).
 
 
 LANGUAGE: ALGOL 60.
 
 
 THE FOLLOWING HOLDS FOR BOTH PROCEDURES:
 
 
 METHOD AND PERFORMANCE:
 
     A MATRIX M IS SAID TO BE EQUILIBRATED, WHEN THE DIAGONAL ELEMENTS
     OF M''M - MM'' ARE ZERO, WHERE '' STANDS FOR CONJUGATING
     AND TRANSPOSING.  IN  EQILBRCOM  THE  MATRIX  M  IS  EQUILIBRATED
     BY MEANS OF OSBORNE'S DIAGONAL SIMILARITY TRANSFORMATION WITH
     POSSIBLE INTERCHANGES (OSBORNE, 1960).
     BAKLBRCOM PERFORMS THE CORRESPONDING BACK TRANSFORMATION.
     LET THE EIGENVECTORS OF THE EQUILIBRATED MATRIX BE GIVEN IN THE
     COLUMNS OF MATRIX V. THE EIGENVECTORS OF THE ORIGINAL MATRIX ARE
     OBTAINED BY MULTIPLYING (OR POSSIBLE INTERCHANGING) THE ROWS OF THE
     MATRIX V WITH THE SCALING FACTORS. AS THE SCALING FACTORS ARE REAL
     QUANTITIES, THE TRANSFORMATION IS PERFORMED BY CALLING THE
     PROCEDURE BAKLBR FOR BOTH VR AND VI (DEKKER AND HOFFMANN, 1968).
 
 
 REFERENCES:
 
     DEKKER, T.J. AND W.HOFFMANN (1968),
     ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
     MATH. CENTRE TRACTS 23, MATHEMATISCH CENTRUM;
 
     OSBORNE, E.E. (1960),
     ON PRECONDITIONING OF MATRICES,
     JACM., 7, P.338-354;
 
     PARLETT, B.N. AND C.REINSCH (1969),
     BALANCING A MATRIX FOR CALCULATION OF EIGENVALUES AND
     EIGENVECTORS,
     NUM. MATH., 13, P.293-304;
1SECTION:3.2.1.1.2            (JUNE 1974)                         PAGE 4
 
 
 
 EXAMPLE OF USE:
 
     BAKLBRCOM IS USED IN THE PROCEDURE EIGCOM (SEE SECTION 3.3.2.2.2.).
     AS A FORMAL TEST OF THE PROCEDURE EQILBRCOM, THE FOLLOWING MATRIX
     WAS USED:
       1     0  1024*I
       0     1    0
     I/1024  0    2
 
     "BEGIN" "INTEGER" I,J; "INTEGER""ARRAY" INT[1:3];
     "REAL" "ARRAY" A1,A2[1:3,1:3],EM[0:7],D[1:3];
     EM[0]:=5"-14;EM[6]:=10;
     INIMAT(1,3,1,3,A1,0);INIMAT(1,3,1,3,A2,0);
     A1[1,1]:=A1[2,2]:=1;A1[3,3]:=2;
     A2[1,3]:=2**10;A2[3,1]:=1/2**10;
     EQILBRCOM(A1,A2,3,EM,D,INT);
     OUTPUT(61,"(""("EQUILIBRATED MATRIX:")",/")");
     OUTPUT(61,"("3(D2B),/,2(D2B),"("I")",/,D2B,"("I")",2BD/")",
              A1[1,1],A1[1,2],A1[1,3],A1[2,1],A1[2,2],A1[3,1],A1[3,3]);
     OUTPUT(61,"("/,"("EM[7]:")",5BD/")",EM[7]);
     OUTPUT(61,"(""("D[1:3]: ")",3(3ZD2B),/")",D[1],D[2],D[3]);
     OUTPUT(61,"(""("INT[1:3]: ")",BD,3B,2BD,B4ZD")",
                  INT[1],INT[2],INT[3])
     "END"
 
     OUTPUT:
     EQUILIBRATED MATRIX:
     1  0  0
     0  1  I
     0  I  2
 
     EM[7]:     4
     D[1:3]:    1  1024     1
     INT[1:3]:  2     0     0
 
 
 SOURCE TEXT(S) :
0"CODE" 34361;
     "PROCEDURE" EQILBRCOM(A1, A2, N, EM, D, INT); "VALUE" N;
     "INTEGER" N; "ARRAY" A1, A2, EM, D; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, P, Q, J, T, COUNT, EXPONENT, NI, IM, I1;
         "REAL" C, R, EPS;
                                                               "COMMENT"
1SECTION:3.2.1.1.2            (JUNE 1974)                         PAGE 5
                                                                  ;
 
 
         "PROCEDURE" MOVE(K); "VALUE" K; "INTEGER" K;
         "BEGIN" "REAL" DI;
             NI:= Q - P; T:= T + 1; "IF" K ^= I "THEN"
             "BEGIN" ICHCOL(1, N, K, I, A1); ICHROW(1, N, K, I, A1);
                 ICHCOL(1, N, K, I, A2); ICHROW(1, N, K, I, A2);
                 DI:= D[I]; D[I]:= D[K]; D[K]:= DI
             "END"
         "END" MOVE;
         EPS:= EM[0] ** 4; T:= P:= 1; Q:= NI:= I:= N;
         COUNT:= EM[6];
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" D[J]:= 1; INT[J]:= 0 "END";
         "FOR" I:= "IF" I < Q "THEN" I + 1 "ELSE" P "WHILE" COUNT > 0
         "AND" NI > 0 "DO"
         "BEGIN" COUNT:= COUNT - 1; IM:= I - 1; I1:= I + 1;
             C:= TAMMAT(P, IM, I, I, A1, A1) + TAMMAT(I1, Q, I,
             I, A1, A1) + TAMMAT(P, IM, I, I, A2, A2) +
             TAMMAT(I1, Q, I, I, A2, A2);
             R:= MATTAM(P, IM, I, I, A1, A1) + MATTAM(I1, Q, I,
             I, A1, A1) + MATTAM(P, IM, I, I, A2, A2) +
             MATTAM(I1, Q, I, I, A2, A2); "IF" C / EPS <= R "THEN"
             "BEGIN" INT[T]:= I; MOVE(P); P:= P + 1 "END"
             "ELSE" "IF" R / EPS <= C "THEN"
             "BEGIN" INT[T]:= - I; MOVE(Q); Q:= Q - 1 "END"
             "ELSE"
             "BEGIN" EXPONENT:= LN(R / C) * 0.36067;
                 "IF" ABS(EXPONENT) > 1 "THEN"
                 "BEGIN" NI:= Q - P; C:= 2 ** EXPONENT;
                     D[I]:= D[I] * C;
                     "FOR" J:= 1 "STEP" 1 "UNTIL" IM, I1 "STEP" 1
                     "UNTIL" N "DO"
                     "BEGIN" A1[J,I]:= A1[J,I] * C;
                         A1[I,J]:= A1[I,J] / C;
                         A2[J,I]:= A2[J,I] * C;
                         A2[I,J]:= A2[I,J] / C
                     "END"
                 "END"
                 "ELSE" NI:= NI - 1
             "END"
         "END";
         EM[7]:= EM[6] - COUNT
     "END" EQILBRCOM;
         "EOP"
0"CODE" 34362;
     "PROCEDURE" BAKLBRCOM(N, N1, N2, D, INT, VR, VI);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2; "ARRAY" D, VR, VI;
     "INTEGER" "ARRAY" INT;
     "BEGIN"
         BAKLBR(N, N1, N2, D, INT, VR);
         BAKLBR(N, N1, N2, D, INT, VI)
     "END" BAKLBRCOM;
         "EOP"
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 1
 
 
 
 AUTHORS:      T.J.DEKKER, W.HOFFMANN.
 
 
 CONTRIBUTORS: W.HOFFMANN, J.G.VERWER.
 
 
 INSTITUTE:    MATHEMATICAL CENTRE.
 
 
 RECEIVED:     730705.
 
 
 BRIEF DESCRIPTION:
     THIS SECTION CONTAINS FIVE PROCEDURES.
     A) TFMSYMTRI2 AND TFMSYMTRI1 TRANSFORM A REAL SYMMETRIC MATRIX INTO
     A SIMILAR TRIDIAGONAL ONE BY MEANS OF HOUSEHOLDER'S TRANSFORMATION,
     B) BAKSYMTRI2   AND   BAKSYMTRI1  PERFORM  THE  CORRESPONDING  BACK
     TRANSFORMATION  AND  FINALLY,
     C) TFMPREVEC (WHICH IS TO BE USED IN COMBINATION  WITH  TFMSYMTRI2)
     CALCULATES THE TRANSFORMING MATRIX.
     TFMSYMTRI2  AND  BAKSYMTRI2  USE  THE  UPPER  TRIANGLE  OF  A  TWO-
     DIMENSIONAL  ARRAY  FOR THE UPPER  TRIANGLE OF THE GIVEN  SYMMETRIC
     MATRIX  (TFMSYMTRI2)  OR  FOR  THE  DATA  FOR   HOUSEHOLDER'S  BACK
     TRANSFORMATION  (BAKSYMTRI2).  THE OTHER  ELEMENTS ARE NEITHER USED
     NOR CHANGED.  TFMSYMTRI1 AND
                   BAKSYMTRI1 USE AN ARRAY A[1:(N+1)*N//2] FOR THE GIVEN
     SYMMETRIC  MATRIX (TFMSYMTRI1)  OR  FOR THE DATA FOR  HOUSEHOLDER'S
     TRANSFORMATION (BAKSYMTRI1).
 
 KEYWORDS:
     HOUSEHOLDER'S TRANSFORMATION,
     TRIANGULARIZATION.
 
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 2
 
 
 
 SUBSECTION: TFMSYMTRI2.
 
 CALLING SEQUENCE:
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" TFMSYMTRI2(A, N, D, B, BB, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, D, B, BB, EM; "CODE" 34140;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE UPPER TRIANGLE OF THE SYMMETRIC MATRIX  MUST BE
                     GIVEN  IN  THE  UPPER  TRIANGULAR  PART  OF  A (THE
                     ELEMENTS A[I,J],I<=J);
             EXIT:   THE DATA FOR HOUSEHOLDER'S  BACK  TRANSFORMATION IS
                     DELIVERED IN THE  UPPER  TRIANGULAR  PART OF A. THE
                     ELEMENTS  A[I,J], I>J ARE NEITHER USED NOR CHANGED;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY"D[1:N];
             EXIT:   THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX   T  (SAY),   PRODUCED   BY  HOUSEHOLDER'S
                     TRANSFORMATION;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             EXIT:   THE CODIAGONAL  ELEMENTS OF T ARE DELIVERED IN B[1]
                     THROUGH B[N-1]; B[N] IS SET EQUAL TO ZERO;
     BB:     <ARRAY IDENTIFIER>;
             "ARRAY"BB[1:N];
             EXIT:   THE  SQUARES  OF THE  CODIAGONAL  ELEMENTS OF T ARE
                     DELIVERED  IN  BB[1] THROUGH BB[N-1];  BB[N] IS SET
                     EQUAL TO ZERO;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY"EM[0:1];
             ENTRY:  EM[0], THE MACHINE PRECISION;
             EXIT:   EM[1], THE  INFINITY  NORM OF THE ORIGINAL  MATRIX.
 
 PROCEDURES USED:
     TAMVEC   =      CP34012,
     MATMAT   =      CP34013,
     TAMMAT   =      CP34014,
     ELMVECCOL=      CP34021,
     ELMCOLVEC=      CP34022,
     ELMCOL   =      CP34023.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 3
 
 
 
 METHOD AND PERFORMANCE:
     A  GIVEN  SYMMETRIC  MATRIX M IS TRANSFORMED INTO A TRIDIAGONAL ONE
     BY  MEANS OF N-1 ORTHOGONAL  SIMILARITY  TRANSFORMATIONS; THE  P-TH
     TRANSFORMATION  IS  CHOSEN  IN  SUCH  A  WAY THAT IN THE (N-P+1)-TH
     COLUMN AND ROW OF M THE DESIRED  ZEROES  ARE  INTRODUCED.  HOWEVER,
     IF, IN THIS COLUMN AND ROW, ALL ELEMENTS OUTSIDE THE MAIN  DIAGONAL
     AND THE  ADJACENT  CODIAGONALS  ARE SMALLER IN ABSOLUTE  VALUE THAN
     THE INFINITY NORM OF M TIMES THE MACHINE  PRECISION, THEN THE  P-TH
     TRANSFORMATION IS SKIPPED.
     FOR FURTHER DETAILS SEE REF[1] AND REF[2].
 
 
 SUBSECTION: BAKSYMTRI2.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" BAKSYMTRI2(A, N, N1, N2, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC; "CODE" 34141;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE DATA FOR THE BACK  TRANSFORMATION,  AS PRODUCED
                     BY  TFMSYMTRI2,   MUST   BE   GIVEN  IN  THE  UPPER
                     TRIANGULAR PART OF A;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     N1,N2:  <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND, RESPECTIVELY, OF THE COLUMN NUMBERS
             OF VEC;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY"VEC[1:N,N1:N2];
             ENTRY:  THE VECTORS ON WHICH THE BACK TRANSFORMATION HAS TO
                     BE PERFORMED;
             EXIT:   THE TRANSFORMED VECTORS.
 
 PROCEDURES USED:
     TAMMAT  =       CP34014,
     ELMCOL  =       CP34023.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED TIMES (N2-N1+1).
 
 
 METHOD AND PERFORMANCE: SEE REF[1].
 
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 4
 
 SUBSECTION: TFMPREVEC.
 
 CALLING SEQUENCE:
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" TFMPREVEC(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "CODE" 34142;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE DATA  FOR THE BACK  TRANSFORMATION, AS PRODUCED
                     BY   TFMSYMTRI2,   MUST   BE  GIVEN  IN  THE  UPPER
                     TRIANGULAR PART OF A;
             EXIT:   THE MATRIX  WHICH  TRANSFORMS  THE ORIGINAL  MATRIX
                     INTO A SIMILAR TRIDIAGONAL ONE.
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE MATRIX;
 
 PROCEDURES USED:
     TAMMAT  =       CP34014,
     ELMCOL  =       CP34023.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 METHOD AND PERFORMANCE: SEE REF[1].
 
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 5
 
 
 
 SUBSECTION: TFMSYMTRI1.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THIS PROCEDURE IS:
     "PROCEDURE" TFMSYMTRI1(A, N, D, B, BB, EM); "VALUE" N;
     "INTEGER" N; "ARRAY" A, D, B, BB, EM; "CODE" 34143;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:(N+1)*N//2];
             ENTRY:  THE  UPPER  TRIANGLE OF THE GIVEN  MATRIX  MUST  BE
                     GIVEN  IN SUCH A WAY THAT THE  (I,J)-TH  ELEMENT OF
                     THE MATRIX IS A[(J-1)*J//2+I], 1<=I<=J<=N;
             EXIT:   THE DATA FOR HOUSEHOLDER'S BACK TRANSFORMATION AS
                     USED BY BAKSYMTRI1;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     D:      <ARRAY IDENTIFIER>;
             "ARRAY"D[1:N];
             EXIT:   THE  MAIN  DIAGONAL  OF THE  SYMMETRIC  TRIDIAGONAL
                     MATRIX   T  (SAY),   PRODUCED   BY  HOUSEHOLDER'S
                     TRANSFORMATION;
     B:      <ARRAY IDENTIFIER>;
             "ARRAY" B[1:N];
             EXIT:   THE CODIAGONAL  ELEMENTS OF T ARE DELIVERED IN B[1]
                     THROUGH B[N-1]; B[N] IS SET EQUAL TO ZERO;
     BB:     <ARRAY IDENTIFIER>;
             "ARRAY"BB[1:N];
             EXIT:   THE  SQUARES  OF THE  CODIAGONAL  ELEMENTS OF T ARE
                     DELIVERED  IN  BB[1] THROUGH BB[N-1];  BB[N] IS SET
                     EQUAL TO ZERO;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY"EM[0:1];
             ENTRY:  EM[0], THE MACHINE PRECISION;
             EXIT:   EM[1], THE  INFINITY  NORM OF THE  ORIGINAL MATRIX.
 
 PROCEDURES USED:
     VECVEC  =       CP34010,
     SEQVEC  =       CP34016,
     ELMVEC  =       CP34020.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 METHOD AND PERFORMANCE: SEE TFMSYMTRI2 (THIS SECTION).
 
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 6
 
 
 
 SUBSECTION: BAKSYMTRI1.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" BAKSYMTRI1(A, N, N1, N2, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC; "CODE" 34144;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:(N+1)*N//2];
             ENTRY:  THE DATA FOR THE BACK  TRANSFORMATION, AS  PRODUCED
                     BY  TFMSYMTRI1;
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     N1,N2:  <ARITHMETIC EXPRESSION>;
             LOWER AND UPPER BOUND, RESPECTIVELY, OF THE COLUMN NUMBERS
             OF VEC;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY"VEC[1:N,N1:N2];
             ENTRY:  THE VECTORS ON WHICH THE BACK TRANSFORMATION HAS TO
                     BE PERFORMED;
             EXIT:   THE TRANSFORMED VECTORS.
 
 PROCEDURES USED:
     VECVEC  =       CP34010,
     ELMVEC  =       CP34020.
 
 REQUIRED CENTRAL MEMORY:
     AN AUXILIARY  ONE-DIMENSIONAL REAL ARRAY OF LENGTH N IS USED.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED TIMES (N2-N1+1).
 
 METHOD AND PERFORMANCE: SEE REF[1].
 
 REFERENCES:
     [1]     DEKKER, T.J. AND HOFFMANN, W.
             ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
             MATHEMATICAL CENTRE TRACTS 23,
             MATHEMATISCH CENTRUM, AMSTERDAM, 1968;
 
     [2]     WILKINSON, J.H.
             THE ALGEBRAIC EIGENVALUE PROBLEM,
             CLARENDON PRESS, OXFORD 1965.
 
 EXAMPLE OF USE:
 
     THE   FIVE   PROCEDURES  OF  THIS   SECTION  ARE  USED  IN
     SECTION 3.3.1.1.2:
             EIGSYM2 USES TFMSYMTRI2 AND BAKSYMTRI2;
             EIGSYM1 USES TFMSYMTRI1 AND BAKSYMTRI1;
             QRISYM  USES TFMSYMTRI2 AND TFMPREVEC.
1SECTION:3.2.1.2.1.1          (JUNE 1974)                         PAGE 7
 
 
 
 SOURCE TEXT(S):
0"CODE" 34140;
     "COMMENT" MCA 2300;
     "PROCEDURE" TFMSYMTRI2(A, N, D, B, BB, EM); "VALUE" N;"INTEGER" N;
      "ARRAY" A, B, BB, D, EM;
     "BEGIN" "INTEGER" I, J, R, R1;
         "REAL" W, X, A1, B0, BB0, D0, MACHTOL, NORM;
 
         NORM:= 0;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" J "DO" W:= ABS(A[I,J]) + W;
             "FOR" I:= J + 1 "STEP" 1 "UNTIL" N "DO" W:= ABS(A[J,I]) +
             W; "IF" W > NORM "THEN" NORM:= W
         "END";
         MACHTOL:= EM[0] * NORM; EM[1]:= NORM; R:= N;
         "FOR" R1:= N - 1 "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" D[R]:= A[R,R]; X:= TAMMAT(1, R - 2, R, R, A, A);
             A1:= A[R1,R]; "IF" SQRT(X) <= MACHTOL "THEN"
             "BEGIN" B0:= B[R1]:= A1; BB[R1]:= B0 * B0;A[R,R]:= 1 "END"
             "ELSE"
             "BEGIN" BB0:= BB[R1]:= A1 * A1 + X;
                 B0:= "IF" A1 > 0 "THEN" -SQRT(BB0) "ELSE" SQRT(BB0);
                 A1:= A[R1,R]:= A1 - B0; W:= A[R,R]:= 1 / (A1 * B0);
                 "FOR" J:= 1 "STEP" 1 "UNTIL" R1 "DO" B[J]:= (TAMMAT(1,
                 J, J, R, A, A) + MATMAT(J + 1, R1, J, R, A, A)) * W;
                 ELMVECCOL(1, R1, R, B, A, TAMVEC(1, R1, R, A, B) *
                 W * .5); "FOR" J:= 1 "STEP" 1 "UNTIL" R1 "DO"
                 "BEGIN" ELMCOL(1, J, J, R, A, A, B[J]);
                     ELMCOLVEC(1, J, J, A, B, A[J,R])
                 "END"; B[R1]:= B0
             "END"; R:= R1
         "END";
         D[1]:= A[1,1]; A[1,1]:= 1; B[N]:= BB[N]:= 0
     "END" TFMSYMTRI2
 
1SECTION:3.2.1.2.1.1          (JUNE 1974)                         PAGE 8
 
                                                                   ;
         "EOP"
0"CODE" 34141;
     "COMMENT" MCA 2301;
     "PROCEDURE" BAKSYMTRI2(A, N, N1, N2, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC;
     "BEGIN" "INTEGER" I, J, K; "REAL" W;
 
         "FOR" J:= 2 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:= A[J,J]; "IF" W < 0 "THEN"
             "FOR" K:= N1 "STEP" 1 "UNTIL" N2 "DO"
             ELMCOL(1, J - 1, K, J, VEC, A,
             TAMMAT(1, J - 1, J, K, A, VEC) * W)
         "END"
     "END" BAKSYMTRI2;
         "EOP"
 
0"CODE" 34142;
     "COMMENT" MCA 2302;
     "PROCEDURE" TFMPREVEC(A, N); "VALUE" N; "INTEGER" N; "ARRAY" A;
     "BEGIN" "INTEGER" I, J, J1, K; "REAL" AB;
 
         J1:= 1;
         "FOR" J:= 2 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" J1 - 1 ,
             J "STEP" 1 "UNTIL" N "DO" A[I,J1]:= 0;
             A[J1,J1]:= 1; AB:= A[J,J];
             "IF" AB < 0 "THEN"
             "FOR" K:= 1 "STEP" 1 "UNTIL" J1 "DO"
             ELMCOL(1, J1, K, J, A, A,
             TAMMAT(1, J1, J, K, A, A) * AB); J1:= J
         "END";
         "FOR" I:= N - 1 "STEP" -1 "UNTIL" 1 "DO"
         A[I,N]:= 0; A[N,N]:= 1
     "END" TFMPREVEC
 
1SECTION:3.2.1.2.1.1          (DECEMBER 1979)                     PAGE 9
 
                                                                   ;
         "EOP"
0"CODE" 34143;
     "COMMENT" MCA 2305;
     "PROCEDURE" TFMSYMTRI1(A, N, D, B, BB, EM); "VALUE" N;"INTEGER" N;
      "ARRAY" A, B, BB, D, EM;
     "BEGIN" "INTEGER" I, J, R, R1, P, Q, TI, TJ;
         "REAL" S, W, X, A1, B0, BB0, D0, NORM, MACHTOL;
 
         NORM:= 0; TJ:= 0;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" J "DO" W:= ABS(A[I + TJ]) +W;
             TJ:= TJ + J; TI:= TJ + J;
             "FOR" I:= J + 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" W:= ABS(A[TI]) + W; TI:= TI + I "END";
             "IF" W > NORM "THEN" NORM:= W
         "END";
         MACHTOL:= EM[0] * NORM; EM[1]:= NORM; Q:= (N + 1) * N // 2;
         R:= N; "FOR" R1:= N - 1 "STEP" -1 "UNTIL" 1 "DO"
         "BEGIN" P:= Q - R; D[R]:= A[Q];
             X:= VECVEC(P + 1, Q - 2, 0, A, A);
             A1:= A[Q - 1]; "IF" SQRT(X) <= MACHTOL "THEN"
             "BEGIN" B0:= B[R1]:= A1; BB[R1]:= B0 * B0; A[Q]:= 1 "END"
             "ELSE"
             "BEGIN" BB0:= BB[R1]:= A1 * A1 + X;
                 B0:= "IF" A1 > 0 "THEN" -SQRT(BB0) "ELSE" SQRT(BB0);
                 A1:= A[Q - 1]:= A1 - B0; W:= A[Q]:= 1 / (A1 * B0);
                 TJ:= 0; "FOR" J:= 1 "STEP" 1 "UNTIL" R1 "DO"
                 "BEGIN" TI:= TJ + J; S:= VECVEC(TJ + 1, TI, P - TJ,
                     A, A); TJ:= TI + J;
                     B[J]:= (SEQVEC(J + 1, R1, TJ, P, A, A) + S) * W;
                     TJ:= TI
                 "END";
                 ELMVEC(1, R1, P, B, A, VECVEC(1,R1,P,B,A)* W *.5);
                 TJ:= 0; "FOR" J:= 1 "STEP" 1 "UNTIL" R1 "DO"
                 "BEGIN" TI:= TJ + J; ELMVEC(TJ + 1, TI, P - TJ, A, A,
                     B[J]);ELMVEC(TJ + 1, TI, -TJ, A, B, A[J + P]);
                     TJ:= TI
                 "END"; B[R1]:= B0
             "END";
             Q:= P; R:= R1
         "END";
         D[1]:= A[1]; A[1]:= 1; B[N]:= BB[N]:= 0
     "END" TFMSYMTRI1
 
1SECTION:3.2.1.2.1.1          (JUNE 1974)                        PAGE 10
 
                                                                  ;
         "EOP"
0"CODE" 34144;
     "COMMENT" MCA 2306;
     "PROCEDURE" BAKSYMTRI1(A, N, N1, N2, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC;
     "BEGIN" "INTEGER" J, J1, K, TI, TJ;
         "REAL" W; "ARRAY" AUXVEC[1:N];
 
         "FOR" K:= N1 "STEP" 1 "UNTIL" N2 "DO"
         "BEGIN" "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO"
             AUXVEC[J]:= VEC[J,K]; TJ:= J1:= 1;
             "FOR" J:= 2 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" TI:= TJ + J; W:= A[TI];
                 "IF" W < 0 "THEN" ELMVEC(1, J1, TJ, AUXVEC,A,VECVEC(1,
                 J1, TJ, AUXVEC, A) * W); J1:= J; TJ:= TI
             "END";
             "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" VEC[J,K]:= AUXVEC[J]
         "END"
     "END" BAKSYMTRI1;
         "EOP"
1SECTION:3.2.1.2.1.2          (JUNE 1974)                         PAGE 1
 
 
 
 AUTHORS:      T.J.DEKKER AND W.HOFFMANN.
 
 
 CONTRIBUTORS: W.HOFFMANN, J.G.VERWER.
 
 
 INSTITUTE:    MATHEMATICAL CENTRE.
 
 
 RECEIVED:     731112.
 
 
 BRIEF DESCRIPTION:
 
     THIS SECTION  CONTAINS THREE PROCEDURES.
     A) TFMREAHES TRANSFORMS A MATRIX INTO A SIMILAR  UPPER-HESSENBERG
     MATRIX BY MEANS OF WILKINSON'S TRANSFORMATION,
     B) BAKREAHES1  PERFORMS  THE  CORRESPONDING  BACK TRANSFORMATION ON
     A VECTOR AND SHOULD BE CALLED AFTER TFMREAHES,
     C) BAKREAHES2  PERFORMS  THE  CORRESPONDING  BACK TRANSFORMATION ON
     THE COLUMNS OF A MATRIX AND SHOULD BE CALLED AFTER TFMREAHES.
 
 KEYWORDS:
 
     SIMILARITY TRANSFORMATION,
     UPPER-HESSENBERG MATRIX.
 
 
1SECTION:3.2.1.2.1.2          (DECEMBER 1975)                     PAGE 2
 
 
 
 SUBSECTION: TFMREAHES.
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" TFMREAHES(A, N, EM, INT); "VALUE" N;
     "INTEGER" N; "ARRAY" A, EM; "INTEGER" "ARRAY" INT;
     "CODE" 34170;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE ORDER OF THE GIVEN MATRIX;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE MATRIX TO BE TRANSFORMED;
             EXIT:   THE UPPER-HESSENBERG MATRIX IS  DELIVERED IN  THE
                     UPPER TRIANGLE AND THE FIRST  SUBDIAGONAL OF A, THE
                     (NONTRIVIAL ELEMENTS OF THE) TRANSFORMING   MATRIX,
                     L, IN  THE  REMAINING  PART OF A, I.E. A[I,J] =
                     L[I,J + 1], FOR I = 3,...,N AND J = 1,...,I - 2;
     EM:     <ARRAY IDENTIFIER>;
             "ARRAY"EM[0:1];
             ENTRY:  EM[0], THE MACHINE PRECISION;
             EXIT:   EM[1], THE INFINITY NORM OF THE ORIGINAL MATRIX;
     INT:    <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" INT[1:N];
             EXIT:   THE PIVOTAL INDICES DEFINING  THE  STABILIZING  ROW
                     AND COLUMN INTERCHANGES;
 
 PROCEDURES USED:
     MATVEC          =      CP34011,
     MATMAT          =      CP34013,
     ICHCOL          =      CP34031,
     ICHROW          =      CP34032.
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             A  ONE-DIMENSIONAL REAL ARRAY OF LENGTH N IS DECLARED.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     WILKINSON'S   TRANSFORMATION   IS   A TRIANGULAR       SIMILARITY
     TRANSFORMATION   WITH   STABILIZING  ROW  AND  COLUMN  INTERCHANGES
     TRANSFORMING  A  MATRIX, M, INTO  AN UPPER-HESSENBERG  MATRIX, H.
     THE TRANSFORMING MATRIX IS THE PRODUCT OF A PERMUTATION  MATRIX, P,
     AND A UNIT LOWER-TRIANGULAR MATRIX, L. THE NONDIAGONAL ELEMENTS  IN
     THE FIRST COLUMN OF L ARE 0, AND THE  ROW  AND  COLUMN INTERCHANGES
     ARE CHOSEN IN SUCH A WAY THAT THE  ABSOLUTE  VALUE OF EACH  ELEMENT
     OF L IS AT MOST 1.
     BECAUSE  OF  THE SPECIAL  FORM  OF L, THE  MATRICES H AND L CAN  BE
     STORED TOGETHER  IN  THE  ARRAY  USED FOR THE MATRIX M (SEE CALLING
     SEQUENCE). FOR FURTHER DETAILS SEE REFERENCE [1] AND [2].
1SECTION:3.2.1.2.1.2          (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION: BAKREAHES1.
 
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" BAKREAHES1(A, N, INT, V); "VALUE" N;
     "INTEGER" N; "ARRAY" A, V; "INTEGER" "ARRAY" INT;
     "CODE" 34171;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE LENGTH OF THE VECTOR TO BE TRANSFORMED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE (NONTRIVIAL  ELEMENTS  OF  THE)    TRANSFORMING
                     MATRIX, L, AS PRODUCED BY TFMREAHES MUST  BE  GIVEN
                     IN THE PART  BELOW  THE  FIRST  SUBDIAGONAL  OF  A,
                     I.E. A[I,J] = L[I,J + 1], FOR I = 3,...,N   AND
                     J = 1,...,I - 2;
     INT:    <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" INT[1:N];
             ENTRY:  PIVOTAL INDICES DEFINING  THE  STABILIZING  ROW AND
                     COLUMN INTERCHANGES AS PRODUCED BY TFMREAHES;
     V:      <ARRAY IDENTIFIER>;
             "ARRAY"V[1:N];
             ENTRY:  THE VECTOR TO BE TRANSFORMED;
             EXIT:   THE TRANSFORMED VECTOR.
 
 
 PROCEDURES USED:
     MATVEC          =      CP34011.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N SQUARED.
 
 
 LANGUAGE:   ALGOL 60.
 
 
 METHOD AND PERFORMANCE:
     THE    BACK  TRANSFORMATION  WHICH  CORRESPONDS  TO   WILKINSON'S
     TRANSFORMATION AS PERFORMED BY TFMREAHES  TRANSFORMS  A  VECTOR, X,
     INTO THE VECTOR PLX, WHERE PL IS THE TRANSFORMING MATRIX.
 
 
1SECTION:3.2.1.2.1.2          (JUNE 1974)                         PAGE 4
 
 
 
 SUBSECTION: BAKREAHES2.
 
 CALLING SEQUENCE:
     THE HEADING OF THE PROCEDURE IS:
     "PROCEDURE" BAKREAHES2(A, N, N1, N2, INT, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC; "INTEGER" "ARRAY" INT;
     "CODE" 34172;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     N:      <ARITHMETIC EXPRESSION>;
             THE LENGTH OF THE VECTORS TO BE TRANSFORMED;
     N1, N2: <ARITHMETIC EXPRESSION>;
             THE  COLUMN  NUMBERS  OF  THE  FIRST  AND LAST VECTOR TO BE
             TRANSFORMED;
     A:      <ARRAY IDENTIFIER>;
             "ARRAY"A[1:N,1:N];
             ENTRY:  THE (NONTRIVIAL  ELEMENTS  OF  THE)    TRANSFORMING
                     MATRIX, L, AS PRODUCED BY TFMREAHES MUST  BE  GIVEN
                     IN THE PART  BELOW  THE  FIRST  SUBDIAGONAL  OF  A,
                     I.E. A[I,J] = L[I,J + 1], FOR I = 3,...,N   AND
                     J = 1,...,I - 2;
     INT:    <ARRAY IDENTIFIER>;
             "INTEGER""ARRAY" INT[1:N];
             ENTRY:  PIVOTAL INDICES DEFINING  THE  STABILIZING  ROW AND
                     COLUMN INTERCHANGES AS PRODUCED BY TFMREAHES;
     VEC:    <ARRAY IDENTIFIER>;
             "ARRAY"VEC[1:N,N1:N2];
             ENTRY:  THE   N2 - N1 + 1   VECTORS   OF  LENGTH  N  TO  BE
                     TRANSFORMED;
             EXIT:   THE N2 - N1 + 1 VECTORS OF LENGTH N RESULTING  FROM
                     THE BACK TRANSFORMATION;
 
 PROCEDURES USED:
     TAMVEC          =      CP34012,
     ICHROW          =      CP34032.
 
 REQUIRED CENTRAL MEMORY:
     EXECUTION FIELD LENGTH:
             IONAL REAL ARRAY OF LENGTH N IS DECLARED.
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO (N2 - N1 + 1) * N * N.
 
 LANGUAGE:   ALGOL 60.
 
 METHOD AND PERFORMANCE:
     SEE SUBSECTION BAKREAHES1.
 
 REFERENCES:
     [1]      DEKKER, T. J. AND HOFFMANN, W,
              ALGOL 60 PROCEDURES IN NUMERICAL ALGEBRA, PART 2,
              MATHEMATICAL CENTRE TRACTS 23,
              MATHEMATISCH CENTRUM, AMSTERDAM, 1968;
 
     [2]      J. H. WILKINSON, THE ALGEBRAIC EIGENVALUE PROBLEM,
              CLARENDON PRESS, OXFORD, 1965.
1SECTION:3.2.1.2.1.2          (JUNE 1974)                         PAGE 5
 
 
 
 EXAMPLES OF USE:
 
     EXAMPLES  OF  USE OF  TFMREAHES, BAKREAHES1  AND  BAKREAHES2 CAN BE
     FOUND  IN  THE  PROCEDURES  FOR   CALCULATING    EIGENVALUES    AND
     EIGENVECTORS AS DESCRIBED IN SECTION 3.3.1.2.2.
 
 SOURCE TEXT(S) :
0"CODE" 34170;
     "COMMENT" MCA 2400;
     "PROCEDURE" TFMREAHES(A, N, EM, INT); "VALUE" N; "INTEGER" N;
      "ARRAY" A, EM; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, J, J1, K, L;
         "REAL" S, T, MACHTOL, MACHEPS, NORM;
          "ARRAY" B[0:N - 1];
 
         MACHEPS:= EM[0]; NORM:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" S:= 0;
             "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" S:= S + ABS(A[I,J]);
             "IF" S > NORM "THEN" NORM:= S
         "END";
         EM[1]:= NORM; MACHTOL:= NORM * MACHEPS; INT[1]:= 0;
         "FOR" J:= 2 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" J1:= J - 1; L:= 0; S:= MACHTOL;
             "FOR" K:= J + 1 "STEP" 1 "UNTIL" N "DO"
             "BEGIN" T:= ABS(A[K,J1]); "IF" T > S "THEN"
                 "BEGIN" L:= K; S:= T "END"
             "END";
             "IF" L ^= 0 "THEN"
             "BEGIN" "IF" ABS(A[J,J1]) < S "THEN"
                 "BEGIN" ICHROW(1, N, J, L, A);
                     ICHCOL(1, N, J, L, A)
                 "END"
                 "ELSE" L:= J; T:= A[J,J1];
                 "FOR" K:= J + 1 "STEP" 1 "UNTIL" N "DO"
                 A[K,J1]:= A[K,J1] / T
             "END"
             "ELSE"
             "FOR" K:= J + 1 "STEP" 1 "UNTIL" N "DO" A[K,J1]:= 0;
             "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
             B[I - 1]:= A[I,J]:= A[I,J] +
             ("IF" L = 0 "THEN" 0 "ELSE" MATMAT(J + 1, N, I, J1, A, A))-
             MATVEC(1, "IF" J1 < I - 2 "THEN" J1 "ELSE" I - 2, I, A, B);
             INT[J]:= L
         "END"
     "END" TFMREAHES
1SECTION:3.2.1.2.1.2          (JUNE 1974)                         PAGE 6
 
 
                                                                   ;
         "EOP"
0"CODE" 34171;
     "COMMENT" MCA 2401;
     "PROCEDURE" BAKREAHES1(A, N, INT, V); "VALUE" N; "INTEGER" N;
      "ARRAY" A, V; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, L;
         "REAL" W; "ARRAY" X[1:N];
 
         "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO" X[I - 1]:= V[I];
         "FOR" I:= N "STEP" -1 "UNTIL" 2 "DO"
         "BEGIN" V[I]:= V[I] + MATVEC(1, I - 2, I, A, X);
             L:= INT[I]; "IF" L > I "THEN"
             "BEGIN" W:= V[I]; V[I]:= V[L]; V[L]:= W "END"
         "END"
     "END" BAKREAHES1;
         "EOP"
 
0"CODE" 34172;
     "COMMENT" MCA 2402;
     "PROCEDURE" BAKREAHES2(A, N, N1, N2, INT, VEC); "VALUE" N, N1, N2;
     "INTEGER" N, N1, N2; "ARRAY" A, VEC; "INTEGER" "ARRAY" INT;
     "BEGIN" "INTEGER" I, L, K; "ARRAY" U[1:N];
 
         "FOR" I:= N "STEP" -1 "UNTIL" 2 "DO"
         "BEGIN" "FOR" K:= I - 2 "STEP" -1 "UNTIL" 1 "DO"
             U[K + 1]:= A[I,K];
             "FOR" K:= N1 "STEP" 1 "UNTIL" N2 "DO"
             VEC[I,K]:= VEC[I,K] + TAMVEC(2 , I - 1, K, VEC, U);
             L:= INT[I]; "IF" L > I "THEN" ICHROW(N1, N2, I, L, VEC)
         "END"
     "END" BAKREAHES2;
         "EOP"
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED : 730903.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THREE PROCEDURES;
     A) HSHHRMTRI TRANSFORMS THE HERMITIAN MATRIX M INTO A SIMILAR
         REAL SYMMETRIC TRIDIAGONAL MATRIX S;
     B) BAKHRMTRI PERFORMS A BACK TRANSFORMATION CORRESPONDING TO
     HSHHRMTRI;
     C) HSHHRMTRIVAL DELIVERS THE MAIN DIAGONAL ELEMENTS AND THE
     SQUARES OF THE CODIAGONAL ELEMENTS OF A HERMITIAN TRIDIAGONAL
     MATRIX WHICH IS UNITARY SIMILAR WITH A GIVEN HERMITIAN MATRIX.
 
 
 KEYWORDS :
 
     HERMITIAN MATRIX ,
     TRIDIAGONALIZATION ,
     COMPLEX HOUSEHOLDER,S TRANSFORMATION .
 
 
 SUBSECTION : HSHHRMTRI.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" HSHHRMTRI(A, N, D, B, BB, EM, TR, TI); "VALUE" N;
     "INTEGER" N; "ARRAY" A, D, B, BB, EM, TR, TI;
     "CODE" 34363;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A,TR,TI:   <ARRAY IDENTIFIER>;
                "ARRAY"A[1:N,1:N];
                "ARRAY" TR,TI[1:N-1];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                EXIT: DATA FOR THE BACKTRANSFORMATION;
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 2
 
 
 
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE MATRIX;
     D:         <ARRAY IDENTIFIER>;
                "ARRAY"D[1:N];
                EXIT : THE  MAIN  DIAGONAL  OF THE  RESULTING  SYMMETRIC
                       TRIDIAGONAL MATRIX;
     B:         <ARRAY IDENTIFIER>;
                "ARRAY"B[1:N-1];
                EXIT: THE CODIAGONAL ELEMENTS OF THE RESULTING SYMMETRIC
                      TRIDIAGONAL MATRIX;
     BB:        <ARRAY IDENTIFIER>;
                "ARRAY"BB[1:N-1];
                EXIT : THE  SQUARES  OF  THE  MODULI  OF  THE CODIAGONAL
                       ELEMENTS  OF THE RESULTING  SYMMETRIC TRIDIAGONAL
                       MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY"EM[0:1];
                ENTRY: EM[0], THE MACHINE PRECISION;
                EXIT:  EM[1], AN ESTIMATE FOR A NORM OF THE ORIGINAL
                              MATRIX.
 
 
 PROCEDURES USED :
 
     MATVEC    = CP34011 ,
     TAMVEC    = CP34012 ,
     MATMAT    = CP34013 ,
     TAMMAT    = CP34014 ,
     MATTAM    = CP34015 ,
     ELMVECCOL = CP34021 ,
     ELMCOLVEC = CP34022 ,
     ELMCOL    = CP34023 ,
     ELMROW    = CP34024 ,
     ELMVECROW = CP34026 ,
     ELMROWVEC = CP34027 ,
     ELMROWCOL = CP34028 ,
     ELMCOLROW = CP34029 ,
     CARPOL    = CP34344 .
 
 
 RUNNING TIME : PROPORTIONAL TO N CUBED .
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE HSHHRMTRIVAL (THIS SECTION).
 
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION : BAKHRMTRI.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" BAKHRMTRI(A, N, N1, N2, VECR, VECI, TR, TI);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
     "ARRAY" A, VECR, VECI, TR, TI;
     "CODE" 34365;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A,TR,TI:   <ARRAY IDENTIFIER>;
                "ARRAY"A[1:N,1:N];
                "ARRAY" TR,TI[1:N-1];
                ENTRY: THE DATA FOR THE BACKTRANSFORMATION AS PRODUCED
                       BY HSHHRMTRI;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE MATRIX OF WHICH THE EIGENVECTORS ARE
                CALCULATED;
     N1,N2:     <ARITHMETIC EXPRESSION>;
                THE EIGENVECTORS CORRESPONDING TO THE  EIGENVALUES  WITH
                INDICES N1,...,N2 ARE TO BE TRANSFORMED;
     VECR,VECI: <ARRAY IDENTIFIER>;
                "ARRAY" VECR,VECI[1:N,N1:N2];
                ENTRY:
                THE BACK TRANSFORMATION IS PERFORMED ON THE REAL
                EIGENVECTORS GIVEN IN THE COLUMNS OF ARRAY VECR;
                EXIT:
                VECR : REAL PART OF THE TRANSFORMED EIGENVECTORS;
                VECI : IMAGINARY PART OF THE TRANSFORMED EIGENVECTORS.
 
 
 PROCEDURES USED :
 
     MATMAT    = CP34013 ,
     TAMMAT    = CP34014 ,
     ELMCOL    = CP34023 ,
     ELMCOLROW = CP34029 ,
     COMMUL    = CP34341 ,
     COMROWCST = CP34353 .
 
 RUNNING TIME: PROPORTIONAL TO  (N2-N1+1)*N**2 .
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE HSHHRMTRIVAL (THIS SECTION).
 
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 4
 
 
 
 SUBSECTION : HSHHRMTRIVAL.
 
 
 CALLING SEQUENCE :
 
     THE HEADING OF THE PROCEDURE READS :
     "PROCEDURE" HSHHRMTRIVAL(A, N, D, BB, EM); "VALUE" N; "INTEGER" N;
      "ARRAY" A, D, BB, EM;
     "CODE" 34364;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:         <ARRAY IDENTIFIER>;
                "ARRAY"A[1:N,1:N];
                ENTRY: THE  REAL  PART  OF  THE  UPPER  TRIANGLE OF  THE
                       HERMITIAN   MATRIX  MUST  BE  GIVEN IN THE  UPPER
                       TRIANGULAR PART OF A (THE ELEMENTS A[I,J], I<=J);
                       THE  IMAGINARY  PART OF THE STRICT LOWER TRIANGLE
                       OF  THE   HERMITIAN  MATRIX  MUST BE GIVEN IN THE
                       STRICT LOWER PART OF A (THE ELEMENTS A[I,J],I>J);
                       THE ELEMENTS OF A ARE ALTERED;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     D:         <ARRAY IDENTIFIER>;
                "ARRAY"D[1:N];
                EXIT: THE  MAIN  DIAGONAL  OF THE  RESULTING HERMITIAN
                      TRIDIAGONAL MATRIX;
     BB:        <ARRAY IDENTIFIER>;
                "ARRAY"BB[1:N-1];
                EXIT: THE   SQUARES   OF  THE  MODULI OF THE  CODIAGONAL
                      ELEMENTS OF THE RESULTING HERMITIAN  TRIDIAGONAL
                      MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY"EM[0:1];
                ENTRY: EM[0],THE MACHINE PRECISION;
                EXIT:  EM[1], AN ESTIMATE FOR A NORM OF THE ORIGINAL
                              MATRIX;
 
 
 PROCEDURES USED :
 
     MATVEC    = CP34011 ,
     TAMVEC    = CP34012 ,
     MATMAT    = CP34013 ,
     TAMMAT    = CP34014 ,
     MATTAM    = CP34015 ,
     ELMVECCOL = CP34021 ,
     ELMCOLVEC = CP34022 ,
     ELMCOL    = CP34023 ,
     ELMROW    = CP34024 ,
     ELMVECROW = CP34026 ,
     ELMROWVEC = CP34027 ,
     ELMROWCOL = CP34028 ,
     ELMCOLROW = CP34029 .
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 5
 
 
 
 
 RUNNING TIME : PROPORTIONAL TO N CUBED .
 
 
 LANGUAGE : ALGOL 60.
 
 
 THE FOLLOWING HOLDS FOR THE THREE PROCEDURES :
 
 
 METHOD AND PERFORMANCE :
 
     HSHHRMTRIVAL TRANSFORMS A HERMITIAN MATRIX INTO A SIMILAR
     HERMITIAN TRIDIAGONAL MATRIX BY MEANS OF HOUSEHOLDER'S
     TRANSFORMATION.
     HSHHRMTRI TRANSFORMS A HERMITIAN MATRIX INTO A SIMILAR
     REAL  TRIDIAGONAL MATRIX BY MEANS OF HOUSEHOLDER'S
     TRANSFORMATION FOLLOWED BY A COMPLEX DIAGONAL UNITARY
     SIMILARITY TRANSFORMATION IN ORDER TO MAKE THE RESULTING
     TRIDIAGONAL MATRIX REAL SYMMETRIC;
     HOUSEHOLDER'S TRANSFORMATION FOR COMPLEX HERMITIAN MATRICES
     IS A UNITARY SIMILARITY TRANSFORMATION,TRANSFORMING A HERMITIAN
     MATRIX INTO A SIMILAR COMPLEX TRIDIAGONAL ONE (SEE WILKINSON,
     1965, P. 342-343). LET M BE A GIVEN HERMITIAN MATRIX OF ORDER
     N, WITH REAL PART MR AND IMAGINARY PART MI, P THE
     TRANSFORMING MATRIX AND T THE RESULTING HERMITIAN TRIDIAGONAL
     MATRIX. SINCE P IS UNITARY, WE HAVE T = P"MP, WHERE
     " STANDS  FOR CONJUGATING AND TRANSPOSING. THE MATRIX  P IS THE
     PRODUCT OF N-2 HOUSEHOLDER MATRICES, THESE BEING UNITARY
     HERMITIAN MATRICES OF THE FORM I-U"U/T, WHERE T IS A SCALAR
     (>0), AND U A COMPLEX VECTOR. THE K-TH HOUSEHOLDER MATRIX,
     K=1,...,N-2, IS CHOSEN IN SUCH A WAY THAT THE LAST K ELEMENTS OF U
     VANISH, AND THE DESIRED ZEROS ARE INTRODUCED IN THE (N-K+1)-TH
     COLUMN AND ROW OF THE MATRIX M. HOWEVER, IF THE EUCLIDIAN NORM
     OF THE FIRST N-K-1 ELEMENTS OF COLUMN N-K+1 OF THE MATRIX M IS
     SMALLER THAN THE MACHINE PRECISION TIMES THE INFINITY NORM OF THE
     MATRIX ( NORM(MR) + NORM(MI) ), THEN THE K-TH TRANSFORMATION
     IS SKIPPED (I.E. THE K-TH HOUSEHOLDER MATRIX IS REPLACED BY I).
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 6
 
 
 
     THE COMPLEX DIAGONAL SIMILARITY TRANSFORMATION D TRANSFORMS THE
     HERMITIAN TRIDIAGONAL MATRIX T INTO A REAL SYMMETRIC TRIDIAGONAL
     MATRIX S (MUELLER, 1966). THE DIAGONAL OF D IS CHOSEN IN SUCH
     A WAY THAT THE CODIAGONAL ELEMENTS OF T ARE TRANSFORMED INTO
     THEIR ABSOLUTE VALUES.
     BAKHRMTRI PERFORMS THE BACK TRANSFORMATION TO REPLACE THE
     EIGENVECTORS OF THE TRIDIAGONAL SYMMETRIC MATRIX S BY THE
     EIGENVECTORS OF THE ORIGINAL HERMITIAN MATRIX M. IF X IS AN
     EIGENVECTOR OF S THEN PDX IS THE CORRESPONDING EIGENVECTOR OF
     M. STARTING FROM THE VECTOR V=DX, THE VECTOR PDX IS
     OBTAINED BY SUCCESSIVELY REPLACING V BY THE K-TH HOUSEHOLDER
     MATRIX TIMES V, FOR K=N-2,...,1. THE RESULTING VECTOR V THEN EQUALS
     PDX.
 
 
 REFERENCES :
 
     MUELLER, D.J. (1966),
     HOUSEHOLDER,S METHOD  FOR  COMPLEX MATRICES AND EIGENSYSTEMS   OF
     HERMITIAN MATRICES,
     NUMER.MATH., 8, P.72-92;
 
     WILKINSON, J.H. (1965),
     THE ALGEBRAIC EIGENVALUE PROBLEM,
     CLARENDON PRESS, OXFORD.
 
 
 EXAMPLE OF USE :
 
     THE  PROCEDURES HSHHRMTRIVAL  AND  BAKHRMTRI  ARE  USED  IN SECTION
     3.3.2.1. :
     EIGVALHRM AND QRIVALHRM USE HSHHRMTRIVAL,
     EIGHRM AND QRIHRM USE BAKHRMTRI .
     AS A FORMAL  TEST OF THE PROCEDURE HSHHRMTRI, THE FOLLOWING  MATRIX
     WAS USED (SEE GREGORY AND KARNEY, CHAPTER 6, EXAMPLE 6.6) :
          3    1    0   +2I
          1    3   -2I   0
          0   +2I   1    1
         -2I   0    1    1
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 7
 
 
 
     "BEGIN"
     "COMMENT" GREGORY AND KARNEY,CHAPTER 6, EXAMPLE 6.6;
     "REAL" "ARRAY" A[1:4,1:4],D,B,BB[1:4],TR,TI[1:3],EM[0:1];
     "INTEGER" I,J;
     "PROCEDURE" OUT(S,A,N);
     "VALUE" N;"INTEGER" N;"ARRAY" A;"STRING" S;
     "BEGIN" "INTEGER" I,J;
         OUTPUT(61,"("10S")",S);
         "FOR" I:=1 "STEP" 1 "UNTIL" N "DO"
         OUTPUT(61,"("+D.3DBB")",A[I]);
         OUTPUT(61,"("/")")
     "END" OUT;
 
     INIMAT(1,4,1,4,A,0);
     A[1,1]:=A[2,2]:=3;
     A[1,2]:=A[3,3]:=A[3,4]:=A[4,4]:=1;
     A[3,2]:=2;A[4,1]:=-2;
     EM[0]:="-14;
     OUTPUT(61,"(""("INITIAL MATRIX GIVEN IN ARRAY A[1:4,1:4]:")",/")");
     "FOR" I:=1 "STEP" 1 "UNTIL" 4 "DO"
     "BEGIN" "FOR" J:=1 "STEP" 1 "UNTIL" 4 "DO"
         OUTPUT(61,"("-DBBB")",A[I,J]);
         OUTPUT(61,"("/")")
     "END";
     OUTPUT(61,"("/,"("HSHHRMTRI DELIVERS:")",//")");
     HSHHRMTRI(A,4,D,B,BB,EM,TR,TI);
     OUT("("D[1:4]: ")",D,4);
     OUT("("B[1:3]: ")",B,3);
     OUT("("BB[1:3]: ")",BB,3);
     OUT("("EM[1]: ")",EM,1);
     "END"
 
     OUTPUT :
     INITIAL MATRIX GIVEN IN ARRAY A[1:4,1:4]:
      3    1    0    0
      0    3    0    0
      0    2    1    1
     -2    0    0    1
 
     HSHHRMTRI DELIVERS:
 
     D[1:4]:   +3.000  +1.400  +2.600  +1.000
     B[1:3]:   +2.236  +0.800  +2.236
     BB[1:3]:  +5.000  +0.640  +5.000
     EM[1]:    +6.000
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 8
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34363;
     "PROCEDURE" HSHHRMTRI(A, N, D, B, BB, EM, TR, TI); "VALUE" N;
     "INTEGER" N; "ARRAY" A, D, B, BB, EM, TR, TI;
     "BEGIN" "INTEGER" I, J, J1, JM1, R, RM1;
         "REAL" NRM, W, TOL2, X, AR, AI, MOD, C, S, H, K, T, Q,
         AJR, ARJ, BJ, BBJ;
         NRM:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:= ABS(A[I,I]);
             "FOR" J:= I - 1 "STEP" - 1 "UNTIL" 1, I + 1 "STEP" 1
             "UNTIL" N "DO" W:= W + ABS(A[I,J]) + ABS(A[J,I]);
             "IF" W > NRM "THEN" NRM:= W
         "END" I;
         TOL2:= (EM[0] * NRM) ** 2; EM[1]:= NRM; R:= N;
         "FOR" RM1:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" X:= TAMMAT(1, R - 2, R, R, A, A) + MATTAM(1, R -
             2, R, R, A, A); AR:= A[RM1,R]; AI:= - A[R,RM1];
             D[R]:= A[R,R]; CARPOL(AR, AI, MOD, C, S);
             "IF" X < TOL2 "THEN"
             "BEGIN" A[R,R]:= - 1; B[RM1]:= MOD;
                 BB[RM1]:= MOD * MOD
             "END"
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                         PAGE 9
 
 
 
             "ELSE"
             "BEGIN" H:= MOD * MOD + X; K:= SQRT(H);
                 T:= A[R,R]:= H + MOD * K;
                 "IF" AR = 0 "AND" AI = 0 "THEN" A[RM1,R]:= K "ELSE"
                 "BEGIN" A[RM1,R]:= AR + C * K;
                     A[R,RM1]:= - AI - S * K; S:= - S
                 "END";
                 C:= - C; J:= 1; JM1:= 0;
                 "FOR" J1:= 2 "STEP" 1 "UNTIL" R "DO"
                 "BEGIN" B[J]:= (TAMMAT(1, J, J, R, A, A) +
                     MATMAT(J1, RM1, J, R, A, A) + MATTAM(1,
                     JM1, J, R, A, A) - MATMAT(J1, RM1, R, J,
                     A, A)) / T;
                     BB[J]:= (MATMAT(1, JM1, J, R, A, A) -
                     TAMMAT(J1, RM1, J, R, A, A) - MATMAT(1, J,
                     R, J, A, A) - MATTAM(J1, RM1, J, R, A, A))
                     / T; JM1:= J; J:= J1
                 "END" J1;
                 Q:= (TAMVEC(1, RM1, R, A, B) - MATVEC(1, RM1,
                 R, A, BB)) / T / 2;
                 ELMVECCOL(1, RM1, R, B, A, - Q);
                 ELMVECROW(1, RM1, R, BB, A, Q); J:= 1;
                 "FOR" J1:= 2 "STEP" 1 "UNTIL" R "DO"
                 "BEGIN" AJR:= A[J,R]; ARJ:= A[R,J]; BJ:= B[J];
                     BBJ:= BB[J];
                     ELMROWVEC(J, RM1, J, A, B, - AJR);
                     ELMROWVEC(J, RM1, J, A, BB, ARJ);
                     ELMROWCOL(J, RM1, J, R, A, A, - BJ);
                     ELMROW(J, RM1, J, R, A, A, BBJ);
                     ELMCOLVEC(J1, RM1, J, A, B, - ARJ);
                     ELMCOLVEC(J1, RM1, J, A, BB, - AJR);
                     ELMCOL(J1, RM1, J, R, A, A, BBJ);
                     ELMCOLROW(J1, RM1, J, R, A, A, BJ); J:= J1;
                 "END" J1;
                 BB[RM1]:= H; B[RM1]:= K;
             "END";
             TR[RM1]:= C; TI[RM1]:= S; R:= RM1;
         "END" RM1;
         D[1]:= A[1,1];
     "END" HSHHRMTRI
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                        PAGE 10
 
                                                                  ;
         "EOP"
0"CODE" 34365;
     "PROCEDURE" BAKHRMTRI(A, N, N1, N2, VECR, VECI, TR, TI);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
      "ARRAY" A, VECR, VECI, TR, TI;
     "BEGIN" "INTEGER" I, J, R, RM1;
         "REAL" C, S, T, QR, QI;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO" VECI[I,J]:= 0; C:= 1;
         S:= 0;
         "FOR" J:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" COMMUL(C, S, TR[J], TI[J], C, S);
             COMROWCST(N1, N2, J, VECR, VECI, C, S)
         "END" J;
         RM1:= 2;
         "FOR" R:= 3 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" T:= A[R,R]; "IF" T > 0 "THEN"
             "FOR" J:= N1 "STEP" 1 "UNTIL" N2 "DO"
             "BEGIN" QR:= (TAMMAT(1, RM1, R, J, A, VECR) -
                 MATMAT(1, RM1, R, J, A, VECI)) / T;
                 QI:= (TAMMAT(1, RM1, R, J, A, VECI) +
                 MATMAT(1, RM1, R, J, A, VECR)) / T;
                 ELMCOL(1, RM1, J, R, VECR, A, - QR);
                 ELMCOLROW(1, RM1, J, R, VECR, A, - QI);
                 ELMCOLROW(1, RM1, J, R, VECI, A, QR);
                 ELMCOL(1, RM1, J, R, VECI, A, - QI)
             "END";
             RM1:= R;
         "END" R
     "END" BAKHRMTRI
 
1SECTION:3.2.1.2.2.1          (JUNE 1974)                        PAGE 11
 
                                                                  ;
         "EOP"
0"CODE" 34364;
     "PROCEDURE" HSHHRMTRIVAL(A, N, D, BB, EM); "VALUE" N; "INTEGER" N;
      "ARRAY" A, D, BB, EM;
     "BEGIN" "INTEGER" I, J, J1, JM1, R, RM1;
         "REAL" NRM, W, TOL2, X, AR, AI, H, T, Q, AJR, ARJ, DJ,
         BBJ, MOD2;
         NRM:= 0;
         "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" W:= ABS(A[I,I]);
             "FOR" J:= I - 1 "STEP" - 1 "UNTIL" 1, I + 1 "STEP" 1
             "UNTIL" N "DO" W:= W + ABS(A[I,J]) + ABS(A[J,I]);
             "IF" W > NRM "THEN" NRM:= W
         "END" I;
         TOL2:= (EM[0] * NRM) ** 2; EM[1]:= NRM; R:= N;
         "FOR" RM1:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" X:= TAMMAT(1, R - 2, R, R, A, A) + MATTAM(1, R -
             2, R, R, A, A); AR:= A[RM1,R]; AI:= - A[R,RM1];
             D[R]:= A[R,R];
             "IF" X < TOL2 "THEN" BB[RM1]:= AR * AR + AI * AI "ELSE"
             "BEGIN" MOD2:= AR * AR + AI * AI; "IF" MOD2 = 0 "THEN"
                 "BEGIN" A[RM1,R]:= SQRT(X); T:= X "END"
                 "ELSE"
                 "BEGIN" X:= X + MOD2; H:= SQRT(MOD2 * X);
                     T:= X + H; H:= 1 + X / H;
                     A[R,RM1]:= - AI * H; A[RM1,R]:= AR * H;
                 "END";
                                                               "COMMENT"
1SECTION:3.2.1.2.2.1          (JUNE 1974)                        PAGE 12
                                                                 ;
 
 
                 J:= 1; JM1:= 0;
                 "FOR" J1:= 2 "STEP" 1 "UNTIL" R "DO"
                 "BEGIN" D[J]:= (TAMMAT(1, J, J, R, A, A) +
                     MATMAT(J1, RM1, J, R, A, A) + MATTAM(1,
                     JM1, J, R, A, A) - MATMAT(J1, RM1, R, J,
                     A, A)) / T;
                     BB[J]:= (MATMAT(1, JM1, J, R, A, A) -
                     TAMMAT(J1, RM1, J, R, A, A) - MATMAT(1, J,
                     R, J, A, A) - MATTAM(J1, RM1, J, R, A, A))
                     / T; JM1:= J; J:= J1
                 "END" J1;
                 Q:= (TAMVEC(1, RM1, R, A, D) - MATVEC(1, RM1,
                 R, A, BB)) / T / 2;
                 ELMVECCOL(1, RM1, R, D, A, - Q);
                 ELMVECROW(1, RM1, R, BB, A, Q); J:= 1;
                 "FOR" J1:= 2 "STEP" 1 "UNTIL" R "DO"
 
                 "BEGIN" AJR:= A[J,R]; ARJ:= A[R,J]; DJ:= D[J];
                     BBJ:= BB[J];
                     ELMROWVEC(J, RM1, J, A, D, - AJR);
                     ELMROWVEC(J, RM1, J, A, BB, ARJ);
                     ELMROWCOL(J, RM1, J, R, A, A, - DJ);
                     ELMROW(J, RM1, J, R, A, A, BBJ);
                     ELMCOLVEC(J1, RM1, J, A, D, - ARJ);
                     ELMCOLVEC(J1, RM1, J, A, BB, - AJR);
                     ELMCOL(J1, RM1, J, R, A, A, BBJ);
                     ELMCOLROW(J1, RM1, J, R, A, A, DJ); J:= J1;
                 "END" J1;
                 BB[RM1]:= X;
             "END";
             R:= RM1;
         "END" RM1;
         D[1]:= A[1,1];
     "END" HSHHRMTRIVAL;
         "EOP"
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 1
 
 
 
 AUTHOR   : C.G. VAN DER LAAN.
 
 
 CONTRIBUTORS : H.FIOLET, C.G. VAN DER LAAN.
 
 
 INSTITUTE : MATHEMATICAL CENTRE.
 
 
 RECEIVED: 731016.
 
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THE PROCEDURES HSHCOMHES AND BAKCOMHES.
     HSHCOMHES TRANSFORMS A COMPLEX MATRIX BY MEANS OF HOUSEHOLDER'S
     TRANSFORMATION FOLLOWED BY A COMPLEX DIAGONAL TRANSFORMATION INTO
     A SIMILAR UNITARY UPPER-HESSENBERG MATRIX WITH A REAL NONNEGATIVE
     SUBDIAGONAL.
     BAKCOMHES PERFORMS THE CORRESPONDING BACK TRANSFORMATION.
 
 
 KEYWORDS:
 
     COMPLEX EIGENPROBLEM,
     REDUCTION HESSENBERG FORM,
     HOUSEHOLDER'S TRANSFORMATION.
 
 
 SUBSECTION: HSHCOMHES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL); "VALUE" N;
     "INTEGER" N; "ARRAY" AR, AI, EM, B, TR, TI, DEL;
     "CODE" 34366;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI:     <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[1:N,1:N];
                ENTRY:
                THE REAL PART AND THE IMAGINARY PART OF THE MATRIX TO BE
                TRANSFORMED  MUST BE GIVEN IN THE ARRAYS AR AND AI,
                RESPECTIVELY;
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE UPPER
                TRIANGLE OF THE RESULTING UPPER-HESSENBERG MATRIX ARE
                DELIVERED IN THE CORRESPONDING PARTS OF THE ARRAYS AR
                AND AI, RESPECTIVELY; DATA FOR THE HOUSEHOLDER BACK-
                TRANSFORMATION ARE DELIVERED IN THE STRICT LOWER
                TRIANGLES OF THE ARRAYS AR AND AI;
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 2
 
 
 
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE GIVEN MATRIX;
     EM:        <ARRAY IDENTIFIER>;
                "ARRAY"EM[0:1];
                ENTRY:
                EM[0]: THE MACHINE PRECISION;
                EM[1]: AN ESTIMATE OF THE NORM OF THE COMPLEX MATRIX;
                  (OR, E.G. THE SUM OF THE INFINITY NORMS OF THE REAL
                  (PART AND IMAGINARY PART OF THE MATRIX);
     B:         <ARRAY IDENTIFIER>;
                "ARRAY"B[1:N-1];
                EXIT:
                THE REAL NONNEGATIVE SUBDIAGONAL OF THE RESULTING
                UPPER-HESSENBERG MATRIX;
     TR,TI:     <ARRAY IDENTIFIER>;
                "ARRAY" TR,TI[1:N];
                EXIT:
                THE REAL PART AND THE IMAGINARY PART OF THE DIAGONAL
                ELEMENTS OF A DIAGONAL SIMILARITY TRANSFORMATION ARE
                DELIVERED IN THE ARRAYS TR AND TI, RESPECTIVELY; BY THIS
                INFORMATION THE COMPLEX UPPER-HESSENBERG MATRIX IS
                TRANSFORMED INTO A UPPER-HESSENBERG MATRIX WITH A REAL
                SUBDIAGONAL;
     DEL:       <ARRAY IDENTIFIER>;
                "ARRAY"DEL[1:N-2];
                EXIT:
                INFORMATION CONCERNING THE SEQUENCE OF HOUSEHOLDER
                MATRICES.
 
 
 PROCEDURES USED:
 
     HSHCOMCOL = CP34355,
     MATMAT    = CP34013,
     ELMROWCOL = CP34028,
     HSHCOMPRD = CP34356,
     CARPOL    = CP34344,
     COMMUL    = CP34341,
     COMCOLCST = CP34352,
     COMROWCST = CP34353.
 
 
 RUNNING TIME: ROUGHLY PROPORTIONAL TO N CUBED.
 
 
 LANGUAGE: ALGOL 60.
 
 
 METHOD AND PERFORMANCE: SEE BAKCOMHES (THIS SECTION).
 
 
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 3
 
 
 
 SUBSECTION: BAKCOMHES.
 
 
 CALLING SEQUENCE:
 
     THE HEADING OF THE PROCEDURE READS:
     "PROCEDURE" BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, N1, N2);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
      "ARRAY" AR, AI, TR, TI, DEL, VR, VI;
     "CODE" 34367;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     AR,AI,TR,TI,DEL:
                <ARRAY IDENTIFIER>;
                "ARRAY" AR,AI[1:N,1:N];
                "ARRAY" TR,TI[1:N];
                "ARRAY"DEL[1:N-2];
                ENTRY: THE DATA FOR THE BACKTRANSFORMATION AS PRODUCED
                       BY HSHCOMHES;
     VR,VI:     <ARRAY IDENTIFIER>;
                "ARRAY" VR,VI[1:N,N1:N2];
                ENTRY:
                THE BACK TRANSFORMATION IS PERFORMED ON THE EIGENVECTORS
                WITH THE REAL PARTS GIVEN IN ARRAY VR AND THE IMAGINARY
                PARTS GIVEN IN ARRAY VI;
                EXIT:
                THE REAL PARTS AND IMAGINARY PARTS OF THE RESULTING
                EIGENVECTORS ARE DELIVERED IN THE COLUMNS OF THE ARRAYS
                VR AND VI, RESPECTIVELY;
     N:         <ARITHMETIC EXPRESSION>;
                THE ORDER OF THE MATRIX OF WHICH THE EIGENVECTORS ARE
                CALCULATED;
     N1,N2:     <ARITHMETIC EXPRESSION>;
                THE EIGENVECTORS CORRESPONDING TO THE EIGENVALUES WITH
                INDICES N1,...,N2 ARE TO BE TRANSFORMED;
 
 
 PROCEDURES USED:
 
     COMROWCST = CP34353,
     HSHCOMPRD = CP34356.
 
 
 RUNNING TIME: PROPORTIONAL TO (N2-N1) * N**2.
 
 
 LANGUAGE : ALGOL 60.
 
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 4
 
 
 
 THE FOLLOWING HOLDS FOR BOTH PROCEDURES:
 
 
 METHOD AND PERFORMANCE:
 
     HSHCOMHES:
     HOUSEHOLDER'S TRANSFORMATION (FOR COMPLEX MATRICES) IS A UNITARY
     SIMILARITY TRANSFORMATION, WHICH TRANSFORMS A COMPLEX MATRIX INTO A
     SIMILAR UPPER-HESSENBERG MATRIX (SEE WILKINSON, 1965, P. 347-349).
     LET M BE A GIVEN COMPLEX MATRIX OF ORDER N, P THE TRANSFORMING
     MATRIX AND H THE RESULTING UPPER-HESSENBERG MATRIX. SINCE P IS
     UNITARY, WE THEN HAVE H = P''MP, WHERE '' STANDS FOR CONJUGATING
     AND TRANSPOSING.  THE MATRIX P IS  THE PRODUCT OF  N-2 HOUSEHOLDER
     MATRICES,  THESE  BEING  UNITARY  HERMITEAN  MATRICES  OF
     THE FORM I - UU''/T, WHERE T IS A SCALAR (>0), AND U A COMPLEX
     VECTOR. THE R-TH HOUSEHOLDER MATRIX, R=1,...,N-2, IS CHOSEN IN SUCH
     A WAY THAT THE FIRST R ELEMENTS OF U VANISH, AND THE DESIRED ZEROS
     ARE INTRODUCED IN THE LAST N-R-1 ELEMENTS OF THE R-TH COLUMN OF THE
     MATRIX M. HOWEVER, IF THE EUCLIDEAN NORM OF THE LAST N-R-1 ELEMENTS
     OF COLUMN R OF THE MATRIX M IS SMALLER THAN THE MACHINE PRECISION
     TIMES A NORM OF THE MATRIX THEN THE R-TH TRANSFORMATION IS SKIPPED
     (I.E. THE R-TH HOUSEHOLDER MATRIX IS REPLACED BY I). THE COMPLEX
     DIAGONAL SIMILARITY TRANSFORMATION D TRANSFORMS THE UPPER-
     HESSENBERG MATRIX H INTO AN UPPER-HESSENBERG MATRIX HR, WITH REAL
     NONNEGATIVE ELEMENTS. THE DIAGONAL OF D IS CHOSEN IN SUCH A WAY
     THAT SUBDIAGONAL ELEMENTS OF H ARE TRANSFORMED INTO THEIR ABSOLUTE
     VALUES (SEE MUELLER, 1966).
     BAKCOMHES:
     THE BACK TRANSFORMATION TRANSFORMS A COMPLEX VECTOR X INTO THE
     COMPLEX VECTOR PDX. IF X IS AN EIGENVECTOR OF H  THEN PDX IS THE
     CORRESPONDING EIGENVECTOR OF M. STARTING FROM THE VECTOR V=DX, THE
     VECTOR PDX IS OBTAINED BY SUCCESSIVELY REPLACING V BY THE R-TH
     HOUSEHOLDER MATRIX TIMES V, FOR R=N-2,...,1. THE RESULTING VECTOR
     THEN EQUALS PDX.
 
 
 REFERENCES:
 
     MUELLER, D.J. (1966),
     HOUSEHOLDER'S METHOD  FOR  COMPLEX MATRICES AND EIGENSYSTEMS   OF
     HERMITIAN MATRICES,
     NUMER.MATH., 8, P.72-92;
 
     WILKINSON, J.H. (1965),
     THE ALGEBRAIC EIGENVALUE PROBLEM,
     CLARENDON PRESS, OXFORD;
 
 
 EXAMPLE OF USE:
 
     HSHCOMHES IS USED IN THE PROCEDURES EIGVALCOM AND EIGCOM.
     BAKCOMHES IS USED IN THE PROCEDURE EIGCOM.
     (SEE SECTION 3.3.2.2.2.).
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34366;
     "PROCEDURE" HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL); "VALUE" N;
     "INTEGER" N; "ARRAY" AR, AI, EM, B, TR, TI, DEL;
     "BEGIN" "INTEGER" R, RM1, I, J, NM1;
         "REAL" TOL, T, XR, XI;
         NM1:= N - 1; TOL:= (EM[0] * EM[1]) ** 2; RM1:= 1;
         "FOR" R:= 2 "STEP" 1 "UNTIL" NM1 "DO"
         "BEGIN" "IF" HSHCOMCOL(R, N, RM1, AR, AI, TOL, B[RM1],
             TR[R], TI[R], T) "THEN"
             "BEGIN" "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
                 "BEGIN" XR:= (MATMAT(R, N, I, RM1, AI, AI) -
                     MATMAT(R, N, I, RM1, AR, AR)) / T;
                     XI:= ( - MATMAT(R, N, I, RM1, AR, AI) -
                     MATMAT(R, N, I, RM1, AI, AR)) / T;
                     ELMROWCOL(R, N, I, RM1, AR, AR, XR);
                     ELMROWCOL(R, N, I, RM1, AR, AI, XI);
                     ELMROWCOL(R, N, I, RM1, AI, AR, XI);
                     ELMROWCOL(R, N, I, RM1, AI, AI, - XR)
                 "END";
                 HSHCOMPRD(R, N, R, N, RM1, AR, AI, AR, AI, T);
             "END";
             DEL[RM1]:= T; RM1:= R
         "END" FORR;
         "IF" N > 1 "THEN" CARPOL(AR[N,NM1], AI[N,NM1], B[NM1],
         TR[N], TI[N]); RM1:= 1; TR[1]:= 1; TI[1]:= 0;
         "FOR" R:= 2 "STEP" 1 "UNTIL" N "DO"
         "BEGIN" COMMUL(TR[RM1], TI[RM1], TR[R], TI[R], TR[R],
             TI[R]); COMCOLCST(1, RM1, R, AR, AI, TR[R], TI[R]);
             COMROWCST(R + 1, N, R, AR, AI, TR[R], - TI[R]);
             RM1:= R
         "END";
     "END" HSHCOMHES
 
1SECTION:3.2.1.2.2.2          (JUNE 1974)                         PAGE 6
 
                                                                   ;
         "EOP"
0"CODE" 34367;
     "PROCEDURE" BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, N1, N2);
     "VALUE" N, N1, N2; "INTEGER" N, N1, N2;
      "ARRAY" AR, AI, TR, TI, DEL, VR, VI;
     "BEGIN" "INTEGER" I, R, RM1;
         "REAL" H;
         "FOR" I:= 2 "STEP" 1 "UNTIL" N "DO" COMROWCST(N1, N2, I, VR,
         VI, TR[I], TI[I]); R:= N - 1;
         "FOR" RM1:= N - 2 "STEP" - 1 "UNTIL" 1 "DO"
         "BEGIN" H:= DEL[RM1];
             "IF" H > 0 "THEN" HSHCOMPRD(R, N, N1, N2, RM1, VR, VI,
             AR, AI, H); R:= RM1
         "END"
     "END" BAKCOMHES;
         "EOP"
1SECTION:3.2.2.1.1            (DECEMBER 1975)                     PAGE 1
 
 
 
 AUTHOR : D.T.WINTER
 
 
 INSTITUTE : MATHEMATICAL CENTRE
 
 RECEIVED : 731217
 
 BRIEF DESCRIPTION :
 
     THIS SECTION CONTAINS THREE PROCEDURES :
     1.  HSHREABID.
         THIS PROCEDURE  TRANSFORMS  A GIVEN MATRIX  TO BIDIAGONAL FORM,
         BY PREMULTIPLYING  AND  POSTMULTIPLYING  THE GIVEN MATRIX  WITH
         ORTHOGONAL MATRICES.
     2.  PSTTFMMAT.
         THIS PROCEDURE CALCULATES THE  POSTMULTIPLYING  MATRIX FROM THE
         DATA GENERATED BY HSHREABID.
     3.  PRETFMMAT.
         THIS PROCEDURE  CALCULATES THE  PREMULTIPLYING  MATRIX FROM THE
         DATA GENERATED BY HSHREABID.
 
 KEYWORDS :
     HOUSEHOLDER'S TRANSFORMATION
     BIDIAGONALISATION
 
 SUBSECTION : HSHREABID
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" HSHREABID(A, M, N, D, B, EM);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, D, B, EM;
     "CODE" 34260;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY" A[1:M,1:N];
         ENTRY: THE GIVEN MATRIX;
         EXIT: DATA CONCERNING THE  PREMULTIPLYING  AND  POSTMULTIPLYING
             MATRICES;
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF THE GIVEN MATRIX;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF THE GIVEN MATRIX,
         N SHOULD SATISFY N <= M;
     D:  <ARRAY IDENTIFIER>;
         "ARRAY"D[1:N];
         EXIT: THE DIAGONAL OF THE BIDIAGONAL MATRIX;
     B:  <ARRAY IDENTIFIER>;
         "ARRAY"B[1:N];
         EXIT: THE SUPERDIAGONAL OF THE BIDIAGONAL MATRIX IS DELIVERED
         IN B[1:N-1];
     EM: <ARRAY IDENTIFIER>;
         "ARRAY"EM[0:1];
         ENTRY: EM[0]: THE MACHINE-PRECISION;
         EXIT: EM[1]: THE INFINITY NORM OF THE GIVEN MATRIX.
1SECTION:3.2.2.1.1            (JUNE 1974)                         PAGE 2
 
 
 
 PROCEDURES USED :
     TAMMAT = CP34014
     MATTAM = CP34015
     ELMCOL = CP34023
     ELMROW = CP34024
 
 
 RUNNING TIME :
     RUNNING TIME IS ROUGHLY PROPORTIONAL TO (M + N) * N * N
 
 
 METHOD AND PERFORMANCE :
     LET  US  ASSUME  A  GIVEN  MATRIX  A[ 1:M , 1:N ],  WITH  M  >=  N.
     FIRSTLY WE PREMULTIPLY A WITH A HOUSEHOLDER MATRIX,  CHOSEN IN SUCH
     A WAY THAT THE FIRST COLUMN OF THE RESULTING MATRIX A' IS ZERO WITH
     THE EXCEPTION  OF THE FIRST  ELEMENT.  SECONDLY WE  POSTMULTIPLY A'
     WITH A  HOUSEHOLDER  MATRIX SO  THAT THE FIRST ROW OF THE RESULTING
     MATRIX  IS ZERO  WITH  THE EXCEPTION  OF  THE FIRST  TWO  ELEMENTS.
     NOW  WE REMOVE  THE FIRST ROW AND COLUMN,  AND REPEAT  THIS PROCESS
     UNTIL  THE  MATRIX  IS  TOTALLY  TRANSFORMED  TO  BIDIAGONAL  FORM.
     THIS  PROCEDURE  IS A  REWRITING  OF A PART  OF  THE PROCEDURE  SVD
     PUBLISHED  BY  G.H.GOLUB  AND  C.REINSCH[1]. HOWEVER IN CONTRAST TO
     THEIR PROCEDURE, HERE WE SKIP A TRANSFORMATION IF THE COLUMN OR ROW
     ON WHICH  OUR  ATTENTION  IS FOCUSSED  IS ALREADY  (NEARLY)  IN THE
     DESIRED FORM,  I.E.  IF THE SUM OF THE SQUARES OF THE ELEMENTS THAT
     OUGHT TO BE  ZERO  IS SMALLER THAN  A CERTAIN CONSTANT,  IN SVD THE
     TRANSFORMATION  IS  SKIPPED  ONLY  IF THE  NORM  OF THE FULL ROW OR
     COLUMN  IS SMALL ENOUGH.  OUR WAY SEEMS TO GIVE BETTER RESULTS,  AS
     SOME  ILL-DEFINED  TRANSFORMATIONS  ARE  SKIPPED.  MOREOVER,  IF  A
     TRANSFORMATION  IS  SKIPPED,   WE  DO  NOT  STORE  A  ZERO  IN  THE
     DIAGONAL  OR  SUPERDIAGONAL,  BUT  WE  STORE  THE VALUE  THAT WOULD
     HAVE  BEEN  FOUND  IF THE  COLUMN  OR  ROW  WAS IN THE DESIRED FORM
     ALREADY.
 
 
 LANGUAGE : ALGOL-60
 
 
1SECTION:3.2.2.1.1            (DECEMBER 1975)                     PAGE 3
 
 
 
 SUBSECTION : PSTTFMMAT
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" PSTTFMMAT(A, N, V, B);
     "VALUE" N; "INTEGER" N; "ARRAY" A, V, B;
     "CODE" 34261;
 
     THE MEANING OF THE FORMAL PARAMETERS IS:
     A:  <ARRAY IDENTIFIER>;
         "ARRAY"A[1:N,1:N];
         THE DATA  CONCERNING THE  POSTMULTIPLYING MATRIX,  AS GENERATED
         BY HSHREABID;
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS AND ROWS OF A;
     V:  <ARRAY IDENTIFIER>;
         "ARRAY"V[1:N,1:N];
         EXIT: THE POSTMULTIPLYING MATRIX;
     B:  <ARRAY IDENTIFIER>;
         "ARRAY"B[1:N];
         THE SUPERDIAGONAL AS GENERATED BY HSHREABID.
 
 
 PROCEDURES USED :
     MATMAT = CP34013
     ELMCOL = CP34023
 
 
 RUNNING TIME :
     THE RUNNING TIME IS ABOUT PROPORTIONAL TO N ** 3
 
 
 LANGUAGE : ALGOL 60
 
 
1SECTION:3.2.2.1.1            (JUNE 1974)                         PAGE 4
 
 
 
 SUBSECTION : PRETFMMAT
 
 
 CALLING SEQUENCE :
     THE HEADING OF THE PROCEDURE IS :
     "PROCEDURE" PRETFMMAT(A, M, N, D);
     "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, D;
     "CODE" 34262;
 
     THE MEANING OF THE FORMAL PARAMETERS IS :
     A:  <ARRAY IDENTIFIER>;
         "ARRAY"A[1:M,1:N];
         ENTRY:  THE  DATA   CONCERNING  THE  PREMULTIPLYING  MATRIX  AS
             GENERATED BY HSHREABID
         EXIT : THE PREMULTIPLYING MATRIX.
     M:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF ROWS OF A.
     N:  <ARITHMETIC EXPRESSION>;
         THE NUMBER OF COLUMNS OF A, N SHOULD SATISFY N <= M.
     D:  <ARRAY IDENTIFIER>;
         "ARRAY"D[1:N];
         THE DIAGONAL AS GENERATED BY HSHREABID.
 
 
 PROCEDURES USED :
     TAMMAT = CP34014
     ELMCOL = CP34023
 
 
 RUNNING TIME :
     THE RUNNING TIME IS ABOUT PROPORTIONAL TO M * N * N
 
 
 LANGUAGE : ALGOL-60
 
 
 REFERENCES :
     [1] WILKINSON, J.H. AND C.REINSCH
         HANDBOOK FOR AUTOMATIC COMPUTATION, VOL. 2
         LINEAR ALGEBRA
         HEIDELBERG (1971)
 
 
 EXAMPLE OF USE :
 
     FOR AN EXAMPLE OF USE ONE IS REFERRED TO SECTION 3.5.1.2
 
1SECTION:3.2.2.1.1            (JUNE 1974)                         PAGE 5
 
 
 
 SOURCE TEXT(S) :
0"CODE" 34260;
 "PROCEDURE" HSHREABID(A, M, N, D, B, EM);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, D, B, EM;
 "BEGIN" "INTEGER" I, J, I1;
     "REAL" NORM, MACHTOL, W, S, F, G, H;
 
     NORM:= 0;
     "FOR" I:= 1 "STEP" 1 "UNTIL" M "DO"
     "BEGIN" W:= 0;
         "FOR" J:= 1 "STEP" 1 "UNTIL" N "DO" W:= ABS(A[I,J]) + W;
         "IF" W > NORM "THEN" NORM:= W
     "END";
     MACHTOL:= EM[0] * NORM; EM[1]:= NORM;
     "FOR" I:= 1 "STEP" 1 "UNTIL" N "DO"
     "BEGIN" I1:= I + 1; S:= TAMMAT(I1, M, I, I, A, A);
         "IF" S < MACHTOL "THEN" D[I]:= A[I,I] "ELSE"
         "BEGIN" F:= A[I,I]; S:= F * F + S;
             D[I]:= G:= "IF" F < 0 "THEN" SQRT(S) "ELSE" - SQRT(S);
             H:= F * G - S; A[I,I]:= F - G;
             "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
             ELMCOL(I, M, J, I, A, A, TAMMAT(I, M, I, J, A, A) / H)
         "END";
         "IF" I < N "THEN"
         "BEGIN" S:= MATTAM(I1 + 1, N, I, I, A, A);
             "IF" S < MACHTOL "THEN" B[I]:= A[I,I1] "ELSE"
             "BEGIN" F:= A[I,I1]; S:= F * F + S;
                 B[I]:= G:= "IF" F < 0 "THEN" SQRT(S) "ELSE" - SQRT(S);
                 H:= F * G - S; A[I,I1]:= F - G;
                 "FOR" J:= I1 "STEP" 1 "UNTIL" M "DO"
                 ELMROW(I1, N, J, I, A, A, MATTAM(I1, N, I, J, A, A) /
                 H)
             "END"
         "END"
     "END"
 "END" HSHREABID
1SECTION:3.2.2.1.1            (JUNE 1974)                         PAGE 6
 
 
                                                                   ;
         "EOP"
0"CODE" 34261;
 "PROCEDURE" PSTTFMMAT(A, N, V, B);
 "VALUE" N; "INTEGER" N; "ARRAY" A, V, B;
 "BEGIN" "INTEGER" I, I1, J;
     "REAL" H;
 
     I1:= N; V[N,N]:= 1;
     "FOR" I:= N - 1 "STEP" - 1 "UNTIL" 1 "DO"
     "BEGIN" H:= B[I] * A[I,I1]; "IF" H < 0 "THEN"
         "BEGIN" "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO" V[J,I]:= A[I,J] /
             H;
             "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
             ELMCOL(I1, N, J, I, V, V, MATMAT(I1, N, I, J, A, V))
         "END";
         "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO" V[I,J]:= V[J,I]:= 0;
         V[I,I]:= 1; I1:= I
     "END"
 "END" PSTTFMMAT;
         "EOP"
0"CODE" 34262;
 "PROCEDURE" PRETFMMAT(A, M, N, D);
 "VALUE" M, N; "INTEGER" M, N; "ARRAY" A, D;
 "BEGIN" "INTEGER" I, I1, J;
     "REAL" G, H;
 
     "FOR" I:= N "STEP" - 1 "UNTIL" 1 "DO"
     "BEGIN" I1:= I + 1; G:= D[I]; H:= G * A[I,I];
         "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO" A[I,J]:= 0;
         "IF" H < 0 "THEN"
         "BEGIN" "FOR" J:= I1 "STEP" 1 "UNTIL" N "DO"
             ELMCOL(I, M, J, I, A, A, TAMMAT(I1, M, I, J, A, A) / H);
             "FOR" J:= I "STEP" 1 "UNTIL" M "DO" A[J,I]:= A[J,I] / G
         "END"
         "ELSE"
         "FOR" J:= I "STEP" 1 "UNTIL" M "DO" A[J,I]:= 0;
         A[I,I]:= A[I,I] + 1
     "END"
 "END" PRETFMMAT;
         "EOP"
